# PROJECT DOCUMENTATION
# Generated on: Wed Jul  9 21:35:06 CEST 2025
# Source documentation files for Claude Projects


=== ./background/README.md ===

# Background Resources

This folder holds all source and reference materials for developing a web GUI rich rule editor compatible with firewalld, potentially as a Webmin or Cockpit module.

=== ./background/firewalld-docs/rich-rules.html ===

<!DOCTYPE html>
<html>
  








  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name=viewport content="width=device-width, initial-scale=1">
  <title>[404] Not Found | firewalld</title>
  
    <meta name="author" content="Thomas Woerner">
  
  
    <meta name="description" content="Welcome to the firewalld project homepage! Firewalld provides a dynamically managed firewall with support for network/firewall zones that defines t...">
  
    <meta name="keywords" content="firewalld, firewall, linux, security, netfilter, dbus, daemon">
  
    
  <link href="/css/main.css" media="screen, projection, print" rel="stylesheet" type="text/css">
  <link rel="canonical" href="/404.html">
  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" type="application/atom+xml" title="firewalld" href="/atom.xml"/>
  
  <!-- Social media content metadata -->



  
  
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-83693467-1', 'auto');
    ga('send', 'pageview');
    </script>


  
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>[404] Not Found | firewalld</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="[404] Not Found" />
<meta name="author" content="Thomas Woerner" />
<meta property="og:locale" content="en" />
<meta name="description" content="Welcome to the firewalld project homepage! Firewalld provides a dynamically managed firewall with support for network/firewall zones that defines the trust level of network connections or interfaces." />
<meta property="og:description" content="Welcome to the firewalld project homepage! Firewalld provides a dynamically managed firewall with support for network/firewall zones that defines the trust level of network connections or interfaces." />
<link rel="canonical" href="firewalld.github.io/404.html" />
<meta property="og:url" content="firewalld.github.io/404.html" />
<meta property="og:site_name" content="firewalld" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="[404] Not Found" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Thomas Woerner"},"description":"Welcome to the firewalld project homepage! Firewalld provides a dynamically managed firewall with support for network/firewall zones that defines the trust level of network connections or interfaces.","headline":"[404] Not Found","url":"firewalld.github.io/404.html"}</script>
<!-- End Jekyll SEO tag -->

</head>

  <body>
    <main class="wrap">
      <header class="banner-block" role="banner">
  <div class="banner row">
    <a href="/"><img class="banner-image" src="/images/firewalld.org.png"></a>
    <p>A service daemon with D-Bus interface</p>
  </div>
</header>

      <nav class="navbar-block">
  <nav class="row navbar">
    <div id="nav">
      <ul class="columns medium-12 left primary-nav">
	<li id="toggleMenu"><a href="#nav">Menu</a></li>
	<li id="hideMenu"><a href="#toggleMenu">Menu</a></li>
        
<li class="normal">
  <a href='/'>Home</a>

</li>

<li class="normal">
  <a href='/blog/'>Blog</a>

</li>

<li class="normal">
  <a href='/community.html'>Community</a>

</li>

<li class="normal">
  <a href='/contribute.html'>Contribute</a>

</li>

<li class="dropdown normal">
  <a href='/documentation/'>Documentation</a>

  <ul>
    
<li class="normal">
  <a href='/documentation/concepts.html'>Concepts</a>

</li>

<li class="normal">
  <a href='/documentation/architecture.html'>Architecture</a>

</li>

<li class="subdropdown normal">
  <a href='/documentation/configuration/'>Configuration</a>

  <ul>
    
<li class="normal">
  <a href='/documentation/configuration/directories.html'>Directories</a>

</li>

<li class="normal">
  <a href='/documentation/configuration/runtime-versus-permanent.html'>Runtime versus Permanent</a>

</li>

<li class="normal">
  <a href='/documentation/configuration/firewalld-conf.html'>firewalld.conf</a>

</li>

  </ul>

</li>

<li class="subdropdown normal">
  <a href='/documentation/utilities/'>Utilities</a>

  <ul>
    
<li class="normal">
  <a href='/documentation/utilities/firewall-cmd.html'>firewall-cmd</a>

</li>

<li class="normal">
  <a href='/documentation/utilities/firewall-offline-cmd.html'>firewall-offline-cmd</a>

</li>

<li class="normal">
  <a href='/documentation/utilities/firewall-config.html'>firewall-config</a>

</li>

<li class="normal">
  <a href='/documentation/utilities/firewall-applet.html'>firewall-applet</a>

</li>

  </ul>

</li>

<li class="normal">
  <a href='/documentation/the-daemon-firewalld.html'>The daemon: firewalld</a>

</li>

<li class="subdropdown normal">
  <a href='/documentation/zone/'>Zone</a>

  <ul>
    
<li class="normal">
  <a href='/documentation/zone/predefined-zones.html'>Predefined Zones</a>

</li>

<li class="normal">
  <a href='/documentation/zone/connections-interfaces-and-sources.html'>Connections, Interfaces and Sources</a>

</li>

<li class="normal">
  <a href='/documentation/zone/configuration-of-zones.html'>Configuration of Zones</a>

</li>

<li class="normal">
  <a href='/documentation/zone/default-zone.html'>Default Zone</a>

</li>

<li class="normal">
  <a href='/documentation/zone/use-of-zones.html'>Use of Zones</a>

</li>

<li class="normal">
  <a href='/documentation/zone/options.html'>Options</a>

</li>

<li class="normal">
  <a href='/documentation/zone/examples.html'>Examples</a>

</li>

  </ul>

</li>

<li class="subdropdown normal">
  <a href='/documentation/service/'>Service</a>

  <ul>
    
<li class="normal">
  <a href='/documentation/service/options.html'>Options</a>

</li>

<li class="normal">
  <a href='/documentation/service/examples.html'>Examples</a>

</li>

  </ul>

</li>

<li class="subdropdown normal">
  <a href='/documentation/ipset/'>IPSet</a>

  <ul>
    
<li class="normal">
  <a href='/documentation/ipset/options.html'>Options</a>

</li>

<li class="normal">
  <a href='/documentation/ipset/examples.html'>Examples</a>

</li>

  </ul>

</li>

<li class="subdropdown normal">
  <a href='/documentation/helper/'>Helper</a>

  <ul>
    
<li class="normal">
  <a href='/documentation/helper/options.html'>Options</a>

</li>

<li class="normal">
  <a href='/documentation/helper/examples.html'>Examples</a>

</li>

  </ul>

</li>

<li class="subdropdown normal">
  <a href='/documentation/icmptype/'>ICMP Type</a>

  <ul>
    
<li class="normal">
  <a href='/documentation/icmptype/options.html'>Options</a>

</li>

<li class="normal">
  <a href='/documentation/icmptype/examples.html'>Examples</a>

</li>

  </ul>

</li>

<li class="subdropdown normal">
  <a href='/documentation/direct/'>Direct Interface</a>

  <ul>
    
<li class="normal">
  <a href='/documentation/direct/options.html'>Options</a>

</li>

<li class="normal">
  <a href='/documentation/direct/examples.html'>Examples</a>

</li>

  </ul>

</li>

<li class="subdropdown normal">
  <a href='/documentation/howto/'>HowTo</a>

  <ul>
    
<li class="normal">
  <a href='/documentation/howto/enable-and-disable-firewalld.html'>Enable and Disable firewalld</a>

</li>

<li class="normal">
  <a href='/documentation/howto/get-firewalld-state.html'>Get firewalld State</a>

</li>

<li class="normal">
  <a href='/documentation/howto/reload-firewalld.html'>Reload firewalld</a>

</li>

<li class="normal">
  <a href='/documentation/howto/open-a-port-or-service.html'>Open a Port or Service</a>

</li>

<li class="normal">
  <a href='/documentation/howto/add-a-service.html'>Add a Service</a>

</li>

<li class="normal">
  <a href='/documentation/howto/debug-firewalld.html'>Debug firewalld</a>

</li>

  </ul>

</li>

<li class="subdropdown normal">
  <a href='/documentation/man-pages/'>Manual Pages</a>

  <ul>
    
<li class="normal">
  <a href='/documentation/man-pages/firewalld.html'>firewalld(1)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewall-cmd.html'>firewall-cmd(1)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewall-offline-cmd.html'>firewall-offline-cmd(1)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewall-config.html'>firewall-config(1)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewall-applet.html'>firewall-applet(1)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewalld.conf.html'>firewalld.conf(5)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewalld.zones.html'>firewalld.zones(5)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewalld.zone.html'>firewalld.zone(5)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewalld.policies.html'>firewalld.policies(5)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewalld.policy.html'>firewalld.policy(5)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewalld.service.html'>firewalld.service(5)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewalld.ipset.html'>firewalld.ipset(5)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewalld.helper.html'>firewalld.helper(5)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewalld.icmptype.html'>firewalld.icmptype(5)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewalld.richlanguage.html'>firewalld.richlanguage(5)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewalld.direct.html'>firewalld.direct(5)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewalld.lockdown-whitelist.html'>firewalld.lockdown-whitelist(5)</a>

</li>

<li class="normal">
  <a href='/documentation/man-pages/firewalld.dbus.html'>firewalld.dbus(5)</a>

</li>

  </ul>

</li>

<li class="normal">
  <a href='/documentation/external.html'>External Resources</a>

</li>

<li class="normal">
  <a href='/documentation/working-with-the-source.html'>Working With The Source</a>

</li>

  </ul>

</li>

<li class="dropdown normal">
  <a href='/download/'>Download</a>

  <ul>
    
<li class="normal">
  <a href='/download/all.html'>All Releases</a>

</li>

  </ul>

</li>

<li class="normal">
  <a href='/search.html'>Search</a>

</li>

	
	<li class="right">
	  <a href="https://github.com/firewalld/firewalld"><span class="icon-github socials"></span></a>
	</li>
        
      </ul>
    </div>
  </nav>
</nav>

      <div class="row page-navigation">
      <ul class="breadcrumb">
        
      </ul>
      </div>
      <div class="row">

  <article class="page-content row">
    <section class="columns medium-9">
      <h1>[404] Not Found</h1>
      <div id="message">
<p>The page you have been looking for could not be found.</p>
<p>You can try a search or start over on the <a href="/">home page</a>.</p>
</div>

<script type="text/javascript">
  // Remove trailing slash to make blog pages compatible to old firewalld.org.
  var href = location.href;
  if (href.substr(href.length-1) == '/') {
    var redirect_to = href.substr(0, href.length-1);
    window.location = redirect_to;

    var text = "Redirecting ...";
    document.title = document.title.replace("[404] Not Found", text);
    document.getElementsByTagName("h1")[0].innerHTML = text;
    document.getElementById("message").innerHTML = "Please click <a href=\""+redirect_to+"\">here</a> if it is not happening automatically.";
}
</script>


    </section>
    <section class="columns medium-3">
      
<aside class="small-12">

<form class="search-form" action="/search.html" method="get">
  <input class="search-input" type="text" name="search" placeholder="Search..."></input>
</form>

</aside>


      <aside class="small-12 recent-posts">
  <h2>Recent Posts</h2>
  <ul>
    
      <li>
        <a href="/2024/11/strict-forward-ports">Strict Forward Ports</a>
      </li>
    
      <li>
        <a href="/2024/04/strictly-filtering-docker-containers">Strict Filtering of Docker Containers</a>
      </li>
    
      <li>
        <a href="/2024/01/firewalld-2-1-0-release">firewalld 2.1.0 release</a>
      </li>
    
      <li>
        <a href="/2023/06/firewalld-2-0-0-release">firewalld 2.0.0 release</a>
      </li>
    
      <li>
        <a href="/2023/05/nftables-flowtable">Software fastpath with nftables flowtable</a>
      </li>
    
  </ul>
</aside>

      <aside class="small-12 quick-links">
  <h2>Quick Links</h2>
  <ul>
    <li>
      <a href="https://github.com/firewalld/firewalld/issues/new">Report a new issue</a>
    </li>
    <li>
      <a href="https://github.com/firewalld/firewalld/issues">Browse issues</a>
    </li>
  </ul>
</aside>

    </section>
  </article>

</div>

<!-- For rendering mermaid diagrams. -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  mermaid.initialize({ startOnLoad: true,
                       theme: 'base'});
  window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
</script>

    </main>
    <footer class="site-footer">
  <div class="row">
    <div class="small-12 columns">
      All website content subject to the <a href="https://unlicense.org">Unlicense</a>.
    </div>
  </div>
</footer> 

  </body>
</html>

<!-- For rendering mermaid diagrams. -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  mermaid.initialize({ startOnLoad: true,
                       theme: 'base'});
  window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
</script>

=== ./background/nftables-gui/.github/ISSUE_TEMPLATE/bug_report.md ===

---
name: Bug report
about: Create a report to help us improve
title: ''
labels: ''
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Version [e.g. 22]

**Smartphone (please complete the following information):**
 - Device: [e.g. iPhone6]
 - OS: [e.g. iOS8.1]
 - Browser [e.g. stock browser, safari]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.

=== ./background/nftables-gui/.github/ISSUE_TEMPLATE/feature_request.md ===

---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: ''
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.

=== ./background/nftables-gui/.github/ISSUE_TEMPLATE/test.md ===

---
name: Test
about: Plantilla para hacer pruebas
title: Pruebas de
labels: test
assignees: alegarsan11

---

## Descripción del Test

[Describe aquí brevemente el propósito y el alcance del test que deseas crear.]

## Comportamiento Esperado

[Describe aquí cuál debería ser el resultado esperado después de completar los pasos anteriores.]

## Comportamiento Actual

[Opcional: Describe el comportamiento actual o cualquier problema encontrado al realizar el test.]

## Capturas de Pantalla

[Opcional: Adjunta capturas de pantalla que ayuden a ilustrar el comportamiento actual o esperado.]

## Observaciones

[Cualquier comentario adicional o información relevante sobre el test.]

=== ./background/nftables-gui/LICENSE ===

                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

=== ./background/nftables-gui/README.md ===

# nftables-gui

[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=alegarsan11_nftables-gui&metric=alert_status)](https://sonarcloud.io/summary/new_code?id=alegarsan11_nftables-gui)

This repository is used to develop a web interface that enables the configuration of nftables through a graphical user interface.

## Requirements
To use this project, you need to install `python3-nftables` and `python3-hug`. For proper functioning, it's necessary to run the parsing file as an administrator. Also you need to create a virtual environment with `python3 -m venv venv` and use it as a source to install dependencies with `source venv/bin/activate`.

## Default User Credentials
The default user credentials are as follows:
- Username: default
- Password: defaultpassword

## Running the Project
To run the project, follow these steps:

1. Grant permissions to the `run.sh` file: 

    `sudo chmod +x run.sh`

2. Execute the run.sh file. This file is used to run the project:

    `sudo ./run.sh`

3. To kill all processes:

    `sudo killall python`

### Deploying the Apache Server
To deploy an Apache server, use the build.sh file:
1. Grant permissions to the build.sh file:

    `sudo chmod +x build.sh`

2. Execute the build.sh file:

    `sudo ./build.sh`

(Apache server will be available on port 8080)

### Deploying with gunicorn
1. Install dependencies

    `sudo apt install gunicorn gevent`

2.  In nftables-frontend folder execute:

    `sudo gunicorn -w 4 -b 0.0.0.0:4000 --worker-class gevent app:app`

3.  In nftables-parser execute:

    `sudo hug -f main.py` 


### Testing and Coverage
To run the tests and generate coverage reports, use the following commands:
- Execute the test files (in the nftables-frontend folder):

    `python -m pytest`

- Execute coverage:

    `python -m pytest --cov`

- Generate a coverage report:

    `python -m pytest --cov --cov-report=html`

=== ./background/nftables-gui/nftables-frontend/instance/README.md ===

This is a folder to use a db for the frontend app
=== ./background/nftables-gui/nftables-frontend/migrations/README ===

Single-database configuration for Flask.

=== ./background/nftables-gui/nftables-frontend/static/css/base.css ===

.navbar {
    background-color: #333;
    border-radius: 0%;
}

.navbar a {
    display: block;
    color: #f2f2f2;
    padding: 16px;
    text-decoration: none;
}

.navbar a:hover {
    background-color: #ddd;
    color: black;
}

.parrafo {
    margin-top: 10px;
    font-size: 18px;
    color: #ddd;
    margin-right: 10px;

}

.button-logout {
    background-color: #f44336;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 10px 20px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 16px;
    margin: 4px 2px;
    cursor: pointer;

}

.salida {
    display: flex;
    text-align: right;
    justify-content: flex-end;
}

.content {
    margin-left: 20px !important;
    padding: 1px 16px !important;
}

.personal-table{
    background-color: #343a40;
    color: #fff;
    border: 1px solid #343a40 !important;
}

.personal-table th{
    background-color: #343a40;
    color: #fff;
    border: 1px solid #343a40 !important;
    text-align: center;
}

.personal-table td{
    background-color: #fff;
    color: #343a40;
    border: 1px solid #343a40 !important;
    text-align: center;
}

.container-main {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
}

.navbar-nav {
    list-style: none;
}

.navbar-nav .active {
    background-color: #858585;
    color: #343a40 !important;
    border-radius: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
}

.button-save {
    background-color: #28a745;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 10px 20px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 16px;
    margin: 4px 2px;
    margin-right: 10px;
    cursor: pointer;
}
=== ./background/nftables-gui/nftables-frontend/static/css/login.css ===

.login-form {
    background-color: dimgray;
    color: white;
    margin-top: 50%;
    padding: 15px;

}
=== ./background/nftables-gui/nftables-frontend/static/css/rule.css ===

.personal-table {
    background-color: #343a40;
    color: #fff;
    border: 1px solid #343a40;
    margin: 0 auto; /* Centrar la tabla */
  }
  
  .personal-table th {
    background-color: #343a40;
    color: #fff;
    border: 1px solid #343a40;
    text-align: center;
    padding: 10px; /* Añadir espacio alrededor del texto */
    font-weight: bold; /* Texto en negrita */
  }
  
  .personal-table td {
    background-color: #fff;
    color: #343a40;
    border: 1px solid #343a40;
    text-align: center;
    padding: 10px; /* Añadir espacio alrededor del texto */
  }
  
  .personal-table tr:nth-child(odd) {
    background-color: #f0f0f0; /* Color de fondo gris claro para filas pares */
  }
  
  .personal-table tr:hover {
    background-color: #e0e0e0; /* Color de fondo gris claro para filas al pasar el cursor */
  }
  
  .espaciado {
    margin-top: 20px; /* Añadir espacio en la parte superior */
    margin-bottom: 20px; /* Añadir espacio en la parte inferior */
    margin-right: 20px;
    margin-left: 20px;
  }
=== ./background/nftables-gui/nftables-frontend/static/css/tables.css ===

.personal-table{
    background-color: #343a40;
    color: #fff;
    border: 1px solid #343a40 !important;
}

.personal-table th{
    background-color: #343a40;
    color: #fff;
    border: 1px solid #343a40 !important;
    text-align: center;
}

.personal-table td{
    background-color: #fff;
    color: #343a40;
    border: 1px solid #343a40 !important;
    text-align: center;
}


=== ./background/nftables-gui/nftables-frontend/static/css/users.css ===

.users-table {
    width: 100%;
    border-collapse: collapse;
    border: 1px solid #333;

}

.head-user-table {
    text-align: center;
    background-color: #333;
    color: white;
    border: 1px solid #333;

}

.body-user-table {
    background-color: white;
    color: black;
    border: 1px solid #333;
}

.tr, td , th{
    text-align: center;
    border: 1px solid #333;
    height: 50px;
}
=== ./background/nftables-gui/nftables-frontend/static/img/README.md ===

This is a folder to use on main page view nftables-info
=== ./background/nftables-gui/nftables-frontend/temp_config/README.md ===

This is a directory to save temporal configurations of nftables
=== ./background/nftables-gui/nftables-frontend/templates/base.html ===

{% extends "bootstrap/base.html" %}
{% block title %}nftables-gui{% endblock %}
{% block head %}
{{ super() }}
<link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
{% endblock %}
{% block navbar %}
<nav class="navbar">
  <div>
    <a class="navbar-brand" href="/">nftables-gui</a>
  </div>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item{% if request.path == '/tables' %} active{% endif %}">
          <a class="nav-link" href="/tables">Tables</a>
        </li>
        <li class="nav-item{% if request.path == '/chains' %} active{% endif %}">
          <a class="nav-link" href="/chains">Chains</a>
        </li>
        <li class="nav-item{% if request.path == '/rules' %} active{% endif %}">
          <a class="nav-link" href="/rules">Rules</a>
        </li>
        <li class="nav-item{% if request.path == '/list_ruleset' %} active{% endif %}">
          <a class="nav-link" href="/list_ruleset">List ruleset</a>
        </li>
        <li class="nav-item{% if request.path == '/sets' %} active{% endif %}">
          <a class="nav-link" href="/sets">Sets</a>
        </li>
        <li class="nav-item{% if request.path == '/maps' %} active{% endif %}">
          <a class="nav-link" href="/maps">Maps</a>
        </li>
        <li class="nav-item{% if request.path == '/users' %} active{% endif %}">
          <a class="nav-link" href="/users">Users</a>
        </li>
        

      </ul>
        <div class="salida">
          <button class="button-save" onclick="location.href='/save-changes'">Save changes</button>

          <p class="parrafo">{{ current_user.username }}</p>

          <button class="button-logout" onclick="location.href='/logout'">Logout</button>

        </div>
    </div>

    </nav>
{% endblock %}

{% block content %}
{% endblock %}


  {% block footer %}
  <footer class="footer">
    <div class="container">
      <span class="text-muted">Nftables-frontend</span>
    </div>
  </footer>
  {% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/chains/chain.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
  <h1>Chain: {{ chain.name }}</h1>
  <button class="btn btn-danger" onclick="window.location.href='/chains/{{ chain.id }}/{{chain.table.name}}/delete'">Delete</button>
  <button class="btn btn-warning" onclick="window.location.href='/chains/{{ chain.id }}/{{chain.table.name}}/flush'">Flush</button>
  <div class="row">
    <div class="col-md-6">
      <h2>Details:</h2>
      <p><strong>Table:</strong> {{ chain.table.name }}</p>
      <p><strong>Hook type:</strong> 
        {% if chain.hook_type == None %}
          This chain is not associated with a hook
        {% else %}
        {{ chain.hook_type }}</p>
        {% endif %}
      {% if chain.type != None %}
        <p><strong>Type:</strong> {{ chain.type }}</p>
      {% endif %}
      {% if chain.description == None %}
        <p><strong>Description:</strong> No description</p>
      {% else %}
        <p><strong>Description:</strong> {{ chain.description }}</p>
      {% endif %}
      {% if chain.policy != None %}
        <p><strong>Policy:</strong> {{ chain.policy }}</p>
      {% endif %}
      {% if chain.priority != None %}
        <p><strong>Priority:</strong> {{ chain.priority }}</p>
      {% endif %}
      <p><strong>Family:</strong> {{ chain.table.family }}</p>
    </div>
    <div class="col-md-6">
      <h2>Rules:</h2>
      <table class="table personal-table">
        <thead>
          <tr>
            <th>Handle</th>
            <th>Expresion</th>
            <th>Description</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody>
        {% for rule in chain.rules %}
        {% if rule.table().name == chain.table.name and rule.family == chain.family %}

          <tr>
            <td>{{ rule.handle }}</td>
            <td>{% for statement in rule.expr %}
              {% if statement.get("match", None) != None %}
              {{ statement.get("match", None)["left"] }} {{ statement.get("match", None)["op"]  }} {{ statement.get("match", None)["right"] }}
              <br></br>
              {% else %}
              {% set first_key = statement.keys()|list|first %}
              {{ first_key }}
              <br></br>
              {% endif %}
              {% endfor %}
            </td>
            <td>
              {% if rule.description == None %}
                No description
              {% else %}
              {{ rule.description }}
              {% endif %}</td>
            <td><button class="btn btn-primary" onclick="window.location.href='/rules/{{rule.id}}'">View</button></td>
          </tr>
        {% endif %}
        {% endfor %}
        </tbody>
    </div>
  </div>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/chains/chains.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
  <h1>Chains:</h1>
  
  <a href="/create_chain" class="btn btn-primary">Add chain</a>    
  <a href="/create_base_chain" class="btn btn-primary" style="background-color: green">Add base chain</a>
  <br></br>

  <table class="table personal-table ">
    <thead>
      <tr>
        <th>Table</th>
        <th>Family</th>
        <th>Chain</th>
        <th>Policy</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>
      {% for chain in chains %}
      <tr>
        <td>
          <a href="/table/{{ chain.table.name}}/{{ chain.table.family }}"> {{ chain.table.name }}</a></td>
        <td>{{ chain.table.family }}</td>
        <td> <a href="/chain/{{ chain.name}}/{{ chain.table.family }}/{{ chain.table.id }}"> {{ chain.name }}</a></td>

          {% if chain.policy == None %}
          <td>Non existing policy for this chain</td>
          {% else %}
          <td>{{ chain.policy }}</td>
          {% endif %}
        <td>
          <a href="/chains/{{ chain.id }}/{{chain.table.id}}/delete" class="btn btn-danger">Delete</a>
        </td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/chains/create_base_chain.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
<script>
    // Función para actualizar el valor del input oculto con la table.family seleccionada
    function updateHiddenInput() {
        var selectedTable = document.getElementById('table').value;
        var hiddenInput = document.getElementById('family');
        hiddenInput.value = selectedTable.split('-')[1].trim(); // Obtener la parte de la familia de la tabla seleccionada
    }
</script>
{% endblock %}
{% block content %}
<div class="container">
  <h1>Create chain:</h1>
    <form id="myForm" action="/create_base_chain" method="POST">
        {{ form.csrf_token }}
        <div class="form-group">
            {{ form.table.label }} 
            <select name="table" class="form-control">
                {% for table in tables %}
                    <option name="family" value="{{ table.family }}&&{{ table.id }}">{{ table.name }} - {{table.family}}</option>
                {% endfor %}
            </select>
            {% if form.table.errors %}
                <ul class="errors">
                    {% for error in form.table.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
        </div>
        <div class="form-group">
            {{ form.name.label }} {{ form.name(class="form-control") }}
            {% if form.name.errors %}
                <ul class="errors">
                    {% for error in form.name.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
            </div>
        <div class="form-group">
            {{ form.hook_type.label }} {{ form.hook_type(class="form-control") }}
            {% if form.hook_type.errors %}
                <ul class="errors">
                    {% for error in form.hook_type.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
            </div>
        <div class="form-group">
            {{ form.type.label}} {{ form.type(class="form-control") }}
            {% if form.type.errors %}
                <ul class="errors">
                    {% for error in form.type.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
            </div>
        <div class="form-group">
            {{ form.policy.label }} {{ form.policy(class="form-control") }}
            {% if form.policy.errors %}
                <ul class="errors">
                    {% for error in form.policy.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
            </div>
        <div class="form-group">
            {{ form.priority.label }} {{ form.priority(class="form-control") }}
            {% if form.priority.errors %}
                <ul class="errors">
                    {% for error in form.priority.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
            </div>
        <button type="submit" class="btn btn-primary">Create</button>
</div>
{% endblock %}

=== ./background/nftables-gui/nftables-frontend/templates/chains/create_chain.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
<script>
    // Función para actualizar el valor del input oculto con la table.family seleccionada
    function updateHiddenInput() {
        var selectedTable = document.getElementById('table').value;
        var hiddenInput = document.getElementById('family');
        hiddenInput.value = selectedTable.split('-')[1].trim(); // Obtener la parte de la familia de la tabla seleccionada
    }
</script>
{% endblock %}
{% block content %}
<div class="container">
    <h1>Create chain:</h1>
    <form id="myForm" action="/create_chain" method="POST" onsubmit="updateHiddenInput()">
        {{ form.csrf_token }}
        <div class="form-group">
            {{ form.table.label }}
            <select id="table" name="table" class="form-control" onchange="updateHiddenInput()">
                {% for table in tables %}
                <option value="{{ table.id }}&&{{ table.family }}">{{ table.name }} - {{ table.family }}</option>
                {% endfor %}
            </select>
            {% if form.table.errors %}
            <ul class="errors">
                {% for error in form.table.errors %}
                <li>{{ error }}</li>
                {% endfor %}
            </ul>
            {% endif %}
        </div>
        <div class="form-group">
            {{ form.name.label }} {{ form.name(class="form-control") }}
            {% if form.name.errors %}
            <ul class="errors">
                {% for error in form.name.errors %}
                <li>{{ error }}</li>
                {% endfor %}
            </ul>
            {% endif %}
        </div>
        <div class="form-group">
            {{ form.policy.label }}
            <select name="policy" class="form-control">
                <option value="accept">accept</option>
                <option value="drop">drop</option>
                <option value="reject">reject</option>
                <option value="return">return</option>
            </select>
            {% if form.policy.errors %}
            <ul class="errors">
                {% for error in form.policy.errors %}
                <li>{{ error }}</li>
                {% endfor %}
            </ul>
            {% endif %}
        </div>
        <input type="hidden" id="family" name="family" value="">
        <button type="submit" class="btn btn-primary">Create</button>
    </form>
</div>
{% endblock %}

=== ./background/nftables-gui/nftables-frontend/templates/error.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
<link rel="stylesheet" href="{{ url_for('static', filename='css/error.css') }}">
{% endblock %}
{% block content %}
<div class="container">
    <h1>Error</h1>
    <div>
        <h3 class="warning">Message: {{ message }}</h3> 
    </div>
    </div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/login.html ===

{% extends "bootstrap/base.html" %}
{% block title %}login{% endblock %}
{% block head %}
{{ super() }}
<link rel="stylesheet" href="{{ url_for('static', filename='css/login.css') }}">
{% endblock %}
{% block content %}
<div class="container">
    <div class="row">
        <div class="col-md-4 col-md-offset-4">
            <form method="POST" action="/login" class="login-form">
                {{ form.hidden_tag() }}
                <h2 style="color: white">Login</h2>

                <div class="form-group">
                    {{ form.username.label }} {{ form.username(class="form-control") }}
                    {% if form.username.errors %}
                        <div class="alert alert-danger">
                            {% for error in form.username.errors %}
                                <p>{{ error }}</p>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>
                <div class="form-group">
                    {{ form.password.label }} {{ form.password(class="form-control") }}
                    {% if form.password.errors %}
                        <div class="alert alert-danger">
                            {% for error in form.password.errors %}
                                <p>{{ error }}</p>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>
                <button type="submit" class="btn btn-primary">Submit</button>
            </form>
        </div>
    </div>
</div>
{% endblock %}

=== ./background/nftables-gui/nftables-frontend/templates/main.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container-main">
    <div class="row">
        <div class="col-md-4">
            <h1>nftables-gui</h1>
            <p>Welcome to the first GUI of nftables</p>
            <p> Hostname: {{ hostname }}</p>
            <p> IP address: {{ ip_address }}</p>  
            <br></br>
            <button type="button" class="btn btn-primary" onclick="window.location.href='/reload'">Reload nftables</button>         
        </div>
        <div class="col-md-5">
            <h1>General dashboard</h1>
            <img src="{{ nftables_info_image }}" alt="Gráfico de elementos nftables">
        </div>

    </div>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/maps/add_element.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
  <h1>Add element</h1>
  <form method="POST">
    <div class="form-group">
      <label for="key">Key</label>
      ({{ map.type }})
      <input type="text" class="form-control" id="key" name="key" required>
    </div>
    <div class="form-group">
      <label for="value">Value</label>
      ({{ map.map}})
      <input type="text" class="form-control" id="value" name="value" required>
    </div>
    <button type="submit" class="btn btn-primary">Add</button>
  </form>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/maps/create_map.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
    <h1>Create Map</h1>
    <form method="POST">
        <div class="form-group">
            <label for="name">Name</label>
            <input type="text" class="form-control" id="name" name="name" required>
        </div>
        <div class="form-group">
            <label for="table">Table</label>
            <select class="form-control" id="table" name="table" required>
                {% for table in tables %}
                <option value="{{ table.id }}&&{{ table.family }}">{{ table.name }} - {{ table.family}}</option>
                {% endfor %}
            </select>
        </div>
        {{ form.csrf_token }}
        <div class="form-group">
            {{ form.type.label }}
            {{ form.type(class="form-control") }}
            {% if form.type.errors %}
                <ul class="errors">
                    {% for error in form.type.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
        </div>
        <div class="form-group">
            {{ form.map_type.label }}
            {{ form.map_type(class="form-control") }}
            {% if form.map_type.errors %}
                <ul class="errors">
                    {% for error in form.map_type.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
            </div>
            <div class="form-group">
        {{ form.description.label }}
        {{ form.description(class="form-control") }}
        {% if form.description.errors %}
            <ul class="errors">
                {% for error in form.description.errors %}
                    <li>{{ error }}</li>
                {% endfor %}
            </ul>
        {% endif %}
        </div>
        <button type="submit" class="btn btn-primary">Create</button>
    </form>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/maps/delete_element.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
  <h1>Delete element</h1>
  <form method="POST">
    <div class="form-group">
      <label for="key">Key</label>
      <select class="form-control" id="key" name="key" required>
        {% for element in aux %}
        <option value="{{ element }}">{{ element }}</option>
        {% endfor %}
        </select>
    </div>
    <button type="submit" class="btn btn-danger">Delete</button>
  </form>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/maps/map.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
  <h1>Map</h1>
  <button class="btn btn-primary" onclick="location.href='/maps/{{ map.id }}/add_element'">Add element</button>
    <button class="btn btn-danger" onclick="location.href='/maps/{{ map.id }}/delete_element'">Delete element</button>
    <br><br>
  <table class="table personal-table">
    <tbody>
      <tr>
        <th>Map</th>
        <td>{{ map.name }}</td>
      </tr>
      <tr>
        <th>Type</th>
        <td>{{ map.type }}</td>
      </tr>
      <tr>
        <th>Mapper</th>
        <td>{{ map.map }}</td>
      </tr>
      <tr>
        <th>Elements</th>
        <td>{{ map.elements or "No elements yet"}}</td>
    </tbody>
  </table>
  <a href="/maps/{{ map.id }}/delete" class="btn btn-danger">Delete</a>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/maps/maps.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
  <h1>Maps</h1>
  <a href="/maps/new" class="btn btn-primary">New map</a>
    <br><br>
  <table class="table personal-table">
    <thead>
      <tr>
        <th>Map</th>
        <th>Type</th>
        <th>Mapper</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>
      {% for map in maps %}
      <tr>
        <td>{{ map.name }}</td>
        <td>{{ map.type }}</td>
        <td>{{ map.map }}</td>
        <td>
          <a href="/maps/{{ map.id }}" class="btn btn-primary">View</a>
          <a href="/maps/{{ map.id }}/delete" class="btn btn-danger">Delete</a>
        </td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/rules/create_rule.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
<link rel="stylesheet" href="{{ url_for('static', filename='css/rules.css') }}">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script>
$(document).ready(function(){
    $('#formSelect').change(function(){
        if ($(this).val() == 'not_terminal') {
            $('#statements').show();
            $('#statements_term').hide();
        } else if ($(this).val() == 'terminal') {
            $('#statements').hide();
            $('#statements_term').show();
        } else {
            $('#statements').hide();
            $('#statements_term').hide();
        }
    });
    // Añadir listeners de eventos para los cambios en los selects go_to y jump
    $('#statements_term-go_to').change(function(){
        $('#go_to').val($(this).val());
    });
    $('#statements_term-jump').change(function(){
        $('#jump').val($(this).val());
    });
});

    // Función para actualizar el valor del input oculto con la table.family seleccionada
function updateHiddenInput() {
    var selectedTable = document.getElementById('chain').value;
    var hiddenInput = document.getElementById('family');
    hiddenInput.value = selectedTable.split('-')[1].trim(); // Obtener la parte de la familia de la tabla seleccionada
}

</script>
{% endblock %}
{% block content %}
<div class="container">
    <h1>Create Rule</h1>
    <form method="POST" action="/rules/create_rule" class="needs-validation" novalidate>
        {{ form.csrf_token}}
        <div class="form-group">
            {{ form.description.label(class="form-control-label") }}
            {{ form.description(class="form-control form-control-lg") }}
        </div>
        <div class="form-group">
            {{ form.chain.label }}
            <select id="chain" name="chain" class="form-control" onchange="updateHiddenInput()">
                {% for chain in chains %}
                <option value="{{ chain.id }}&&{{chain.table.family}}&&{{chain.table.name}}&&{{chain.name}}">Name: {{ chain.name }} - Family: {{ chain.family }} - Table: {{ chain.table.name }}</option>
                {% endfor %}
            </select>
            {% if form.chain.errors %}
            <ul class="errors">
                {% for error in form.chain.errors %}
                <li>{{ error }}</li>
                {% endfor %}
            </ul>
            {% endif %}
        </div>

        <div class="form-group">
            <label for="formSelect">Selects the statements:</label>
            <select class="form-control" id="formSelect" name="statement_select">
                <option value="">--Selects--</option>
                <option value="not_terminal">Not terminal statements</option>
                <option value="terminal">Terminal statements</option>
            </select>
        </div>
        {% if form.chain.errors == [] and form.description.errors == [] %}
        <div class="alert alert-danger" role="alert">
            <strong>Warning!</strong> The rule could not be created because there are errors in the statement form.
        </div>
        {% endif %}
        <div id="statements" class="form-group" style="display:none">
            {% for field in form.statements %}
                {% if field.name != 'csrf_token' and field.type != 'SubmitField' %}
                    {% if field.name == 'statements-nflog' %}
                    <div class="form-group">
                        {{ field.label(class="form-control-label") }}
                        <p>Insert the name of the flog flow</p>
                        {{ field(class="form-control form-control-lg") }}
                        {% if field.errors %}
                        <ul class="errors">
                            {% for error in field.errors %}
                            <li>{{ error }}</li>
                            {% endfor %}
                        </ul>
                        {% endif %}
                    </div>
                    {% elif field.name == 'statements-src_ip_objects' %}
                    <div class="form-group">
                        {{ field.label(class="form-control-label") }}
                        <p>Insert the name of the source object</p>
                        <select id="statements-src_ip_objects" name="statements-src_ip_objects" class="form-control">
                            <option>--Selects--</option>
                            {% for object in objects %}
                            <option value="{{ object.name }}">{{ object.name }}</option>
                            {% endfor %}
                        </select>
                        <input type="hidden" id="src_ip_objects" name="src_ip_objects" value=""></input>
                        {% if field.errors %}
                        <ul class="errors">
                            {% for error in field.errors %}
                            <li>{{ error }}</li>
                            {% endfor %}
                        </ul>
                        {% endif %}
                    </div>
                    {% elif field.name == 'statements-dst_ip_objects' %}
                    <div class="form-group">
                        {{ field.label(class="form-control-label") }}
                        <p>Insert the name of the destination object</p>
                        <select id="statements-dst_ip_objects" name="statements-dst_ip_objects" class="form-control">
                            <option>--Selects--</option>
                            {% for object in objects %}
                            <option value="{{ object.name }}">{{ object.name }}</option>
                            {% endfor %}
                        </select>
                        <input type="hidden" id="dst_ip_objects" name="dst_ip_objects" value=""></input>
                        {% if field.errors %}
                        <ul class="errors">
                            {% for error in field.errors %}
                            <li>{{ error }}</li>
                            {% endfor %}
                        </ul>
                        {% endif %}
                    </div>
                    {% elif field.name == 'statements-src_port_objects' %}
                    <div class="form-group">
                        {{ field.label(class="form-control-label") }}
                        <p>Insert the name of the source port object</p>
                        <select id="statements-src_port_objects" name="statements-src_port_objects" class="form-control">
                            <option>--Selects--</option>
                            {% for object in objects %}
                            <option value="{{ object.name }}">{{ object.name }}</option>
                            {% endfor %}
                        </select>
                        <input type="hidden" id="src_port_objects" name="src_port_objects" value=""></input>
                        {% if field.errors %}
                        <ul class="errors">
                            {% for error in field.errors %}
                            <li>{{ error }}</li>
                            {% endfor %}
                        </ul>
                        {% endif %}
                    </div>
                    {% elif field.name == 'statements-dst_port_objects' %}
                    <div class="form-group">
                        {{ field.label(class="form-control-label") }}
                        <p>Insert the name of the destination port object</p>
                        <select id="statements-dst_port_objects" name="statements-dst_port_objects" class="form-control">
                            <option>--Selects--</option>
                            {% for object in objects %}
                            <option value="{{ object.name }}">{{ object.name }}</option>
                            {% endfor %}
                        </select>
                        <input type="hidden" id="dst_port_objects" name="dst_port_objects" value=""></input>
                        {% if field.errors %}
                        <ul class="errors">
                            {% for error in field.errors %}
                            <li>{{ error }}</li>
                            {% endfor %}
                        </ul>
                        {% endif %}
                    </div>
                    {% else %}
                    <div class="form-group">
                        {{ field.label(class="form-control-label") }}
                        {{ field(class="form-control form-control-lg") }}
                        {% if field.errors %}
                        <ul class="errors">
                            {% for error in field.errors %}
                            <li>{{ error }}</li>
                            {% endfor %}
                        </ul>
                        {% endif %}
                    </div>
                {% endif %}
                {% endif %}
            {% endfor %}
        </div>
        <div id="statements_term" class="form-group" style="display:none">
            {% for field in form.statements_term %}
                {% if field.name != 'csrf_token' and field.type != 'SubmitField' %}

                    {% if field.name == 'statements_term-jump' %}
                    <div class="form-group">
                        {{ field.label(class="form-control-label") }}
                        <p>Insert the name of the chain to jump</p>
                        <select id="statements_term-jump" name="statements_term-jump" class="form-control">
                            <option>--Selects--</option>
                            {% for chain in chains %}
                            
                            <option value="{{ chain.name }}">{{ chain.name }}</option>
                            {% endfor %}
                            </select>
                            <input type="hidden" id="jump" name="jump" value=""></input>

                        {% if field.errors %}
                        <ul class="errors">
                            {% for error in field.errors %}
                            <li>{{ error }}</li>
                            {% endfor %}
                        </ul>
                        {% endif %}
                    </div>
                    {% elif field.name == 'statements_term-go_to' %}
                    <div class="form-group">
                        {{ field.label(class="form-control-label") }}
                        <p>Insert the name of the chain to go to</p>
                        <select id="statements_term-go_to" name="statements_term-go_to" class="form-control">
                            <option>--Selects--</option>
                            {% for chain in chains %}
                            <option value="{{ chain.name }}">{{ chain.name }}</option>
                            {% endfor %}
                            </select>
                            <input type="hidden" id="go_to" name="go_to" value=""></input>

                        {% if field.errors %}
                        <ul class="errors">
                            {% for error in field.errors %}
                            <li>{{ error }}</li>
                            {% endfor %}
                        </ul>
                        {% endif %}
                    </div>
                    {% elif field.name == 'statements_term-src_ip_objects' %}
                    <div class="form-group">
                        {{ field.label(class="form-control-label") }}
                        <p>Insert the name of the source object</p>
                        <select id="statements_term-src_ip_objects" name="statements_term-src_ip_objects" class="form-control">
                            <option>--Selects--</option>
                            {% for object in objects %}
                            <option value="{{ object.name }}">{{ object.name }}</option>
                            {% endfor %}
                        </select>
                        <input type="hidden" id="src_ip_objects" name="src_ip_objects" value=""></input>
                        {% if field.errors %}
                        <ul class="errors">
                            {% for error in field.errors %}
                            <li>{{ error }}</li>
                            {% endfor %}
                        </ul>
                        {% endif %}
                    </div>
                    {% elif field.name == 'statements_term-dst_ip_objects' %}
                    <div class="form-group">
                        {{ field.label(class="form-control-label") }}
                        <p>Insert the name of the destination object</p>
                        <select id="statements_term-dst_ip_objects" name="statements_term-dst_ip_objects" class="form-control">
                            <option>--Selects--</option>
                            {% for object in objects %}
                            <option value="{{ object.name }}">{{ object.name }}</option>
                            {% endfor %}
                        </select>
                        <input type="hidden" id="dst_ip_objects" name="dst_ip_objects" value=""></input>
                        {% if field.errors %}
                        <ul class="errors">
                            {% for error in field.errors %}
                            <li>{{ error }}</li>
                            {% endfor %}
                        </ul>
                        {% endif %}
                    </div>
                    {% elif field.name == 'statements_term-src_port_objects' %}
                    <div class="form-group">
                        {{ field.label(class="form-control-label") }}
                        <p>Insert the name of the source port object</p>
                        <select id="statements_term-src_port_objects" name="statements_term-src_port_objects" class="form-control">
                            <option>--Selects--</option>
                            {% for object in objects %}
                            <option value="{{ object.name }}">{{ object.name }}</option>
                            {% endfor %}
                        </select>
                        <input type="hidden" id="src_port_objects" name="src_port_objects" value=""></input>
                        {% if field.errors %}
                        <ul class="errors">
                            {% for error in field.errors %}
                            <li>{{ error }}</li>
                            {% endfor %}
                        </ul>
                        {% endif %}
                    </div>
                    {% elif field.name == 'statements_term-dst_port_objects' %}
                    <div class="form-group">
                        {{ field.label(class="form-control-label") }}
                        <p>Insert the name of the destination port object</p>
                        <select id="statements_term-dst_port_objects" name="statements_term-dst_port_objects" class="form-control">
                            <option>--Selects--</option>
                            {% for object in objects %}
                            <option value="{{ object.name }}">{{ object.name }}</option>
                            {% endfor %}
                        </select>
                        <input type="hidden" id="dst_port_objects" name="dst_port_objects" value=""></input>
                        {% if field.errors %}
                        <ul class="errors">
                            {% for error in field.errors %}
                            <li>{{ error }}</li>
                            {% endfor %}
                        </ul>
                        {% endif %}
                    </div>

                    {% else %}                        
                    <div class="form-group">
                        {{ field.label(class="form-control-label") }}
                        {{ field(class="form-control form-control-lg") }}
                        {% if field.errors %}
                        <ul class="errors">
                            {% for error in field.errors %}
                            <li>{{ error }}</li>
                            {% endfor %}
                        </ul>
                        {% endif %}
                    </div>
                    {% endif %}
                {% endif %}
            {% endfor %}
        </div>
        <input type="hidden" id="family" name="family" value="">
        {% if form.errors %}
        <ul class="errors">
            {% for error in form.errors %}
            <li>{{ error }}</li>
            {% endfor %}
        </ul>
        {% endif %}
        <div class="form-group">
            {{ form.submit (class="btn btn-primary") }}
        </div>
        {{ msg }}
    </form>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/rules/edit_description.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
<h3>Edit Description</h3>
<h2>Rule: {{ rule.handle }}</h2>
<h1>Rule Description: {{ rule.description }}</h1>
<form method="POST">
  <div class="form-group">
    <label for="description">Description:</label>
    <input type="text" class="form-control" id="description" name="description" value="{{ rule.description }}">
  </div>
  <button type="submit" class="btn btn-primary">Submit</button>
</form>
</div>
    {% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/rules/rule.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
<link rel="stylesheet" href="{{ url_for('static', filename='css/rule.css') }}">
{% endblock %}
{% block content %}
<div class="container">
    <h1>Rule</h1>
    <div>
      <ul>
        <li>
        <h3>Handle: {{ rule.handle }}</h3>
        </li>
        <li>
        <h3>Family: {{ rule.table().family }}</h3>
        </li>
        <li>
        <h3>Table: {{ rule.table().name }}</h3>
        </li>
        <li>
        <h3>Chain: {{ rule.chain.name }}</h3>
        </li>
        <li>
          <h3>Description: {{ rule.description or "" }} </h3><button onclick="window.location.href='/rules/{{ rule.id }}/edit_description'">Edit Description</button>
        </li>
      </ul>
    </div>
    </div>
    <div class="espaciado">
    <h1>Statements</h1>
        <table class="table personal-table">
                <thead>
                  <tr>
                    <th>SRC</th>
                    <th>DST</th>
                    <th>SRC PORT</th>
                    <th>DST PORT</th>
                    <th>INPUT INTERFACE</th>
                    <th>OUTPUT INTERFACE</th>
                    <th>PROTOCOL</th>

                  </tr>
                </thead>
                <tbody>
                    {% for statement in statements %}
                    {% if statement.rule_id == rule.id %}
                      <tr>
                      {% if statement.src_ip != None %}
                      <td>{{ statement.src_ip }}</td>
                      {% else %}
                      <td>No source IP</td>
                      {% endif %}
                      {% if statement.dst_ip != None %}
                      <td>{{ statement.dst_ip }}</td>
                      {% else %}
                      <td>No destination IP</td>
                      {% endif %}
                      {% if statement.src_port != None %}
                      <td>{{ statement.src_port }}</td>
                      {% else %}
                      <td>No source port</td>
                      {% endif %}
                      {% if statement.dst_port != None %}
                      <td>{{ statement.dst_port }}</td>
                      {% else %}
                      <td>No destination port</td>
                      {% endif %}
                      <td>{{ statement.input_interface or "" }}</td>
                      <td>{{ statement.output_interface or "" }}</td>
                      <td>{{ statement.protocol or "" }}</td>

                    </tr>
                    {% endif %}
                    {% endfor %}
                </tbody>
              </table>
              <h1>Terminal Actions</h1>
              <table class="table personal-table">
                <thead>
                  <tr>
                    <th>reject</th>
                    <th>drop</th>
                    <th>accept</th>
                    <th>queue</th>
                    <th>return_</th>
                    <th>jump</th>
                    <th>go_to</th>

                  </tr>
                </thead>
                <tbody>
                  {% for statement in statements %}
                  <tr>
                  {% if statement.rule_id == rule.id %}
                  <td>{{ statement.reject or "" }}</td>
                  <td>{% if statement.drop %}
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check" viewBox="0 0 16 16">
                    <path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425z"/>
                  </svg>
                  {% endif %}

                  </td>
                  <td>{% if statement.accept %}
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check" viewBox="0 0 16 16">
                    <path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425z"/>
                  </svg>
                  {% endif %} 

                  </td>
                  <td>{{ statement.queue or ""}}</td>
                  <td>{% if statement.return_ == 1 %}
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check" viewBox="0 0 16 16">
                    <path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425z"/>
                  </svg>
                  {% elif statement.return_ %}
                  {{ statement.return_ }}
                  {% endif %}
                  </td>
                  <td>{{ statement.jump or ""}}</td>
                  <td>{{ statement.go_to or "" }}</td>
                  {% endif %}
                  </tr>
                  {% endfor %}
                </tbody>
              </table>
              <h1>Not terminal Actions</h1>
              <table class="table personal-table">
                <thead>
                  <tr>
                    <th>limit</th>
                    <th>log</th>
                    <th>counter</th>
                    <th>masquerade</th>
                    <th>snat</th>
                    <th>dnat</th>
                    <th>redirect</th>
                  </tr>
                </thead>
                <tbody>
                  {% for statement in statements %}
                  <tr>
                  {% if statement.rule_id == rule.id %}
                  <td>{{ statement.limit or ""}}</td>
                  <td>{{ statement.log or ""}}</td>
                  <td>{{ statement.counter or "" }}</td>
                  <td>
                  {% if statement.masquerade %}
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check" viewBox="0 0 16 16">
                    <path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425z"/>
                  </svg>
                  {% endif %}
                  </td>
                  <td>{{ statement.snat or "" }}</td>
                  <td>{{ statement.dnat or ""}}</td>
                  <td>{{ statement.redirect or ""}}</td>
                  {% endif %}
                  </tr>
                  {% endfor %}
                </tbody>
              </table>
              
    </div>

{% endblock %}              
=== ./background/nftables-gui/nftables-frontend/templates/rules/rules.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
  <h1>Rules</h1>
  <button class="btn btn-primary" onclick="window.location.href='/rules/create_rule'">Add</button>
  <br></br>
  <table class="table personal-table">
    <thead>
      <tr>
        <th>Handle</th>
        <th>Description</th>
        <th>Table</th>
        <th>Family</th>
        <th>Chain</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>
       
    {% for rule in rules %}
      <tr>
        <td>{{ rule.handle }}</td>
        <td>
          {% if rule.description == None %}
            No description
          {% else %}
          {{ rule.description }}
          {% endif %}</td>
        <td><a href="/table/{{ rule.chain.table.name}}/{{ rule.chain.table.family }}">   {{ rule.chain.table.name }}</a></td>
        <td>{{ rule.chain.table.family }}</td>
        <td><a href="/chain/{{ rule.chain.name }}/{{ rule.chain.table.family }}/{{ rule.chain.table.id }}"> {{ rule.chain.name }}</a></td>

              <td>
                <button class="btn btn-danger" onclick="window.location.href='/rules/{{ rule.id }}/delete'">Delete</button> 
                <br></br>
                <button class="btn btn-primary" onclick="window.location.href='/rules/{{ rule.id }}'">Details</button>
              </td>
      </tr>

    {% endfor %}
    </tbody>
  </table>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/ruleset.html ===

{% extends "base.html" %}
{% block content %}
<div class="container">
    <h1>Complete configuration of nftables</h1>
    <form action="/list_ruleset" method="post">
        <div class="form-group">
            <button type="submit" class="btn btn-primary">Load ruleset</button>
        </div>
    </form>
    <pre>{{ ruleset }}</pre>
</div>
{% endblock %}

=== ./background/nftables-gui/nftables-frontend/templates/save-changes.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
    <h2>Save changes:</h2>
    <form method="POST">
        <label for="comment">How do you want to save the changes?</label>
        <select class="form-control" id="save" name="save" required>
            <option value="config" selected>Directly to configuration file</option>
            <option value="file">On another file - it will be saved in the tmp_config folder of the proyect</option>


        </select>
        <br></br>
        <button type="submit" class="btn btn-primary">Save</button>
    </form>
</div>
{% endblock %}

=== ./background/nftables-gui/nftables-frontend/templates/sets/add-list.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
  <h1>Add black/white list</h1>
  <form method="POST" enctype="multipart/form-data">
    {{ form.csrf_token }}
    <div class="form-group">
      <label for="name">Name</label>
      <input type="text" class="form-control" id="name" name="name" required>
      {% for error in form.name.errors %}
        <div class="alert alert-danger" role="alert">
            {{ error }}
            </div>
        {% endfor %}
    </div>
    <div class="form-group">
      <label for="table">Table</label>
      <select class="form-control" id="table" name="table">
        {% for table in tables %}
        <option value="{{ table.id }}&&{{table.family}}">{{ table.name }} - {{table.family}}</option>
        {% endfor %}
      </select>
    <div class="form-group">
    <input type="hidden" name="type" value="ipv4_addr">        
    </div>
    <div class="form-group">
      <label for="list">List</label>
      <input type="file" class="form-control" id="list" name="list"></input>
      {{ mssg }}
    </div>
    <div>
        <label for="description">Description</label>
        <textarea class="form-control" id="description" name="description" rows="3"></textarea>
        {% for error in form.description.errors %}
        <div class="alert alert-danger" role="alert">
            {{ error }}
            </div>
        {% endfor %}
    </div>
    <br></br>
    <button type="submit" class="btn btn-primary">Submit</button>
  </form>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/sets/add_element.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
  <h1>Add element</h1>
  <a href="https://es.wikipedia.org/wiki/Anexo:N%C3%BAmeros_de_protocolo_IP" target="_blank">IP protocol numbers</a>
  <br></br>
  <form method="POST">
    <div class="form-group">
      <label for="element">Element</label>
      <input type="text" class="form-control" id="element" name="element" required>
    </div>
    <button type="submit" class="btn btn-primary">Add</button>
  </form>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/sets/create_set.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
  <h1>Create set</h1>
  <form method="POST">
    {{ form.csrf_token }}
    <div class="form-group">
      <label for="name">Name</label>
      <input type="text" class="form-control" id="name" name="name" required>
    </div>
    <div class="form-group">
      <label for="table">Table</label>
      <select class="form-control" id="table" name="table" required>
        {% for table in tables %}
        <option value="{{ table.id }}&&{{table.family}}">{{ table.name }} - {{table.family}}</option>
        {% endfor %}
      </select>
    </div>
    <div class="form-group">
        <label for="type">Type</label>
        <select class="form-control" id="type" name="type" required>
            <option value="ipv4_addr">IPv4 address</option>
            <option value="ipv6_addr">IPv6 address</option>
            <option value="inet_service">Service</option>
            <option value="ether_addr">MAC address</option>
            <option value="inet_proto">Protocol</option>
            <option value="mark">Mark</option>
        </select>
    </div>
    <div class="form-group">
        <label for="description">Description</label>
        <input type="text" class="form-control" id="description" name="description">
    </div>

    <button type="submit" class="btn btn-primary">Create</button>
    </form>
</div>
{% endblock %}

=== ./background/nftables-gui/nftables-frontend/templates/sets/delete_element.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
  <h1>Delete element</h1>
  <form method="POST">
    <div class="form-group">
      <label for="element">Element</label>
        <select class="form-control" id="element" name="element" required>
          {% for element in aux %}
          <option value="{{ element }}">{{ element }}</option>
          {% endfor %}
          </select>
    </div>
    <button type="submit" class="btn btn-primary">Delete</button>
  </form>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/sets/set.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
  <h1>Set</h1>
  <button class="btn btn-primary" onclick="location.href='/sets/{{ set.id }}/add_element'">Add element</button>
  <button class="btn btn-danger" onclick="location.href='/sets/{{ set.id }}/delete_element'">Delete element</button>
  <br></br>

  <table class="table personal-table">
    <tbody>
      <tr>
        <th>Name</th>
        <td>{{ set.name }}</td>
      </tr>
      <tr>
        <th>Type</th>
        <td>{{ set.type }}</td>
      </tr>
      <tr>
        <th>Elements</th>
        <td>
          <ul>
            {% if set.elements != None %}
            {{ set.elements }}
            {% else %}
            <li>No elements</li>
            {% endif %}
          </ul>
        </td>
      </tr>
    </tbody>
  </table>
  <a href="/sets/{{ set.id }}/delete" class="btn btn-danger">Delete</a>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/sets/sets.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
  <h1>Sets</h1>
  <a href="/sets/new" class="btn btn-primary">New set</a>
  <button class="btn btn-success" onclick="location.href='/add-list'">Insert black/white list</button>
    <br><br>
  <table class="table personal-table">
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>
      {% for set in sets %}
      <tr>
        <td>{{ set.name }}</td>
        <td>{{ set.type }}</td>
        <td>
          <a href="/sets/{{ set.id }}" class="btn btn-primary">View</a>
          <a href="/sets/{{ set.id }}/delete" class="btn btn-danger">Delete</a>
        </td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/tables/add_table.html ===

{% extends "base.html" %}
{% block content %}
<div class="container">
    <h2>Create Table</h2>
    <form id="myForm" action="/add_table" method="POST">
        {{ form.csrf_token }}
        <div class="form-group">
            {{ form.name.label }} {{ form.name(class="form-control") }}
            {% if form.name.errors %}
                <ul class="errors">
                    {% for error in form.name.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
        </div>

        <div class="form-group">
            {{ form.family.label }} {{ form.family(class="form-control") }}
            {% if form.family.errors %}
                <ul class="errors">
                    {% for error in form.family.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
        </div>
        <div class="form-group">
            {{ form.description.label }} {{ form.description(class="form-control") }}
            {% if form.description.errors %}
                <ul class="errors">
                    {% for error in form.description.errors %}
                        <li>{{ error }}</li>
                    {% endfor %}
                </ul>
            {% endif %}
        </div>
        <button type="submit" class="btn btn-primary">Create</button>
    </form>
</div>
{% endblock %}


=== ./background/nftables-gui/nftables-frontend/templates/tables/table.html ===

{% extends "base.html" %}
{% block head%}
{{ super() }}
{% endblock %}
{% block content %}
<div class="container">
    <h1>Table: {{ table.name }}</h1>
    <button class="btn btn-danger" onclick="location.href='/delete_table/{{ table.name }}/{{ table.family }}'">Delete table</button>
    <button class="btn btn-warning" onclick="location.href='/flush_table/{{ table.name }}/{{ table.family }}'">Flush table</button>
    <br></br>
    <table class="table personal-table">
        <thead>
            <tr>
                <th>Chain</th>
                <th>Family</th>
                <th>Description</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            {% if table.chains == [] %}
                <tr>
                    <td colspan="3">No chains</td>
                </tr>
            {% else %}
            {% for chain in table.chains %}
                <tr>
                    <td><a href="/chain/{{ chain.name }}/{{chain.table.family}}/{{ table.id }}"> {{ chain.name }}</a></td>
                    <td>{{ table.family }}</td>
                    <td>
                        {% if chain.description %}
                            {{ chain.description }}
                        {% else %}
                            No description
                        {% endif %}
                    </td>
                    <td>
                        <button class="btn btn-danger" onclick="location.href='/chains/{{ chain.name }}/{{ chain.family }}/{{ table.name }}/delete'">Delete</button>
                    </td>
                </tr>
            {% endfor %}
            {% endif %}
        </tbody>
    </table>
</div>
{% endblock %}
=== ./background/nftables-gui/nftables-frontend/templates/tables/tables.html ===

{% extends "base.html" %}
{% block head%}
{{ super() }}
<link rel="stylesheet" href="{{ url_for('static', filename='css/tables.css') }}">
{% endblock %}
{% block content %} 
    <div class="container">
        <h1>Tables:</h1>
        <button class="btn btn-primary" onclick="location.href='/add_table'">Add table</button>
        <br></br>
        <table class="table personal-table">
            <thead>
                <tr>
                    <th>Table</th>
                    <th>Family</th>
                    <th>Description</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                {% if tables == [] %}
                    <tr>
                        <td colspan="3">No tables</td>
                    </tr>
                {% else %}
                {% for table in tables %}
                    <tr>
                        <td><a href="/table/{{ table.name }}/{{ table.family }}"> {{ table.name }}</a></td>
                        <td>{{ table.family }}</td>
                        <td>
                            {% if table.description %}
                                {{ table.description }}
                            {% else %}
                                No description
                            {% endif %}
                        </td>
                        <td>
                            <button class="btn btn-danger" onclick="location.href='/delete_table/{{ table.name }}/{{table.family}}'">Delete</button>
                        </td>
                    </tr>
                {% endfor %}
                {% endif %}
            </tbody>
</div>
    {% endblock %}

=== ./background/nftables-gui/nftables-frontend/templates/users/create_user.html ===

{% extends "base.html" %}
{% block head %}
{{ super() }}
<link rel="stylesheet" href="{{ url_for('static', filename='css/create_user.css') }}">
{% endblock %}
{% block content %}
<div class="container">
    <div class="row">
        <div class="col-md-4 col-md-offset-4">
            <form method="POST" action="/create_user" class="create-user-form">
                {{ form.hidden_tag() }}
                <h2 style="color: white">Create user</h2>

                <div class="form-group
                    {% if form.username.errors %} has-error {% endif %}">
                    {{ form.username.label }} {{ form.username(class="form-control") }}
                    {% if form.username.errors %}
                        <div class="alert alert-danger">
                            {% for error in form.username.errors %}
                                <p>{{ error }}</p>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>
               
                <div class="form-group {% if form.password.errors %} has-error {% endif %}">
                    {{ form.password.label }} {{ form.password(class="form-control") }}
                    {% if form.password.errors %}
                        <div class="alert alert-danger">
                            {% for error in form.password.errors %}
                                <p>{{ error }}</p>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>
                <div class="form-group {% if form.confirm_password.errors %} has-error {% endif %}">
                    {{ form.confirm_password.label }} {{ form.confirm_password(class="form-control") }}
                    {% if form.confirm_password.errors %}
                        <div class="alert alert-danger">
                            {% for error in form.confirm_password.errors %}
                                <p>{{ error }}</p>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>
                <div class="form-group {% if form.role.errors %} has-error {% endif %}">
                    {{ form.role.label }} {{ form.role(class="form-control") }}
                    {% if form.role.errors %}
                        <div class="alert alert-danger">
                            {% for error in form.role.errors %}
                                <p>{{ error }}</p>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>
                <button type="submit" class="btn btn-primary">Submit</button>
            </form>
        </div>
    </div>
</div>
{% endblock %}
                    
=== ./background/nftables-gui/nftables-frontend/templates/users/users.html ===

{% extends "base.html"%}
{% block head %}
{{ super() }}
<link rel="stylesheet" href="{{ url_for('static', filename='css/users.css') }}">
{% endblock %}
{% block content %}
<div class="container">
    <h1>Users:</h1>
    <button class="btn btn-primary" onclick="location.href='/create_user'" class="button-create-user">Create user</button>
    <br></br>
<table aria-describedby="users-table-description" class="users-table">
    <tr class="head-user-table">
        <th>Username</th>
        <th>Role</th>
        <th>Actions</th>
    </tr>
    {% for user in users %}
    <tr class="body-user-table">
        <td>{{ user.username }}</td>
        <td>{{ user.role }}</td>
        <td>
            <button class="btn btn-danger" onclick="location.href='/delete_user/{{ user.id }}'">Delete</button>
        </td>
    </tr>
    {% endfor %}
</table>
</div>
{% endblock %}

=== ./background/nftables-gui/requirements.txt ===

flask==3.0.1
flask-bootstrap==3.3.7.1
flask_sqlalchemy==3.1.1
flask-migrate==4.0.7
flask-login==0.6.3
flask-wtf==1.2.1
hug
email_validator
matplotlib
python-Levenshtein
pytest
pytest-sugar
pytest-order
pytest-cov

=== ./background/relianoid/LICENSE ===

                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

=== ./background/relianoid/README.md ===

# [RELIANOID Load Balancer Community Edition](https://www.relianoid.com)

![SourceForge Downloads](https://img.shields.io/sourceforge/dt/relianoid?label=SourceForge%20downloads)
![GitHub Downloads](https://img.shields.io/github/downloads/relianoid/adc-loadbalancer/total?label=GitHub%20downloads)
![GitHub Release Date](https://img.shields.io/github/release-date/relianoid/adc-loadbalancer)
![GitHub Release](https://img.shields.io/github/v/release/relianoid/adc-loadbalancer)
![Static Badge](https://img.shields.io/badge/perl-5.36-blue)
[![License: AGPL v3](https://img.shields.io/badge/License-AGPL%20v3-blue.svg)](https://www.gnu.org/licenses/agpl-3.0)

Open-source load balancer that makes easy to make your websites and services always available, more secure and faster.

It does this by **sharing traffic** between multiple servers and **keeping your services running smoothly** even if one server goes down.

It is designed to be easy to use, with a simple web interface that lets you manage everything without needing advanced technical skills.

**Features**:

- Load balancing backends: Layer 4, HTTP and HTTPS.
- Load balancing algorithms: round-robin, least connections and others.
- HTTPS certificates and Let's Encrypt support.
- Monitoring of backend servers health status.
- Monitoring, statistics and SNMP suport.
- VLAN networking support.
- Stateless cluster support.
- Backups.

## Getting Started

- Download the latest ISO image at [SourceForge](https://sourceforge.net/projects/relianoid/files/latest/download) or [Github](https://github.com/relianoid/adc-loadbalancer/releases/latest).
- [Installation guide](https://www.relianoid.com/resources/knowledge-base/community-edition-v7-administration-guide/ce-v7-installation/).


### Requirements

- At least 512 MB of RAM is recommended.
- At least 4 GB of disk is recommended. Uses 1.6 GB after install.


## Support

- [Knowledge base](https://www.relianoid.com/resources/knowledge-base/)
  - [Community Edition](https://www.relianoid.com/resources/knowledge-base/community-edition/)
    - [Administration guide](https://www.relianoid.com/resources/knowledge-base/community-edition-v7-administration-guide/)
  - [HOWTOs](https://www.relianoid.com/resources/knowledge-base/howtos/)
  - [Troubleshooting](https://www.relianoid.com/resources/knowledge-base/troubleshooting/)
  - [API Reference](https://www.relianoid.com/apidoc/v4.0/)
- [Community support forum](https://www.relianoid.com/community/support/)

[Professional support](https://www.relianoid.com/services/support/) is also avalable.


## Contributing

- Before reporting a new issue, try to make sure it's not already in our knowledge base or is already reported in the forum.
- The best way to get your bug fixed is to provide a reduced test case.

### Project Structure

- **DEBIAN/**: Debian package files.
- **etc/**: System services and configuration files.
- **usr/share/perl5/**: Perl library.
- **usr/local/relianoid/**: Commands, configuration and data.
  - **api-model/**: API Specification files.
  - **app/**: Files to suppport the use dependencies, like Let's Encrypt or clustering via ucarp.
  - **bin/**: Relianoid commands.
  - **backups/**: Default directory where the configuration backups will be placed.
  - **config/**: Default directory where the load balancing services, health checks and network configuration files will be placed.
  - **share/**: Directory for templates and other data.
  - **www/**: API and web interface files.


## License

See [license.txt](https://github.com/relianoid/adc-loadbalancer/blob/master/usr/local/relianoid/license.txt).


---


More info at https://www.relianoid.com

=== ./background/relianoid/usr/local/relianoid/app/letsencrypt/webroot/index.html ===

<HTML>
	RELIANOID Service configuration for letsencrypt certificate validation.
</HTML>


=== ./background/relianoid/usr/local/relianoid/license.html ===

	<h4 style="text-align: center;">GNU Affero General Public License version 3</h4>
	<p>Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;<br>
     Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</p>

    <h5 style="text-align: center;">Preamble</h5>

    <p>The GNU Affero General Public License is a free, copyleft license for software and other kinds of works, specifically designed to ensure cooperation with the community in the case of network server software.</p>

    <p>The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, our General Public Licenses are intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users.</p>

    <p>When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.</p>

    <p>Developers that use our General Public Licenses protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License which gives you legal permission to copy, distribute and/or modify the software.</p>

    <p>A secondary benefit of defending all users' freedom is that improvements made in alternate versions of the program, if they receive widespread use, become available for other developers to incorporate. Many developers of free software are heartened and encouraged by the resulting cooperation. However, in the case of software used on network servers, this result may fail to come about. The GNU General Public License permits making a modified version and letting the public access it on a server without ever releasing its source code to the public.</p>

    <p>The GNU Affero General Public License is designed specifically to ensure that, in such cases, the modified source code becomes available to the community. It requires the operator of a network server to provide the source code of the modified version running there to the users of that server. Therefore, public use of a modified version, on a publicly accessible server, gives the public access to the source code of the modified version.</p>

    <p>An older license, called the Affero General Public License and published by Affero, was designed to accomplish similar goals. This is a different license, not a version of the Affero GPL, but Affero has released a new version of the Affero GPL which permits relicensing under this license.</p>

    <p>The precise terms and conditions for copying, distribution and modification follow.</p>

    <h5 style="text-align: center;">TERMS AND CONDITIONS</h5>

    <h5>0. Definitions.</h5>

    <p>"This License" refers to version 3 of the GNU Affero General Public License.</p>

    <p>"Copyright" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.</p>

    <p>"The Program" refers to any copyrightable work licensed under this License. Each licensee is addressed as "you". "Licensees" and "recipients" may be individuals or organizations.</p>

    <p>To "modify" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a "modified version" of the earlier work or a work "based on" the earlier work.</p>

    <p>A "covered work" means either the unmodified Program or a work based on the Program.</p>

    <p>To "propagate" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.</p>

    <p>To "convey" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.</p>

    <p>An interactive user interface displays "Appropriate Legal Notices" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.</p>

    <h5>1. Source Code.</h5>

    <p>The "source code" for a work means the preferred form of the work for making modifications to it. "Object code" means any non-source form of a work.</p>

    <p>A "Standard Interface" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.</p>

    <p>The "System Libraries" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A "Major Component", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.</p>

    <p>The "Corresponding Source" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.</p>

    <p>The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.</p>

    <p>The Corresponding Source for a work in source code form is that same work.</p>

    <h5>2. Basic Permissions.</h5>

    <p>All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.</p>

    <p>You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.</p>

    <p>Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.</p>

    <h5>3. Protecting Users' Legal Rights From Anti-Circumvention Law.</h5>

    <p>No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.</p>

    <p>When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.</p>

    <h5>4. Conveying Verbatim Copies.</h5>

    <p>You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.</p>

    <p>You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.</p>

    <h5>5. Conveying Modified Source Versions.</h5>

    <p>You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:</p>

    <ul><li>a) The work must carry prominent notices stating that you modified it, and giving a relevant date.</li>

      <li>b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to "keep intact all notices".</li>

      <li>c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it.</li>

      <li>d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so.</li>
    </ul><p>A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an "aggregate" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.</p>

    <h5>6. Conveying Non-Source Forms.</h5>

    <p>You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:</p>

    <ul><li>a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange.</li>

      <li>b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge.</li>

      <li>c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b.</li>

      <li>d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements.</li>

      <li>e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d.</li>
    </ul><p>A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.</p>

    <p>A "User Product" is either (1) a "consumer product", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, "normally used" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.</p>

    <p>"Installation Information" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.</p>

    <p>If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).</p>

    <p>The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.</p>

    <p>Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.</p>

    <h5>7. Additional Terms.</h5>

    <p>"Additional permissions" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.</p>

    <p>When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.</p>

    <p>Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:</p>

    <ul><li>a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or</li>

      <li>b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or</li>

      <li>c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or</li>

      <li>d) Limiting the use for publicity purposes of names of licensors or authors of the material; or</li>

      <li>e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or</li>

      <li>f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors.</li>
    </ul><p>All other non-permissive additional terms are considered "further restrictions" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.</p>

    <p>If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.</p>

    <p>Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.</p>

    <h5>8. Termination.</h5>

    <p>You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).</p>

    <p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p>

    <p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p>

    <p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.</p>

    <h5>9. Acceptance Not Required for Having Copies.</h5>

    <p>You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.</p>

    <h5>10. Automatic Licensing of Downstream Recipients.</h5>

    <p>Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License.</p>

    <p>An "entity transaction" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.</p>

    <p>You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.</p>

    <h5>11. Patents.</h5>

    <p>A "contributor" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's "contributor version".</p>

    <p>A contributor's "essential patent claims" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, "control" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.</p>

    <p>Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.</p>

    <p>In the following three paragraphs, a "patent license" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To "grant" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.</p>

    <p>If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. "Knowingly relying" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.</p>

    <p>If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.</p>

    <p>A patent license is "discriminatory" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.</p>

    <p>Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.</p>

    <h5>12. No Surrender of Others' Freedom.</h5>

    <p>If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.</p>

    <h5>13. Remote Network Interaction; Use with the GNU General Public License.</h5>

    <p>Notwithstanding any other provision of this License, if you modify the Program, your modified version must prominently offer all users interacting with it remotely through a computer network (if your version supports such interaction) an opportunity to receive the Corresponding Source of your version by providing access to the Corresponding Source from a network server at no charge, through some standard or customary means of facilitating copying of software. This Corresponding Source shall include the Corresponding Source for any work covered by version 3 of the GNU General Public License that is incorporated pursuant to the following paragraph.</p>

    <p>Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the work with which it is combined will remain governed by version 3 of the GNU General Public License.</p>

    <h5>14. Revised Versions of this License.</h5>

    <p>The Free Software Foundation may publish revised and/or new versions of the GNU Affero General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p>

    <p>Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU Affero General Public License "or any later version" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU Affero General Public License, you may choose any version ever published by the Free Software Foundation.</p>

    <p>If the Program specifies that a proxy can decide which future versions of the GNU Affero General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program.</p>

    <p>Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.</p>

    <h5>15. Disclaimer of Warranty.</h5>

    <p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</p>

    <h5>16. Limitation of Liability.</h5>

    <p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>

    <h5>17. Interpretation of Sections 15 and 16.</h5>

    <p>If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.</p>

    <p style="text-align:center";>END OF TERMS AND CONDITIONS</p>

=== ./background/relianoid/usr/local/relianoid/license.txt ===

                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

=== ./background/relianoid_adc/source_tree/LICENSE ===

                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

=== ./background/relianoid_adc/source_tree/README.md ===

# [RELIANOID Load Balancer Community Edition](https://www.relianoid.com)

![SourceForge Downloads](https://img.shields.io/sourceforge/dt/relianoid?label=SourceForge%20downloads)
![GitHub Downloads](https://img.shields.io/github/downloads/relianoid/adc-loadbalancer/total?label=GitHub%20downloads)
![GitHub Release Date](https://img.shields.io/github/release-date/relianoid/adc-loadbalancer)
![GitHub Release](https://img.shields.io/github/v/release/relianoid/adc-loadbalancer)
![Static Badge](https://img.shields.io/badge/perl-5.36-blue)
[![License: AGPL v3](https://img.shields.io/badge/License-AGPL%20v3-blue.svg)](https://www.gnu.org/licenses/agpl-3.0)

Open-source load balancer that makes easy to make your websites and services always available, more secure and faster.

It does this by **sharing traffic** between multiple servers and **keeping your services running smoothly** even if one server goes down.

It is designed to be easy to use, with a simple web interface that lets you manage everything without needing advanced technical skills.

**Features**:

- Load balancing backends: Layer 4, HTTP and HTTPS.
- Load balancing algorithms: round-robin, least connections and others.
- HTTPS certificates and Let's Encrypt support.
- Monitoring of backend servers health status.
- Monitoring, statistics and SNMP suport.
- VLAN networking support.
- Stateless cluster support.
- Backups.

## Getting Started

- Download the latest ISO image at [SourceForge](https://sourceforge.net/projects/relianoid/files/latest/download) or [Github](https://github.com/relianoid/adc-loadbalancer/releases/latest).
- [Installation guide](https://www.relianoid.com/resources/knowledge-base/community-edition-v7-administration-guide/ce-v7-installation/).


### Requirements

- At least 512 MB of RAM is recommended.
- At least 4 GB of disk is recommended. Uses 1.6 GB after install.


## Support

- [Knowledge base](https://www.relianoid.com/resources/knowledge-base/)
  - [Community Edition](https://www.relianoid.com/resources/knowledge-base/community-edition/)
    - [Administration guide](https://www.relianoid.com/resources/knowledge-base/community-edition-v7-administration-guide/)
  - [HOWTOs](https://www.relianoid.com/resources/knowledge-base/howtos/)
  - [Troubleshooting](https://www.relianoid.com/resources/knowledge-base/troubleshooting/)
  - [API Reference](https://www.relianoid.com/apidoc/v4.0/)
- [Community support forum](https://www.relianoid.com/community/support/)

[Professional support](https://www.relianoid.com/services/support/) is also avalable.


## Contributing

- Before reporting a new issue, try to make sure it's not already in our knowledge base or is already reported in the forum.
- The best way to get your bug fixed is to provide a reduced test case.

### Project Structure

- **DEBIAN/**: Debian package files.
- **etc/**: System services and configuration files.
- **usr/share/perl5/**: Perl library.
- **usr/local/relianoid/**: Commands, configuration and data.
  - **api-model/**: API Specification files.
  - **app/**: Files to suppport the use dependencies, like Let's Encrypt or clustering via ucarp.
  - **bin/**: Relianoid commands.
  - **backups/**: Default directory where the configuration backups will be placed.
  - **config/**: Default directory where the load balancing services, health checks and network configuration files will be placed.
  - **share/**: Directory for templates and other data.
  - **www/**: API and web interface files.


## License

See [license.txt](https://github.com/relianoid/adc-loadbalancer/blob/master/usr/local/relianoid/license.txt).


---


More info at https://www.relianoid.com

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/app/letsencrypt/webroot/index.html ===

<HTML>
	RELIANOID Service configuration for letsencrypt certificate validation.
</HTML>


=== ./background/relianoid_adc/source_tree/usr/local/relianoid/license.html ===

	<h4 style="text-align: center;">GNU Affero General Public License version 3</h4>
	<p>Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;<br>
     Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</p>

    <h5 style="text-align: center;">Preamble</h5>

    <p>The GNU Affero General Public License is a free, copyleft license for software and other kinds of works, specifically designed to ensure cooperation with the community in the case of network server software.</p>

    <p>The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, our General Public Licenses are intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users.</p>

    <p>When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.</p>

    <p>Developers that use our General Public Licenses protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License which gives you legal permission to copy, distribute and/or modify the software.</p>

    <p>A secondary benefit of defending all users' freedom is that improvements made in alternate versions of the program, if they receive widespread use, become available for other developers to incorporate. Many developers of free software are heartened and encouraged by the resulting cooperation. However, in the case of software used on network servers, this result may fail to come about. The GNU General Public License permits making a modified version and letting the public access it on a server without ever releasing its source code to the public.</p>

    <p>The GNU Affero General Public License is designed specifically to ensure that, in such cases, the modified source code becomes available to the community. It requires the operator of a network server to provide the source code of the modified version running there to the users of that server. Therefore, public use of a modified version, on a publicly accessible server, gives the public access to the source code of the modified version.</p>

    <p>An older license, called the Affero General Public License and published by Affero, was designed to accomplish similar goals. This is a different license, not a version of the Affero GPL, but Affero has released a new version of the Affero GPL which permits relicensing under this license.</p>

    <p>The precise terms and conditions for copying, distribution and modification follow.</p>

    <h5 style="text-align: center;">TERMS AND CONDITIONS</h5>

    <h5>0. Definitions.</h5>

    <p>"This License" refers to version 3 of the GNU Affero General Public License.</p>

    <p>"Copyright" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.</p>

    <p>"The Program" refers to any copyrightable work licensed under this License. Each licensee is addressed as "you". "Licensees" and "recipients" may be individuals or organizations.</p>

    <p>To "modify" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a "modified version" of the earlier work or a work "based on" the earlier work.</p>

    <p>A "covered work" means either the unmodified Program or a work based on the Program.</p>

    <p>To "propagate" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.</p>

    <p>To "convey" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.</p>

    <p>An interactive user interface displays "Appropriate Legal Notices" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.</p>

    <h5>1. Source Code.</h5>

    <p>The "source code" for a work means the preferred form of the work for making modifications to it. "Object code" means any non-source form of a work.</p>

    <p>A "Standard Interface" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.</p>

    <p>The "System Libraries" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A "Major Component", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.</p>

    <p>The "Corresponding Source" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.</p>

    <p>The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.</p>

    <p>The Corresponding Source for a work in source code form is that same work.</p>

    <h5>2. Basic Permissions.</h5>

    <p>All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.</p>

    <p>You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.</p>

    <p>Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.</p>

    <h5>3. Protecting Users' Legal Rights From Anti-Circumvention Law.</h5>

    <p>No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.</p>

    <p>When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.</p>

    <h5>4. Conveying Verbatim Copies.</h5>

    <p>You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.</p>

    <p>You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.</p>

    <h5>5. Conveying Modified Source Versions.</h5>

    <p>You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:</p>

    <ul><li>a) The work must carry prominent notices stating that you modified it, and giving a relevant date.</li>

      <li>b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to "keep intact all notices".</li>

      <li>c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it.</li>

      <li>d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so.</li>
    </ul><p>A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an "aggregate" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.</p>

    <h5>6. Conveying Non-Source Forms.</h5>

    <p>You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:</p>

    <ul><li>a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange.</li>

      <li>b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge.</li>

      <li>c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b.</li>

      <li>d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements.</li>

      <li>e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d.</li>
    </ul><p>A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.</p>

    <p>A "User Product" is either (1) a "consumer product", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, "normally used" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.</p>

    <p>"Installation Information" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.</p>

    <p>If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).</p>

    <p>The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.</p>

    <p>Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.</p>

    <h5>7. Additional Terms.</h5>

    <p>"Additional permissions" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.</p>

    <p>When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.</p>

    <p>Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:</p>

    <ul><li>a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or</li>

      <li>b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or</li>

      <li>c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or</li>

      <li>d) Limiting the use for publicity purposes of names of licensors or authors of the material; or</li>

      <li>e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or</li>

      <li>f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors.</li>
    </ul><p>All other non-permissive additional terms are considered "further restrictions" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.</p>

    <p>If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.</p>

    <p>Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.</p>

    <h5>8. Termination.</h5>

    <p>You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).</p>

    <p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p>

    <p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p>

    <p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.</p>

    <h5>9. Acceptance Not Required for Having Copies.</h5>

    <p>You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.</p>

    <h5>10. Automatic Licensing of Downstream Recipients.</h5>

    <p>Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License.</p>

    <p>An "entity transaction" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.</p>

    <p>You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.</p>

    <h5>11. Patents.</h5>

    <p>A "contributor" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's "contributor version".</p>

    <p>A contributor's "essential patent claims" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, "control" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.</p>

    <p>Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.</p>

    <p>In the following three paragraphs, a "patent license" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To "grant" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.</p>

    <p>If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. "Knowingly relying" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.</p>

    <p>If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.</p>

    <p>A patent license is "discriminatory" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.</p>

    <p>Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.</p>

    <h5>12. No Surrender of Others' Freedom.</h5>

    <p>If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.</p>

    <h5>13. Remote Network Interaction; Use with the GNU General Public License.</h5>

    <p>Notwithstanding any other provision of this License, if you modify the Program, your modified version must prominently offer all users interacting with it remotely through a computer network (if your version supports such interaction) an opportunity to receive the Corresponding Source of your version by providing access to the Corresponding Source from a network server at no charge, through some standard or customary means of facilitating copying of software. This Corresponding Source shall include the Corresponding Source for any work covered by version 3 of the GNU General Public License that is incorporated pursuant to the following paragraph.</p>

    <p>Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the work with which it is combined will remain governed by version 3 of the GNU General Public License.</p>

    <h5>14. Revised Versions of this License.</h5>

    <p>The Free Software Foundation may publish revised and/or new versions of the GNU Affero General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p>

    <p>Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU Affero General Public License "or any later version" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU Affero General Public License, you may choose any version ever published by the Free Software Foundation.</p>

    <p>If the Program specifies that a proxy can decide which future versions of the GNU Affero General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program.</p>

    <p>Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.</p>

    <h5>15. Disclaimer of Warranty.</h5>

    <p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</p>

    <h5>16. Limitation of Liability.</h5>

    <p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>

    <h5>17. Interpretation of Sections 15 and 16.</h5>

    <p>If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.</p>

    <p style="text-align:center";>END OF TERMS AND CONDITIONS</p>

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/license.txt ===

                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

=== ./background/relianoid_adc/summary.md ===

# Summary

=== ./background/webmin-docs/Creating Modules.txt ===

Download
Changelog
FAQ
Documentation
Forum 
Search ?
Introduction
Modules
Third Party Modules
Development
Creating Modules
Creating Themes
Creating Overlay Themes
Creating Scheduled Cron Jobs
Translations
XML-RPC Calls
API
Module
Creating Modules
October 1, 2023
  40 min  Jamie Cameron | 
Suggest Changes
This page should be read if you are planning to write your own Webmin module, as it explains all the requirements for creating a usable module.

It assumes that you have a working knowledge of Perl, HTML, and web application concepts. It also focuses towards the new module API in Webmin 1.460 and later.

Introduction
Webmin is designed to allow the easy addition of new modules without changing any of the existing code. A module can be thought of as something like a Photoshop plugin or iPhone application - it can be written by someone other than the developers of Webmin and distributed under a license the developer chooses.

A module should be written to administer one service or server, such as the Unix password file or the Apache web server. Some complex system functions may even be split over several modules - for example, disk partitioning, mounting disks, and disk quota management are 3 separate modules in the standard Webmin distribution.

Modules can theoretically be written in any language. However, to make use of the Webmin API Perl version 5.8 or above should be used. A module should be written entirely in Perl, with no C functions or external binary programs. The aim is for modules to be as portable as possible across different Unix systems and CPU types.

Modules written in other languages will not be displayed using the standard Webmin UI and will not be able to call its API. For these reasons, using Perl is strongly recommended.

At their simplest, modules are really just directories of CGI programs that Webmins web server runs. However, there are certain rules that should be followed to make sure that they work with the Webmin API, main menu, and access control system. Even though you can just stick any existing CGI script into a module directory, this is not a good idea.

Required files
Every module has its own directory under the Webmin base directory, in which all the modules CGI programs and configuration files must be stored. For example, if the Webmin base was /usr/libexec/webmin, a module called foobar would be created or installed in /usr/libexec/webmin/foobar.

You can find this base directory by looking at the root entry in your /etc/webmin/miniserv.conf file. It will differ depending on which operating system Webmin is installed.

For a module to be displayed on the main Webmin menu, it should contain at least the following files. Only module.info is mandatory though.

module.info

This file contains information about the module and the operating systems it runs under. See below for details on its format.

images/icon.gif

The icon displayed on the main menu for this module. The icon should be 48x48 pixels and should use the same colour scheme as the other icons on the main menu.

lang/en

The text strings used by this module, as explained in the Internationalization section of this documentation.

install_check.pl

Program that checks to see if the service or program is installed and usable, returning a non-zero value if so.

Each module name on Webmins left menu is a link to the module directory. Thus you must have an index.cgi file to be displayed when the user clicks on the link. A typical module contains many .cgi programs that are linked to from index.cgi, each of which performs some function such as displaying a form or saving inputs from a form.

When you first create a new module, it will not be in the allowed list of any Webmin user and so you will not be able to see it in the main menu. To fix this, you must first delete the file /etc/webmin/module.infos.cache to clear the cache of known modules. Then to make your module visible, either edit the file /etc/webmin/webmin.acl or use the Webmin Users module to grant yourself access.

The module.info file
This file contains meta-information about your module, such as its title, supported operating systems, and category. It is a text file with each line containing a name and value separated by =, a format widely used by Webmin. An example module.info file might look like:

desc=Foo Web Server
os_support=*-linux
category=servers
Required entries are:

desc

A description for the module, such as Foo Web Server. This is the text that will appear on Webmins left menu.

os_support

A space-separated list of operating systems that this module supports. The module will only be displayed on the main menu if the OS Webmin is running on is in the list or if there is no os_support line at all. Unless your module configures some service that only exists on a few operating systems (such as X.Org), this line should be omitted instead of trying to list all of those supported by Webmin. The actual operating system codes used in this line can be seen in the third column of the os_list.txt file in the Webmin root directory and are the same as those that can be appended to the names of config- files, as explained in the Module Configuration section. To specify only a certain version of some OS, add it to the OS name after a slash. For example, a module.info file might contain: os_support=redhat-linux suse-linux/15.5. If your module supports all Linux distributions both no other operating systems, you can use the OS code *-linux in this line.

category

The code for the Webmin menu category to display the module under. This will typically be one of servers, system, net or hardware.

Module library
The Webmin web server treats files with the extension .cgi as CGI programs, just like most other web servers. All the forms, menus, and other pages in your module will be generated by CGI programs, so knowledge of the basic concepts of CGI programming and HTML is necessary for writing a module.

All CGI programs are run with root privileges, which is generally necessary for them to be able to edit configuration files. In some cases your code may drop those privileges by switching to another user, for example if the modules access control settings for some Webmin user specify it.

When writing a new module, you should create a file with the same name as the modules directory, but with -lib.pl appended. So if your module directory was foobar, you should create foobar-lib.pl. This file will contain common functions that your modules CGI programs will call and will in turn call Webmins initialization functions.

An example library file could look like:

=head1 foobar-lib.pl

Functions for managing the Foobar webserver configuration file.

  foreign_require("foobar");
  my @sites = foobar::list_foobar_websites()

=cut

BEGIN { push(@INC, ".."); };
use WebminCore;
init_config();

=head2 get_foobar_config()

Returns the Foobar Webserver configuration as a list of hash references with name and value keys.

=cut
sub get_foobar_config
{
my $lref = &read_file_lines($config{'foobar_conf'});
my @rv;
my $lnum = 0;
foreach my $line (@$lref) {
    my ($n, $v) = split(/\s+/, $line, 2);
    if ($n) {
      push(@rv, { 'name' => $n, 'value' => $v, 'line' => $lnum });
      }
    $lnum++;
    }
return @rv;
}
The first two lines being in the core Webmin API, which exports numerous functions for parameter parsing, HTML generation, user management, reading and writing config files, and much more. These are fully documented below.

The init_config(); line calls a Webmin API function to initialize the modules environment. This sets several variables in your modules package, such as the %config hash containing the modules current configuration. It also checks if the current user is allowed to access this module, blocks links from un-trusted referers, and much more. See the documentation for init_config for a full list of the variables it exports.

Finally, the get_foobar_config sub is just an example of a function your modules CGI scripts might call to read the config file for the server it manages. In a good module design, all access to configuration files is done via functions like this, rather than directly in CGI scripts. This way your functions can be called from other modules and code duplication is reduced.

Note how the file begins with a POD format documentation comment explaining what it does and giving a short snippet of code showing how another module could call this one. Also, individual functions should have POD format comments, as you can see on get_foobar_config. This allows other developers to use a command like perldoc foobar-lib.pl to see all the documentation.

Module CGI scripts
CGIs are responsible for generating the HTML for pages and forms that the user interacts with. Wherever possible they should use the Webmin UI functions to generate headers, forms, inputs, tables, and so on. This way the UI is consistent and can be overridden by custom themes.

The modules index.cgi file might contain code like:

#!/usr/bin/perl

require 'foobar-lib.pl';
ui_print_header(undef, $text{'index_title'}, "", undef, 1, 1);

$conf = get_foobar_config();
$dir = find($conf, "root");
print &text('index_root', $dir),"<p>\n";

ui_print_footer("/", $text{'index'});
The first line is standard for all Perl scripts and must match the path to Perl on your system. This can be found in the /etc/webmin/perl-path file.

The line require 'foobar-lib.pl'; brings in the modules function library described above and calls Webmins init_config initialization function.

The pages HTML header is generated by the call to ui_print_header. The most important parameter is $text{'index_title'}, which refers to the %text hash that is loaded from the modules lang/en file, described below.

The next two lines are calls to functions from the example modules library. The print statement outputs some HTML, using the Webmin API function text to substitute a programmatically-generated string into a message.

Finally, the call to ui_print_footer generates a link back to Webmins main menu, if needed.

Language files
Webmin has an internationalization system based on the contents of files in each modules lang sub-directory. The global default language is English, so each module must have a lang/en file containing US English messages used by its CGI scripts. It can also have files for other languages, like de form German or fr for French. Each file contains lines of text, one per message, formatted like:

index_title=Foobar Web Server
index_root=The root directory is $1.
When your code calls init_config, this file is read into the module-level hash %text. In addition, any strings defined in the appropriate files under Webmins top-level lang directory are also read. These contain useful messages codes like save, delete, and index.

The example index_root line contains a placeholder $1, which will be replaced by the text function with its second parameter. Strings can contain multiple placeholders like this, using the codes $2, $3, and so on.

Module configuration
Almost all modules have a set of user-editable configuration parameters, available in the %config hash which is set by the init_config function. When Webmin or a module is installed, a configuration file appropriate for the chosen operating system is copied from the module directory to the Webmin configuration directory for that module, typically something like /etc/webmin/foobar/config. It is this file that is read by init_config.

In general, module configuration settings are for things that the user may want to edit. These include paths to other config files that the module manages, display preferences, and options that control behavior. Making the locations of programs and other files editable makes your module more flexible and able to support systems on which config files are in different locations.

In most cases, your module only needs to include a single file named config in its base directory, which is copied to /etc/webmin at install time. If you are writing a module yourself from scratch, you will need to do this manually with commands like:

cd /usr/libexec/webmin/foobar
mkdir /etc/webmin/foobar
cp config /etc/webmin/foobar
An example config file for your module might contain:

foobar_conf=/etc/foobar.conf
sort_mode=0
In other cases, you might want the default configuration to differ depending on the operating system. For example, Apache is installed in a different place in almost every operating system, but its config always files have the same format. Webmins core Apache module contains files named like config-redhat-linux and config-solaris, which define the locations for httpd.conf and apachectl. At install time the appropriate file is copied to /etc/webmin/apache/config and values from it are then used by the Apache Webmin module to find other config files.

User configuration editing
Every module with a config file should also have a meta-config file named config.info that tells the core Webmin API what values and options are allowed. When a user clicks on a modules Module Config link, the page that appears is driven by the contents of the modules config.info file. A sample file looks like:

foobar_conf=Path to Foobar Webserver configuration file,0
sort_mode=Sort users by,1,1-Name,0-ID
Like most Webmin files, config.info is a text file with lines in name=value format. Each name must match an entry in the config file.

The right-hand side is a comma-separated list, with the following elements:

A human-readable description of this configurable setting.
A numeric type code that determines how the value can be edited.
An option comma-separated list of type parameters. Their number and format depends on the type code.
Type code zero is most common and is used for free-text fields. The other possible type codes are:

One of many. The user can choose one of several options. For this type, the rest of the line is a comma-separated list of value/display pairs. The value part of each pair is what gets stored in the config file, while the display part is what is shown to the user.
Many of many. The user can choose zero of more of several options. Available options are specified in the same way as type 2.
Optional free text. The user can either select the default option or enter some value. The rest of the line is the description of the default option (typically something like None or Default mode)
One of many. The same as type 1, but uses a menu instead of a row of radio buttons
Unix user. Displays a selector for a user from the host Webmin is running on.
Unix group. Displays a group selector from the host Webmin is running on.
Directory. Like the free text input, but with a directory chooser next to it.
File. Like the free text input, but with a file chooser next to it.
Multiline free text. The first value after the type is the width of the input and the second the height.
Like type 1, but with an additional option for entering free text of the users choice.
A parameter of this type does not allow the user to enter anything, but instead puts a section header row containing the description into the configuration form at this point.
A field for entering a password, without actually displaying the current value.
Not every configurable parameter needs an entry in config.info - only those that the user may want to edit.

Global configuration
The hash %gconfig contains global configuration options, typically from the file /etc/webmin/config. Some useful entries are:

os_type

A code for the operating system type detected at install time, such as debian-linux or redhat-linux.

os_version

Webmins internal code for the OS version, such as 5.9.

path

The Unix path for this operating system, as a colon separated list of directories. This is also available in $ENV{'PATH'}, as thus to any programs that you module runs.

User interface
Webmins API contains a large number of functions for generating forms, tables, inputs, and tabs. While a module can create its own HTML with simple Perl print statements, using the API is both easier and produces a more consistent look.

Some example code for creating a form might look like:

print ui_form_start("save.cgi");

print ui_table_row($text{'edit_username'},
    ui_textbox("username", $username, 40));

print ui_table_row($text{'edit_pass'},
    ui_password("pass", $password, 40));

print ui_form_end([ [ undef, $text{'save'} ], [ 'delete', $text{'delete'} ] ]);
To create a table, you can use code like:

print ui_columns_start([ $text{'index_username'}, $text{'index_realname'} ]);
foreach my $u (@users) {
    print ui_columns_row([
        ui_link("edit.cgi?user=$u->{'user'}", $u->{'user'}),
        $u->{'real'} ]);
    }
print ui_columns_end();
Some other good guidelines for module user interfaces are:

Try to follow the layout of core modules. For example, your modules main page index.cgi might display a table of objects, each of which contains a link to edit.cgi. This page in turn shows a form for editing or creating a user and submits to a script called save.cgi to update the underlying config files.
Dont use Flash or Java unless there is no other alternative. Most dynamic UIs can be created using JavaScript in modern browsers.
Design goals
A typical Webmin module is written to configure some Unix service, such as Apache, Squid or NFS exports. Most Unix servers are normally configured by editing some text file, which may have a complex format. Any Webmin module that modifies some configuration file must be able to parse all possible options in such a configuration file - even if not all options are presented to the user.

No module should ever corrupt a service configuration file or remove options that it does not understand. Modules should be able to parse any valid configuration without requiring special comments or a special format. If your module cannot deal with some option in a file, it should be left alone.

Webmin modules should be designed to be easy for novices to use, but still allow the user to do almost everything that could be done by editing the configuration file directly. However, in some cases configurations options will exist that very few users will need to edit or that do not lend themselves to be edited through a GUI. These kind of settings should be left out of your Webmin module if they would clutter up the user interface with their presence.

Online help
Webmin has support for context-sensitive help, both for an entire page or for individual elements. The hlink function outputs HTML for a link that displays a given help page. Help pages are stored in the help subdirectory under the module directory and are named simply page.html for those in English. So a call to hlink like:

print ui_table_row(hlink($text{'edit_username'}, 'username'),
    ui_textbox("username", $username, 40));
 would output a link to display the help page in the file help/username.html under the modules base directory. This could contain:

<header>Foobar Username</header>

Enter the name of a login for the Foobar webserver.<p>

<footer>
This file is basically regular HTML, except for the special <header> tag which must contain the help pages title.

If the help parameter to the ui_print_header function is set, a link labeled Help to the specified help page is included in the heading. This can be useful if you have created some documentation that explains what the entire page does in general, instead of or as well as documenting fields individually. The same rules about help HTML file selection apply.

Even though online help is not mandatory (or even common) in Webmin modules, it can be useful to provide additional information to users about what a field really means or what the purpose of a page is. In many cases inputs are not self-explanatory and need additional documentation, so why not make it available from the page itself?

Webmin modules can support multiple languages through the use of alternative translation files in the lang subdirectory. Help pages can exist if more than one language as well, by creating files named like page.language.html in the help subdirectory. If such a file exists, it will be used in preference to page.html, which is assumed to be in English. For example, to add a Greek version of an existing name.html page you would need to create name.el.html.

Module packaging
The Webmin Configuration module allows the user to add a new module to their existing setup. Modules must be packaged as a compressed Unix TAR file containing one or more modules. Each module in the TAR file must have all its files in one subdirectory.

To create such a package, you could use commands like:

cd /usr/libexec/webmin
tar cvzf /tmp/foomod.wbm.gz foobar
The standard extension for Webmin modules is .wbm.gz or just .wbm if the tar file is not compressed. For themes the extension is usually .wbt.gz and for Usermin modules it is .ubm.gz.

Webmin modules can also be packaged as RPMs, which are suitable for installing on servers on which the RPM version of Webmin itself is already installed. You can download a script called makemodulerpm.pl that can package up a module directory into an RPM by creating the spec file automatically. It will place the resulting RPM file into the /usr/src/redhat/RPMS/noarch directory. The RPM name is always wbm- followed by the modules directory name or wbt- for themes.

Similarly, you can create a Debian package of a module using makemoduledeb.pl file. The resulting .deb file is placed in the /tmp directory. The package name is always webmin- followed by the directory name, for both modules and themes.

Example module
The best way to show what a Webmin module should look like is via an example. You can install a demo module for the imaginary Foobar Webserver by following these steps:

Login to Webmin as root and go to Webmin ? Webmin Configuration ? Webmin Modules
Select the From HTTP or FTP URL option and enter the URL http://download.webmin.com/download/modules/foobar.wbm.gz into the adjacent text box
Click the Install Module button
You should now be able to find the Foobar Webserver module under the Servers category. Its source code is in the foobar directory under the Webmin root.

The main page of this module shows a table of websites, with a link to add a new one. Adding or editing a site brings up a separate form for entering its details. This kind of layout is typical in Webmin and should be copied (where appropriate) in your own modules.

The Webmin API
The full API available to modules is documented on the Webmin API page. This covers both the core API and that exported by other modules. You can call functions from other modules with code like:

foreign_require("useradmin");
@users = useradmin::list_users();
foreach my $u (@users) {
  print $u->{'user'},"\n";
  }
Advanced concepts
Module Access Control
Webmin supports a standard method for restricting which features of a module a user can access. For example, the Apache module allows a Webmin user to be restricted to managing selected virtual servers, and the BIND module allows user to be limited to editing records only in certain domains.

This kind of detailed access control is separate from the first level ACLs that control which users have access to which modules. As long as your module calls init_config, the Webmin API will automatically block users who do not have access to the entire module.

Module access control options are set in the Webmin Users module by clicking on a username and then on the name of a module. The options available are generated by code from the module itself (except for the Can edit module configuration? option, which is always present). When the user clicks on Save the form parameters are also parsed by code from the module being configured, before being saved in the Webmin configuration directory.

A module wanting to use access control must contain a file called acl_security.pl in its directory. This file must contain two Perl functions:

acl_security_form(acl) This function takes a reference to a hash containing the current ACL options for this user, and must output HTML for form inputs to edit those ACL options. You must use the ui_table_row function to format your output.
acl_security_save(acl, inputs). This function must fill in the given hash reference with values from the form created by acl_security_form. Form inputs are available in the second parameter to the function, which is in the same format as the %in hash created by the ReadParse function.
An example acl_security.pl file looks like:

require "foomod-lib.pl";

sub acl_security_form
{
my ($access) = @_;
print ui_table_row("Allow creation of websites?",
  ui_yesno_radio("create", $access->{'create'}));
}

sub acl_security_save
{
my ($access, $in) = @_;
$access->{'create'} = $in->{'create'};
}
Because these functions are called in the context of your module, the acl_security.pl file can require the common functions file used by other CGI programs in the module. This gives you access to all the standard Webmin functions, and allows you to provide more meaningful inputs. For example, when setting ACL options for the Apache module a list of virtual servers from the Apache configuration is displayed for the user to select from.

If a user has not yet had any ACL options set for a module, a default set of options will be used. These are read from the file defaultacl in the module directory, which must contain name=value pairs one per line. These options should allow the user to do anything, so that the admin or master Webmin user is not restricted by default.

To actually enforced the chosen ACL options for each user, your module programs must use the get_module_acl function to get the ACL for the current user, and then verify that each action is allowed. When called with no parameters this function will return a hash containing the options set for the current user in the current module, which is almost always what you want. For example:

#!/usr/bin/perl
require 'foobar-lib.pl'; 
%access = &get_module_acl();
$access{'create'} || error("You are not allowed to create new websites"); 
When designing a module that some users will have limited access to, remember the user can enter any URL, not just those that you link to. For example, just doing ACL checking in the program that displays a form is not enough - the program that processing the form should do all the same checks as well. Similarly, CGI parameters should never be trusted, even hidden parameters that cannot normally be input by the user.

User and Group Update Notification
Webmin has a feature that allows the Users and Groups module to notify other modules when a Unix user or group is added, updated or deleted. This can be useful if your module deals with additional information that is associated with users. For example, the Disk Quotas module sets default quotas when new users are created, and the Samba Windows File Sharing module keeps the Samba password file in sync with the Unix user list.

To have your module notified when a user is added, updated or deleted you must create a Perl script called useradmin_update.pl in your module directory. This file must contain three functions:

useradmin_create_user(user) This function is called when a new Unix user is created. The user parameter is a hash containing the details of the new user, described in more detail below.
useradmin_modify_user(user, olduser) This function is called when an existing Unix user is modified in any way. The user parameter is a hash containing the new details of the user, and olduser the details of the user before he was modified.
useradmin_delete_user(user) This function is called when a Unix user is deleted. Like the other functions, the user hash contains the users details.
The hash reference passed to each of the three functions has the following keys:

user - The Unix username
pass - Encrypted password, perhaps using MD5 or DES
uid - Users ID
gid - Users primary groups ID
real - Real name for the user. May also contain office phone, home phone and office location, comma-separated
home - Users home directory
shell - Shell command to run when the user logs in
passmode - Set to 0 if the user has no password, 1 for a lock password, 2 for a pre-encrypted password, 3 if a new password was entered, or 4 if the password was not changed
plainpass - The users plain-text password, if available
In addition, if the system supports shadow passwords it may also have the keys:

change - Days since 1970 the password was last changed
min - Days before password may be changed
max - Days after which password must be changed
warn - Days before password is to expire that user is warned
inactive - Days after password expires that account is disabled
expire - Days since Jan 1, 1970 that account is disabled
When your functions are called, they will be in the context of your module. This means that your useradmin_update.pl script can require the file of common functions used by other CGI programs. The functions can perform any action you like in order to update other configuration files or whatever, but should not generate any output on STDOUT, or take too long to execute. An example useradmin_update.pl might look like:

do 'foobar-lib.pl'; 

sub useradmin_create_user
{
  my ($user) = @_;
  my $lref = &read_file_lines($users_file);
  push(@$lref, "$user->{'user'}:$user->{'pass'}"); 
  &flush_file_lines($users_file);
} 
Groups update information can also be passed to your module if the useradmin_update.pl script contains the functions useradmin_create_group , useradmin_modify_group and useradmin_delete_group. These take group hash references as parameters, which contain the keys:

group - The group name
pass - Rarely-used encrypted password, in DES or MD5 format
gid - Unix ID for the group
members - A comma-separated list of secondary group members
Internationalisation
Webmin provides module writers with functions for generating different text and messages depending on the language selected by the user. Each module that wishes to use this feature should have a subdirectory called lang which contains a translation file for each language supported. Each line of a translation file defines a message in that language in the format messagecode=Message in this language.

The default language for Webmin is English (code en), so every module should have at least a file called lang/en. If any other language is missing a message, the English one will be used instead. Check the file lang_list.txt for all the languages currently supported and their codes. To change the current language, go into the Webmin Configuration module and click on the Language icon.

When your module calls the init_config function, all the messages from the appropriate translation file will be read into the hash %text. Thus instead of generating hard-coded text like this:

print "Click here to start the server<p>\n"; 
Your module should use the %text hash like so:

print $text{'index_startmsg'},"<p>\n"; 
The lang/en file would then have a line like:

index_startmsg=Click here to start the server
Messages from the appropriate file in the top-level lang directory are also included in %text. Several useful messages such as save, delete and create are thus available to every module.

In some cases, you may want to include some variable text in a message. Because the position of the variable may differ depending on the language used, message strings can include place-markers like $1, $2 or $3. The function text should be used to replace these place-markers with actual values like so:

print &text('servercount', $count),"<p>\n"; 
Your modules module.info file can also support multiple languages by adding a line with the key =desc=code for each language, where code is the language code. So the German description for your module would be specified with a link like:

desc_de=Verwalten von Benutzer und Gruppen
You can also have a separate config.info file for each language, whose filename has the language code appended. So the file for German would be named config.info.de , and might contain the contents:

users_file=Die Benutzer-Datei,8
groups_file=Gruppen-Datei,8
show_groups=Details anzeigen Gruppe?,1,1-Ja,0-Nein
Help files can also be translated for each language, by creating separate files with the same prefixes as the English help, but with a language code before the .html extension. So the introductory help page for our module in German might be named intro.de.html .

In all cases, if there is no translation for the users chosen language then the default (English) will be used instead.

File Locking
Webmins API has several simple functions for locking files to prevent multiple programs from writing to them at the same time. Module programmers should make use of these functions in order to prevent the corruption or overwriting of configuration files in cases where two users are using the same module at the same time.

Locking is done by the function lock_file, which takes the name of a file as a parameter and obtains and exclusive lock on that file by creating a file with the same name but with .lock appended. Similarly, the function unlock_file removes the lock on the file given as a parameter. Because the .lock file stores the PID of the process that locked the file, any locks a CGI program holds will be automatically released when it exits. However, it is recommended that locks be properly released by calling unlock_file or unlock_all_files before exiting.

The following code shows how the locking functions might be used:

lock_file("/etc/something.conf"); 
open(CONF, ">>/etc/something.conf");
print CONF "some new directive\n"; 
close(CONF);
unlock_file("/etc/something.conf"); 
Locking should be done as soon as possible in the CGI program, ideally before reading the file to be changed and definitely before writing to it. Files can and should be locked during creation and deletion as well, as should directories and symbolic links before creation or removal. While this is not really necessary to prevent file corruption, it does make the logging of file changes performed by the program more complete, as explained below.

Many other programs also use .lock files for the same purpose, but most do not put their process ID in the file. If the lock_file function encounters a lock like this, it will wait until it is completely removed before obtaining its own lock, as there is no way to tell if the original process is still running or not.

If you want to just read from a file while being sure that no other process is corrupting it by writing to it, the lock_file function takes an optional second parameter that can be set to 1 to indicate a read-only lock. This will prevent other Webmin processes from writing to the same file, but will not block read locks by other scripts.

Safe File Writes
If your module writes to critical system configuration files, you should use IO functions built into the Webmin API instead of Perls standard open function. These protect files from problems like the failure of a script part way through writing a file, lack of disk space, or un-expected termination.

To open a file for writing safely, use the open_tempfile function. This writes to a temporary file in the same directory until it is closed with close_tempfile, at which point the target file is over-written. For example:

open_tempfile(CONFIG, ">/etc/foo.conf");
print_tempfile(CONFIG, "foo bar\n");
close_tempfile(CONFIG);
The print_tempfile function behaves like Perls built-in print, but immediately calls error to terminate the script if the write fails due to lack of disk space or some other reason.

Functions in the Webmin API that write to files like flush_file_lines, write_file and replace_file_line already call the safe file IO functions internally.

Action Logging
Webmin has support for detailed logging by CGI programs of the actions performed by users for later viewing in the Webmin Actions Log module. Logs are also written to the file /var/webmin/miniserv.log, this does not contain the information required to work out exactly what each Webmin user had been doing. To improve on this, Webmin now logs detailed information to the file /var/webmin/webmin.log and optionally to files in the directory /var/webmin/diffs. Note that nothing will be recorded in this file if logging is not enabled in the Webmin Configuration module.

The function webmin_log should be called by CGI programs after they have successfully completed all processing and file updates. The parameters taken by the function are:

action - A short code for the action being performed, like create
type - A code for the type of object the action is performed to, like user
object - A short name for the object, like joe if the Unix user joe was just created
params - A hash ref of additional information about the action
module - Name of the module in which the action was performed, which defaults to the current module
host - Remote host on which the action was performed. You should never need to set this (or the following two parameters), as they are used only for remote Webmin logging
script-on-host - Script name like create_user.cgi on the host the action was performed on
client-ip - IP address of the browser that performed the action
All of these parameters can contain any information you want, as they are merely logged to the actions log file and not interpreted by webmin_log in any way. For example, a module might call the function like this:

lock_file("/etc/foo.users"); 
open(USERS, ">>/etc/foo.users"); 
print USERS "$in{'username'} $in{'password'}\n";
close(USERS);
unlock_file("/etc/foo.users");
webmin_log("create", "user", $in{'username'}, \%in); 
Because the raw log files are not easy to understand, Webmin also provides support for converting detailed action logs into human-readable format. The Webmin Actions Log module makes use of a Perl function in the file log_parser.pl in each modules subdirectory to convert logs records from that module into a readable message.

This file must contain the function parse_webmin_log, which is called once for each log record for this module. It will be called with the following parameters:

user - The Webmin user who run the program that generated this log record.
script - The filename of the CGI script that generated this log, without the directory
action - Whatever was passed as the action parameter to webmin_log to create this log record
type - Whatever was passed as the type parameter to webmin_log
object - Whatever was passed as the object parameter to webmin_log
parameters - A reference to a hash the same as the one passed to webmin_log
long - If non-zero, this indicates that the function is being called to create the description for the Action Details page, and thus can return a longer message than normal. You can ignore this if you like.
The function should return a text string based on the parameters passed to it that converts them into a readable description for the user. For example, your log_parser.pl file might look like:

require 'foobar-lib.pl'; 

sub parse_webmin_log 
{
my ($user, $script, $action, $type, $object, $params, $long) = @_;
if ($action eq 'create') {
    return &text('log_create', $user);
    }
elsif ($action eq 'delete') {
    return &text('log_delete', $user);
    }
else {
    return undef;
    }
} 
Because the log_parser.pl file is read and executed in a similar way to how the acl_security.pl file is handled by the Webmin Users module, it can require the modules own library of functions just like any module CGI program would. This means that the text function and %text hash are available for accessing the modules translated text strings, as in the example above.

Webmin can also be configured to record exactly what file changes have been made by each CGI program before calling webmin_log. Under Logging in the Webmin Configuration module is a checkbox labeled Log changes made to files by each action which when enabled will cause the webmin_log function to use the diff command to find changes made to any file locked by each program.

When logging of file changes is enabled, the Action Details page in the actions log module will show the diffs for all files updates, creations and deletions by the chosen action. If locking of directories and symbolic links is done as well, it will show their creations and modifications too.

As well as having their file changes logged, programs can also use the common functions system_logged, kill_logged and rename_logged which take the same parameters as the Perl system, kill and rename functions, but also record the event for viewing on the Action Details page. There is also a backquote_logged function which works similar to the Perl backquote operator (it takes a command and executes it, returning the output), but also logs the command. If these functions are used they must be called before webmin_log for the logging to be actually recorded, as in this example:

if ($pid) { 
    kill_logged('TERM', $pid);
    }
else {
    system_logged("/etc/init.d/foo stop");
    }
webmin_log("stop"); 
Pre and Post Install Scripts
Webmin allows modules to define scripts that will be run after a module is installed and before it is un-installed. If your module contains a file called postinstall.pl , the Perl function module_install in this file will be called after the install of your module is complete. Because it is executed in the modules directory, it can make use of the common functions library, like so:

require 'foobar-lib.pl'; 

sub module_install 
{
if (!-r "$config_directory/somefile") {
    copy_source_dest("$module_root_directory/somefile", "$config_directory/somefile");
    }
}
The function will be called when a module is installed from the Webmin Configuration or Cluster Webmin Servers modules, when a module RPM or Debian package is installed, or when the install-module.pl command is used. It will also be called when your module is upgraded or when Webmin is upgraded, so make sure it doesnt over-write.

Similarly, if your module contains a file called uninstall.pl, the Perl function module_uninstall in that file will be called just before the module is deleted. This can happen when it is deleted using the Webmin Users or Cluster Webmin Servers modules, or when the entire of Webmin is uninstalled. The uninstall function should clean up any configuration that will no longer work when the module is uninstalled, such as Cron jobs that reference scripts in the module.

Installed Checks
Webmin module writers can call the API function foreign_installed to check if the server or service managed by some other module is installed on the system. If you are writing a module that manages some server, you can add a file to your modules directory that provides this information to callers. In addition, this determines if your module appears under Un-used Modules on the left menu.

This is done by creating a script called install_check.pl that contains the single Perl function is_installed. This function takes a mode parameter with the same meaning as the parameter passed to foreign_installed, and must interpret it in the same way. Because most modules dont require an extra level of configuration before use, your function can just return 0 if the server is not installed, or mode + 1 if it is.

This example code shows how an is_installed function might be written:

do 'foobar-lib.pl';

sub is_installed
{
my $mode = $_[0];
if (!-r $config{'foo_config_file'}) {
        return 0;
        }
else {
        return $mode + 1;
        }
}
Functions in Other Modules
The standard Webmin modules contain a vast number of useful functions for parsing and manipulating the configuration files for Apache Webserver, BIND DNS Server, Users and Groups and so on. If your module needs to configure these servers as well in some way, it makes sense to make use of existing functions in the standard modules.

Because the standard modules have typically already been configured with the correct paths for files like httpd.conf and squid.conf, their functions will use those paths when you call them to read and write configuration files. The actual %config settings for another module can also be accessed, so that your module knows what commands to use to apply changes to or start some server like Apache or Squid.

When you first load the library for some other module with the foreign_require function, it is actually executed in a separate Perl module namespace. All of your modules CGI programs and its library will be in the their own namespace, but other foreign modules functions will be put in a namespace with the same name as the Webmin module. This means that you can call those functions with code like useradmin::list_users(), and access global variables like $useradmin::config{'passwd_file'}. This Perl namespace separation ensures that functions and globals with the same names can exist in both your and the foreign module, without any clashes. Some things are shared between all modules though, such as caches used by get_system_hostname, load_language, read_file_cached and get_all_module_infos, so that loading the library of a new module with foreign_require is not too slow.

Documentation on functions available in other modules can be found on the Webmin API page.

Remote Procedure Calls
Webmin has several API functions for executing code on remote Webmin servers. They are used by some of the standard modules (such as those in the Cluster category) to control multiple servers from a single interface, and may be useful in your own modules as well. These functions, all of which have names starting with remote, let you call functions, evaluation Perl code, and transfer data to and from other system running Webmin.

Before a master server can make RPC calls to a remote host, it must be registered in the Webmin Servers Index module on the master system. The Link type field must be set to Login via Webmin and a username and password entered. The user specified should be root or admin, as others are not by default allowed to accept RPC calls.

RPC is usually used to call functions in other modules on a remote system, or common functions. This is done with the remote_foreign_call function, but before it can be used remote_foreign_require must be called to load the library for the module that you want to call. This is very similar to calling functions in other local modules with the foreign functions, explained above.

A piece of code that edits a user on a remote system might look like:

$server = "www.example.com"; 
$user = "joe";
remote_foreign_require($server, "useradmin", "user-lib.pl");
@users = remote_foreign_call($server, "useradmin", "list_users");
($joe) = grep { $_->{'user'} eq $user } @users;
if ($joe) {
    $joe->{'real'} = "Joe Bloggs";
    &remote_foreign_call($server, "useradmin", "modify_user", $joe, $joe);
    }
Of course, you need to be familiar with the available functions in other modules, and also to be sure that the module that you want to call is actually installed and of the right version.

All parameters passed to remote functions are converted to a serialized text form for transfer to the remote server, and any return value is also sent back in serialized form. The API functions serialize_variable and unserialize_variable are used, but the process is hidden from both the caller and the remote function - they only see scalars and references in their original format. One thing to look out for is circular references though - trying to send a structure that contains links to itself (such as a doubly-linked list) will fail due to the shortcomings of the serialize_variable function. Also, try to avoid using extremely large parameters, such as strings over 1 MB in size, as serialization may make them massive.

Parameters that are references to hashes, arrays or scalars that would normally be filled in by the function will not be transferred properly. For example, the read_file function normally fills in the hash referenced by its second argument with the contents of a file. This will not work when it is called remotely, as all parameters and anything that they refer to are copied to the other system.

The remote_eval function can be used to execute an arbitrary block of Perl code on a remote system, which allows you to do things that calls to remote functions cannot. It is the only way to call native Perl functions such as unlink, to read and write arbitrary format files, set global variables and properly call functions that set their parameters. Whatever the Perl code evaluates to will be sent back returned by this function. This example shows remote_eval in use:

$data = &remote_eval($server, "useradmin",
    "rename('/etc/foo', '/etc/bar');\n".
    "local \%data;\n".
    "&read_file('/etc/bar', \\%data);\n".
    "return \\%data;\n");
&write_file('/etc/foo', $data);
As you can see, proper quoting is necessary when constructing the Perl code string, so that any variable symbols (such as $, % and @) are escape, as is the \ character. The second module parameter to remote_eval can be set to undef, which indicates that the code should be executed in the global Webmin context, rather than in any modules.

The functions remote_read and remote_write can be used to transfer the contents of an entire file between the master and remote systems. They are must faster than reading in the file and encoding it for use in the remote_foreign_call or remote_eval functions, as the file is transferred un-encoded over a separate TCP connection.

If your module makes RPC calls, you may want the user to select a system to make calls to from a menu. A list of the names of all those available can be obtained from the Webmin Servers Index module with code like this:

foreign_require("servers", "servers-lib.pl"); 
@allservers = servers::list_servers();
@rpcservers = map { $_->{'host'} } grep { $_->{'user'} } @allservers;
In addition, all of the remote functions will accept undef for the server parameter. This indicates that the local system should be used, which never needs to be defined in the Webmin Servers Index module. This is how all of the Cluster category modules can include the this server option in their lists of hosts to manage.

Creating Usermin Modules
Usermin has a very similar architecture to Webmin, and so its modules have an almost identical design to Webmin modules. The main difference is that Usermin is designed to be used by any Unix user on a server to perform tasks that they could perform from he command line. Any third-party Usermin Modules should be written with this in mind.

By default, module CGI programs are run as root, just like in Webmin. This is necessary because some tasks (like changing passwords) can only be done as root. However, most Usermin modules do not need super-user privileges and so should call the switch_to_remote_user API function just after calling init_config, in order to lower privileges to those of the logged-in user.

Usermin module can have global configuration variables that are initially set from the config files in the module directory, and are available in %config. However, these variables are never editable by the user - they can only be set in the Usermin Configuration module in Webmin.

Per-user configurable options are supported though, using a different mechanism. When the standard create_user_config_dirs function is called, the global hash %userconfig will be filled with values from the following sources, with later sources overriding earlier ones:

The defaultuconfig file in the module directory This should contain the default options for this module for all users, to be used if no other settings are made by the user or system administrator.
The file defaultuconfig in the modules directory under /etc/usermin . This contains defaults for the module on this system, as set by the system administrator using the second form in the Usermin Module Configuration page feature in the Usermin Configuration Webmin module.
The file config in the modules directory in .usermin under the users home directory. This contains options chosen by users themselves.
The editors for the system-wide and per-user configuration variables are defined by the uconfig.info file in the module directory. This file has the exact same format as the config.info file used for Webmin and Usermin global configuration, explained elsewhere in this document.

If you create your own Usermin module, it should be packaged in exactly the same way as a Webmin module (as a .tar or .tar.gz file). However, the module.info file must contain the line usermin=1 so that it cannot be installed into Webmin where it would not work properly.

If your module needs to store additional data in the users .usermin directory, it should call the create_user_config_dirs API function first to ensure that directory exists. This in turn sets the $user_config_directory and $user_module_config_directory global variables, which contain paths to the .usermin directory and its per-module sub-directory.

On this page
Introduction
Required files
The module.info file
Module library
Module CGI scripts
Language files
Module configuration
User configuration editing
Global configuration
User interface
Design goals
Online help
Module packaging
Example module
The Webmin API
Advanced concepts
Module Access Control
User and Group Update Notification
Internationalisation
File Locking
Safe File Writes
Action Logging
Pre and Post Install Scripts
Installed Checks
Functions in Other Modules
Remote Procedure Calls
Creating Usermin Modules
 1997 - 2025 Webmin
=== ./background/webmin-plugins/firewall/CHANGELOG ===

---- Changes since 1.160 ----
Added button for re-setting the firewall to a default configuration.
Added module configuration options for commands to run before and after the firewall is applied.
The firewall configuration can now be copied automatically to multiple hosts in a cluster, and will be applied on all hosts when the the Apply button is clicked. Like other cluster features in Webmin, this requires that the servers be first setup in the Webmin Servers Index module.
---- Changes since 1.180 ----
Added button for deleting multiple rules from list.
Added several new access control options for limiting allowed actions, cluster management, and creation and deletion of chains.
---- Changes since 1.200 ----
Additional IPtables modules can now be specified when editing a rule.
---- Changes since 1.240 ----
Protocol numbers can be explicitly entered in a rule, along with the defaults of TCP, UDP and so on.
---- Changes since 1.260 ----
Added a Module Config option to have rule comments stored used the --comment IPtables argument, rather than # comments in the save file.
---- Changes since 1.270 ----
The ICMP rejection type is now settable in all valid chains.
---- Changes since 1.290 ----
On Debian 3.1 systems, IPtables rules are saved in /etc/iptables.up.rules and activated through /etc/network/interfaces, rather than using an init.d script.
---- Changes since 1.350 ----
Added a setup option to configure a firewall for a typical hosting server.
---- Changes since 1.400 ----
Show SNAT and masquerade inputs in custom NAT chains.
---- Changes since 1.440 ----
DNS queries are now allowed when the firewall is setup for web hosting.
Rule coments using --comment containing spaces or - are now properly parsed.
When initializing the firewall, the actual ports for Webmin, Usermin and SSHd are used instead of the standard ports.
Added an option for the UNTRACKED state in rules.
---- Changes since 1.450 ----
Fixed 'Does not equal' option for multiple ports.
---- Changes since 1.470 ----
Disallow rules on virtual interfaces, as they don't work.
---- Changes since 1.490 ----
Removed invalid "Above" options for packet flow rate.
---- Changes since 1.500 ----
Added a button to move rules to another chain.
Added a button to rename an existing custom chain.
---- Changes since 1.510 ----
Better handle the case where a rule has a --comment format description, but # format comments are enabled.
Added support for physdev module options, for matching based on the bridged interface.
---- Changes since 1.550 ----
Added the open-ports.pl command which can be run from the shell to open ports on the firewall.
---- Changes since 1.630 ----
Updated all screens to use Webmin's new user interface library, for a more consistent look.
---- Changes since 1.980 ----
Fail2ban rules are preserved when applying the IPtables configuration file.

=== ./background/webmin-plugins/firewall/help/cluster.ar.auto.html ===

<header> خوادم جدار الحماية العنقودية </header> يمكن استخدام هذه الصفحة لدفع تكوين جدار الحماية الخاص بك إلى عدة أنظمة في وقت واحد ، بحيث يمكنك إدارة مجموعة من أنظمة جدار الحماية من واجهة واحدة. قبل أن تتم إضافة خادم إلى هذه الصفحة ، يجب أن يكون مثبتًا Webmin 1.170 أو أعلى وأن تتم إضافته في الوحدة النمطية Webmin Servers Index. يجب أن يكون لديه أيضا برامج <tt>جداول ipi (6)</tt> اللازمة مثبتة ومهيأة بشكل صحيح. <p style=";text-align:right;direction:rtl"><hr>
=== ./background/webmin-plugins/firewall/help/cluster.bg.auto.html ===

<header> Сървъри за защитна стена на клъстери </header> Тази страница може да се използва за изтласкване на вашата конфигурация на защитната стена към няколко системи едновременно, така че да можете да управлявате клъстер от системи на защитна стена от един интерфейс. Преди сървърът да може да бъде добавен към тази страница, той трябва да има инсталиран Webmin 1.170 или по-висок и да бъде добавен в модула Webmin Server Index. Той също трябва да има необходимите програми за <tt>ipi (6) таблици</tt> , инсталирани и правилно конфигурирани. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.ca.html ===

<header>Servidors del Clúster del Tallafoc</header>

Aquesta pàgina es pot utilitzar per copiar la configuració del tallafoc a
diferents sistemes alhora, de manera que puguis gestionar un clúster de
sistemes tallafoc des d'una sola interfície. Abans de poder afegir un servidor
en aquesta pàgina, ha de tenir instal·lat el Webmin 1.170 o superior i estar
afegit al mòdul d'Índex de Servidors Webmin. També ha de tenir els programes
<tt>ipi(6)tables</tt> necessaris instal·lats i configurats adequadament. <p>

<hr>


=== ./background/webmin-plugins/firewall/help/cluster.cs.auto.html ===

<header> Servery Firewall clusteru </header> Tuto stránku lze použít k vytlačení konfigurace brány firewall do několika systémů současně, takže můžete spravovat cluster systémů brány firewall z jediného rozhraní. Před přidáním serveru na tuto stránku musí být nainstalován produkt Webmin 1.170 nebo vyšší a musí být přidán do modulu Webmin Servers Index. Musí mít také nainstalované a správně nakonfigurované potřebné <tt>programy ipi (6) tabulek</tt> . <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.da.auto.html ===

<header> Cluster Firewall-servere </header> Denne side kan bruges til at skubbe din firewall-konfiguration ud til flere systemer samtidig, så du kan administrere en klynge af firewall-systemer fra en enkelt grænseflade. Inden en server kan tilføjes til denne side, skal den have Webmin 1.170 eller nyere installeret og tilføjes i Webmin Servers Index-modulet. Det skal også have de nødvendige <tt>ipi (6) -tabelprogrammer</tt> installeret og korrekt konfigureret. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.de.html ===

<header>Cluster-Firewall-Server</header>Diese Seite kann verwendet werden, um Ihre Firewall-Konfiguration gleichzeitig auf mehreren Systemen anzuwenden, sodass Sie ein Cluster von Firewall-Systemen über eine einzige Schnittstelle verwalten können. Bevor ein Server zu dieser Seite hinzugefügt werden kann, muss Webmin 1.170 oder höher installiert und im Webmin Servers Index-Modul hinzugefügt sein. Es müssen auch die notwendigen <tt>ipi(6)tables</tt> Programme installiert und richtig konfiguriert sein.<p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.el.auto.html ===

<header> Διακομιστές τείχους προστασίας συμπλέγματος </header> Αυτή η σελίδα μπορεί να χρησιμοποιηθεί για να ωθήσει τη διαμόρφωση του τείχους προστασίας σε πολλά συστήματα ταυτόχρονα, έτσι ώστε να μπορείτε να διαχειριστείτε ένα σύμπλεγμα συστημάτων τείχους προστασίας από μία μόνο διεπαφή. Για να μπορέσει να προστεθεί ένας διακομιστής σε αυτήν τη σελίδα, πρέπει να έχει εγκατεστημένο το Webmin 1.170 ή παραπάνω και να προστεθεί στη μονάδα Webmin Servers Index. Πρέπει επίσης να έχει τα απαραίτητα προγράμματα <tt>ipi (6) για πίνακες</tt> εγκατεστημένα και σωστά διαμορφωμένα. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.es.auto.html ===

<header> Servidores de firewall de clúster </header> Esta página se puede usar para enviar la configuración de su firewall a varios sistemas simultáneamente, de modo que pueda administrar un grupo de sistemas de firewall desde una única interfaz. Antes de que se pueda agregar un servidor a esta página, debe tener instalado Webmin 1.170 o superior y agregarse en el módulo Índice de servidores Webmin. También debe tener los programas de <tt>tablas ipi (6)</tt> necesarios instalados y configurados correctamente. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.eu.auto.html ===

<header> Firewall Zerbitzari klusterrak </header> Orrialde hau zure suebakiaren konfigurazioa hainbat sistemetara aldatzeko aldi berean erabil daiteke, suebakien sistemen multzoa interfaze bakar batetik kudeatu ahal izateko. Zerbitzari bat orri honetara gehitu aurretik, Webmin 1.170 edo berria instalatu behar du eta Webmin Servers Index moduluan gehitu behar da. Beharrezkoak diren <tt>ipi (6) tauletako</tt> programak instalatu eta behar bezala konfiguratu behar ditu. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.fa.auto.html ===

<header> سرورهای فایروال خوشه ای </header> از این صفحه می توان برای پیكربندی پیكربندی فایروال خود به چندین سیستم به طور همزمان استفاده كرد تا بتوانید یك خوشه سیستم های فایروال را از یك رابط واحد مدیریت كنید. قبل از افزودن سرور به این صفحه ، باید Webmin 1.170 یا بالاتر نصب شود و در ماژول Webmin Servers Index اضافه شود. همچنین باید برنامه های <tt>جداول ipi (6)</tt> نصب شده و به درستی پیکربندی شده داشته باشد. <p style=";text-align:right;direction:rtl"><hr>
=== ./background/webmin-plugins/firewall/help/cluster.fi.auto.html ===

<header> Klusteripalomuuripalvelimet </header> Tätä sivua voidaan käyttää palomuurin määritysten siirtämiseen useisiin järjestelmiin samanaikaisesti, jotta voit hallita palomuurijärjestelmien klusteria yhdestä käyttöliittymästä. Ennen kuin palvelin voidaan lisätä tälle sivulle, siinä on oltava Webmin 1.170 tai uudempi ja asennettava Webmin-palvelimien hakemisto -moduuliin. Siinä on myös oltava tarvittavat <tt>ipi (6) -taulukko-</tt> ohjelmat asennettuna ja määritetty oikein. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.fr.auto.html ===

<header> Serveurs de pare-feu de cluster </header> Cette page peut être utilisée pour pousser votre configuration de pare-feu vers plusieurs systèmes simultanément, afin que vous puissiez gérer un cluster de systèmes de pare-feu à partir d&#39;une seule interface. Avant qu&#39;un serveur puisse être ajouté à cette page, il doit avoir Webmin 1.170 ou supérieur installé et être ajouté dans le module Webmin Servers Index. Il doit également avoir les programmes de <tt>tables ipi (6)</tt> nécessaires installés et correctement configurés. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.hr.auto.html ===

<header> Poslužitelji vatrozida klastera </header> Ova se stranica može koristiti za potiskivanje konfiguracije vatrozida na nekoliko sustava istovremeno, tako da možete upravljati skupom vatrozida sa jednog sučelja. Prije nego što se poslužitelj može dodati na ovu stranicu, mora imati instaliran Webmin 1.170 ili noviji i biti dodan u modulu Webmin Servers Index. Također mora imati instalirane i ispravno konfigurirane programe <tt>ipi (6) tablica</tt> . <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.html ===

<header>Cluster Firewall Servers</header>

This page can be used to push your firewall configuration out to several systems
simultaneously, so that you can manage a cluster of firewall systems from a single
interface. Before a server can be added to this page, it must have Webmin 1.170 or
above installed and be added in the Webmin Servers Index module. It must also have the
necessary <tt>ipi(6)tables</tt> programs installed and properly configured. <p>

<hr>


=== ./background/webmin-plugins/firewall/help/cluster.hu.auto.html ===

<header> Klaszter tűzfal szerverek </header> Ez az oldal felhasználható a tűzfalkonfiguráció több rendszerre történő továbbítására egyidejűleg, így egyetlen tűzfal kezelheti a tűzfalrendszer-fürtöt. Mielőtt szervert lehet hozzáadni ehhez az oldalhoz, telepítenie kell a Webmin 1.170 vagy újabb verziót, és fel kell vennie a Webmin Szervers Index modulba. Emellett a szükséges <tt>ipi (6) táblák</tt> programjai is telepítve vannak és megfelelően vannak konfigurálva. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.it.auto.html ===

<header> Server firewall cluster </header> Questa pagina può essere utilizzata per inviare la configurazione del firewall a più sistemi contemporaneamente, in modo da poter gestire un cluster di sistemi firewall da un&#39;unica interfaccia. Prima di poter aggiungere un server a questa pagina, è necessario che Webmin 1.170 o versione successiva sia installato e che sia aggiunto nel modulo Indice server Webmin. Deve inoltre disporre dei programmi di <tt>tabelle ipi (6)</tt> necessari installati e configurati correttamente. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.ja.auto.html ===

<header>クラスタファイアウォールサーバー</header>このページを使用して、ファイアウォール構成を複数のシステムに同時にプッシュできるため、単一のインターフェースからファイアウォールシステムのクラスターを管理できます。このページにサーバーを追加する前に、サーバーにWebmin 1.170以上がインストールされていて、Webmin Servers Indexモジュールに追加されている必要があります。また、必要な<tt>ipi（6）tables</tt>プログラムがインストールされ、適切に設定されている必要があります。 <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.ko.auto.html ===

<header> 클러스터 방화벽 서버 </header> 이 페이지를 사용하여 방화벽 구성을 여러 시스템으로 동시에 푸시 할 수 있으므로 단일 인터페이스에서 방화벽 시스템 클러스터를 관리 할 수 있습니다. 이 페이지에 서버를 추가하려면 Webmin 1.170 이상이 설치되어 있고 Webmin Servers Index 모듈에 추가되어 있어야합니다. 또한 필요한 <tt>ipi (6) 테이블</tt> 프로그램이 설치되고 올바르게 구성되어 있어야합니다. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.ms.auto.html ===

<header> Pelayan Firewall Kluster </header> Halaman ini dapat digunakan untuk mendorong konfigurasi firewall ke beberapa sistem secara serentak, sehingga Anda dapat mengatur sekumpulan sistem firewall dari satu muka. Sebelum pelayan dapat ditambahkan ke halaman ini, Webmin 1.170 ke atas mesti dipasang dan ditambahkan dalam modul Indeks Pelayan Webmin. Ia juga mesti memasang program <tt>jadual ipi (6) yang</tt> diperlukan dan dikonfigurasi dengan betul. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.nl.html ===

<header>Cluster Firewall Servers</header>

Met deze pagina kunt u uw firewall configuratie in 1 keer naar diverse andere
systemen tegelijk invoeren, zodat u een cluster met firewall systemen vanaf een enkel
systeem kunt beheren.
Voordat een server kan worden toegevoegd aan deze pagina moet u controleren dat die
minimaal de Webmin versie 1.170 of nieuwer geïnstalleerd heeft en is toegevoegd aan
de "Webmin Servers Index" module. Op dit systeem moet ook de noodzakelijke <tt>ipi(6)tables</tt>
programma's geïnstalleerd zijn en op de juiste manier geconfigureerd zijn. <p>

<hr>


=== ./background/webmin-plugins/firewall/help/cluster.no.auto.html ===

<header> Cluster Firewall-servere </header> Denne siden kan brukes til å skyve brannmurkonfigurasjonen ut til flere systemer samtidig, slik at du kan administrere en klynge brannmursystemer fra et enkelt grensesnitt. Før en server kan legges til denne siden, må den ha Webmin 1.170 eller nyere installert og legges til i Webmin Servers Index-modulen. Den må også ha nødvendige <tt>ipi (6) -tabellsprogrammer</tt> installert og riktig konfigurert. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.pl.html ===

<header>Firewall serwerów klastra</header>

Ta strona może być użyta w celu wysłania konfiguracji firewalla na inne systemy,
więc możesz zarządzać firewallem klastra za pomocą jednego interfejsu.
Nim serwer będzie mógł być zarządzany przez tę stronę, to wersja Webmina
musi być przynajmniej w wersji 1.170 i musi być on dodany w module Serwery
Webmina. Musi mieć on także zainstalowany i skonfigurowany program <tt>ipi(6)tables</tt> <p>

<hr>


=== ./background/webmin-plugins/firewall/help/cluster.pt.auto.html ===

<header> Servidores de firewall de cluster </header> Esta página pode ser usada para enviar sua configuração de firewall para vários sistemas simultaneamente, para que você possa gerenciar um cluster de sistemas de firewall a partir de uma única interface. Para que um servidor possa ser adicionado a esta página, ele deve ter o Webmin 1.170 ou superior instalado e ser adicionado no módulo Índice de Servidores Webmin. Ele também deve ter os programas de <tt>tabelas ipi (6)</tt> necessários instalados e configurados corretamente. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.pt_BR.html ===

<header>Conjunto (Cluster) de Servidores de Firewall</header>

Esta pgina pode ser utilizada para carregar a configurao do firewall em vrios sistemas simultaneamente, portanto voc pode gerenciar um conjunto (cluster) de sistemas de firewall a partir de uma nica interface. Antes de poder adicionar um servidor nesta pgina, ele dever possuir o Webmin 1.170 ou superior instalado e esteja adicionado no mdulo de ndice de Servidores do Webmin. Tambm  necessrio que ele possua os programas do <tt>ipi(6)tables</tt> instalados e configurados adequadamente. <p>

<hr>
=== ./background/webmin-plugins/firewall/help/cluster.ru.html ===

<header>Серверы кластера брандмауэров</header>

Эта страница можно использовать для загрузить вашей конфигурации брандмауэра сразу на несколько систем одновременно. 
Таким образом, вы можете управлять кластером брандмауэров при помощи единого интерфейса. 
Прежде чем сервер сможет быть добавлен на эту страницу, на него необходимо установить Webmin 1.170 или новее, и добавить его в модуле <tt>Серверы Webmin</tt>. Так же, на нём должна быть установлена, и должным образом сконфигурирована программа <tt>ipi(6)tables</tt>.<p>

<hr>


=== ./background/webmin-plugins/firewall/help/cluster.sk.html ===

<header>Firewall serverového clusteru</header>

Táto stránka môže byť použitá na nastavenie konfigurácie firewallu súčasne na niekoľko 
systémov, takže môžete riadiť firewally i cez jedno rozhranie. Pred tým, ako bude 
môcť byť server pridaný na túto stránku, musí na ňom byť nainštalovaný Webmin 1.170 alebo 
vyšší a musí byť pridaný do modulu Zoznam Webmin Serverov. Samozrejme tiež musí mať nainštalované
a správne nakonfigurované programy <tt>ipi(6)tables</tt>. <p>

<hr>
=== ./background/webmin-plugins/firewall/help/cluster.sv.auto.html ===

<header> Cluster Firewall-servrar </header> Den här sidan kan användas för att driva ut din brandväggskonfiguration till flera system samtidigt, så att du kan hantera ett kluster av brandväggssystem från ett enda gränssnitt. Innan en server kan läggas till på denna sida måste den ha Webmin 1.170 eller högre installerad och läggas till i Webmin Servers Index-modulen. Det måste också ha nödvändiga <tt>ipi (6) -tabellsprogram</tt> installerade och korrekt konfigurerade. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.tr.auto.html ===

<header> Küme Güvenlik Duvarı Sunucuları </header> Bu sayfa, güvenlik duvarı yapılandırmanızı aynı anda birden fazla sisteme göndermek için kullanılabilir, böylece güvenlik duvarı sistemleri kümesini tek bir arabirimden yönetebilirsiniz. Bir sunucunun bu sayfaya eklenebilmesi için, Webmin 1.170 veya daha yeni bir sürümünün kurulu olması ve Webmin Sunucuları Dizin modülüne eklenmesi gerekir. Ayrıca, gerekli <tt>ipi (6) tablo</tt> programlarının yüklü ve düzgün yapılandırılmış olması gerekir. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.uk.auto.html ===

<header> Сервери брандмауера кластерів </header> Цю сторінку можна використовувати для виштовхування конфігурації брандмауера на кілька систем одночасно, щоб ви могли керувати кластером систем брандмауера з одного інтерфейсу. Перш ніж сервер можна буде додати до цієї сторінки, він повинен мати встановлений Webmin 1.170 або вище та бути доданий у модуль індексу серверів Webmin. Він також повинен мати необхідні програми <tt>ipi (6),</tt> встановлені та належним чином налаштовані. <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.zh.auto.html ===

<header>群集防火墙服务器</header>此页面可用于将防火墙配置同时推送到多个系统，以便您可以从单个界面管理防火墙系统的集群。在将服务器添加到此页面之前，必须先安装Webmin 1.170或更高版本，然后将其添加到Webmin Servers索引模块中。它还必须安装并正确配置了必要的<tt>ipi（6）tables</tt>程序。 <p><hr>
=== ./background/webmin-plugins/firewall/help/cluster.zh_TW.auto.html ===

<header>群集防火牆服務器</header>此頁面可用於將防火牆配置同時推送到多個系統，以便您可以從單個界面管理防火牆系統的集群。在將服務器添加到此頁面之前，必須先安裝Webmin 1.170或更高版本，然後將其添加到Webmin Servers索引模塊中。它還必須安裝並正確配置了必要的<tt>ipi（6）tables</tt>程序。 <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.ar.auto.html ===

<header> جدار حماية لينكس </header><h3 style=";text-align:right;direction:rtl"> مقدمة الوحدة </h3> تتيح لك هذه الوحدة تكوين ميزات جدار الحماية IPtables الموجودة في سلسلة 2.4 من نواة لينكس. على عكس بعض برامج تكوين جدار الحماية الأخرى ، فبدلاً من إنشاء نص برمجي shell يقوم بإعداد جدار الحماية ، فإنه يقوم بقراءة وتحرير ملف حفظ بتنسيق قراءة وكتابة بواسطة <tt>ipi (6) استعادة الجداول</tt> و <tt>ipi (6) حفظ جداول على</tt> التوالي. <p style=";text-align:right;direction:rtl"> إذا كان لديك بالفعل جدار حماية على نظامك تم إعداده يدويًا أو من ملف برنامج نصي ، فستعرض الوحدة النمطية تحويله إلى ملف حفظ IPtables لك ، وإنشاء برنامج نصي ليتم تشغيله في وقت التمهيد لتنشيط القواعد في الملف. ومع ذلك ، إذا قمت بذلك ، فلا يجب عليك بعد الآن تحرير البرنامج النصي لقواعد جدار الحماية الخاص بك ويجب تعطيله من التشغيل في وقت التمهيد أيضًا. <p style=";text-align:right;direction:rtl"><h3 style=";text-align:right;direction:rtl"> نظرة عامة على IPtables </h3> يتم فحص كل حزمة شبكة تدخل أو تخرج من أو يعيدها نظامك مقابل سلسلة واحدة أو أكثر لتحديد ما سيحدث لها. تحتوي كل سلسلة على صفر أو أكثر من القواعد ، لكل منها شرط (لتحديد الحزم التي تتطابق معها) وإجراء (للتحكم في ما يحدث لتلك الحزم المطابقة). تحتوي كل سلسلة أيضًا على إجراء افتراضي يتحكم في ما يحدث للحزم التي لا تتطابق مع أي قاعدة. <p style=";text-align:right;direction:rtl"> كل سلسلة هي جزء من جدول ، يوجد منها حاليًا ثلاثة: <ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <b>تصفية الحزم ( <tt>مرشح</tt> )</b> <br> يمكن استخدام السلاسل في هذا الجدول للتحكم في البيانات الواردة إلى نظامك من مضيفين آخرين على الشبكة ، والبيانات التي يرسلها المستخدمون والعمليات من نظامك ، والبيانات التي يعيدها نظامك إذا كان يعمل كموجه. <p style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <b>ترجمة عنوان الشبكة ( <tt>nat</tt> )</b> <br> يمكن استخدام هذا الجدول لإعداد NAT أو التنكر ، وهو أمر مفيد إذا كنت ترغب في منح شبكة كاملة من الأجهزة إمكانية الوصول إلى الإنترنت من خلال عنوان IP حقيقي واحد فقط. <p style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <b>تعديل الحزمة ( <tt>mangle</tt> )</b> <br> هذا الجدول مخصص لتعديل الحزم المعاد توجيهها أو إرسالها من نظامك. <p style=";text-align:right;direction:rtl"></ul> بالإضافة إلى السلاسل القياسية التي تشكل جزءًا من كل جدول ، يمكنك أيضًا إنشاء سلاسلك الخاصة التي يمكن تشغيلها بواسطة القواعد في السلاسل المضمنة. يمكن أن يكون هذا مفيدًا لتجميع القواعد ومشاركتها التي يمكن استخدامها في أماكن متعددة. <p style=";text-align:right;direction:rtl"><h3 style=";text-align:right;direction:rtl"> الصفحة الرئيسية </h3> تسرد الصفحة الرئيسية لهذه الوحدة جميع السلاسل والقواعد من أحد الجداول المتاحة ، المحددة من القائمة في أعلى اليسار. يوجد أدناه قسم لكل سلسلة في الجدول الحالي ، مع سرد جميع القواعد في كل سلسلة ووصف ظروفها بأفضل ما يمكن من قدرة الوحدة. لكل سلسلة ، يمكنك تغيير الإجراء الافتراضي باستخدام القائمة المنسدلة إذا كانت السلسلة واحدة من تلك المضمنة للجدول ، أو حذفها باستخدام زر حذف السلسلة إذا تم تحديدها من قبل المستخدم. <p style=";text-align:right;direction:rtl"> يمكنك النقر فوق أي قاعدة في سلسلة لتحريرها ، أو النقر فوق الأسهم الموجودة على يمين كل صف لتحريكها لأعلى أو لأسفل ، أو النقر فوق الزر &quot;إضافة قاعدة&quot; لإضافة قاعدة جديدة. ستأخذك إضافة قاعدة أو تعديلها إلى صفحة يمكنك من خلالها تحديد الإجراء لكل قاعدة ، والظروف التي يتم تنفيذ الإجراء من أجلها. <p style=";text-align:right;direction:rtl"> يوجد في الجزء السفلي من الصفحة زر لجعل تكوين جدار الحماية الحالي نشطًا ، عن طريق تحميله في kernel باستخدام الأمر <tt>ipi (6) جداول - استعادة</tt> . يوجد أدناه زر للقيام بالعكس - بأخذ التكوين الموجود حاليًا في kernel وإتاحته للتحرير. أخيرًا ، إذا كان توزيعك يدعمه ، فهناك زر لتغيير ما إذا كان جدار الحماية نشطًا في وقت التمهيد أم لا. <p style=";text-align:right;direction:rtl"><h3 style=";text-align:right;direction:rtl"> سلاسل الترشيح </h3> لتحسين التعاون مع البرامج النصية iptables الخارجية ، يمكنك استبعاد السلاسل الفردية من المعالجة بواسطة جدار الحماية. للقيام بذلك ، يجب عليك تحديد المعالجة المباشرة للقواعد في الإعدادات وإدخال قائمة التصفية ، والتي تستبعد السلاسل المناسبة من المعالجة. يتم وضع علامة على السلاسل التي لم يتم استبعادها من التحرير برسالة &quot;لا يديرها جدار الحماية&quot;. <p style=";text-align:right;direction:rtl"><h3 style=";text-align:right;direction:rtl"> مجموعات IP </h3> الإصدارات الأحدث من جدول ip (6) تدعم امتداد ipset. مجموعات IP هي قوائم بعناوين IP في الذاكرة الرئيسية ، والتي يمكن البحث عنها بكفاءة عالية واستخدامها كشرط في القواعد. في الصفحة الرئيسية ، يتم عرض مجموعات IP الموجودة التي يمكن استخدامها بواسطة القواعد. ومع ذلك ، لا يمكن حاليًا إدارتها في جدار الحماية. <p style=";text-align:right;direction:rtl"><hr>
=== ./background/webmin-plugins/firewall/help/intro.bg.auto.html ===

<header> Linux защитна стена </header><h3> Въвеждане на модул </h3> Този модул ви позволява да конфигурирате функциите на защитната стена на IPtables, намиращи се в 2.4 серията Linux ядра. За разлика от някои други програми за конфигуриране на защитната стена, вместо да създава скрипт за черупки, който настройва защитната стена, той чете и редактира файл за запазване във формат, прочетен и написан съответно от <tt>ipi (6) таблици-възстановяване</tt> и <tt>ipi (6) таблици-запазване</tt> . <p> Ако вече имате защитна стена на вашата система, която е била инсталирана ръчно или от скриптов файл, модулът ще предложи да я преобразува в файл за запазване на IPtables за вас и да създаде скрипт, който да се стартира при зареждане, за да активирате правилата в файлът. Ако направите това обаче, не трябва повече да редактирате скрипта си с правила за защитна стена и да го забраните да работи и по време на зареждане. <p><h3> Преглед на IPtables </h3> Всеки мрежов пакет, който влиза, излиза или препраща от вашата система, се проверява за една или повече вериги, за да се определи какво ще се случи с нея. Всяка верига съдържа нула или повече правила, всяко от които има условие (за да определи кои пакети съвпада) и действие (за контрол на това, което се случва с тези съвпадащи пакети). Всяка верига също има действие по подразбиране, което контролира какво се случва с пакетите, които не съответстват на нито едно правило. <p> Всяка верига е част от таблица, от която в момента има три: <ul><li> <b>Филтриране на пакети ( <tt>филтър</tt> )</b> <br> Веригите в тази таблица могат да се използват за контрол на данни, постъпващи във вашата система от други хостове в мрежата, данни, изпращани от вашата система от потребители и процеси, и данни, предавани от вашата система, ако тя действа като рутер. <p><li> <b>Превод на мрежови адреси ( <tt>nat</tt> )</b> <br> Тази таблица може да се използва за настройка на NAT или маскиране, което е полезно, ако искате да дадете на цяла мрежа от машини достъп до интернет чрез само един реален IP адрес. <p><li> <b>Промяна на пакети ( <tt>mangle</tt> )</b> <br> Тази таблица е за промяна на пакети, препратени или изпратени от вашата система. <p></ul> В допълнение към стандартните вериги, които са част от всяка таблица, можете също да създадете свои собствени вериги, които могат да бъдат управлявани по правила във веригите за вграждане. Това може да бъде полезно за групиране и споделяне на правила, които могат да се използват на много места. <p><h3> Главната страница </h3> Главната страница на този модул изброява всички вериги и правила от една от наличните таблици, избрани от списъка в горния ляв ъгъл. По-долу е даден раздел за всяка верига в текущата таблица, като всички правила във всяка верига са изброени и техните условия са описани най-добре от възможностите на модула. За всяка верига можете да промените действието по подразбиране, като използвате падащия списък, ако веригата е една от вградените в таблицата, или да я изтриете с бутона Изтриване на веригата, ако е дефиниран от потребителя. <p> Можете да кликнете върху всяко правило във верига, за да го редактирате, щракнете върху стрелките вдясно на всеки ред, за да го преместите нагоре или надолу, или щракнете върху бутона Добавяне на правило, за да добавите ново. Добавянето или редактирането на правило ще ви отведе до страница, на която можете да изберете действието за всяко правило и условията, за които се изпълнява действието. <p> В долната част на страницата е бутон за активиране на текущата конфигурация на защитната стена, като я заредите в ядрото с <tt>командата ipi (6) таблици-възстановяване</tt> . Под него има бутон за извършване на обратната страна - вземане на конфигурацията, която е в момента в ядрото, и предоставяне на нея за редактиране. И накрая, ако вашата дистрибуция го поддържа, има бутон, за да промените дали защитната стена е активирана по време на зареждане или не. <p><h3> Филтриращи вериги </h3> За по-добро сътрудничество с външни iptables скриптове можете да изключите отделни вериги от обработката чрез защитната стена. За да направите това, трябва да изберете директна обработка на правила в настройките и да въведете списък с филтри, което изключва съответните вериги от обработката. Веригите, които не са изключени от редактирането, са маркирани със съобщение „не се управлява от защитна стена“. <p><h3> IP комплекти </h3> По-новите версии на ip (6) таблицата поддържат разширението ipset. IP наборите са списъци с IP адреси в основната памет, които могат да се търсят много ефективно и да се използват като условие в правилата. На главната страница се показват съществуващите IP набори, които могат да се използват от правила. В момента обаче не е възможно да се управляват тези в защитната стена. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.ca.html ===

<header>Tallafoc Linux</header>

<h3>Introducció al mòdul</h3>

Aquest mòdul permet configurar les característiques del tallafoc IPtables 
que es troba a la sèrie de nuclis Linux 2.4. Contràriament a altres
programes de configuració de tallafoc, en lloc de crear un script shell
que configura el tallafoc, llegeix i edita un fitxer en el format llegit
i escrit per <tt>ipi(6)tables-restore</tt> i <tt>ipi(6)tables-save</tt>, respectivament. <p>

Si ja tens al sistema un tallafoc que s'ha configurat manualment o des d'un
fitxer de script, el mòdul t'oferirà de convertir-lo per tu a un fitxer
IPtables, i crearà un script per executar-se en engegar el sistema que
activarà les regles del fitxer. No obstant, si fas això no has des seguir
editant el teu script de regles del tallafoc i l'hauries de desactivar
i també evitar que s'executi en engegar. <p>

<h3>Resum d'IPtables</h3>

Cada paquet de xarxa que entra, surt o és reenviat pel sistema, es comprova
contra una o més cadenes per determinar què li passarà.
Cada cadena conté zero o més regles, cadascuna de les quals té una condició
(per determinar quins paquets la compleixen) i una acció (per controlar
què passa amb els paquets coincidents). Cada cadena té una acció per defecte
que controla què passa amb el paquet que no compleix cap regla. <p>

Cada cadena és part d'una taula, de les quals n'hi ha actualment tres:
<ul>
<li><b>Filtratge de Paquets (<tt>filter</tt>)</b><br>
   Les cadenes d'aquesta taula es poden utilitzar per controlar les dades que
   entren al sistema des d'altres hosts de la xarxa, les dades que surten del
   sistema per part dels usuaris i processos, i les dades reenviades per 
   sistema si està actuant com a router. <p>
<li><b>Traducció d'Adreces de Xarxa (<tt>nat</tt>)</b><br>
   Aquesta taula es pot utilitzar per establir una NAT o una mascarada, cosa
   útil si vols donar accés a Internet a tota una xarxa de màquines a través
   d'una sola adreça IP real. <p>
<li><b>Alteració de Paquets (<tt>mangle</tt>)</b><br>
   Aquesta taula és per a modificar paquets enviats o reenviats des del teu
   sistema. <p>
</ul>

A més a més de les cadenes estàndard que són part de cada taula, també pots
crear les teves pròpies cadenes que poden ser executades per regles de les
cadenes ja integrades. Això pot ser útil per agrupar i compartir regles que
es poden utilitzar a llocs diferents. <p>

<h3>La pàgina principal</h3>

La pàgina principal d'aquest mòdul llista totes les cadenes i regles d'una de
les taules disponibles, seleccionades de la llista de la part superior esquerra.
A sota hi ha una selecció per a cada cadena de la taula actual, amb totes les
regles de cada cadena llistades i les seves condicions descrites tant bé com el
mòdul n'és capaç. Per a cada cadena, pots canviar l'acció per defecte utilitzant
la llista desplegable si la cadena és una de les ja integrades a la taula, o bé
suprimir-la amb el botó Suprimeix la cadena si està definida per l'usuari. <p>

Pots fer clic sobre qualsevol regla d'una cadena per editar-la, fer clic
sobre les fletxes de l'esquerra per desplaçar-les amunt i avall, o fer 
clic sobre el botó Afegeix Regla per afegir-ne una de nova. Afegir o
editar una regla et durà a una pàgina on pots seleccionar l'acció per a
cada regla, i les condicions per les quals s'executa l'acció. <p>

Al peu de la pàgina, hi ha un botó per fer activa la configuració
actual del tallafoc, recarregant-la en el nucli amb l'ordre
<tt>ipi(6)tables-restore</tt>. A sota, hi ha un botó per fer just el contrari -
prendre la configuració que hi ha actualment al nucli i posar-la a
disposició de l'editor. Finalment, si la distribució ho suporta, hi ha
un botó per canviar si el tallafoc s'activa en engegar el sistema o no. <p>

<h3>Cadenes de filtratge</h3>

Per a una millor col·laboració amb scripts d'iptables externs, pots excloure cadenes
individuals del processament del tallafoc. Per fer-ho, has de seleccionar el
processament directe de les regles als paràmetres i introduir una llista de 
filtres que exclouen les cadenes apropiades del processament.
Les cadenes que no s'han exclòs de l'edició es marquen amb el missatge "no gestionada pel tallafoc".
<p>

<h3>Conjunts d'IPs</h3>

Les noves versions d'ip(6)table suporten l'extensió ipset.
Els conjunts d'IPs són llistes d'adreces IP en memòria principal, que es poden buscar eficientment
i s'usen com a condició en les regles, A la pàgina principal es mostren els conjunts d'IPs existents
que es poden fer servir com a condició a les regles. Actualment, però, no és possible gestionar-los al tallafoc.
<p>

<hr>


=== ./background/webmin-plugins/firewall/help/intro.cs.auto.html ===

<header> Linux Firewall </header><h3> Úvod do modulu </h3> Tento modul umožňuje konfigurovat funkce brány firewall IPtables, které jsou obsaženy v linuxových jádrech řady 2.4. Na rozdíl od některých jiných konfiguračních programů brány firewall namísto vytváření skriptu prostředí, který firewall nastavuje, čte a upravuje <tt>ukládací</tt> soubor ve formátu, který čte a zapisuje <tt>tabulka ipi (6) tables-restore</tt> a <tt>ipi (6) tables-save</tt> . <p> Pokud již máte v systému firewall, který byl nastaven ručně nebo ze souboru skriptu, modul nabídne převod do souboru IPtables pro uložení a vytvoří skript, který bude spuštěn v době spuštění a aktivuje pravidla v soubor. Pokud to však uděláte, neměli byste již upravovat skript pravidel brány firewall a měli byste jej také zakázat v době spuštění. <p><h3> Přehled IPtables </h3> Každý síťový paket, který přichází, vychází z vašeho systému nebo je přeposílá, je zkontrolován proti jednomu nebo více řetězcům, aby se určilo, co se s ním stane. Každý řetězec obsahuje nula nebo více pravidel, z nichž každé má podmínku (pro určení, které pakety se shoduje) a akci (pro řízení toho, co se stane těmto odpovídajícím paketům). Každý řetězec má také výchozí akci, která řídí, co se stane s pakety, které neodpovídají žádnému pravidlu. <p> Každý řetězec je součástí tabulky, z nichž v současné době existují tři: <ul><li> <b>Filtrování paketů ( <tt>filtr</tt> )</b> <br> Řetězy v této tabulce lze použít k řízení dat přicházejících do vašeho systému od ostatních hostitelů v síti, dat odesílaných z vašeho systému uživateli a procesy a dat předávaných vaším systémem, pokud jedná jako router. <p><li> <b>Překlad síťových adres ( <tt>nat</tt> )</b> <br> Tato tabulka může být použita pro nastavení NAT nebo maskování, což je užitečné, pokud chcete dát celé síti strojů přístup k internetu pouze přes jednu skutečnou IP adresu. <p><li> <b>Změna paketu ( <tt>mangle</tt> )</b> <br> Tato tabulka slouží k úpravě paketů předaných nebo odeslaných z vašeho systému. <p></ul> Kromě standardních řetězců, které jsou součástí každé tabulky, si také můžete vytvořit vlastní řetězce, které lze spouštět podle pravidel v zabudovaných řetězcích. To může být užitečné pro seskupování a sdílení pravidel, která mohou být použita na více místech. <p><h3> Hlavní stránka </h3> Na hlavní stránce tohoto modulu jsou uvedeny všechny řetězce a pravidla z jedné z dostupných tabulek vybraných ze seznamu v levém horním rohu. Níže je oddíl pro každý řetězec v aktuální tabulce, se všemi pravidly v každém řetězci uvedenými a jejich podmínkami popsanými podle nejlepších schopností modulu. Pro každý řetězec můžete změnit výchozí akci pomocí rozevíracího seznamu, pokud je řetězec jedním z vestavěných pro tabulku, nebo jej odstranit pomocí tlačítka Odstranit řetězec, pokud je definován uživatelem. <p> Můžete kliknout na libovolné pravidlo v řetězci a upravit jej, kliknutím na šipky napravo od každého řádku jej přesunout nahoru nebo dolů, nebo kliknutím na tlačítko Přidat pravidlo přidat nové. Přidáním nebo úpravou pravidla se dostanete na stránku, na které můžete vybrat akci pro každé pravidlo a podmínky, pro které je akce provedena. <p> Ve spodní části stránky je tlačítko pro <tt>aktivaci</tt> aktuální konfigurace firewallu načtením do jádra pomocí příkazu <tt>ipi (6) tables-restore</tt> . Pod ním je tlačítko pro provádění zpětného chodu - převzetí konfigurace, která je aktuálně v jádře a její zpřístupnění pro úpravy. A konečně, pokud to vaše distribuce podporuje, je zde tlačítko pro změnu, zda je firewall aktivován v době spuštění nebo ne. <p><h3> Filtrační řetězy </h3> Pro lepší spolupráci s externími iptables skripty můžete vyloučit jednotlivé řetězce ze zpracování firewallem. Chcete-li to provést, musíte v nastavení vybrat přímé zpracování pravidel a zadat seznam filtrů, který vyloučí příslušné řetězce ze zpracování. Řetězy, které nejsou vyřazeny z úprav, jsou označeny zprávou „neřízeno pomocí brány firewall“. <p><h3> IP sady </h3> Novější verze tabulky ip (6) podporují rozšíření ipset. IP sady jsou seznamy IP adres v hlavní paměti, které lze velmi efektivně prohledávat a používat jako podmínku v pravidlech. Na hlavní stránce jsou zobrazeny existující sady IP, které lze použít podle pravidel. V současné době však není možné tyto spravovat ve firewallu. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.da.auto.html ===

<header> Linux Firewall </header><h3> Introduktion til modul </h3> Dette modul giver dig mulighed for at konfigurere IPtables-firewallfunktioner, der findes i 2.4-serien med Linux-kerner. I modsætning til nogle andre firewall-konfigurationsprogrammer, i stedet for at oprette et shell-script, der opsætter firewall, læser og redigerer det en gem-fil i det format, der er læst og skrevet af henholdsvis <tt>ipi (6) -tabeller-gendannelse</tt> og <tt>ipi (6) -tabeller</tt> . <p> Hvis du allerede har en firewall på dit system, der er opsat manuelt eller fra en scriptfil, tilbyder modulet at konvertere den til en IPtables-gemningsfil for dig og oprette et script, der skal køres på starttidspunktet for at aktivere reglerne i filen. Men hvis du gør dette, skal du ikke længere redigere dit firewall-regler script og skulle deaktivere det fra at køre også på starttidspunktet. <p><h3> Oversigt over IPtables </h3> Hver netværkspakke, der kommer ind, går ud fra eller videresendes af dit system, kontrolleres mod en eller flere kæder for at afgøre, hvad der vil ske med det. Hver kæde indeholder nul eller flere regler, som hver har en betingelse (for at bestemme, hvilke pakker den matcher) og en handling (for at kontrollere, hvad der sker med de matchende pakker). Hver kæde har også en standardhandling, der styrer, hvad der sker med pakker, der ikke matcher nogen regel. <p> Hver kæde er en del af et bord, hvoraf der i øjeblikket er tre: <ul><li> <b>Pakkefiltrering ( <tt>filter</tt> )</b> <br> Kæderne i denne tabel kan bruges til at kontrollere data, der kommer ind i dit system fra andre værter på netværket, data, der sendes ud fra dit system af brugere og processer, og data, der videresendes af dit system, hvis det fungerer som en router. <p><li> <b>Oversættelse af netværksadresse ( <tt>nat</tt> )</b> <br> Denne tabel kan bruges til opsætning af NAT eller maskering, hvilket er nyttigt, hvis du vil give et helt netværk af maskiner adgang til internettet gennem kun en rigtig IP-adresse. <p><li> <b>Ændring af <tt>pakker</tt> ( <tt>mangle</tt> )</b> <br> Denne tabel er til at ændre pakker, der er videresendt af eller sendt fra dit system. <p></ul> Ud over de standardkæder, der er en del af hver tabel, kan du også oprette dine egne kæder, der kan køres efter regler i de indbyggede kæder. Dette kan være nyttigt til gruppering og delingsregler, der kan bruges flere steder. <p><h3> Hovedsiden </h3> Hovedsiden i dette modul viser alle kæder og regler fra en af de tilgængelige tabeller valgt fra listen øverst til venstre. Nedenfor er et afsnit for hver kæde i den aktuelle tabel med alle regler i hver kæde anført og deres forhold beskrevet efter modulets evne. For hver kæde kan du ændre standardhandlingen ved hjælp af rullelisten, hvis kæden er en af de indbyggede i tabellen, eller slette den med knappen Slet kæde, hvis den er brugerdefineret. <p> Du kan klikke på en vilkårlig regel i en kæde for at redigere den, klikke på pilene til højre for hver række for at flytte den op eller ned, eller klikke på knappen Tilføj regel for at tilføje en ny. Tilføjelse eller redigering af en regel fører dig til en side, hvor du kan vælge handlingen for hver regel, og de betingelser, som handlingen udføres for. <p> Nederst på siden er der en knap til at aktivere den aktuelle firewall-konfiguration ved at indlæse den i kernen med <tt>ipi (6) -tabeller-gendannelseskommandoen</tt> . Under det er en knap til at gøre det omvendte - tage den konfiguration, der i øjeblikket er i kernen og gøre den tilgængelig til redigering. Endelig, hvis din distribution understøtter det, er der en knap til at ændre, om firewall er aktiveret ved starttidspunktet eller ej. <p><h3> Filtrering af kæder </h3> For bedre samarbejde med eksterne iptables-scripts kan du ekskludere individuelle kæder fra behandlingen med firewall. For at gøre dette skal du vælge direkte behandling af regler i indstillingerne og gå ind i en filterliste, som udelukker de relevante kæder fra behandlingen. Kæder, der ikke er ekskluderet fra redigering, markeres med en &quot;ikke administreret af firewall&quot; -meddelelse. <p><h3> IP-sæt </h3> Nyere versioner af ip (6) -tabel understøtter ipset-udvidelsen. IP-sæt er lister over IP-adresser i hovedhukommelsen, som kan søges meget effektivt og bruges som en betingelse i regler. På hovedsiden vises eksisterende IP-sæt, der kan bruges efter regler. I øjeblikket er det imidlertid ikke muligt at administrere disse i firewall. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.de.html ===

<header>Linux-Firewall</header><h3>Modul-Übersicht</h3>Dieses Modul ermöglicht es Ihnen, die IPtables-Firewall-Funktionen zu konfigurieren, die in der 2.4-Serie der Linux-Kernel zu finden sind. Im Gegensatz zu einigen anderen Firewall-Konfigurationsprogrammen, bei denen ein Shell-Skript zur Einrichtung der Firewall erstellt wird, liest und bearbeitet es eine Sicherungsdatei im Format, das von <tt>ipi(6)tables-restore</tt> und <tt>ipi(6)tables-save</tt> gelesen und geschrieben wird.<p>Wenn Sie bereits eine manuell eingerichtete Firewall auf Ihrem System haben oder eine Skriptdatei verwenden, bietet das Modul an, diese in eine IPtables-Sicherungsdatei zu konvertieren und ein Skript zu erstellen, das beim Start ausgeführt wird, um die Regeln in der Datei zu aktivieren. Wenn Sie dies tun, sollten Sie jedoch Ihr Firewall-Regelskript nicht mehr bearbeiten und es auch von der Ausführung beim Start deaktivieren.<p><h3>IPtables-Übersicht</h3>Jedes Netzwerkpaket, das in Ihr System gelangt, es verlässt oder von Ihrem System weitergeleitet wird, wird gegen eine oder mehrere Chains geprüft, um zu bestimmen, was mit ihm passieren soll. Jede Chain enthält null oder mehr Regeln, von denen jede eine Bedingung (zur Bestimmung, welche Pakete sie übereinstimmt) und eine Aktion (zur Steuerung, was mit diesen übereinstimmenden Paketen passiert) hat. Jede Chain hat auch eine Standardaktion, die steuert, was mit Paketen passiert, die keine Regel erfüllen.<p>Jede Chain ist Teil einer Tabelle, von denen es derzeit drei gibt:<ul><li><b>Paketsfilterung (<tt>filter</tt>)</b><br>Die Chains in dieser Tabelle können verwendet werden, um Daten zu kontrollieren, die von anderen Hosts im Netzwerk in Ihr System kommen, von Ihrem System an andere Hosts gesendet werden oder von Ihrem System weitergeleitet werden, wenn es als Router fungiert.<p><li><b>Netzwerkadressübersetzung (<tt>nat</tt>)</b><br>Diese Tabelle kann für die Einrichtung von NAT oder Masquerading verwendet werden, was nützlich ist, wenn Sie einem gesamten Netzwerk von Maschinen den Zugriff auf das Internet über nur eine reale IP-Adresse gewähren möchten.<p><li><b>Paketanpassung (<tt>mangle</tt>)</b><br>Diese Tabelle dient der Modifikation von Paketen, die von Ihrem System weitergeleitet oder von ihm gesendet werden.<p></ul>Zusätzlich zu den Standardchains, die Teil jeder Tabelle sind, können Sie auch Ihre eigenen Chains erstellen, die von Regeln in den eingebauten Chains ausgeführt werden können. Dies kann nützlich sein, um Regeln zu gruppieren und zu teilen, die möglicherweise an mehreren Stellen verwendet werden.<p><h3>Die Hauptseite</h3>Die Hauptseite dieses Moduls listet alle Chains und Regeln aus einer der verfügbaren Tabellen auf, die aus der Liste oben links ausgewählt werden kann. Darunter befindet sich ein Abschnitt für jede Chain in der aktuellen Tabelle, in dem alle Regeln in jeder Chain aufgelistet und ihre Bedingungen so gut wie möglich beschrieben werden. Für jede Chain können Sie die Standardaktion mit der Dropdown-Liste ändern, wenn die Chain eine der eingebauten für die Tabelle ist, oder sie mit der Schaltfläche <tt>Chain löschen</tt> löschen, wenn sie benutzerdefiniert ist.<p>Sie können auf jede Regel in einer Chain klicken, um sie zu bearbeiten, auf die Pfeile rechts jeder Zeile klicken, um sie nach oben oder unten zu verschieben, oder auf die Schaltfläche <tt>Regel hinzufügen</tt> klicken, um eine neue hinzuzufügen. Das Hinzufügen oder Bearbeiten einer Regel führt Sie zu einer Seite, auf der Sie die Aktion für jede Regel und die Bedingungen auswählen können, unter denen die Aktion ausgeführt wird.<p>Am unteren Rand der Seite befindet sich eine Schaltfläche, um die aktuelle Firewall-Konfiguration aktiv zu machen, indem sie mit dem Befehl <tt>ipi(6)tables-restore</tt> in den Kernel geladen wird. Darunter befindet sich eine Schaltfläche, um das Gegenteil zu tun – die aktuell im Kernel befindliche Konfiguration verfügbar zu machen, um sie zu bearbeiten. Schließlich gibt es, wenn Ihre Distribution dies unterstützt, eine Schaltfläche, um zu ändern, ob die Firewall beim Booten aktiviert werden soll oder nicht.<p><h3>Filter-Chains</h3>Für eine bessere Zusammenarbeit mit externen iptables-Skripten können Sie einzelne Chains von der Verarbeitung durch die Firewall ausschließen. Dazu müssen Sie in den Einstellungen die direkte Verarbeitung von Regeln auswählen und eine Filterliste eingeben, die die entsprechenden Chains von der Verarbeitung ausschließt. Chains, die nicht vom Bearbeiten ausgeschlossen sind, werden mit der Nachricht "Nicht von der Firewall verwaltet" markiert.<p><h3>IP-Sets</h3>Neuere Versionen von ip(6)table unterstützen die ipset-Erweiterung. IP-Sets sind Listen von IP-Adressen im Arbeitsspeicher, die sehr effizient durchsucht werden können und als Bedingung in Regeln verwendet werden können. Auf der Hauptseite werden vorhandene IP-Sets angezeigt, die von Regeln verwendet werden können. Derzeit ist es jedoch nicht möglich, diese in der Firewall zu verwalten.<p><hr>
=== ./background/webmin-plugins/firewall/help/intro.el.auto.html ===

<header> Τείχος προστασίας Linux </header><h3> Εισαγωγή ενότητας </h3> Αυτή η ενότητα σάς επιτρέπει να διαμορφώσετε τις δυνατότητες τείχους προστασίας IPtables που βρίσκονται στη σειρά 2.4 των πυρήνων Linux. Σε αντίθεση με ορισμένα άλλα προγράμματα διαμόρφωσης τείχους προστασίας, αντί να δημιουργεί ένα σενάριο κελύφους που ρυθμίζει το τείχος προστασίας, διαβάζει και επεξεργάζεται ένα αρχείο αποθήκευσης με τη μορφή ανάγνωσης και γραφής από το <tt>ipi (6) tables-restore</tt> και το <tt>ipi (6) tables-save</tt> αντίστοιχα. <p> Εάν έχετε ήδη ένα τείχος προστασίας στο σύστημά σας που έχει ρυθμιστεί χειροκίνητα ή από ένα αρχείο δέσμης ενεργειών, η μονάδα θα προσφέρει τη μετατροπή του σε αρχείο αποθήκευσης IPtables για εσάς και θα δημιουργήσετε ένα σενάριο που θα εκτελεστεί κατά την εκκίνηση για να ενεργοποιήσετε τους κανόνες το αρχείο. Ωστόσο, εάν το κάνετε αυτό, δεν θα πρέπει πλέον να επεξεργάζεστε το σενάριο κανόνων του τείχους προστασίας και να το απενεργοποιείτε και κατά την εκκίνηση. <p><h3> Επισκόπηση IPtables </h3> Κάθε πακέτο δικτύου που εισέρχεται, βγαίνει από ή προωθείται από το σύστημά σας ελέγχεται έναντι μίας ή περισσότερων αλυσίδων για να προσδιορίσει τι θα συμβεί σε αυτό. Κάθε αλυσίδα περιέχει μηδενικούς ή περισσότερους κανόνες, καθένας από τους οποίους έχει μια συνθήκη (για να προσδιορίσει ποια πακέτα ταιριάζει) και μια ενέργεια (για τον έλεγχο του τι συμβαίνει σε αυτά τα πακέτα που ταιριάζουν). Κάθε αλυσίδα έχει επίσης μια προεπιλεγμένη ενέργεια που ελέγχει τι συμβαίνει σε πακέτα που δεν ταιριάζουν με κανέναν κανόνα. <p> Κάθε αλυσίδα είναι μέρος ενός πίνακα, του οποίου υπάρχουν τρεις: <ul><li> <b>Φιλτράρισμα πακέτων ( <tt>φίλτρο</tt> )</b> <br> Οι αλυσίδες σε αυτόν τον πίνακα μπορούν να χρησιμοποιηθούν για τον έλεγχο δεδομένων που εισέρχονται στο σύστημά σας από άλλους κεντρικούς υπολογιστές στο δίκτυο, δεδομένα που αποστέλλονται από το σύστημά σας από χρήστες και διαδικασίες και δεδομένα που προωθούνται από το σύστημά σας εάν λειτουργεί ως δρομολογητής. <p><li> <b>Μετάφραση διεύθυνσης δικτύου ( <tt>nat</tt> )</b> <br> Αυτός ο πίνακας μπορεί να χρησιμοποιηθεί για τη ρύθμιση NAT ή μεταμφίεση, το οποίο είναι χρήσιμο εάν θέλετε να δώσετε σε ένα ολόκληρο δίκτυο μηχανημάτων πρόσβαση στο Διαδίκτυο μέσω μιας μόνο πραγματικής διεύθυνσης IP. <p><li> <b>Αλλαγή πακέτων ( <tt>mangle</tt> )</b> <br> Αυτός ο πίνακας προορίζεται για τροποποίηση πακέτων που προωθούνται ή αποστέλλονται από το σύστημά σας. <p></ul> Εκτός από τις τυπικές αλυσίδες που αποτελούν μέρος κάθε πίνακα, μπορείτε επίσης να δημιουργήσετε τις δικές σας αλυσίδες που μπορούν να λειτουργούν με κανόνες στις ενσωματωμένες αλυσίδες. Αυτό μπορεί να είναι χρήσιμο για την ομαδοποίηση και την κοινή χρήση κανόνων που ενδέχεται να χρησιμοποιούνται σε πολλά μέρη. <p><h3> Η κύρια σελίδα </h3> Η κύρια σελίδα αυτής της ενότητας παραθέτει όλες τις αλυσίδες και τους κανόνες από έναν από τους διαθέσιμους πίνακες, που επιλέγονται από τη λίστα στην επάνω αριστερή γωνία. Ακολουθεί μια ενότητα για κάθε αλυσίδα στον τρέχοντα πίνακα, όπου αναφέρονται όλοι οι κανόνες σε κάθε αλυσίδα και οι συνθήκες τους περιγράφονται με τον καλύτερο δυνατό τρόπο στην ενότητα. Για κάθε αλυσίδα, μπορείτε να αλλάξετε την προεπιλεγμένη ενέργεια χρησιμοποιώντας την αναπτυσσόμενη λίστα, εάν η αλυσίδα είναι μία από τις ενσωματωμένες για τον πίνακα ή να τη διαγράψετε με το κουμπί Διαγραφή αλυσίδας εάν είναι καθορισμένη από τον χρήστη. <p> Μπορείτε να κάνετε κλικ σε οποιονδήποτε κανόνα σε μια αλυσίδα για να τον επεξεργαστείτε, να κάνετε κλικ στα βέλη στα δεξιά κάθε σειράς για να τον μετακινήσετε πάνω ή κάτω ή να κάνετε κλικ στο κουμπί Προσθήκη κανόνα για να προσθέσετε έναν νέο. Η προσθήκη ή η επεξεργασία ενός κανόνα θα σας οδηγήσει σε μια σελίδα στην οποία μπορείτε να επιλέξετε την ενέργεια για κάθε κανόνα και τις προϋποθέσεις για τις οποίες εκτελείται η ενέργεια. <p> Στο κάτω μέρος της σελίδας υπάρχει ένα κουμπί για την ενεργοποίηση της τρέχουσας διαμόρφωσης τείχους προστασίας, φορτώνοντάς την στον πυρήνα με την εντολή <tt>επαναφοράς πινάκων ipi (6)</tt> . Παρακάτω είναι ένα κουμπί για να κάνετε την αντίστροφη - λαμβάνοντας τη διαμόρφωση που βρίσκεται επί του παρόντος στον πυρήνα και καθιστώντας τη διαθέσιμη για επεξεργασία. Τέλος, εάν το υποστηρίζει η διανομή σας, υπάρχει ένα κουμπί για να αλλάξετε εάν το τείχος προστασίας είναι ενεργοποιημένο κατά την εκκίνηση ή όχι. <p><h3> Φιλτράρισμα αλυσίδων </h3> Για καλύτερη συνεργασία με εξωτερικά σενάρια iptables, μπορείτε να εξαιρέσετε μεμονωμένες αλυσίδες από την επεξεργασία από το τείχος προστασίας. Για να το κάνετε αυτό, πρέπει να επιλέξετε την άμεση επεξεργασία κανόνων στις ρυθμίσεις και να εισαγάγετε μια λίστα φίλτρων, η οποία αποκλείει την επεξεργασία των κατάλληλων αλυσίδων. Οι αλυσίδες που δεν απαλλάσσονται από την επεξεργασία επισημαίνονται με ένα μήνυμα &quot;δεν διαχειρίζεται από τείχος προστασίας&quot;. <p><h3> Σετ IP </h3> Οι νεότερες εκδόσεις του πίνακα ip (6) υποστηρίζουν την επέκταση ipset. Τα σύνολα IP είναι λίστες διευθύνσεων IP στην κύρια μνήμη, οι οποίες μπορούν να αναζητηθούν πολύ αποτελεσματικά και να χρησιμοποιηθούν ως συνθήκη στους κανόνες. Στην κύρια σελίδα, εμφανίζονται τα υπάρχοντα σύνολα IP που μπορούν να χρησιμοποιηθούν από κανόνες. Προς το παρόν, ωστόσο, δεν είναι δυνατή η διαχείριση αυτών στο τείχος προστασίας. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.es.auto.html ===

<header> Cortafuegos de Linux </header><h3> Introducción al módulo </h3> Este módulo le permite configurar las funciones de firewall de IPtables que se encuentran en la serie 2.4 de núcleos de Linux. A diferencia de otros programas de configuración de firewall, en lugar de crear un script de shell que configura el firewall, lee y edita un archivo de guardar en el formato leído y escrito por <tt>ipi (6) tables-restore</tt> e <tt>ipi (6) tables-save</tt> respectivamente. <p> Si ya tiene un firewall en su sistema que se configuró manualmente o desde un archivo de script, el módulo le ofrecerá convertirlo en un archivo de guardado de IPtables para usted y crear un script que se ejecutará en el momento del arranque para activar las reglas en el archivo. Sin embargo, si hace esto, ya no debería editar su script de reglas de firewall y debería deshabilitarlo para que no se ejecute también en el momento del arranque. <p><h3> Resumen de IPtables </h3> Cada paquete de red que ingresa, sale o es reenviado por su sistema se compara con una o más cadenas para determinar qué le sucederá. Cada cadena contiene cero o más reglas, cada una de las cuales tiene una condición (para determinar con qué paquetes coincide) y una acción (para controlar qué sucede con esos paquetes coincidentes). Cada cadena también tiene una acción predeterminada que controla lo que sucede con los paquetes que no coinciden con ninguna regla. <p> Cada cadena es parte de una tabla, de la cual actualmente hay tres: <ul><li> <b>Filtrado de paquetes ( <tt>filtro</tt> )</b> <br> Las cadenas en esta tabla se pueden usar para controlar los datos que ingresan a su sistema desde otros hosts en la red, los datos enviados desde su sistema por usuarios y procesos, y los datos reenviados por su sistema si está actuando como un enrutador. <p><li> <b>Traducción de direcciones de red ( <tt>nat</tt> )</b> <br> Esta tabla se puede usar para configurar NAT o enmascaramiento, lo cual es útil si desea dar acceso a Internet a toda una red de máquinas a través de una sola dirección IP real. <p><li> <b>Alteración de paquetes ( <tt>mangle</tt> )</b> <br> Esta tabla es para modificar paquetes reenviados o enviados desde su sistema. <p></ul> Además de las cadenas estándar que forman parte de cada tabla, también puede crear sus propias cadenas que pueden ejecutarse mediante reglas en las cadenas integradas. Esto puede ser útil para agrupar y compartir reglas que podrían usarse en varios lugares. <p><h3> La página principal </h3> La página principal de este módulo enumera todas las cadenas y reglas de una de las tablas disponibles, seleccionadas de la lista en la esquina superior izquierda. A continuación hay una sección para cada cadena en la tabla actual, con todas las reglas en cada cadena listadas y sus condiciones descritas de la mejor manera posible para el módulo. Para cada cadena, puede cambiar la acción predeterminada utilizando la lista desplegable si la cadena es una de las integradas para la tabla, o eliminarla con el botón Eliminar cadena si está definida por el usuario. <p> Puede hacer clic en cualquier regla de una cadena para editarla, hacer clic en las flechas a la derecha de cada fila para moverla hacia arriba o hacia abajo, o hacer clic en el botón Agregar regla para agregar una nueva. Agregar o editar una regla lo llevará a una página en la que puede seleccionar la acción para cada regla y las condiciones para las cuales se ejecuta la acción. <p> En la parte inferior de la página hay un botón para activar la configuración actual del firewall, cargándola en el núcleo con el <tt>comando ipi (6) tables-restore</tt> . Debajo hay un botón para hacer lo contrario: tomar la configuración que está actualmente en el núcleo y ponerla a disposición para su edición. Finalmente, si su distribución lo admite, hay un botón para cambiar si el firewall está activado en el momento del arranque o no. <p><h3> Cadenas de filtrado </h3> Para una mejor colaboración con scripts de iptables externos, puede excluir cadenas individuales del procesamiento por parte del firewall. Para hacer esto, debe seleccionar el procesamiento directo de las reglas en la configuración e ingresar una lista de filtros, que excluye el procesamiento de las cadenas apropiadas. Las cadenas que no se excluyen de la edición se marcan con un mensaje &quot;no administrado por firewall&quot;. <p><h3> Conjuntos de IP </h3> Las versiones más nuevas de la tabla ip (6) admiten la extensión ipset. Los conjuntos de IP son listas de direcciones IP en la memoria principal, que pueden buscarse de manera muy eficiente y usarse como una condición en las reglas. En la página principal, se muestran los conjuntos de IP existentes que pueden usar las reglas. Actualmente, sin embargo, no es posible administrarlos en el firewall. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.eu.auto.html ===

<header> Linux suebakia </header><h3> Moduluaren sarrera </h3> Modulu honek 2.4 nukleo Linux seriean aurkitutako IPtables suebakiaren funtzioak konfiguratu ditzakezu. Firewall konfigurazioko beste programa batzuetan ez bezala, suebakia konfiguratzen duen shell script bat sortu beharrean, <tt>ipi (6) taulak-</tt> <tt>restaurazioa</tt> eta <tt>ipi (6) taulak-gorde</tt> aurrezteko fitxategia irakurri eta editatzen du. <p> Eskuz konfiguratutako sisteman firewall bat baduzu edo script-fitxategi batetik abiatuta, moduluak zuretzako gordetako fitxategia IPtables bihurtzeko eskainiko du eta arauak aktibatzeko abiarazi beharreko gidoia sortuko du. fitxategia. Hala ere, hau egiten baduzu, ez zenuke gehiago suebakiaren arauen script editatu behar eta abiarazi ere exekutatu beharko zenuke. <p><h3> IPtableen ikuspegi orokorra </h3> Sistemak sartu edo ateratzen duen sareko pakete bakoitza kate bat edo gehiagorekin kontrolatuta dago zer gertatuko den jakiteko. Kate bakoitzak zero arau edo gehiago ditu, eta bakoitzak baldintza bat dauka (paketeekin bat datorren zehazteko) eta ekintza bat (bat datozen paketeekin zer gertatzen den kontrolatzeko). Kate bakoitza ere arau bat ez duten paketeetan gertatzen dena kontrolatzen duen ekintza bat da. <p> Kate bakoitza taula baten zati bat da, eta gaur egun hiru daude: <ul><li> <b>Paketen iragazkia ( <tt>iragazkia</tt> )</b> <br> Taula honetako kateak sareko beste ostalari batzuetatik zure sistemara sartzen diren datuak kontrolatzeko erabil daitezke, erabiltzaileek eta prozesuak sistematik bidalitako datuak eta zure sistemak bidalitako datuak bideratzaile gisa jokatzen badu. <p><li> <b>Sareko <tt>helbideen</tt> itzulpena ( <tt>nat</tt> )</b> <br> Taula hau NAT edo maskaradak konfiguratzeko erabil daiteke, eta hori erabilgarria da makinen sare osoari internetera heltzeko benetako IP helbide baten bidez eman nahi baduzu. <p><li> <b>Paketeen aldaketa ( <tt>mangle</tt> )</b> <br> Taula hau zure sistematik bidalitako edo bidalitako paketeak aldatzeko da. <p></ul> Taula bakoitza osatzen duten kate estandarrez gain, barne-kateetan arauak erabil daitezkeen kateak ere sor ditzakezu. Hainbat tokitan erabil daitezkeen arauak taldekatzeko eta partekatzeko erabilgarria izan daiteke. <p><h3> Orrialde nagusia </h3> Modulu honen orrialde nagusiak goi-ezkerreko zerrendan hautatutako taula bateko arau guztiak zerrendatzen ditu. Jarraian, uneko taulan kate bakoitzeko atal bat dago, kate bakoitzeko arau guztiak zerrendatuta eta moduluak gaitasunik onenarekin deskribatzen dituena. Kate bakoitzeko, ekintza lehenetsia alda dezakezu goitibeherako zerrenda erabiliz, katea taulan eraikitakoetariko bat bada edo ezabatu katearen botoiarekin, erabiltzaileak definituta badago. <p> Kate bateko edozein arautan klik egin dezakezu editatzeko, egin klik errenkada bakoitzeko eskuineko gezietan, gora edo behera mugitzeko, edo egin klik Gehitu araua botoian, beste bat gehitzeko. Araua gehitzeak edo editatzeak arau bakoitzerako ekintza hautatu dezakezuen orrira eta ekintza gauzatzeko baldintzetara eramango zaitu. <p> Orriaren behealdean botoia dago gaur egungo suebakiaren konfigurazioa aktibatzeko, nukleoan kargatzeko <tt>ipi (6) taulak leheneratzeko</tt> komandoarekin. Azpian, alderantzizko botoia dago. Gaur egun nukleoan dagoen konfigurazioa hartu eta editatzeko eskuragarri dago. Azkenean, zure banaketak onartzen badu, suebakia abiaraztean aktibatuta dagoen edo ez aldatzeko botoia dago. <p><h3> Iragazteko kateak </h3> Kanpoko iptableen scriptekin elkarlanean aritzeko, suhiltzaileak prozesatzetik kate banakak baztertu ditzakezu. Horretarako, arauen tratamendu zuzena ezarpenetan hautatu behar duzu eta iragazkien zerrendan sartu, eta horrek kate egokiak prozesatzetik baztertzen ditu. Editatzetik ateratzen ez diren kateak &quot;suebakiak kudeatu ez&quot; dituen mezuarekin markatzen dira. <p><h3> IP multzoak </h3> Ip (6) taularen bertsio berriagoek ipset luzapena onartzen dute. IP multzoak memoria nagusiko IP helbideen zerrendak dira, oso modu eraginkorrean bilatu eta arauetan baldintza gisa erabil daitezkeenak. Orrialde nagusian, arauek erabil ditzaketen IP multzoak agertzen dira. Gaur egun, ordea, ezin da horiek suebakian kudeatu. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.fa.auto.html ===

<header> فایروال لینوکس </header><h3 style=";text-align:right;direction:rtl"> معرفی ماژول </h3> این ماژول به شما امکان می دهد ویژگی های فایروال IPtables را که در سری 2.4 هسته های لینوکس موجود است پیکربندی کنید. برخلاف برخی دیگر از برنامه های پیکربندی فایروال ، به جای ایجاد اسکریپت پوسته ای که فایروال را تنظیم می کند ، یک فایل ذخیره را با فرمت خوانده شده و ویرایش شده توسط فرمت های <tt>ipi (6)</tt> <tt>-restore</tt> و <tt>ipi (6) ذخیره</tt> می کند و ویرایش می کند. <p style=";text-align:right;direction:rtl"> اگر از قبل فایروال روی سیستم خود دارید که به صورت دستی یا از یک فایل اسکریپت تنظیم شده است ، ماژول پیشنهاد می کند که آن را به یک فایل ذخیره IPtables برای شما تبدیل کند ، و یک اسکریپت ایجاد کنید که در زمان راه اندازی برای فعال کردن قوانین در پرونده. با این حال ، اگر این کار را انجام دهید ، دیگر نباید اسکریپت قوانین فایروال خود را ویرایش کنید و باید آن را از کار در زمان بوت نیز غیرفعال کنید. <p style=";text-align:right;direction:rtl"><h3 style=";text-align:right;direction:rtl"> مرور اجمالی IPt </h3> هر بسته شبکه ای که وارد شود ، از آن خارج شود یا توسط سیستم شما ارسال شود در مقابل یک یا چند زنجیره بررسی می شود تا مشخص شود چه اتفاقی برای آن خواهد افتاد. هر زنجیره حاوی صفر یا بیشتر قانون است که هر کدام یک شرط دارند (برای تعیین اینکه کدام بسته با آن مطابقت دارند) و یک عمل (برای کنترل آنچه در آن بسته های مطابق با هم اتفاق می افتد) است. هر زنجیره همچنین یک عمل پیش فرض دارد که اتفاقاتی را برای بسته هایی که مطابق با هیچ قاعده نیستند ، کنترل نمی کند. <p style=";text-align:right;direction:rtl"> هر زنجیره بخشی از یک جدول است که در حال حاضر سه جدول وجود دارد: <ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <b>فیلتر بسته ( <tt>فیلتر</tt> )</b> <br> زنجیرهای این جدول می توانند برای کنترل داده های وارد شده از سیستم از دیگر میزبان های موجود در شبکه ، داده های ارسال شده از سیستم توسط کاربران و پردازش ها ، و داده هایی که در صورت عملکرد به عنوان روتر از سیستم شما ارسال می شود ، استفاده شوند. <p style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <b>ترجمه آدرس شبکه ( <tt>nat</tt> )</b> <br> از این جدول می توان برای تنظیم NAT یا Mas maskade استفاده کرد که در صورتی که بخواهید از طریق یک آدرس IP واقعی به کل شبکه از دستگاه ها دسترسی به اینترنت بدهید ، مفید است. <p style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <b>تغییر بسته ( <tt>مانبه</tt> )</b> <br> این جدول برای تغییر بسته هایی است که توسط سیستم شما ارسال شده یا ارسال شده است. <p style=";text-align:right;direction:rtl"></ul> علاوه بر زنجیرهای استاندارد که بخشی از هر جدول هستند ، می توانید زنجیرهای خود را نیز ایجاد کنید که با استفاده از قوانین در زنجیره های داخلی قابل اجرا باشد. این می تواند برای گروه بندی و به اشتراک گذاری قوانینی که ممکن است در چندین مکان استفاده شود مفید باشد. <p style=";text-align:right;direction:rtl"><h3 style=";text-align:right;direction:rtl"> صفحه اصلی </h3> در صفحه اصلی این ماژول همه زنجیره ها و قوانین از یکی از جداول موجود ، که از لیست در بالا سمت چپ انتخاب شده است ، لیست می کند. در زیر یک بخش برای هر زنجیره در جدول فعلی وجود دارد که تمام قوانین در هر زنجیره ذکر شده و شرایط آنها به بهترین شکل ممکن از ماژول شرح داده شده است. برای هر زنجیره ، اگر زنجیره یکی از نمونه های ساخته شده برای جدول است ، می توانید اقدام به طور پیش فرض با استفاده از لیست کشویی را تغییر دهید یا در صورت تعریف کاربر ، آن را با دکمه Delete زنجیره حذف کنید. <p style=";text-align:right;direction:rtl"> می توانید بر روی هر قانون در یک زنجیره کلیک کنید تا آن را ویرایش کنید ، روی فلش های سمت راست هر سطر کلیک کنید تا آن را به بالا یا پایین حرکت دهید یا بر روی دکمه Add قاعده کلیک کنید تا یک مورد جدید اضافه شود. اضافه کردن یا ویرایش یک قانون ، شما را به صفحه ای می برد که در آن می توانید برای هر قانون ، اقداماتی را انتخاب کنید و شرایط انجام این عمل را نیز انجام دهید. <p style=";text-align:right;direction:rtl"> در پایین صفحه دکمه ای برای فعال سازی پیکربندی فایروال فعلی وجود دارد که با بارگیری آن در هسته با دستور <tt>ipi (6) جدول بازگردانی</tt> در هسته می توانید آن را فعال کنید. در زیر آن یک دکمه برای انجام معکوس وجود دارد - پیکربندی موجود در هسته و تهیه آن را برای ویرایش در دسترس است. سرانجام ، اگر توزیع شما از آن پشتیبانی می کند ، دکمه ای وجود دارد که می تواند فایروال را در زمان بوت فعال کند یا خیر. <p style=";text-align:right;direction:rtl"><h3 style=";text-align:right;direction:rtl"> فیلترهای زنجیره ای </h3> برای همکاری بهتر با اسکریپت های iptables خارجی می توانید زنجیره های فردی را از پردازش توسط فایروال خارج کنید. برای انجام این کار ، باید پردازش مستقیم قوانین را در تنظیمات انتخاب کنید و یک لیست فیلتر را وارد کنید ، که زنجیره های مناسب را از پردازش خارج می کند. زنجیرهایی که از ویرایش برجسته نیستند با پیام &quot;با مدیریت فایروال&quot; پرچم گذاری نمی شوند. <p style=";text-align:right;direction:rtl"><h3 style=";text-align:right;direction:rtl"> مجموعه های IP </h3> نسخه های جدیدتر جدول ip (6) از پسوند ipset پشتیبانی می کنند. مجموعه های IP لیست هایی از آدرس های IP در حافظه اصلی هستند که می توانند بسیار کارآمد جستجو شوند و در قوانین به عنوان یک شرط مورد استفاده قرار گیرند. در صفحه اصلی مجموعه های IP موجود که می توانند توسط قوانین استفاده شوند نمایش داده می شوند. اما در حال حاضر ، مدیریت این موارد در فایروال امکان پذیر نیست. <p style=";text-align:right;direction:rtl"><hr>
=== ./background/webmin-plugins/firewall/help/intro.fi.auto.html ===

<header> Linux-palomuuri </header><h3> Moduulin esittely </h3> Tämä moduuli antaa sinun määrittää IPtable-palomuurin ominaisuudet, jotka löytyvät Linux-ytimen 2.4-sarjasta. Toisin kuin joissain muissa palomuurin määritysohjelmissa, sen sijaan, että luodaan kuori-skripti, joka asettaa palomuurin, se lukee ja editoi tallennustiedostoa muodossa, jonka lukevat ja kirjoittavat <tt>ipi (6) taulut-palauta</tt> ja <tt>ipi (6) taulut-tallenna</tt> . <p> Jos järjestelmässäsi on jo palomuuri, joka on määritetty manuaalisesti tai komentotiedostosta, moduuli tarjoaa muuntaa sen sinulle IPtables-tallennustiedostoksi ja luoda komentosarjan, joka suoritetaan käynnistyshetkellä sääntöjen aktivoimiseksi tiedosto. Jos kuitenkin teet tämän, sinun ei pitäisi enää muokata palomuurisääntöjen komentosarjaa ja estää sen käynnistymisen myös käynnistyksen yhteydessä. <p><h3> IP-taulukko yleiskatsaus </h3> Jokainen verkkopaketti, joka tulee, lähtee ulos tai jonka järjestelmäsi välittää, tarkistetaan yhden tai useamman ketjun suhteen sen selvittämiseksi, mitä siihen tapahtuu. Jokainen ketju sisältää nolla tai enemmän sääntöjä, joista jokaisella on ehto (sen määrittämiseksi, mitä paketteja se vastaa) ja toiminto (hallita, mitä tapahtuu näille vastaaville paketeille). Jokaisella ketjulla on myös oletustoiminto, joka ohjaa mitä tapahtuu paketeille, jotka eivät vastaa mitään sääntöä. <p> Jokainen ketju on osa taulukkoa, jota on tällä hetkellä kolme: <ul><li> <b>Pakettien suodatus ( <tt>suodatin</tt> )</b> <br> Tämän taulukon ketjuja voidaan käyttää ohjaamaan järjestelmään tulevia tietoja verkon muilta isäntiltä, käyttäjien ja prosessien järjestelmästä lähettämiä tietoja ja järjestelmän välittämiä tietoja, jos se toimii reitittimenä. <p><li> <b>Verkko-osoitteen käännös ( <tt>nat</tt> )</b> <br> Tätä taulukkoa voidaan käyttää NAT: n asettamiseen tai naamiointiin, mikä on hyödyllistä, jos haluat antaa koko koneverkolle pääsyn Internetiin vain yhden todellisen IP-osoitteen kautta. <p><li> <b>Pakettien muuttaminen ( <tt>mangle</tt> )</b> <br> Tämä taulukko on tarkoitettu järjestelmän lähettämien tai lähettämien pakettien muokkaamiseen. <p></ul> Jokaiseen taulukkoon kuuluvien vakioketjujen lisäksi voit myös luoda omia ketjuja, joita voidaan hallita rakennusketjujen sääntöillä. Tämä voi olla hyödyllinen ryhmittäessään ja jakamalla sääntöjä, joita voidaan käyttää useissa paikoissa. <p><h3> Pääsivu </h3> Tämän moduulin pääsivulla luetellaan kaikki ketjut ja säännöt yhdestä käytettävissä olevista taulukoista, jotka valitaan vasemman yläkulman luettelosta. Alla on osa jokaisesta nykyisen taulukon ketjusta, jossa on lueteltu kunkin ketjun kaikki säännöt ja niiden ehdot kuvattu moduulin parhaan kykyjen mukaan. Voit muuttaa jokaisessa ketjussa oletustoimintoa avattavan luettelon avulla, jos ketju on yksi taulukon sisäisistä, tai poistaa sen Poista ketju -painikkeella, jos se on käyttäjän määrittelemä. <p> Voit napsauttaa mitä tahansa ketjun sääntöä muokataksesi sitä, napsauttaa kunkin rivin oikealla puolella olevia nuolia siirtääksesi sitä ylös tai alas tai napsauttamalla Lisää sääntö -painiketta lisätäksesi uuden. Säännön lisääminen tai muokkaaminen vie sivulle, jolla voit valita toiminnon kullekin säännölle ja ehdoille, joissa toiminto suoritetaan. <p> Sivun alaosassa on painike nykyisen palomuurin kokoonpanon <tt>aktivoimiseksi</tt> lataamalla se ytimeen <tt>ipi (6) tables-Resto</tt> -komennolla. Sen alapuolella on painike, jolla käänteinen tapahtuu - ytimen nykyisen kokoonpanon ottaminen ja sen muokkaamista varten. Viimeinkin, jos jakelu tukee sitä, on painike, jolla voit muuttaa, aktivoidaanko palomuuri käynnistyksen yhteydessä vai ei. <p><h3> Suodatusketjut </h3> Parempaa yhteistyötä ulkoisten iptable-komentosarjojen kanssa voit sulkea yksittäiset ketjut palomuurin suorittamasta prosessoinnista. Voit tehdä tämän valitsemalla asetuksissa suoran prosessoinnin ja syöttämällä suodatinluettelon, joka sulkee pois asianmukaiset ketjut käsittelystä. Ketjut, joita ei suljeta pois muokkaamisesta, merkitään viestillä &quot;ei hallitse palomuuri&quot;. <p><h3> IP-asetukset </h3> Ip (6) -taulun uudemmat versiot tukevat ipset-laajennusta. IP-sarjat ovat päämuistin IP-osoitteiden luetteloita, joita voidaan hakea erittäin tehokkaasti ja joita voidaan käyttää ehtona säännöissä. Pääsivulla näkyvät olemassa olevat IP-sarjat, joita sääntöjä voi käyttää. Tällä hetkellä niitä ei kuitenkaan ole mahdollista hallita palomuurissa. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.fr.auto.html ===

<header> Pare-feu Linux </header><h3> Introduction du module </h3> Ce module vous permet de configurer les fonctionnalités de pare-feu IPtables présentes dans la série 2.4 de noyaux Linux. Contrairement à d&#39;autres programmes de configuration de pare-feu, au lieu de créer un script shell qui configure le pare-feu, il lit et modifie un fichier de sauvegarde au format lu et écrit par <tt>ipi (6) tables-restore</tt> et <tt>ipi (6) tables-save</tt> respectivement. <p> Si vous avez déjà un pare-feu sur votre système qui a été installé manuellement ou à partir d&#39;un fichier de script, le module vous proposera de le convertir en un fichier de sauvegarde IPtables et de créer un script à exécuter au démarrage pour activer les règles dans le fichier. Cependant, si vous faites cela, vous ne devez plus modifier votre script de règles de pare-feu et vous devez également désactiver son exécution au démarrage. <p><h3> Présentation d&#39;IPtables </h3> Chaque paquet réseau entrant, sortant ou transmis par votre système est vérifié par rapport à une ou plusieurs chaînes pour déterminer ce qui va lui arriver. Chaque chaîne contient zéro ou plusieurs règles, chacune ayant une condition (pour déterminer les paquets auxquels elle correspond) et une action (pour contrôler ce qui arrive à ces paquets correspondants). Chaque chaîne a également une action par défaut qui contrôle ce qui arrive aux paquets qui ne correspondent à aucune règle. <p> Chaque chaîne fait partie d&#39;un tableau, dont il existe actuellement trois: <ul><li> <b>Filtrage de paquets ( <tt>filtre</tt> )</b> <br> Les chaînes de ce tableau peuvent être utilisées pour contrôler les données entrant dans votre système à partir d&#39;autres hôtes du réseau, les données envoyées depuis votre système par les utilisateurs et les processus, et les données transmises par votre système s&#39;il agit en tant que routeur. <p><li> <b>Traduction d&#39;adresses réseau ( <tt>nat</tt> )</b> <br> Ce tableau peut être utilisé pour configurer le NAT ou le masquage, ce qui est utile si vous souhaitez donner à un réseau entier de machines un accès à Internet via une seule adresse IP réelle. <p><li> <b>Altération de paquets ( <tt>mangle</tt> )</b> <br> Ce tableau sert à modifier les paquets transmis ou envoyés par votre système. <p></ul> En plus des chaînes standard qui font partie de chaque table, vous pouvez également créer vos propres chaînes qui peuvent être exécutées par des règles dans les chaînes intégrées. Cela peut être utile pour regrouper et partager des règles qui peuvent être utilisées à plusieurs endroits. <p><h3> La page principale </h3> La page principale de ce module répertorie toutes les chaînes et règles d&#39;une des tables disponibles, sélectionnées dans la liste en haut à gauche. Vous trouverez ci-dessous une section pour chaque chaîne du tableau actuel, avec toutes les règles de chaque chaîne répertoriées et leurs conditions décrites au mieux des capacités du module. Pour chaque chaîne, vous pouvez modifier l&#39;action par défaut à l&#39;aide de la liste déroulante si la chaîne fait partie de celles intégrées pour la table, ou la supprimer avec le bouton Supprimer la chaîne si elle est définie par l&#39;utilisateur. <p> Vous pouvez cliquer sur n&#39;importe quelle règle d&#39;une chaîne pour la modifier, cliquer sur les flèches à droite de chaque ligne pour la déplacer vers le haut ou vers le bas, ou cliquer sur le bouton Ajouter une règle pour en ajouter une nouvelle. L&#39;ajout ou la modification d&#39;une règle vous amène à une page sur laquelle vous pouvez sélectionner l&#39;action pour chaque règle et les conditions pour lesquelles l&#39;action est exécutée. <p> Au bas de la page se trouve un bouton pour rendre la configuration actuelle du pare-feu active, en la chargeant dans le noyau avec la commande <tt>ipi (6) tables-restore</tt> . En dessous, il y a un bouton pour faire l&#39;inverse - prendre la configuration qui est actuellement dans le noyau et la rendre disponible pour l&#39;édition. Enfin, si votre distribution le prend en charge, il y a un bouton pour changer si le pare-feu est activé au démarrage ou non. <p><h3> Chaînes filtrantes </h3> Pour une meilleure collaboration avec les scripts iptables externes, vous pouvez exclure des chaînes individuelles du traitement par le pare-feu. Pour ce faire, vous devez sélectionner le traitement direct des règles dans les paramètres et entrer une liste de filtres, qui exclut les chaînes appropriées du traitement. Les chaînes qui ne sont pas exclues de l&#39;édition sont signalées par un message &quot;non géré par le pare-feu&quot;. <p><h3> Ensembles IP </h3> Les versions plus récentes de la table ip (6) prennent en charge l&#39;extension ipset. Les ensembles IP sont des listes d&#39;adresses IP dans la mémoire principale, qui peuvent être recherchées très efficacement et utilisées comme condition dans les règles. Sur la page principale, les ensembles IP existants qui peuvent être utilisés par des règles sont affichés. Actuellement, cependant, il n&#39;est pas possible de les gérer dans le pare-feu. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.hr.auto.html ===

<header> Linux vatrozid </header><h3> Uvod u modul </h3> Ovaj modul vam omogućuje konfiguriranje značajki vatrozida IPtablesa koje se nalaze u 2.4 jezgri Linux kernela. Za razliku od nekih drugih programa konfiguracije vatrozida, umjesto stvaranja skripte školjke koja postavlja vatrozid, ona čita i uređuje datoteku spremanja u formatu koji čitaju i pišu <tt>ipi (6) tablice-obnavljaju</tt> i <tt>ipi (6) tablice-spremaju</tt> . <p> Ako već imate vatrozid na vašem sustavu koji je ručno postavljen ili iz datoteke skripte, modul će vam ponuditi da ga pretvorite u datoteku za spremanje IPtables za vas i stvoriti skriptu koja će se pokrenuti u vrijeme pokretanja kako biste aktivirali pravila u Datoteka. Međutim, ako to učinite, tada više ne biste trebali uređivati skriptu pravila vatrozida i trebali biste je onemogućiti u pokretanju i u vrijeme dizanja. <p><h3> Pregled IPtables </h3> Svaki mrežni paket koji ulazi, odlazi ili prosljeđuje vaš sustav provjerava se s jednim ili više lanaca kako bi odredio što će se s njim dogoditi. Svaki lanac sadrži nula ili više pravila, od kojih svako ima uvjet (da bi odredio koji paketi odgovaraju) i radnju (za kontrolu onoga što se događa s tim odgovarajućim paketima). Svaki lanac također ima zadanu radnju koja kontrolira što se događa s paketima koji ne odgovaraju nijednom pravilu. <p> Svaki je lanac dio tablice, od čega trenutno postoje tri: <ul><li> <b>Filtriranje paketa ( <tt>filter</tt> )</b> <br> Lanci u ovoj tablici mogu se koristiti za kontrolu podataka koji u vaš sustav dolaze od drugih domaćina na mreži, podataka koje su iz vašeg sustava poslali korisnici i procesi i podataka koje vaš sustav prosljeđuje ako djeluje kao usmjerivač. <p><li> <b>Prijevod mrežne adrese ( <tt>nat</tt> )</b> <br> Ova se tablica može koristiti za postavljanje NAT-a ili maskiranje, što je korisno ako želite dati cijeloj mreži strojeva pristup internetu putem samo jedne stvarne IP adrese. <p><li> <b>Izmjena paketa ( <tt>mangle</tt> )</b> <br> Ova je tablica za izmjenu paketa prosljeđenih ili poslanih iz vašeg sustava. <p></ul> Pored standardnih lanaca koji su dio svake tablice, možete stvoriti i vlastite lance koji se po pravilima mogu pokrenuti u lancima ugrađivanja. Ovo može biti korisno za grupiranje i dijeljenje pravila koja se mogu koristiti na više mjesta. <p><h3> Glavna stranica </h3> Na glavnoj stranici ovog modula nalaze se svi lanci i pravila iz jedne od dostupnih tablica, odabranih s popisa u gornjem lijevom kutu. Ispod je odjeljak za svaki lanac u trenutnoj tablici, sa svim pravilima u svakom lancu i njihovim uvjetima opisanima najbolje što mogu u modulu. Za svaki lanac možete promijeniti zadanu radnju pomoću padajućeg popisa ako je lanac jedan od ugrađenih za tablicu ili ga izbrisati gumbom Izbriši lanac ako ga definira korisnik. <p> Možete kliknuti bilo koje pravilo u lancu da biste ga uredili, kliknite strelice s desne strane svakog retka za pomicanje prema gore ili prema dolje ili kliknite gumb Dodaj pravilo da biste dodali novo. Dodavanje ili uređivanje pravila odvest će vas na stranicu na kojoj možete odabrati radnju za svako pravilo i uvjete u kojima se radnja izvršava. <p> Pri dnu stranice nalazi se gumb za aktiviranje trenutne konfiguracije vatrozida, učitavanjem u kernel pomoću naredbe za <tt>vraćanje ipi (6) tablice</tt> . Ispod je gumb za obrnuto - snimanje konfiguracije koja je trenutno u jezgri i stavljanje na raspolaganje za uređivanje. Konačno, ako ga vaša distribucija podržava, postoji gumb za promjenu je li vatrozid aktiviran u vrijeme pokretanja ili ne. <p><h3> Lanci za filtriranje </h3> Za bolju suradnju s vanjskim iptables skriptu možete zaštitnim zidom isključiti pojedinačne lance iz obrade. Da biste to učinili, morate odabrati izravnu obradu pravila u postavkama i unijeti popis filtara koji isključuje odgovarajuće lance iz obrade. Lanci koji nisu izuzeti iz uređivanja označeni su porukom &quot;ne upravlja vatrozidom&quot;. <p><h3> IP setovi </h3> Novije verzije tablice ip (6) podržavaju ipset ekstenziju. IP skupovi su popisi IP adresa u glavnoj memoriji, koje se može vrlo učinkovito pretraživati i koristiti kao uvjet u pravilima. Na glavnoj stranici prikazuju se postojeći IP skupovi koje pravila mogu koristiti. Trenutno, međutim, tim vatrozidom nije moguće upravljati. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.html ===

<header>Linux Firewall</header>

<h3>Module introduction</h3>

This module allows you to configure the IPtables firewall features found in
the 2.4 series of Linux kernels. Unlike some other firewall configuration
programs, instead of creating a shell script that sets up the firewall, it
reads and edits a save file in the format read and written by
<tt>ipi(6)tables-restore</tt> and <tt>ipi(6)tables-save</tt> respectively. <p>

If you already have a firewall on your system that has been setup manually
or from a script file, the module will offer to convert it to an IPtables
save file for you, and create a script to be run at boot time to activate
the rules in the file. However, if you do this then you should no longer
edit your firewall rules script and should disable it from running at boot
time as well. <p>

<h3>IPtables overview</h3>

Every network packet that comes into, goes out from or is forwarded by your system
is checked against one or more chains to determine what will happen to it.
Each chain contains zero or more rules, each of which has a condition (to
determine which packets it matches) and an action (to control what happens
to those matching packets). Each chain also has a default action that controls
what happens to packets that do not match any rule. <p>

Each chain is part of a table, of which there are currently three :
<ul>
<li><b>Packet filtering (<tt>filter</tt>)</b><br>
    The chains in this table can be used to control data coming into your
    system from other hosts on the network, data sent out from your system
    by users and processes, and data forwarded by your system if it is acting
    as a router. <p>
<li><b>Network address translation (<tt>nat</tt>)</b><br>
    This table can be used for setting up NAT or masquerading, which is useful
    if you want to give an entire network of machines access to the internet
    through only one real IP address. <p>
<li><b>Packet alteration (<tt>mangle</tt>)</b><br>
    This table is for modifying packets forwarded by or sent out from your
    system. <p>
</ul>

In addition to the standard chains that are part of each table, you can also
create your own chains that can be run by rules in the build-in chains. This
can be useful for grouping and sharing rules that might be used in multiple
places. <p>

<h3>The main page</h3>

The main page of this module lists all the chains and rules from one of
the available tables, selected from the list in the top-left. Below is a
section for each chain in the current table, with all rules in each chain
listed and their conditions described to the best of the module's ability.
For each chain, you can change the default action using the drop-down list
if the chain is one of the build-in ones for the table, or delete it with
the Delete chain button if it is user-defined. <p>

You can click on any rule in a chain to edit it, click on the arrows on the
right of each row to move it up or down, or click on the Add rule button to add
a new one. Adding or editing a rule will take you to a page on which you
can select the action for each rule, and the conditions for which the action
is executed. <p>

At the bottom of the page is a button for making the current firewall
configuration active, by loading it into the kernel with the
<tt>ipi(6)tables-restore</tt> command. Below it is a button for doing the reverse -
taking the configuration that is currently in the kernel and making it
available for editing. Finally, if your distribution supports it, there is
a button to change whether the firewall is activated at boot time or not. <p>

<h3>Filtering chains</h3>

For better collaboration with external iptables scripts you can exclude individual
chains from the processing by the firewall. To do this, you must select direct
processing of rules in the settings and enter a filter list, which excludes
the appropriate chains from processing.
Chains that are not exculded from editing are flagged with a "not managed by firewall" message.
<p>

<h3>IP Sets</h3>

Newer versions of ip(6)table support the ipset extension.
IP sets are lists of IP addresses in the main memory, which can be searched very efficiently
and used as a condition in rules. On the main page, existing IP sets that can be used by 
rules are displayed. Currently, however, it is not possible to manage these in the firewall.
<p>

<hr>


=== ./background/webmin-plugins/firewall/help/intro.hu.auto.html ===

<header> Linux tűzfal </header><h3> Modul bevezetése </h3> Ez a modul lehetővé teszi az IPtable tűzfal funkcióinak konfigurálását, amelyek a 2.4-es Linux kernelek sorozatában találhatók. Más tűzfalkonfigurációs programokkal ellentétben a tűzfalat beállító shell parancsfájl létrehozása helyett elolvassa és szerkeszti az mentési fájlt az <tt>ipi (6) táblák - helyreállítás</tt> és az <tt>ipi (6) táblák - mentés</tt> által olvasott és írt formátumban. <p> Ha már van olyan tűzfala a rendszeren, amelyet manuálisan vagy egy szkriptfájlból állít be, a modul felajánlja, hogy konvertálja azt egy IPtable mentési fájlba az Ön számára, és létrehoz egy szkriptet, amelyet a rendszerindításkor futtatni kell a szabályok aktiválásához a fájl. Ha azonban ezt megteszi, akkor már nem szabad szerkesztenie a tűzfalszabályok parancsfájlját, és le kell tiltania a futtatást a rendszerindításkor is. <p><h3> IP táblázatok áttekintése </h3> Minden olyan hálózati csomagot, amely bekerül, kikerül vagy továbbítja a rendszer, egy vagy több lánchoz viszonyítva ellenőrzik, hogy mi történjen vele. Mindegyik lánc nulla vagy több szabályt tartalmaz, amelyek mindegyike rendelkezik feltétellel (annak meghatározására, hogy melyik csomaghoz felel meg) és egy művelettel (annak vezérlésére, hogy mi történjen azokkal a megfelelő csomagokkal). Minden láncon van egy alapértelmezett művelet, amely szabályozza, hogy mi történjen az olyan csomagokkal, amelyek nem felelnek meg a szabályoknak. <p> Minden lánc egy táblázat része, amelyből jelenleg három van: <ul><li> <b>Csomagszűrés ( <tt>szűrő</tt> )</b> <br> Az ebben a táblázatban szereplő láncok felhasználhatók a rendszer más hálózati gazdagépektől érkező adatok, a felhasználók által a rendszerből küldött adatok és a folyamatok, valamint a rendszer által továbbított adatok, ha útvonalválasztóként működik. <p><li> <b>Hálózati cím fordítása ( <tt>nat</tt> )</b> <br> Ez a táblázat felhasználható a NAT beállítására vagy álarcosításra, ami akkor hasznos, ha azt szeretné, hogy a gépek teljes hálózata csak egyetlen valódi IP-címen keresztül hozzáférjen az internethez. <p><li> <b>Csomag módosítása ( <tt>mangle</tt> )</b> <br> Ez a táblázat a rendszer által továbbított vagy a számítógépről küldött csomagok módosítására szolgál. <p></ul> Az egyes táblázatok részét képező szokásos láncokon kívül saját láncokat is létrehozhat, amelyeket a beépített láncok szabályai futtathatnak. Ez hasznos lehet a több helyen használható szabályok csoportosítása és megosztása céljából. <p><h3> Főoldal </h3> Ennek a modulnak a főoldala felsorolja a rendelkezésre álló táblák egyik láncát és szabályát, amelyeket a bal felső sarokban lévő listából választanak ki. Az alábbiakban egy szakasz található az aktuális táblázat minden egyes lánca számára, felsorolva az egyes láncok minden szabályát és feltételeit, a modul legjobb képességeinek megfelelően. Minden lánc esetében megváltoztathatja az alapértelmezett műveletet a legördülő lista segítségével, ha a lánc a táblázat egyik beépített eleme, vagy törölheti a Lánc törlése gombbal, ha a felhasználó meghatározza. <p> A szerkesztéshez kattintson a lánc bármelyik szabályára, kattintson az egyes sorok jobb oldalán található nyilakra, hogy felfelé vagy lefelé mozgassa, vagy kattintson az Új szabály hozzáadása gombra, hogy hozzáadjon egy új. Egy szabály hozzáadásával vagy szerkesztésével egy oldalra jut, ahol kiválaszthatja az egyes szabályok mûveletét, valamint a mûvelet végrehajtásának feltételeit. <p> Az oldal alján található egy gomb az aktuális tűzfalkonfiguráció aktívvá <tt>tételéhez</tt> , az <tt>ipi (6) tables -tore</tt> paranccsal betöltve a kernelbe. Az alatt egy gomb van a fordított fordítás elvégzéséhez - a kernelben lévő konfiguráció átvételéhez és szerkeszthetővé tételéhez. Végül, ha az Ön disztribúciója támogatja, akkor van egy gomb annak módosítására, hogy a tűzfal aktiválódik-e a rendszerindításkor. <p><h3> Láncok szűrése </h3> A külső iptable szkriptekkel való jobb együttműködés érdekében kizárhatja az egyes láncokat a tűzfal általi feldolgozásból. Ehhez ki kell választania a szabályok közvetlen feldolgozását a beállításokban, és be kell írnia egy szűrőlistát, amely kizárja a megfelelő láncokat a feldolgozásból. Azokat a láncokat, amelyek nem tartoznak a szerkesztés alá, jelöljük egy &quot;nem a tűzfal kezeli&quot; üzenettel. <p><h3> IP-készletek </h3> Az ip (6) tábla újabb verziói támogatják az ipset kiterjesztést. Az IP készletek a fő memóriában található IP-címek listája, amelyek nagyon hatékonyan kereshetők és felhasználhatók a szabályok feltételeként. A főoldalon a meglévő IP-készletek jelennek meg, amelyeket a szabályok használhatnak. Jelenleg azonban ezeket nem lehet a tűzfalon kezelni. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.it.auto.html ===

<header> Firewall Linux </header><h3> Introduzione al modulo </h3> Questo modulo consente di configurare le funzionalità del firewall IPtables presenti nella serie 2.4 di kernel Linux. A differenza di altri programmi di configurazione del firewall, invece di creare uno script di shell che imposta il firewall, legge e modifica un file di salvataggio nel formato letto e scritto rispettivamente dalle <tt>tabelle</tt> <tt>ipi (6)-restore</tt> e <tt>ipi (6)-save</tt> . <p> Se hai già un firewall sul tuo sistema che è stato impostato manualmente o da un file di script, il modulo offrirà di convertirlo in un file di salvataggio IPtables per te e creare uno script da eseguire all&#39;avvio per attivare le regole in il file. Tuttavia, se lo fai, non dovresti più modificare lo script delle regole del firewall e disabilitare anche l&#39;esecuzione all&#39;avvio. <p><h3> Panoramica di IPtables </h3> Ogni pacchetto di rete che entra, esce o viene inoltrato dal sistema viene verificato rispetto a una o più catene per determinare cosa accadrà ad esso. Ogni catena contiene zero o più regole, ognuna delle quali ha una condizione (per determinare quali pacchetti corrisponde) e un&#39;azione (per controllare cosa succede a quei pacchetti corrispondenti). Ogni catena ha anche un&#39;azione predefinita che controlla cosa succede ai pacchetti che non corrispondono a nessuna regola. <p> Ogni catena fa parte di una tabella, di cui attualmente ci sono tre: <ul><li> <b>Filtro pacchetti ( <tt>filtro</tt> )</b> <br> Le catene in questa tabella possono essere utilizzate per controllare i dati che arrivano nel sistema da altri host della rete, i dati inviati dal sistema da utenti e processi e i dati inoltrati dal sistema se agisce come un router. <p><li> <b>Traduzione dell&#39;indirizzo di rete ( <tt>nat</tt> )</b> <br> Questa tabella può essere utilizzata per impostare NAT o mascherare, il che è utile se si desidera dare a un&#39;intera rete di macchine l&#39;accesso a Internet tramite un solo indirizzo IP reale. <p><li> <b>Alterazione dei pacchetti ( <tt>mangle</tt> )</b> <br> Questa tabella consente di modificare i pacchetti inoltrati o inviati dal sistema. <p></ul> Oltre alle catene standard che fanno parte di ogni tabella, puoi anche creare le tue catene che possono essere eseguite da regole nelle catene di build. Ciò può essere utile per raggruppare e condividere regole che potrebbero essere utilizzate in più posizioni. <p><h3> La pagina principale </h3> La pagina principale di questo modulo elenca tutte le catene e le regole da una delle tabelle disponibili, selezionate dall&#39;elenco in alto a sinistra. Di seguito è riportata una sezione per ogni catena nella tabella corrente, con tutte le regole in ciascuna catena elencate e le loro condizioni descritte al meglio delle capacità del modulo. Per ogni catena, è possibile modificare l&#39;azione predefinita utilizzando l&#39;elenco a discesa se la catena è una di quelle incorporate per la tabella oppure eliminarla con il pulsante Elimina catena se è definita dall&#39;utente. <p> Puoi fare clic su qualsiasi regola in una catena per modificarla, fare clic sulle frecce a destra di ogni riga per spostarla verso l&#39;alto o verso il basso o fare clic sul pulsante Aggiungi regola per aggiungerne una nuova. L&#39;aggiunta o la modifica di una regola conduce a una pagina in cui è possibile selezionare l&#39;azione per ciascuna regola e le condizioni per le quali viene eseguita l&#39;azione. <p> Nella parte inferiore della pagina c&#39;è un pulsante per rendere attiva l&#39;attuale configurazione del firewall, caricandola nel kernel con il comando <tt>ipi (6) tables-restore</tt> . Sotto c&#39;è un pulsante per fare il contrario: prendere la configurazione che è attualmente nel kernel e renderla disponibile per la modifica. Infine, se la tua distribuzione lo supporta, c&#39;è un pulsante per cambiare se il firewall è attivato all&#39;avvio o meno. <p><h3> Catene filtranti </h3> Per una migliore collaborazione con script iptables esterni è possibile escludere singole catene dall&#39;elaborazione da parte del firewall. Per fare ciò, è necessario selezionare l&#39;elaborazione diretta delle regole nelle impostazioni e inserire un elenco di filtri, che esclude le catene appropriate dall&#39;elaborazione. Le catene che non sono escluse dalla modifica sono contrassegnate con un messaggio &quot;non gestito dal firewall&quot;. <p><h3> Set IP </h3> Le versioni più recenti della tabella ip (6) supportano l&#39;estensione ipset. I set IP sono elenchi di indirizzi IP nella memoria principale, che possono essere cercati in modo molto efficiente e utilizzati come condizione nelle regole. Nella pagina principale vengono visualizzati i set IP esistenti che possono essere utilizzati dalle regole. Attualmente, tuttavia, non è possibile gestirli nel firewall. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.ja.auto.html ===

<header> Linuxファイアウォール</header><h3>モジュール紹介</h3>このモジュールを使用すると、2.4シリーズのLinuxカーネルにあるIPtablesファイアウォール機能を設定できます。他のファイアウォール設定プログラムとは異なり、ファイアウォールを設定するシェルスクリプトを作成する代わりに、 <tt>それぞれipi（6）tables-restore</tt>および<tt>ipi（6）tables-save</tt>によって読み書きされる形式で保存ファイルを読み取り、編集します。 <p>システムにファイアウォールが手動またはスクリプトファイルからすでに設定されている場合は、モジュールによってファイアウォールがIPtables保存ファイルに変換され、起動時に実行されるスクリプトを作成して、ファイル。ただし、これを行う場合は、ファイアウォールルールスクリプトを編集しないでください。また、起動時にスクリプトが実行されないようにする必要があります。 <p><h3> IPtablesの概要</h3>システムに入ってくる、出て行く、またはシステムによって転送されるすべてのネットワークパケットは、1つまたは複数のチェーンに対してチェックされ、何が起こるかが決定されます。各チェーンには0個以上のルールが含まれ、各ルールには条件（一致するパケットを判別するため）とアクション（一致するパケットの処理を制御するため）があります。各チェーンには、どのルールにも一致しないパケットの処理を制御するデフォルトのアクションもあります。 <p>各チェーンはテーブルの一部であり、現在3つあります。 <ul><li> <b>パケットフィルタリング（ <tt>filter</tt> ）</b> <br>この表のチェーンを使用して、ネットワーク上の他のホストからシステムに着信するデータ、ユーザーおよびプロセスによってシステムから送信されるデータ、およびルーターとして機能している場合はシステムによって転送されるデータを制御できます。 <p><li> <b>ネットワークアドレス変換（ <tt>nat</tt> ）</b> <br>このテーブルは、NATまたはマスカレードのセットアップに使用できます。これは、マシンのネットワーク全体に、1つの実際のIPアドレスのみを介してインターネットにアクセスできるようにする場合に役立ちます。 <p><li> <b>パケット改造（ <tt>マングル</tt> ）</b> <br>このテーブルは、システムによって転送または送信されるパケットを変更するためのものです。 <p></ul>各テーブルの一部である標準のチェーンに加えて、組み込みチェーンのルールによって実行できる独自のチェーンを作成することもできます。これは、複数の場所で使用される可能性のあるルールのグループ化と共有に役立ちます。 <p><h3>メインページ</h3>このモジュールのメインページには、左上にあるリストから選択された使用可能なテーブルの1つからのすべてのチェーンとルールが一覧表示されます。以下は、現在の表の各チェーンのセクションです。各チェーンのすべてのルールがリストされ、それらの条件はモジュールの能力を最大限に発揮して記述されています。各チェーンについて、チェーンがテーブルの組み込みのものである場合はドロップダウンリストを使用してデフォルトのアクションを変更でき、ユーザー定義の場合は[チェーンの削除]ボタンで削除できます。 <p>チェーン内のルールをクリックして編集したり、各行の右側にある矢印をクリックしてルールを上下に移動したり、[ルールの追加]ボタンをクリックして新しいルールを追加したりできます。ルールを追加または編集すると、各ルールのアクションと、アクションが実行される条件を選択できるページが表示されます。 <p>ページの下部には、 <tt>ipi（6）tables-restore</tt>コマンドを使用して現在のファイアウォール構成をカーネルにロードすることにより、現在のファイアウォール構成をアクティブにするためのボタンがあります。その下には、逆の操作を行うためのボタンがあります。現在カーネル内にある構成を取得し、編集できるようにします。最後に、ディストリビューションがサポートしている場合は、起動時にファイアウォールをアクティブにするかどうかを変更するボタンがあります。 <p><h3>フィルタリングチェーン</h3>外部iptablesスクリプトとのより良いコラボレーションのために、ファイアウォールによる処理から個々のチェーンを除外できます。これを行うには、設定でルールの直接処理を選択し、適切なチェーンを処理から除外するフィルターリストを入力する必要があります。編集から除外されていないチェーンには、「ファイアウォールで管理されていません」というメッセージが表示されます。 <p><h3> IPセット</h3>新しいバージョンのip（6）tableは、ipset拡張をサポートしています。 IPセットは、メインメモリ内のIPアドレスのリストであり、非常に効率的に検索して、ルールの条件として使用できます。メインページには、ルールで使用できる既存のIPセットが表示されます。ただし、現時点では、ファイアウォールでこれらを管理することはできません。 <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.ko.auto.html ===

<header> 리눅스 방화벽 </header><h3> 모듈 소개 </h3> 이 모듈을 사용하면 2.4 시리즈 Linux 커널에있는 IPtables 방화벽 기능을 구성 할 수 있습니다. 다른 방화벽 구성 프로그램과 달리 방화벽을 설정하는 쉘 스크립트를 작성하는 대신 <tt>ipi (6) tables-restore</tt> 및 <tt>ipi (6) tables-save에서</tt> 각각 읽고 쓰는 형식으로 저장 파일을 읽고 편집합니다. <p> 시스템에 수동으로 또는 스크립트 파일로 설정된 방화벽이 이미있는 경우, 모듈은 방화벽을 IPtables 저장 파일로 변환하고 부팅시 실행할 스크립트를 생성하여 파일. 그러나이 작업을 수행하면 더 이상 방화벽 규칙 스크립트를 편집하지 않아야하며 부팅시 실행되지 않도록해야합니다. <p><h3> IPtables 개요 </h3> 시스템에 들어오고 나가거나 전달되는 모든 네트워크 패킷은 하나 이상의 체인과 비교하여 어떤 일이 발생할지 결정합니다. 각 체인에는 0 개 이상의 규칙이 포함되어 있으며 각 규칙에는 조건 (일치하는 패킷을 결정하기위한) 및 작업 (일치하는 패킷에 발생하는 것을 제어하기위한)이 있습니다. 각 체인에는 규칙과 일치하지 않는 패킷의 발생을 제어하는 기본 동작이 있습니다. <p> 각 체인은 테이블의 일부이며 현재 세 가지가 있습니다. <ul><li> <b>패킷 필터링 ( <tt>필터</tt> )</b> <br> 이 표의 체인을 사용하면 네트워크의 다른 호스트에서 시스템으로 들어오는 데이터, 사용자 및 프로세스가 시스템에서 전송 한 데이터 및 라우터로 작동하는 경우 시스템에서 전달한 데이터를 제어 할 수 있습니다. <p><li> <b>네트워크 주소 변환 ( <tt>nat</tt> )</b> <br> 이 테이블은 NAT 또는 마스커레이딩을 설정하는 데 사용할 수 있습니다. 이는 하나의 실제 IP 주소를 통해 전체 시스템 네트워크에 인터넷 액세스를 제공하려는 경우에 유용합니다. <p><li> <b>패킷 변경 ( <tt>망글</tt> )</b> <br> 이 테이블은 시스템에서 전달하거나 시스템에서 전송 한 패킷을 수정하기위한 것입니다. <p></ul> 각 테이블의 일부인 표준 체인 외에도 내장 체인의 규칙으로 실행할 수있는 고유 한 체인을 만들 수도 있습니다. 여러 위치에서 사용될 수있는 규칙을 그룹화하고 공유하는 데 유용 할 수 있습니다. <p><h3> 메인 페이지 </h3> 이 모듈의 메인 페이지는 왼쪽 상단의 목록에서 선택한 사용 가능한 테이블 중 하나의 모든 체인과 규칙을 나열합니다. 아래는 현재 표의 각 체인에 대한 섹션으로, 각 체인의 모든 규칙이 나열되어 있으며 해당 조건은 모듈 성능을 최대한 발휘하는 것으로 설명되어 있습니다. 체인이 테이블에 대한 기본 제공 체인 중 하나 인 경우 드롭 다운 목록을 사용하여 기본 조치를 변경하거나 사용자 정의 된 경우 체인 삭제 단추를 사용하여이를 삭제할 수 있습니다. <p> 체인에서 규칙을 클릭하여 편집하거나 각 행의 오른쪽에있는 화살표를 클릭하여 위 또는 아래로 이동하거나 규칙 추가 버튼을 클릭하여 새 규칙을 추가 할 수 있습니다. 규칙을 추가하거나 편집하면 각 규칙에 대한 작업을 선택할 수있는 페이지와 작업이 실행되는 조건이 표시됩니다. <p> 페이지 하단에는 <tt>ipi (6) tables-restore</tt> 명령을 사용하여 현재 방화벽 구성을 커널에로드하여 현재 방화벽 구성을 활성화하는 버튼이 있습니다. 아래에는 현재 커널에있는 구성을 가져 와서 편집 할 수 있도록 리버스를 수행 할 수있는 버튼이 있습니다. 마지막으로, 배포판에서 지원하는 경우 부팅시 방화벽의 활성화 여부를 변경하는 버튼이 있습니다. <p><h3> 필터링 체인 </h3> 외부 iptables 스크립트와의보다 나은 협업을 위해 방화벽에 의한 처리에서 개별 체인을 제외 할 수 있습니다. 이를 수행하려면 설정에서 규칙의 직접 처리를 선택하고 적절한 체인을 처리에서 제외시키는 필터 목록을 입력해야합니다. 편집에서 제외되지 않은 체인에는 &quot;방화벽으로 관리되지 않음&quot;메시지가 표시됩니다. <p><h3> IP 세트 </h3> ip (6) table의 최신 버전은 ipset 확장을 지원합니다. IP 세트는 주 메모리의 IP 주소 목록으로, 매우 효율적으로 검색되고 규칙의 조건으로 사용될 수 있습니다. 기본 페이지에는 규칙에서 사용할 수있는 기존 IP 세트가 표시됩니다. 그러나 현재 방화벽에서는 이러한 기능을 관리 할 수 없습니다. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.ms.auto.html ===

<header> Firewall Linux </header><h3> Pengenalan modul </h3> Modul ini membolehkan anda mengkonfigurasi ciri firewall IPtables yang terdapat dalam siri 2.4 kernel Linux. Tidak seperti beberapa program konfigurasi firewall yang lain, bukannya membuat skrip shell yang menyiapkan firewall, ia membaca dan mengedit fail simpan dalam format yang dibaca dan ditulis oleh <tt>ipi (6) tables-restore</tt> dan <tt>ipi (6) tables-save</tt> masing <tt>-</tt> masing. <p> Sekiranya anda sudah memiliki firewall pada sistem anda yang telah disiapkan secara manual atau dari fail skrip, modul akan menawarkan untuk mengubahnya menjadi file simpanan IPtables untuk anda, dan membuat skrip yang akan dijalankan pada waktu boot untuk mengaktifkan peraturan di fail. Namun, jika anda melakukan ini maka anda tidak perlu lagi mengedit skrip peraturan firewall anda dan juga harus melumpuhkannya agar tidak berjalan pada waktu boot juga. <p><h3> Gambaran keseluruhan IPtables </h3> Setiap paket rangkaian yang masuk, keluar dari atau diteruskan oleh sistem anda diperiksa pada satu atau lebih rantai untuk menentukan apa yang akan terjadi padanya. Setiap rantai mengandungi peraturan sifar atau lebih, masing-masing mempunyai syarat (untuk menentukan paket mana yang sesuai) dan tindakan (untuk mengawal apa yang berlaku pada paket yang sepadan). Setiap rantai juga mempunyai tindakan lalai yang mengawal apa yang berlaku pada paket yang tidak sesuai dengan peraturan apa pun. <p> Setiap rantai adalah bahagian dari jadual, di mana terdapat tiga: <ul><li> <b>Penapisan paket ( <tt>penapis</tt> )</b> <br> Rantai dalam tabel ini dapat digunakan untuk mengendalikan data yang masuk ke sistem anda dari host lain di rangkaian, data yang dikirim dari sistem anda oleh pengguna dan proses, dan data yang diteruskan oleh sistem anda jika berfungsi sebagai penghala. <p><li> <b>Terjemahan alamat rangkaian ( <tt>nat</tt> )</b> <br> Jadual ini dapat digunakan untuk menyiapkan NAT atau menyamar, yang berguna jika anda ingin memberi seluruh rangkaian mesin akses ke internet melalui hanya satu alamat IP sebenar. <p><li> <b>Perubahan paket ( <tt>mangle</tt> )</b> <br> Jadual ini adalah untuk mengubah suai paket yang dihantar oleh atau dihantar dari sistem anda. <p></ul> Sebagai tambahan kepada rantai standard yang merupakan bahagian dari setiap jadual, anda juga boleh membuat rantai anda sendiri yang dapat dijalankan oleh peraturan dalam rantai bawaan. Ini berguna untuk pengelompokan dan perkongsian peraturan yang mungkin digunakan di banyak tempat. <p><h3> Halaman utama </h3> Halaman utama modul ini menyenaraikan semua rantai dan peraturan dari salah satu jadual yang tersedia, yang dipilih dari senarai di kiri atas. Di bawah adalah bahagian untuk setiap rantai dalam jadual semasa, dengan semua peraturan dalam setiap rantaian disenaraikan dan syaratnya dijelaskan dengan sebaik mungkin dari kemampuan modul. Untuk setiap rantai, anda boleh mengubah tindakan lalai menggunakan senarai juntai bawah jika rantai tersebut adalah salah satu bawaan untuk jadual, atau menghapusnya dengan butang Padam rantai jika ditentukan oleh pengguna. <p> Anda boleh mengklik mana-mana peraturan dalam rantai untuk mengeditnya, klik pada anak panah di sebelah kanan setiap baris untuk menggerakkannya ke atas atau ke bawah, atau klik pada butang Tambah peraturan untuk menambahkan yang baru. Menambah atau mengedit aturan akan membawa Anda ke halaman di mana Anda dapat memilih tindakan untuk setiap aturan, dan syarat-syarat di mana tindakan tersebut dijalankan. <p> Di bahagian bawah halaman terdapat butang untuk membuat konfigurasi firewall aktif, dengan memuatkannya ke kernel dengan perintah <tt>pemulihan-ipi (6)</tt> . Di bawahnya adalah butang untuk melakukan sebaliknya - mengambil konfigurasi yang ada di kernel dan menyediakannya untuk diedit. Akhirnya, jika pengedaran anda menyokongnya, ada butang untuk menukar sama ada firewall diaktifkan pada waktu boot atau tidak. <p><h3> Rantai penapisan </h3> Untuk kerjasama yang lebih baik dengan skrip iptables luaran, anda boleh mengecualikan rantai individu dari pemprosesan oleh firewall. Untuk melakukan ini, anda mesti memilih pemprosesan peraturan langsung dalam tetapan dan memasukkan senarai penapis, yang mengecualikan rantai yang sesuai dari pemprosesan. Rantai yang tidak dikecualikan dari penyuntingan ditandai dengan pesan &quot;tidak dikendalikan oleh firewall&quot;. <p><h3> Set IP </h3> Jadual versi ip (6) yang lebih baru menyokong pelanjutan ipset. Set IP adalah senarai alamat IP di memori utama, yang dapat dicari dengan sangat efisien dan digunakan sebagai syarat dalam peraturan. Di halaman utama, set IP yang ada yang dapat digunakan oleh peraturan ditampilkan. Namun, saat ini, tidak mungkin untuk menguruskannya di firewall. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.nl.html ===

<header>Linux Firewall</header>

<h3>Module introductie</h3>

Met deze module kunt u de firewall IP-tafels configureren die aanwezig zijn
in de Linux kernels van de 2.4 serie. Anders dan met andere firewall configuratie
programma's zal deze firewall, in plaats van een shell script die de firewall instelt,
een opgeslagen file lezen en bewerken dmv het uitvoeren van <tt>ipi(6)tables-herstellen</tt>
en <tt>ipi(6)tables-opslaan</tt>. <p>

Indien u reeds een firewall handmatig of middels een script heeft opgezet zal de
module u vragen om dit te converteren naar een IPtables file en die opslaan.
Vervolgens zal er hiervoor een script gemaakt worden die zal worden uitgevoerd
tijdens het booten van uw systeem om de regels van de file te activeren in de
firewall.
Echter indien u heeft gekozen voor deze optie moet u niet meer uw eigen script
bewerken en deze direct verwijderen uit het boot gedeelte. <p>

<h3>IPtables overzicht</h3>

Ieder netwerk pakket dat binnenkomt, het netwerk verlaat of word doorgestuurd door
uw systeem zal gecontroleerd worden met 1 of meerdere ketens om te bepalen wat
ermee moet gebeuren.
Iedere keten bevat nullen of meerdere regels, waarbij aldoor de conditie word 
gecontroleerd (om te bepalen welk pakket overeenkomt) en welke actie ondernomen
moet worden (om te controleren wat er gebeurd met de overeenkomende pakketten).
Iedere keten kan ook een standaard actie uitvoeren die bepaald wat er met dit pakket
moet gebeuren als het niet overeenkomt met een regel. <p>

Iedere keten is een onderdeel van een tabel, waarvan er momenteel 3 zijn :
<ul>
<li><b>Pakket filteren (<tt>filter</tt>)</b><br>
    De ketens in deze tabel kunnen worden gebruikt om data te controleren wat
    uw systeem binnenkomt van andere hosts op het netwerk, dat wat word verstuurd
    vanaf uw systeem door gebruikers en processen en dat wat word doorgestuurd
    indien yw systeem werkt als een router. <p>
<li><b>Netwerk adres vertaling (<tt>nat</tt>)</b><br>
    Deze tabel kan worden opgezet voor NAT of masquerading, wat erg handig kan
    zijn indien u een heel netwerk met 1 IP adres toegang wilt verlenen tot het
    internet. <p>
<li><b>Pakket wijziging (<tt>mangle</tt>)</b><br>
    Deze keten word gebruikt om pakketten te modificeren die worden doorgestuurd
    of worden verzonden vanaf uw systeem. <p>
</ul>

Als toevoeging voor de standaard ketens die een onderdeel zijn van iedere tabel
kunt u ook uw eigen ketens maken die kunnen worden uitgevoerd door regels in
de ingebouwde ketens. Dit kan erg handig zijn indien u regels wilt groeperen
en delen die worden gebruikt op diverse plekken. <p>

<h3>De hoofd pagina</h3>

De hoofdpagina van deze module toont een lijst van alle ketens en regels van
1 van de beschikbare tafels die geselecteerd is van de lijst aan de linker
bovenkant. Daaronder bevind zich een sectie voor iedere keten in de huidige
tabel, met alle regels die in iedere keten zit en de conditie waarin die zich
bevinden.
Voor iedere keten kunt u de standaard actie wijzigen met gebruik van de 
drop-down lijst indien de keten behoort tot een ingebouwde keten van de tabel,
of u verwijdert deze met de "Verwijder keten" knop indien het gebruiker
gedefinieerd is. <p>

U kunt op iedere regel van een keten klikken om deze te bewerken, klik op de pijlen
naast iedere rij om de regel op of neer te verplaatsen of klik op de regel 
"Toevoegen" knop om een nieuwe toe te voegen. Als u kiest voor toevoegen of bewerken
word u verplaatst naar een pagina waar u een actie kunt selecteren voor iedere regel,
en de condities waarvoor de regel moet worden uitgevoerd. <p>

Aan de onderkant van de pagina bevind zich een knop waarmee u de huidige firewall
configuratie direct actief kunt maken, door deze in de kernel te laden met de 
<tt>ipi(6)tables-restore</tt> opdracht. Daaronder bevind zich een knop waarmee u het
omgekeerde kunt doen, dus de IP tabellen uit de kernel halen waarna u deze 
vervolgens kunt bewerken.

Tot slot, indien uw distributie dit ondersteund is er ook een knop waarmee u kunt
wijzigen of de firewall wel of niet tijdens het booten geactiveerd moet worden. <p>


<h3>Filtering chains</h3>

For better collaboration with external iptables scripts you can exclude individual
chains from the processing by the firewall. To do this, you must select direct
processing of rules in the settings and enter a filter list, which excludes
the appropriate chains from processing.
Chains that are not exculded from editing are flagged with a "not managed by firewall" message.
<p>

<h3>IP Sets</h3>

Newer versions of ip(6)table support the ipset extension.
IP sets are lists of IP addresses in the main memory, which can be searched very efficiently
and used as a condition in rules. On the main page, existing IP sets that can be used by 
rules are displayed. Currently, however, it is not possible to manage these in the firewall.
<p>

<hr>


=== ./background/webmin-plugins/firewall/help/intro.no.auto.html ===

<header> Linux-brannmuren </header><h3> Modul introduksjon </h3> Denne modulen lar deg konfigurere IPtables-brannmurfunksjonene som finnes i 2.4-serien med Linux-kjerner. I motsetning til noen andre brannmurkonfigurasjonsprogrammer, i stedet for å lage et skallskript som setter opp brannmuren, leser og redigerer den en lagringsfil i formatet som er lest og skrevet av <tt>henholdsvis ipi (6) tabeller-gjenoppretting</tt> og <tt>ipi (6) -tabeller</tt> . <p> Hvis du allerede har en brannmur på systemet ditt som er konfigurert manuelt eller fra en skriptfil, vil modulen tilby å konvertere den til en IPtables-lagringsfil for deg, og lage et skript som skal kjøres ved starttidspunkt for å aktivere reglene i filen. Imidlertid, hvis du gjør dette, bør du ikke lenger redigere skriptet for brannmurregler, og bør deaktivere at det også kjører på oppstart. <p><h3> Oversikt over IPtables </h3> Hver nettverkspakke som kommer inn, går ut fra eller videresendes av systemet ditt, sjekkes mot en eller flere kjeder for å finne ut hva som vil skje med den. Hver kjede inneholder null eller flere regler, som hver har en betingelse (for å bestemme hvilke pakker den matcher) og en handling (for å kontrollere hva som skjer med de matchende pakkene). Hver kjede har også en standardhandling som kontrollerer hva som skjer med pakker som ikke samsvarer med noen regel. <p> Hver kjede er en del av et bord, hvorav det for øyeblikket er tre: <ul><li> <b>Pakkefiltrering ( <tt>filter</tt> )</b> <br> Kjedene i denne tabellen kan brukes til å kontrollere data som kommer inn i systemet ditt fra andre verter i nettverket, data sendt ut fra systemet av brukere og prosesser, og data som er videresendt av systemet ditt hvis det fungerer som en ruter. <p><li> <b>Nettverksadresse oversettelse ( <tt>nat</tt> )</b> <br> Denne tabellen kan brukes til å sette opp NAT eller maskere, noe som er nyttig hvis du vil gi et helt nettverk av maskiner tilgang til internett gjennom bare en ekte IP-adresse. <p><li> <b>Pakkeendring ( <tt>mangle</tt> )</b> <br> Denne tabellen er for å endre pakker som er videresendt av eller sendt ut fra systemet ditt. <p></ul> I tillegg til standardkjedene som er en del av hvert bord, kan du også lage dine egne kjeder som kan drives etter regler i innebygde kjeder. Dette kan være nyttig for gruppering og delingsregler som kan brukes flere steder. <p><h3> Hovedsiden </h3> Hovedsiden for denne modulen viser alle kjeder og regler fra en av de tilgjengelige tabellene valgt fra listen øverst til venstre. Nedenfor er et avsnitt for hver kjede i den gjeldende tabellen, med alle regler i hver kjede oppført og deres forhold beskrevet etter beste evne til modulen. For hver kjede kan du endre standardhandlingen ved å bruke rullegardinlisten hvis kjeden er en av de innebygde for tabellen, eller slette den med Slett kjedeknapp hvis den er brukerdefinert. <p> Du kan klikke på hvilken som helst regel i en kjede for å redigere den, klikke på pilene til høyre for hver rad for å flytte den opp eller ned, eller klikke på Legg til regel-knappen for å legge til en ny. Når du legger til eller redigerer en regel, kommer du til en side der du kan velge handlingen for hver regel, og betingelsene som handlingen utføres for. <p> Nederst på siden er det en knapp for å gjøre gjeldende brannmurkonfigurasjon aktiv, ved å laste den inn i kjernen med <tt>ipi (6) tabeller-gjenoppretting</tt> . Under det er en knapp for å gjøre det motsatte - ta konfigurasjonen som er i kjernen og gjøre den tilgjengelig for redigering. Til slutt, hvis distribusjonen støtter den, er det en knapp for å endre om brannmuren er aktivert ved starttidspunktet eller ikke. <p><h3> Filtreringskjeder </h3> For bedre samarbeid med eksterne iptables-skript kan du ekskludere individuelle kjeder fra behandlingen av brannmuren. For å gjøre dette, må du velge direkte behandling av regler i innstillingene og gå inn i en filterliste, som utelukker de aktuelle kjedene fra å behandle. Kjeder som ikke blir ekskludert fra redigering, flagges med meldingen &quot;ikke administrert av brannmur&quot;. <p><h3> IP-sett </h3> Nyere versjoner av ip (6) -bordet støtter ipset-utvidelsen. IP-sett er lister over IP-adresser i hovedminnet, som kan søkes veldig effektivt og brukes som betingelse i regler. På hovedsiden vises eksisterende IP-sett som kan brukes av regler. For øyeblikket er det imidlertid ikke mulig å administrere disse i brannmuren. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.pl.html ===

<header>Firewall Linuksa</header>

<h3>Wprowadzenie do modułu</h3>

Ten moduł pozwala na konfigurację funkcji firewalla IPtables znajdujących
się w kernelach Linuksa 2.4. W odróżnieniu od innych programów konfiguracji
firewalla ten moduł nie tworzy skryptów shell, a zamiast tego odczytuje
i edytuje pliki w formacie umożliwiającym ich odczyt w <tt>ipi(6)tables-restore</tt>
i <tt>ipi(6)tables-save</tt>. <p>

Jeżeli masz już w systemie firewall skonfigurowany ręcznie lub przez plik
skryptu, to ten moduł przekonwertuje go do odpowiedniego formatu IPtables
i utworzy skrypt do uruchamiania reguł przy starcie. Po tej operacji nie
powinno się dłużej używać starych skryptów do edycji reguł, należy je
także wyłączyć z autostartu. <p>

<h3>Opis IPtables</h3>

Każdy pakiet sieciowy przesyłany do lub z twojego systemu jest sprawdzany z
przynajmniej jednym łańcuchem, który określa co powinno się z nim stać.
Każdy łańcuch zawiera zero lub więcej reguł, każdy z nich posiada warunek
(określa, które pakiety do niego pasują) i akcję (do kontroli co się stanie
z pasującym pakietem). Każdy łańcuch dodatkowo posiada akcję domyślną, która
określa co się stanie z pakietami, które nie pasują do żadnej reguły. <p>

Każdy łańcuch jest częścią tabeli, aktualnie dostępne są trzy :
<ul>
<li><b>Filtracja pakietu (<tt>filter</tt>)</b><br>
    Łańcuchy w tej tabeli mogą być wykorzystane do kontroli danych pochodzących
	do twojego systemu z innych hostów w sieci, danych wysyłanych ze twojego
	systemu przez użytkowników i procesy oraz dane przekazane przez twój system,
	jeśli działa jako router. <p>
<li><b>Translacja adresów sieciowych (<tt>nat</tt>)</b><br>
    Tabela ta może być używana do konfigurowania NAT lub maskowania, co jest
	przydatne, jeśli chcesz dać całej sieci komputerów dostęp do Internetu za
	pośrednictwem tylko jednego prawdziwego adresu IP. <p>
<li><b>Przeróbka pakietów (<tt>mangle</tt>)</b><br>
    Ta tabela dotyczy modyfikowania pakietów przekazywanych przez lub wysyłanych
	z systemu.<p>
</ul>

Oprócz standardowych łańcuchów, które są częścią każdej tabeli, można również
tworzyć własne łańcuchy, które mogą być uruchamiane przez reguły w łańcuchach
wbudowanych. Może to być przydatne do grupowania i udostępniania zasad, które
mogą być wykorzystane w wielu miejscach. <p>

<h3>Główna strona modułu</h3>

Strona główna tego modułu zawiera wszystkie łańcuchy i reguły z jednej z dostępnych
tabel, wybranej z listy w lewym górnym rogu. Poniżej znajduje się sekcja każdego
łańcucha w bieżącej tabeli, ze wszystkimi regułami w każdym wybranym łańcuchu i
ich opisane warunki. Dla każdego łańcucha, można zmienić domyślną akcję,
korzystając z listy rozwijanej, jeśli łańcuch jest jednym z tych, wbudowanych do
tabeli, lub usunąć go za pomocą przycisku Usuń, jeżeli łańcuch jest zdefiniowany
przez użytkownika. <p>

W celu edycji dowolnej reguły w łańcuchu, kliknij na nią. Kliknij na strzałki
po prawej stronie, aby przenieść w górę lub w dół lub kliknij na przycisk
Dodaj regułę, aby dodać nową. Dodawanie lub edytowanie reguł przekieruje cię
do strony, na której możesz wybrać akcję do każdej reguły i warunki, w celu
określenia kiedy ta akcja ma być wykonana. <p>

Na dole strony znajdują się przyciski umożliwiające aktywację aktualnej
konfiguracji firewalla przez załadowanie do kernela polecenia
<tt>ipi(6)tables-restore</tt>. Poniżej jest przycisk, który działa odwrotnie
tzn. pobiera aktywną konfigurację firewalla z kernela i umożliwia jej
edycję w tym module. Na końcu, jeżeli twoja dystrybucja obsługuje tę
funkcję znajduje się przycisk umożliwiający wybranie, czy firewall
ma być aktywowany w momencie uruchamiania systemu czy nie. <p>


<h3>Filtering chains</h3>

For better collaboration with external iptables scripts you can exclude individual
chains from the processing by the firewall. To do this, you must select direct
processing of rules in the settings and enter a filter list, which excludes
the appropriate chains from processing.
Chains that are not exculded from editing are flagged with a "not managed by firewall" message.
<p>

<h3>IP Sets</h3>

Newer versions of ip(6)table support the ipset extension.
IP sets are lists of IP addresses in the main memory, which can be searched very efficiently
and used as a condition in rules. On the main page, existing IP sets that can be used by 
rules are displayed. Currently, however, it is not possible to manage these in the firewall.
<p>

<hr>


=== ./background/webmin-plugins/firewall/help/intro.pt.auto.html ===

<header> Firewall do Linux </header><h3> Introdução ao módulo </h3> Este módulo permite configurar os recursos de firewall das tabelas de IP encontrados na série 2.4 dos kernels do Linux. Ao contrário de outros programas de configuração de firewall, em vez de criar um script de shell que configura o firewall, ele lê e edita um arquivo salvo no formato lido e gravado por <tt>ipi (6) tables-restore</tt> e <tt>ipi (6) tables-save,</tt> respectivamente. <p> Se você já possui um firewall em seu sistema que foi configurado manualmente ou a partir de um arquivo de script, o módulo oferecerá a conversão para um arquivo de salvamento de tabelas IP para você e criará um script para ser executado no momento da inicialização para ativar as regras em o arquivo. No entanto, se você fizer isso, não deverá mais editar o script de regras do firewall e também deve desativar a execução no momento da inicialização. <p><h3> Visão geral das tabelas de IP </h3> Todo pacote de rede que entra, sai ou é encaminhado pelo sistema é verificado em uma ou mais cadeias para determinar o que acontecerá com ele. Cada cadeia contém zero ou mais regras, cada uma com uma condição (para determinar quais pacotes corresponde) e uma ação (para controlar o que acontece com esses pacotes correspondentes). Cada cadeia também possui uma ação padrão que controla o que acontece com pacotes que não correspondem a nenhuma regra. <p> Cada cadeia faz parte de uma tabela, da qual existem atualmente três: <ul><li> <b>Filtragem de pacotes ( <tt>filtro</tt> )</b> <br> As cadeias nesta tabela podem ser usadas para controlar os dados que chegam ao seu sistema a partir de outros hosts da rede, os dados enviados pelo usuário pelos usuários e processos e os dados encaminhados pelo sistema se estiver atuando como roteador. <p><li> <b>Tradução de endereços de rede ( <tt>nat</tt> )</b> <br> Essa tabela pode ser usada para configurar o NAT ou o mascaramento, o que é útil se você deseja conceder acesso a uma rede inteira de máquinas à Internet através de apenas um endereço IP real. <p><li> <b>Alteração de pacote ( <tt>mangle</tt> )</b> <br> Esta tabela é para modificar pacotes encaminhados ou enviados pelo seu sistema. <p></ul> Além das cadeias padrão que fazem parte de cada tabela, você também pode criar suas próprias cadeias que podem ser executadas por regras nas cadeias integradas. Isso pode ser útil para agrupar e compartilhar regras que podem ser usadas em vários locais. <p><h3> A página principal </h3> A página principal deste módulo lista todas as cadeias e regras de uma das tabelas disponíveis, selecionadas na lista no canto superior esquerdo. Abaixo está uma seção para cada cadeia na tabela atual, com todas as regras em cada cadeia listadas e suas condições descritas da melhor maneira possível. Para cada cadeia, você pode alterar a ação padrão usando a lista suspensa se a cadeia for uma das incorporadas à tabela ou excluí-la com o botão Excluir cadeia se for definido pelo usuário. <p> Você pode clicar em qualquer regra de uma cadeia para editá-la, clicar nas setas à direita de cada linha para movê-la para cima ou para baixo ou clicar no botão Adicionar regra para adicionar uma nova. Adicionar ou editar uma regra o levará a uma página na qual você pode selecionar a ação para cada regra e as condições para as quais a ação é executada. <p> Na parte inferior da página, há um botão para ativar a configuração atual do firewall, carregando-a no kernel com o <tt>comando ipi (6) tables-restore</tt> . Abaixo, há um botão para fazer o inverso - pegando a configuração que está atualmente no kernel e disponibilizando-a para edição. Finalmente, se sua distribuição suportar, existe um botão para alterar se o firewall está ativado no momento da inicialização ou não. <p><h3> Cadeias de filtragem </h3> Para uma melhor colaboração com scripts externos do iptables, você pode excluir cadeias individuais do processamento pelo firewall. Para fazer isso, você deve selecionar o processamento direto de regras nas configurações e inserir uma lista de filtros, que exclui as cadeias apropriadas do processamento. As cadeias que não são excluídas da edição são sinalizadas com uma mensagem &quot;não gerenciado pelo firewall&quot;. <p><h3> Conjuntos de IP </h3> As versões mais recentes da tabela ip (6) suportam a extensão ipset. Conjuntos de IPs são listas de endereços IP na memória principal, que podem ser pesquisadas com muita eficiência e usadas como uma condição nas regras. Na página principal, os conjuntos de IP existentes que podem ser usados por regras são exibidos. Atualmente, no entanto, não é possível gerenciá-los no firewall. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.pt_BR.html ===

<header>Firewall Linux</header>

<h3>Introduo ao Mdulo</h3>

Este mdulo lhe permite configurar as caractersticas do firewall IPtables encontradas na srie 2.4 do kernel do Linux. Diferente de alguns outros programas para configurao de firewall, ao invs de criar um shell script para configurar o firewall, ele l e edita um arquivo salvo no formato de leitura e escrita do <tt>ipi(6)tables-restore</tt> e <tt>ipi(6)tables-save</tt> respectivamente. <p>

Se voc j possui um firewall em seu sistema que foi configurado manualmente ou a partir de um script, o mdulo  oferecer para convert-lo para um arquivo salvo no formato do IPtables, e criar um script que poder ser executado durante a inicializao para a ativao das regras contidas no arquivo. Entretanto, se voc fizer isso, voc no dever editar mais o script com as regras do firewall e dever desabilitar sua execuo durante a inicializao do sistema. <p>

<h3>Viso geral sobre IPtables</h3>

Todo pacote de rede que vem para dentro, sai ou  redirecionado pelo seu sistema  checado em cada chain para determinar o que acontecer com ele.
Cada chain contm zero ou mais regras, que possuem condies (para determinar quais pacotes coincidem com ela) e uma ao (para controlar o que acontece com os pacotes que coincidem com ela). Cada chain possui tambm uma ao padro que controla o que acontece com os pacotes que no coincidem com nenhuma regra. <p>

Cada chain  parte de uma tabela, que atualmente so trs:

<ul>
<li><b>Filtragem de Pacotes (<tt>filter</tt>)</b><br>
    As chains nesta tabela podem ser utilizadas para controlas os dados que entram em seu sistema a partir  
    de outros hosts na rede, dados enviados a partir do seu sistema por usurios e processos, e dados 
    redirecionados pelo seu sistema se sua ao  como um roteador. <p>
<li><b>Traduo de endereo de rede (<tt>nat</tt>)</b><br>
    Esta tabela pode ser utilizada para configurar NAT ou mascaramento, que so teis se voc quer dar acesso 
     internet a mquinas que esto na rede interna atravs de somente um IP real. <p>
<li><b>Alterao de Pacotes (<tt>mangle</tt>)</b><br>
    Esta chain  para modificar pacotes redirecionados ou enviados pelo seu sistema. <p>
</ul>

Em adio s chains padro que so parte de cada tabela, voc tambm pode criar suas prprias chains que podero ser executadas pela regras das chains padro. Isto pode ser til para agrupar e compartilhar regras que podero ser utilizadas em mltiplos lugares. <p>

<h3>A pgina principal</h3>

A pgina principal deste mdulo lista todas as chains e regras de uma das tabelas disponveis, selecionada a partir da lista no topo-esquerdo. Abaixo segue uma seo para cada chain da tabela atual, com todas a regras em cada chain listada e suas respectivas descries. Para cada chain, voc pode alterar a ao padro utilizando o combobox, se a chain  uma chain padro, ou apag-la com o boto Apagar Chain se ela foi definida pelo usurio. <p>

Voc pode clicar em qualquer regra em uma chain para edit-la, clicar nas setas da direita de cada linha para mov-la para cima ou para baixo, ou clicar no boto Adicionar Regra para adicionar uma nova regra.Adicionando ou editando uma regra, voc ser levado para uma pgina na qual voc poder selecionar a ao para cada regra, e as condies para as quais a ao ser executada. <p>

Na parte de baixo da pgina est um boto para tornar a configurao atual do firewall ativa, carregando-a atravs do comando <tt>ipi(6)tables-restore</tt>. A seguir est um boto para fazer o inverso - pegar a configurao que est corrente no kernel e torn-la disponvel para edio. Finalmente, se sua distribuio suportar, existe um boto para indicar se o firewall ser ativado durante o boot ou no. <p>


<h3>Filtering chains</h3>

For better collaboration with external iptables scripts you can exclude individual
chains from the processing by the firewall. To do this, you must select direct
processing of rules in the settings and enter a filter list, which excludes
the appropriate chains from processing.
Chains that are not exculded from editing are flagged with a "not managed by firewall" message.
<p>

<h3>IP Sets</h3>

Newer versions of ip(6)table support the ipset extension.
IP sets are lists of IP addresses in the main memory, which can be searched very efficiently
and used as a condition in rules. On the main page, existing IP sets that can be used by 
rules are displayed. Currently, however, it is not possible to manage these in the firewall.
<p>

<hr>


=== ./background/webmin-plugins/firewall/help/intro.ru.html ===

<header>Межсетевой экран Linux</header>

<h3>Введение</h3>

Этот модуль позволяет вам конфигурировать функции брандмауэра IPtables имеющиеся в ядре Linux 2.4.
В отличии от некоторых других программ конфигураторов, вместо того, чтобы создавать shell script для добавления правил брандмауэра, он считывает и редактирует файл сохраненный в формате, который считывается и записывается командами <tt>ipi(6)tables-restore</tt> и <tt>ipi(6)tables-save</tt> соответственно. <p>

Если в вашей системе уже есть брандмауэр настроенный вручную или при помощи скрипта, модуль предложит конвертировать ваши настройки в IPtables-save файл, и создаст скрипт активирующий правила из этого файла при запуске системы. 

Однако, если Вы сделаете это, вы больше не будете редактировать вручную свой скрипт добавляющий правила в брандмауэр, и должны будете отключить его автозагрузку при старте системы. <p>

<h3>Краткий обзор IPtables</h3>
Каждый входящий (Input), исходящий (Output) или перенаправляемый (Forward) сетевой пакет, проверяется одной или несколькими цепочками правил, для определения того, что с ним делать. Каждая цепочка может содержать несколько правил или может быть пустой. У каждого правила есть Условие (для указания того, какие пакеты будут обрабатываться этим правилом), и Действие (для указания того, что необходимо сделать с пакетом если он соответствует Условию). Если пакет не соответствует Условию, он перемещается дальше по цепочке к следующему правилу. Каждая цепочка правил имеет также "действие по-умолчанию", которое производится с пакетом достигшим конца цепочки.<p>

Каждая цепочка является частью таблицы.
Таблиц всего три:
<ul>
<li><b>Фильтрация пакетов (<tt>filter</tt>)</b><br>
Цепочки в этой таблице могут использоваться для управления информацией приходящей в вашу систему от других хостов в сети, отправляемой пользователями и процессами вашей системы, и перенаправляемой вашей системой, если она используется как маршрутизатор. <p>
<li><b>Преобразование сетевых адресов (<tt>nat</tt>)</b><br>
Эта таблица может быть использована для организации NAT или masquerading, которые понадобятся, если вы захотите предоставить пользователям внутренней сети доступ в интернет через один внешний IP-адрес. <p>
<li><b>Преобразование сетевых пакетов (<tt>mangle</tt>)</b><br>
Эта таблица используется для модификации пакетов отправляемых вашей системой, или перенаправляемых от других хостов в сети. <p>
</ul>

В дополнение к стандартным цепочкам, которые входят в каждую из таблиц, вы можете создать свои собственные Пользовательские цепочки. Их можно вкладываться в другие цепочки в пределах одной таблицы, и если пакет достигнет конца такой цепочки, пакет вернется в вызвавшую его цепочку и продолжит движение по ней.
Пользовательские цепочки можно использовать для группировки часто повторяющихся правил (чтобы не повторять их по несколько раз, а просто пересылать пакет в соответствующую цепочку) или распределения пакетов отвечающих различным условиям по разным цепочкам (например, можно сделать для пакетов принадлежащих разным протоколам отдельные цепочки: чтобы UDP-пакеты не проходили через правила для TCP-пакетов и т.п) .<p>

<h3>Главная страница</h3>

На главной странице этого модуля перечислены все цепочки и правила одной из
доступных таблиц Iptables. 
Выбрать таблицу для отображения можно при помощи выпадающего меню в левом верхнем углу экрана. 
На странице находятся разделы, в каждом из которых отображается одна из цепочек текущей таблицы, с перечислением всех правил.
В конце каждого раздела находятся кнопки, которые позволяют изменить <tt>Действие по-умолчанию</tt> для встроенных цепочек, и переименовать или удалить ранее созданные Пользовательские цепочки. Так же, там находятся кнопки для добавления, перемещения и удаления правил из цепочек.
Создать новую Пользовательскую цепочку, можно при помощи кнопок в правом верхнем углу экрана. <p>

Для каждого правила в списке цепочек, указано его Условие, Действие и Описание.
Щелчком на любом из правил можно его отредактировать. Стрелки справа позволят переместить правило по цепочке вверх или вниз, а так же, сразу создать новое правило в необходимом месте цепочки. 
При попытке добавить или отредактировать правило, откроется новая страница на которой вы сможете выбрать <tt>Действие</tt> для правила, а так же <tt>Условие</tt>, при котором это Действие должно выполняться. <p>

В самом низу главной страницы находятся несколько кнопок: <tt>Применить конфигурацию</tt> - активирует текущие настройки брандмауэра, загружая их в ядро командой <tt>ipi(6)tables-restore</tt>. <tt>Вернуть конфигурацию</tt> действует наоборот - загружает в окно для конфигурирования настройки, активные в данный момент в ядре. <tt>Включать при запуске</tt> позволяет настроить автозапуск брандмауэра (если поддерживается вашим дистрибутивом). <tt>Сбросить конфигурацию</tt> - очищает все цепочки и таблицы, чтобы начать настройку с нуля.<p>

<h3>Filtering chains</h3>

For better collaboration with external iptables scripts you can exclude individual
chains from the processing by the firewall. To do this, you must select direct
processing of rules in the settings and enter a filter list, which excludes
the appropriate chains from processing.
Chains that are not exculded from editing are flagged with a "not managed by firewall" message.
<p>

<h3>IP Sets</h3>

Newer versions of ip(6)table support the ipset extension.
IP sets are lists of IP addresses in the main memory, which can be searched very efficiently
and used as a condition in rules. On the main page, existing IP sets that can be used by 
rules are displayed. Currently, however, it is not possible to manage these in the firewall.
<p>

<hr>


=== ./background/webmin-plugins/firewall/help/intro.sk.html ===

<header>Firewall Linuxu</header>

<h3>Úvod k modulu</h3>

Tento modul umožňuje nakonfigurovať funkcie IP tabuliek firewallu, ktoré 
sa nachádzajú v Linuxových jadrach rady 2.4. Na rozdiel od niektorých iných 
programov na konfiguráciu firewallu namiesto vytvárania scriptu pre shell, 
ktorý nastaví firewall, tento modul prečíta a edituje pravidlá z uloženého 
súboru vo formáte, ktorý je načítavaný a zapisovaný programami
<tt>ipi(6)tables-restore</tt> a <tt>ipi(6)tables-save</tt>. <p>

Ak už máte vo Vašom systéme firewall, ktorý bol nastavený ručne alebo pomocou
scriptu, modul ponúka aj jeho konverziu na IP tabuľky uložené v súbore a vytvorí 
script, ktorý aktivuje pravidlá zo súboru pri zavádzaní systému. Avšak ak to urobíte 
a nebudete chcieť pravidlá firewallu na dlhší čas používať, môžete tiež aktiváciu 
pravidiel pri zavádzaní vypnúť. <p>

<h3>Prehľad IP tabuliek</h3>

Každý sieťový paket, ktorý prichádza dnu, odchádza von alebo je presmerovaný Vaším 
systémom, je skontrolovaný jedným alebo viacerými zreťazeniami, ktoré určia, čo sa 
s ním má stať. Každé zreťazenie obsahuje nula alebo viac pravidiel, z ktorých každé 
má podmienku (určujúcu, pre ktoré pakety bude platiť) a akciu (určujúcu, čo sa má stať 
s paketmi splňujúcimi podmienku). Každé zreťazenie má tiež predvolenú akciu, ktorá hovorí 
čo sa má stať s paketmi, ktoré nespĺňajú ani jednu z uvedených podmienok. <p>
	
Každé zreťazenie je súčasťou jednej z troch tabuliek:
<ul>
<li><b>Filtrovanie paketov (<tt>filter</tt>)</b><br>
    Zreťazenia v tejto tabuľke môžu byť použité na ovládanie dát prichádzajúcich do 
    systému z iných staníc siete, dát odoslaných z Vášho systému používateľmi a procesmi
    a dát presmerovaných vaším systémom, ak funguje ako router. <p>
<li><b>Preklad sieťovej adresy (<tt>nat</tt>)</b><br>
    Táto tabuľka môže byť použitá na nastavenie NAT alebo maškarády, čo je užitočné, ak chcete 
    z celej vašej siete pristupovať do internetu iba s jednou skutočnou IP adresou. <p>
<li><b>Zmena paketov (<tt>mangle</tt>)</b><br>
    Toto zreťazenie slúži na úpravu paketov presmerovaných alebo odoslaných Vašim systémom. <p>
</ul>

Ako dodatok ku štandardným zreťazeniam, ktoré sú súčasťou každej tabuľky, môžete tiež vytvoriť 
Vaše vlastné zreťazenie, ktoré môže byť spustené pravidlami zo zabudovaných zreťazení. To môže byť 
užitočné pri skupinových a zdielaných pravidlách, ktoré by bolo inak potrebné použiť na viacerých 
miestach. <p>

<h3>Hlavná stránka</h3>

Hlavná stránka tohto modulu zobrazuje všetky zreťazenia a pravidlá jednej 
z dostupných tabuliek, vybranej zo zoznamu vľavo hore. Nižšie sú časti pre 
každé zreťazenie v aktuálnej tabuľke so všetkými pravidlami a ich podmienkami, 
ktoré najlepšie opisujú schopnosti modulu. Pre každé zreťazenie, ktoré je 
zabudované v tabuľke, môžete definovať predvolenú akciu prostredníctvom 
rozbaľovacieho poľa. Vlastnoručne zadefinované zreťazenia môžete odstrániť 
pomocou tlačidla Odstrániť zreťazenie. <p>

Môžete kliknúť na ľubovoľné pravidlo v zreťazení a upraviť ho, kliknúť na šipku 
vpravo a presunúť ho vyššie alebo nižšie alebo kliknúť na tlačítko pridať a 
zadefinovať nové pravidlo. Pridávanie alebo úprava pravidla Vás presunie na stránku, 
na ktorej môžete vybrať pre pravidlo akciu a podmienku, pri ktorej sa má akcia vykonať. <p>

V spodnej časti stránky je tlačidlo na aktivovanie aktuálnej konfigurácie, ktoré ju nahrá 
do jadra pomocou <tt>ipi(6)tables-restore</tt>. Pod ním je tlačidlo na vykonanie obnovy -
vezme konfiguráciu, ktorá je nahraná v jadre a umožní ju upravovať. Ak to vaša distribúcia 
podporuje, je tu ešte tlačidlo, ktoré nastaví, či sa má firewall aktivovať pri zavádzaní 
systému alebo nie. <p>


<h3>Filtering chains</h3>

For better collaboration with external iptables scripts you can exclude individual
chains from the processing by the firewall. To do this, you must select direct
processing of rules in the settings and enter a filter list, which excludes
the appropriate chains from processing.
Chains that are not exculded from editing are flagged with a "not managed by firewall" message.
<p>

<h3>IP Sets</h3>

Newer versions of ip(6)table support the ipset extension.
IP sets are lists of IP addresses in the main memory, which can be searched very efficiently
and used as a condition in rules. On the main page, existing IP sets that can be used by 
rules are displayed. Currently, however, it is not possible to manage these in the firewall.
<p>

<hr>


=== ./background/webmin-plugins/firewall/help/intro.sv.auto.html ===

<header> Linux-brandväggen </header><h3> Modulintroduktion </h3> Den här modulen låter dig konfigurera IPtables-brandväggsfunktioner som finns i 2.4-serien med Linux-kärnor. Till skillnad från vissa andra brandväggskonfigurationsprogram, istället för att skapa ett skalskript som sätter upp brandväggen, läser och redigerar en sparfil i formatet läst och skrivet av <tt>ipi (6) tabeller-återställning</tt> respektive <tt>ipi (6) -tabeller-spara</tt> . <p> Om du redan har en brandvägg på ditt system som har konfigurerats manuellt eller från en skriptfil, kommer modulen att erbjuda att konvertera den till en IPtables-sparfil för dig och skapa ett skript som ska köras vid starttid för att aktivera reglerna i filen. Men om du gör detta, bör du inte längre redigera ditt brandväggsregleringsskript och bör inaktivera att det också körs vid starttid. <p><h3> Översikt över IPtables </h3> Varje nätverkspaket som kommer in, går ut från eller vidarebefordras av ditt system kontrolleras mot en eller flera kedjor för att avgöra vad som kommer att hända med det. Varje kedja innehåller noll eller fler regler, var och en har ett villkor (för att bestämma vilka paket det matchar) och en åtgärd (för att kontrollera vad som händer med de matchande paketen). Varje kedja har också en standardåtgärd som styr vad som händer med paket som inte matchar någon regel. <p> Varje kedja är en del av ett bord, av vilka det för närvarande finns tre: <ul><li> <b>Paketfiltrering ( <tt>filter</tt> )</b> <br> Kedjorna i denna tabell kan användas för att kontrollera data som kommer in i ditt system från andra värdar i nätverket, data som skickas ut från ditt system av användare och processer och data som vidarebefordras av ditt system om det fungerar som en router. <p><li> <b>Nätverksadressöversättning ( <tt>nat</tt> )</b> <br> Denna tabell kan användas för att ställa in NAT eller maskera, vilket är användbart om du vill ge ett helt nätverk av maskiner åtkomst till internet via bara en riktig IP-adress. <p><li> <b>Paketändring ( <tt>mangle</tt> )</b> <br> Denna tabell är avsedd för att ändra paket som vidarebefordras av eller skickas ut från ditt system. <p></ul> Förutom standardkedjorna som ingår i varje tabell kan du också skapa dina egna kedjor som kan köras enligt regler i de inbyggda kedjorna. Detta kan vara användbart för gruppering och delningsregler som kan användas på flera platser. <p><h3> Huvudsidan </h3> Huvudsidan för den här modulen visar alla kedjor och regler från en av de tillgängliga tabellerna, valda från listan uppe till vänster. Nedan följer ett avsnitt för varje kedja i den aktuella tabellen, med alla regler i varje kedja listade och deras villkor beskrivna efter bästa möjliga modul. För varje kedja kan du ändra standardåtgärden med hjälp av listrutan om kedjan är en av de inbyggda för tabellen, eller ta bort den med knappen Radera kedja om den är användardefinierad. <p> Du kan klicka på valfri regel i en kedja för att redigera den, klicka på pilarna till höger om varje rad för att flytta den upp eller ner, eller klicka på knappen Lägg till regel för att lägga till en ny. Om du lägger till eller redigerar en regel kommer du till en sida där du kan välja åtgärd för varje regel och villkoren för vilken åtgärden utförs. <p> Längst ner på sidan finns en knapp för att aktivera den aktuella brandväggskonfigurationen genom att ladda den i kärnan med <tt>ipi (6) -tabellåterställningskommandot</tt> . Nedanför är det en knapp för att göra omvänd - ta den konfiguration som för närvarande finns i kärnan och göra den tillgänglig för redigering. Slutligen, om din distribution stöder det, finns det en knapp för att ändra om brandväggen är aktiverad vid starttid eller inte. <p><h3> Filtreringskedjor </h3> För bättre samarbete med externa iptables-skript kan du utesluta enskilda kedjor från behandlingen med brandväggen. För att göra detta måste du välja direkt bearbetning av regler i inställningarna och ange en filterlista, som utesluter lämpliga kedjor från bearbetning. Kedjor som inte exkluderas från redigering flaggas med meddelandet &quot;inte hanteras av brandvägg&quot;. <p><h3> IP-uppsättningar </h3> Nyare versioner av ip (6) -tabellen stöder ipset-förlängningen. IP-uppsättningar är listor över IP-adresser i huvudminnet, som kan sökas mycket effektivt och användas som villkor i regler. På startsidan visas befintliga IP-uppsättningar som kan användas av regler. För närvarande är det emellertid inte möjligt att hantera dessa i brandväggen. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.tr.auto.html ===

<header> Linux Güvenlik Duvarı </header><h3> Modül tanıtımı </h3> Bu modül, 2.4 seri Linux çekirdeğinde bulunan IPtables güvenlik duvarı özelliklerini yapılandırmanıza olanak tanır. Diğer bazı güvenlik duvarı yapılandırma programlarının aksine, güvenlik duvarını oluşturan bir kabuk komut dosyası oluşturmak yerine, sırasıyla bir kaydetme dosyasını <tt>ipi (6) tables-restore</tt> ve <tt>ipi (6) tables-save</tt> tarafından okunup yazılan biçimde okur ve düzenler. <p> Sisteminizde el ile veya bir komut dosyasından ayarlanmış bir güvenlik duvarınız varsa, modül sizin için bir IPtables kayıt dosyasına dönüştürmeyi ve içindeki kuralları etkinleştirmek için önyükleme sırasında çalıştırılacak bir komut dosyası oluşturmayı önerir. dosya. Ancak bunu yaparsanız, güvenlik duvarı kuralları komut dosyanızı artık düzenlememeniz ve önyükleme sırasında da çalışmasını devre dışı bırakmanız gerekir. <p><h3> IPtables&#39;a genel bakış </h3> Sisteminize gelen, çıkan veya sisteminiz tarafından iletilen her ağ paketi, ona ne olacağını belirlemek için bir veya daha fazla zincirle kontrol edilir. Her zincir, her biri bir koşula (hangi paketlerle eşleştiğini belirlemek için) ve bir eyleme (eşleşen paketlere ne olacağını kontrol etmek için) olan sıfır veya daha fazla kural içerir. Her zincirin, herhangi bir kurala uymayan paketlere ne olacağını kontrol eden varsayılan bir eylemi de vardır. <p> Her zincir, şu anda üç tane olan bir tablonun parçasıdır: <ul><li> <b>Paket filtreleme ( <tt>filtre</tt> )</b> <br> Bu tablodaki zincirler, ağdaki diğer ana bilgisayarlardan sisteminize gelen verileri, kullanıcılar ve işlemler tarafından sisteminizden gönderilen verileri ve bir yönlendirici olarak çalışıyorsa sisteminiz tarafından iletilen verileri kontrol etmek için kullanılabilir. <p><li> <b>Ağ adresi çevirisi ( <tt>nat</tt> )</b> <br> Bu tablo, NAT veya maskelenme ayarlamak için kullanılabilir; bu, tüm makine ağına tek bir gerçek IP adresi üzerinden internete erişim vermek istiyorsanız kullanışlıdır. <p><li> <b>Paket değişikliği ( <tt>mangle</tt> )</b> <br> Bu tablo, sisteminiz tarafından iletilen veya sisteminizden gönderilen paketleri değiştirmek içindir. <p></ul> Her tablonun bir parçası olan standart zincirlere ek olarak, yerleşik zincirlerdeki kurallar tarafından çalıştırılabilen kendi zincirlerinizi de oluşturabilirsiniz. Bu, birden fazla yerde kullanılabilecek kuralları gruplandırmak ve paylaşmak için yararlı olabilir. <p><h3> Ana sayfa </h3> Bu modülün ana sayfası, sol üstteki listeden seçilen mevcut tablolardan birindeki tüm zincirleri ve kuralları listeler. Aşağıda, geçerli tablodaki her zincir için, her zincirdeki tüm kuralların listelendiği ve koşullarının modülün en iyi şekilde açıklandığı bir bölüm bulunmaktadır. Her zincir için, zincir tablo için yerleşik olanlardan biriyse açılır listeyi kullanarak varsayılan eylemi değiştirebilir veya kullanıcı tanımlıysa Zinciri sil düğmesiyle silebilirsiniz. <p> Bir zincirdeki herhangi bir kuralı düzenlemek için tıklayabilir, yukarı veya aşağı taşımak için her satırın sağındaki okları veya yeni bir kural eklemek için Kural ekle düğmesini tıklayabilirsiniz. Bir kural eklemek veya düzenlemek sizi, her kural için eylemi ve eylemin yürütülme koşullarını seçebileceğiniz bir sayfaya götürür. <p> Sayfanın altında, <tt>ipi (6) tables-restore</tt> komutuyla çekirdeğe yükleyerek geçerli güvenlik duvarı yapılandırmasını etkin hale getirmek için bir düğme bulunur. Aşağıda bunun tersini yapmak için bir düğme var - şu anda çekirdekte olan yapılandırmayı almak ve düzenleme için kullanılabilir hale getirmek. Son olarak, dağıtımınız destekliyorsa, güvenlik duvarının önyükleme zamanında etkinleştirilip etkinleştirilmeyeceğini değiştirmek için bir düğme vardır. <p><h3> Filtre zincirleri </h3> Harici iptables komut dosyalarıyla daha iyi işbirliği için tek tek zincirleri güvenlik duvarının işlemesinden hariç tutabilirsiniz. Bunu yapmak için, ayarlarda kuralların doğrudan işlenmesini seçmeli ve uygun zincirlerin işlenmesini engelleyen bir filtre listesi girmelisiniz. Düzenlemenin dışında bırakılmayan zincirler, &quot;güvenlik duvarı tarafından yönetilmez&quot; mesajı ile işaretlenir. <p><h3> IP Setleri </h3> İp (6) tablosunun daha yeni sürümleri ipset uzantısını destekler. IP setleri, ana bellekteki IP adreslerinin listeleridir; bunlar çok verimli bir şekilde aranabilir ve kurallarda bir koşul olarak kullanılabilir. Ana sayfada, kurallar tarafından kullanılabilen mevcut IP setleri görüntülenir. Ancak şu anda bunları güvenlik duvarında yönetmek mümkün değildir. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.uk.auto.html ===

<header> Брандмауер Linux </header><h3> Введення модуля </h3> Цей модуль дозволяє налаштувати функції брандмауера IPtables, знайдені в ядрах Linux серії 2.4. На відміну від деяких інших програм конфігурації брандмауера, замість створення сценарію оболонки, який встановлює брандмауер, він зчитує та редагує файл збереження у форматі, прочитаному та записаному <tt>таблицями ipi (6) - відновлення</tt> та <tt>ipi (6) - збереження</tt> відповідно. <p> Якщо у вас вже є брандмауер у вашій системі, який був налаштований вручну або з файлу сценарію, модуль запропонує перетворити його у файл збереження для IPtables для вас, а також створить сценарій для запуску під час завантаження, щоб активувати правила в файл. Однак, якщо ви це зробите, тоді вам більше не слід редагувати сценарій правил брандмауера, а також забороняти його працювати також під час завантаження. <p><h3> Огляд IPtables </h3> Кожен мережевий пакет, який потрапляє, виходить або передається вашою системою, перевіряється на одній або декількох ланцюжках, щоб визначити, що з ним станеться. Кожен ланцюг містить нуль або більше правил, у кожному з яких є умова (визначати, яким пакетам він відповідає) та дія (керувати тим, що відбувається з цими відповідними пакетами). Кожен ланцюг також має дію за замовчуванням, яка контролює, що відбувається з пакетами, які не відповідають жодному правилу. <p> Кожен ланцюжок є частиною таблиці, на даний момент їх три: <ul><li> <b>Фільтрація пакетів ( <tt>фільтр</tt> )</b> <br> Ланцюги в цій таблиці можуть використовуватися для управління даними, що надходять у вашу систему від інших хостів у мережі, даними, що надсилаються з вашої системи користувачами та процесами, і даними, переданими вашою системою, якщо вона виступає в ролі маршрутизатора. <p><li> <b>Переклад мережевих адрес ( <tt>nat</tt> )</b> <br> Ця таблиця може бути використана для налаштування NAT або маскування, що корисно, якщо ви хочете надати всій мережі машин доступ до Інтернету за допомогою лише однієї реальної IP-адреси. <p><li> <b>Зміна пакету ( <tt>mangle</tt> )</b> <br> Ця таблиця призначена для зміни пакетів, пересланих або відправлених з вашої системи. <p></ul> Окрім стандартних ланцюгів, що входять до кожної таблиці, ви також можете створити власні ланцюги, які можна керувати правилами в ланцюгах вбудовування. Це може бути корисно для групування та обміну правилами, які можуть бути використані в декількох місцях. <p><h3> Головна сторінка </h3> На головній сторінці цього модуля перераховані всі ланцюги та правила з однієї з доступних таблиць, вибраних зі списку у верхньому лівому куті. Нижче наведено розділ для кожного ланцюга в поточній таблиці, з усіма переліченими правилами в кожній ланцюжку та їх умовами, описаними якнайкраще для можливостей модуля. Для кожної ланцюжка ви можете змінити дію за замовчуванням, використовуючи розкривний список, якщо ланцюжок є одним із вбудованих для таблиці, або видалити її за допомогою кнопки Видалити ланцюжок, якщо вона визначена користувачем. <p> Ви можете натиснути на будь-яке правило ланцюга, щоб змінити його, натисніть стрілки праворуч кожного ряду, щоб перемістити його вгору або вниз, або натисніть кнопку Додати правило, щоб додати нове. Якщо додати або відредагувати правило, ви перейдете на сторінку, на якій ви можете вибрати дію для кожного правила, та умови, за якими виконується дія. <p> Внизу сторінки розміщена кнопка для <tt>активізації</tt> поточної конфігурації брандмауера, завантаження її в ядро за допомогою команди <tt>ipi (6) таблиці-відновлення</tt> . Внизу знаходиться кнопка для здійснення зворотного - прийняття конфігурації, яка зараз знаходиться в ядрі, і надання її для редагування. Нарешті, якщо ваш дистрибутив підтримує це, є кнопка, щоб змінити, чи брандмауер активований під час завантаження чи ні. <p><h3> Фільтруючі ланцюги </h3> Для кращої співпраці із зовнішніми сценаріями iptables ви можете виключити окремі ланцюги з обробки брандмауером. Для цього потрібно вибрати пряму обробку правил у налаштуваннях та ввести список фільтрів, що виключає відповідні ланцюги з обробки. Ланцюги, які не видаляються з редагування, позначаються повідомленням &quot;не управляється брандмауером&quot;. <p><h3> Набори IP </h3> Новіші версії таблиці ip (6) підтримують розширення ipset. Набори IP - це списки IP-адрес у основній пам&#39;яті, які можна шукати дуже ефективно та використовувати як умову в правилах. На головній сторінці відображаються існуючі набори IP, які можна використовувати правилами. Однак на даний момент керувати ними в брандмауері неможливо. <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.zh.auto.html ===

<header> Linux防火墙</header><h3>模块介绍</h3>该模块允许您配置2.4系列Linux内核中的IPtables防火墙功能。与其他一些防火墙配置程序不同，它没有创建用于设置防火墙的外壳脚本，而是分别以<tt>ipi（6）tables-restore</tt>和<tt>ipi（6）tables-save</tt>读取和写入的格式读取和编辑保存文件。 <p>如果您的系统上已经有手动设置或通过脚本文件设置的防火墙，则该模块将为您提供将其转换为IPtables保存文件的功能，并创建一个在引导时运行的脚本以激活规则。文件。但是，如果执行此操作，则不应再编辑防火墙规则脚本，也应在启动时将其禁用。 <p><h3> IPtables概述</h3>系统会根据一个或多个链来检查系统进入，传出或转发的每个网络数据包，以确定将发生什么情况。每个链包含零个或多个规则，每个规则都有一个条件（确定它匹配的数据包）和一个动作（控制那些匹配的数据包发生什么）。每个链还具有一个默认操作，该操作控制不匹配任何规则的数据包所发生的情况。 <p>每个链都是表的一部分，当前有三个： <ul><li> <b>包过滤（ <tt>filter</tt> ）</b> <br>该表中的链可用于控制从网络上其他主机进入系统的数据，用户和进程从系统发送的数据以及系统充当路由器时由系统转发的数据。 <p><li> <b>网络地址转换（ <tt>nat</tt> ）</b> <br>该表可用于设置NAT或伪装，如果您想让整个计算机网络仅通过一个真实IP地址访问互联网，这将很有用。 <p><li> <b>封包变更（ <tt>mangle</tt> ）</b> <br>该表用于修改系统转发或发送的数据包。 <p></ul>除了每个表中的标准链之外，您还可以创建自己的链，这些链可以由内置链中的规则运行。这对于可能在多个地方使用的分组和共享规则很有用。 <p><h3>主页面</h3>该模块的主页列出了可用表之一的所有链和规则，这些表是从左上角的列表中选择的。以下是当前表中每个链的部分，列出了每个链中的所有规则，并根据模块的最佳功能描述了它们的条件。对于每个链，如果链是表的内置表之一，则可以使用下拉列表更改默认操作；如果是用户定义的，则可以使用“删除链”按钮将其删除。 <p>您可以单击链中的任何规则进行编辑，单击每行右侧的箭头将其向上或向下移动，或单击“添加规则”按钮以添加一个新规则。添加或编辑规则将带您进入一个页面，您可以在该页面上选择每个规则的操作以及执行操作的条件。 <p>页面底部是一个按钮，用于通过使用<tt>ipi（6）tables-restore</tt>命令将其加载到内核中来激活当前防火墙配置。在它的下方是一个用于执行相反操作的按钮-获取内核中当前的配置并使其可用于编辑。最后，如果您的发行版支持它，则有一个按钮可以更改在启动时是否激活防火墙。 <p><h3>过滤链</h3>为了与外部iptables脚本更好地协作，您可以从防火墙的处理中排除单个链。为此，您必须在设置中选择直接处理规则，然后输入一个过滤器列表，该列表将从适当的链中排除。不会从编辑中排除的链条会标有“不受防火墙管理”消息。 <p><h3> IP集</h3>较新版本的ip（6）table支持ipset扩展。 IP集是主内存中IP地址的列表，可以非常有效地搜索它们并将其用作规则中的条件。在主页上，显示规则可以使用的现有IP集。但是，目前尚无法在防火墙中进行管理。 <p><hr>
=== ./background/webmin-plugins/firewall/help/intro.zh_TW.auto.html ===

<header> Linux防火牆</header><h3>模塊介紹</h3>該模塊允許您配置2.4系列Linux內核中的IPtables防火牆功能。與其他一些防火牆配置程序不同，它沒有創建用於設置防火牆的外殼腳本，而是分別以<tt>ipi（6）tables-restore</tt>和<tt>ipi（6）tables-save</tt>讀取和寫入的格式讀取和編輯保存文件。 <p>如果您的系統上已經有手動設置或通過腳本文件設置的防火牆，則該模塊將為您提供將其轉換為IPtables保存文件的功能，並創建一個在引導時運行的腳本以激活規則。文件。但是，如果執行此操作，則不應再編輯防火牆規則腳本，也應在啟動時將其禁用。 <p><h3> IPtables概述</h3>系統會根據一個或多個鏈來檢查系統進入，傳出或轉發的每個網絡數據包，以確定將發生什麼情況。每個鏈包含零個或多個規則，每個規則都有一個條件（確定它匹配的數據包）和一個動作（控制那些匹配的數據包發生什麼）。每個鏈還具有一個默認操作，該操作控制不匹配任何規則的數據包所發生的情況。 <p>每個鏈都是表的一部分，當前有三個： <ul><li> <b>包過濾（ <tt>filter</tt> ）</b> <br>該表中的鏈可用於控制從網絡上其他主機進入系統的數據，用戶和進程從系統發送的數據以及系統充當路由器時由系統轉發的數據。 <p><li> <b>網絡地址轉換（ <tt>nat</tt> ）</b> <br>該表可用於設置NAT或偽裝，如果您想讓整個計算機網絡僅通過一個真實IP地址訪問互聯網，這將很有用。 <p><li> <b>封包變更（ <tt>mangle</tt> ）</b> <br>該表用於修改系統轉發或發送的數據包。 <p></ul>除了每個表中的標準鏈之外，您還可以創建自己的鏈，這些鏈可以由內置鏈中的規則運行。這對於可能在多個地方使用的分組和共享規則很有用。 <p><h3>主頁面</h3>該模塊的主頁列出了可用表之一的所有鍊和規則，這些表是從左上角的列表中選擇的。以下是當前表中每個鏈的部分，列出了每個鏈中的所有規則，並根據模塊的最佳功能描述了它們的條件。對於每個鏈，如果鍊是表的內置表之一，則可以使用下拉列表更改默認操作；如果是用戶定義的，則可以使用“刪除鏈”按鈕將其刪除。 <p>您可以單擊鏈中的任何規則進行編輯，單擊每行右側的箭頭將其向上或向下移動，或單擊“添加規則”按鈕以添加一個新規則。添加或編輯規則將帶您進入一個頁面，您可以在該頁面上選擇每個規則的操作以及執行操作的條件。 <p>頁面底部是一個按鈕，用於通過使用<tt>ipi（6）tables-restore</tt>命令將其加載到內核中來激活當前防火牆配置。在它的下方是一個用於執行相反操作的按鈕-獲取內核中當前的配置並使其可用於編輯。最後，如果您的發行版支持它，則有一個按鈕可以更改在啟動時是否激活防火牆。 <p><h3>過濾鏈</h3>為了與外部iptables腳本更好地協作，您可以從防火牆的處理中排除單個鏈。為此，您必須在設置中選擇直接處理規則，然後輸入一個過濾器列表，該列表將從適當的鏈中排除。不會從編輯中排除的鏈條會標有“不受防火牆管理”消息。 <p><h3> IP集</h3>較新版本的ip（6）table支持ipset擴展。 IP集是主內存中IP地址的列表，可以非常有效地搜索它們並將其用作規則中的條件。在主頁上，顯示規則可以使用的現有IP集。但是，目前尚無法在防火牆中進行管理。 <p><hr>
=== ./background/webmin-plugins/firewalld/CHANGELOG ===

---- Changes since 1.750 ----
First version of this module, for configuring allowed ports and services in FirewallD.
---- Changes since 1.840 ----
Added support for creating and editing port forwards.

=== ./claude_project_files/all_code.txt ===

# PROJECT CODE CONSOLIDATION
# Generated on: Wed Jul  9 21:34:37 CEST 2025
# Project: webmin-rich-rules
# Claude Projects Integration


=== ./background/nftables-gui/build.sh ===

#!/bin/bash

# Configuración de Matplotlib
export MPLCONFIGDIR=/tmp/matplotlib
sudo mkdir -p $MPLCONFIGDIR
sudo chown www-data:www-data $MPLCONFIGDIR
sudo chmod 777 $MPLCONFIGDIR
sudo pip install -r requirements.txt
# Instalación de dependencias
sudo apt-get install libfreetype6-dev 
sudo apt-get install libxft-dev apache2

sleep 5
# Copiar la aplicación
sudo cp -r nftables-frontend /usr/share

# Instalación y configuración de Apache con WSGI
sudo apt-get install -y libapache2-mod-wsgi-py3
sleep 5
sudo a2enmod wsgi

# Configuración del sitio de Apache
sudo cp nftables-frontend/nftables-config.conf /etc/apache2/sites-available/nftables-config.conf
sudo a2ensite nftables-config.conf
sudo a2dissite 000-default.conf

# Ajuste de permisos
sudo touch /usr/share/nftables-frontend/instance/nftables.db
sudo chmod 664 /usr/share/nftables-frontend/instance/nftables.db
sudo chown www-data:www-data /usr/share/nftables-frontend/instance/nftables.db
sudo chown -R www-data:www-data /usr/share/nftables-frontend
sudo chmod -R 775 /usr/share/nftables-frontend
sudo chmod -R 775 /usr/share/nftables-frontend/instance
sudo chmod -R 775 /usr/share/nftables-frontend/static
sudo chown -R www-data:www-data /usr/share/nftables-frontend/static
FICHERO="/etc/apache2/sites-available/000-default.conf"

if [ -f "$FICHERO" ]; then
    rm "$FICHERO"
    echo "El fichero $FICHERO ha sido eliminado."
else
    echo "El fichero $FICHERO no existe."
fi
FICHERO="/etc/apache2/sites-enabled/000-default.conf"

if [ -f "$FICHERO" ]; then
    rm "$FICHERO"
    echo "El fichero $FICHERO ha sido eliminado."
else
    echo "El fichero $FICHERO no existe."
fi

ARCHIVO="/etc/apache2/ports.conf"

# Línea a añadir
LINEA="Listen 8080"

# Comprobar si la línea ya existe en el archivo
if ! grep -qF "$LINEA" "$ARCHIVO"; then
    # Añadir la línea al final del archivo
    echo "$LINEA" | sudo tee -a "$ARCHIVO" > /dev/null
    echo "Línea añadida: $LINEA"
else
    echo "La línea ya existe en el archivo: $LINEA"
fi

# Reiniciar Apache
sudo systemctl restart apache2

# Iniciar el parser de nftables
cd nftables-parser
sudo hug -f main.py 

=== ./background/nftables-gui/nftables-frontend/api.py ===

import os
import requests
import service

def create_table_request(name , family):
    json_data = {"json_data": {"nftables": [{"add": {"table":{"name": name, "family": family}}}]}}
    response = requests.post('http://localhost:8000/tables/create_table', json=json_data)
    if(response.json()["status"] == "success"):
        return "Success"
    else:
        return "Error creating table."
    
def list_tables_request():
    response = requests.get('http://localhost:8000/tables/list_tables')
    return format_nftables_config(response.json()["tables"])

def list_ruleset_request():
    response = requests.get('http://localhost:8000/tables/list_ruleset')
    return format_nftables_config(response.json()["ruleset"])

def delete_table_request(name, family):
    json_data = {"json_data": {"nftables": [{"delete": {"table":{"name": name, "family": family}}}]}}
    response = requests.post('http://localhost:8000/tables/delete_table', json=json_data)
    if(response.json()["status"] == "success"):
        return "Success", response.json()
    else:
        return "Error deleting table."
    
def list_table_request(name, family):
    json_data = {"json_data": {"nftables": [{"list": {"table":{"name": name, "family": family}}}]}}
    response = requests.get('http://localhost:8000/tables/list_table', json=json_data)
    return parse_chains(response.json()["result"][1]["nftables"])

def format_nftables_config(config_string):
    # Replace escape sequences with actual characters
    formatted_string = config_string.replace('\\n', '\n').replace('\\t', '\t')

    # Split the string into lines
    lines = formatted_string.split('\n')

    # Remove empty lines
    lines = [line for line in lines if line.strip() != '']

    # Join the lines back together with newline characters
    formatted_string = '\n'.join(lines)
    return formatted_string

def flush_table_request(name, family):
    json_data = {"json_data": {"nftables": [{"flush": {"table":{"name": name, "family": family}}}]}}
    response = requests.get('http://localhost:8000/tables/flush_table', json=json_data)
    if(response.json()["status"] == "success"):
        return "Success"
    else:
        return "Error flushing table."

def parse_chains(response):
    chains = []
    for item in response:
        if isinstance(item, dict) and 'chain' in item:
            chains.append(item['chain'])
    return chains

def list_chains_request():
    json_data = {"json_data": {"nftables": [{"list": {"chains": {}}}]}}
    response = requests.get('http://localhost:8000/chains/list_chains', json=json_data)
    return (response.json())

def create_chain_request(name, family, table, policy):
    json_data = {"json_data": {"nftables": [{"add": {"chain":{"name": name, "family": family, "table": table, "policy": policy}}}]}}
    response = requests.post('http://localhost:8000/chains/create_chain', json=json_data)
    if(response.json()["status"] == "success"):
        return "Success"
    else:
        return "Error creating chain."
    
def create_base_chain_request(name, family, table, type, priority, policy, hook_type):
    json_data = {"json_data": {"nftables": [{"add": {"base_chain":{"name": name, "family": family, "table": table, "type": type, "priority": priority, "policy": policy, "hook_type": hook_type}}}]}}
    response = requests.post('http://localhost:8000/chains/create_base_chain', json=json_data)
    if(response.json()["status"] == "success"):
        return "Success"
    else:
        return "Error creating base chain."
    
def list_chain_request(chain_name, chain_family, chain_table):
    json_data = {"json_data": {"nftables": [{"list": {"chain":{"name": chain_name, "family": chain_family, "table": chain_table}}}]}}
    response = requests.get('http://localhost:8000/chains/list_rule_chain', json=json_data)
    return response.json()
        
    
def delete_chain_request(name, family, table):
    json_data = {"json_data": {"nftables": [{"delete": {"chain":{"name": name, "family": family, "table": table}}}]}}
    response = requests.post('http://localhost:8000/chains/delete_chain', json=json_data)
    if(response.json()["status"] == "success"):
        return "Success"
    else:
        return "Error deleting chain."
    
def flush_chain_request(name, family, table):
    json_data = {"json_data": {"nftables": [{"flush": {"chain":{"table": table, "name": name, "family": family }}}]}}
    response = requests.post('http://localhost:8000/chains/flush_chain', json=json_data)
    if(response.json()["status"] == "success"):
        return "Success"
    else:
        return "Error flushing chain."
    
import requests

def create_rule_request(rule_id, chain_name, chain_table, family, statement, statement_term, statement_type):
    expr = []
    saddr = None
    daddr = None
    saddr_object = None
    daddr_object = None
    sport = None
    dport = None
    sport_object = None
    dport_object = None
    accept = None
    drop = None
    reject = None
    log = None
    limit = None
    return_ = None
    jump = None
    masquerade = None
    go_to = None
    queue = None
    counter = None
    snat = None
    dnat = None
    input_interface = None
    output_interface = None
    redirect = None
    
    if statement_type == "terminal":
        saddr = statement_term["src_ip"]
        daddr = statement_term["dst_ip"]
        sport = statement_term["src_port"]
        dport = statement_term["dst_port"]
        if statement_term.get("src_ip_objects") != '--Selects--':
            saddr_object = statement_term.get("src_ip_objects")
        if statement_term.get("dst_ip_objects") != '--Selects--':
            daddr_object = statement_term.get("dst_ip_objects")
        if statement_term.get("src_port_objects") != '--Selects--':
            sport_object = statement_term.get("src_port_objects")
        if statement_term.get("dst_port_objects") != '--Selects--':
            dport_object = statement_term.get("dst_port_objects")
        input_interface = statement_term.get("input_interface")
        output_interface = statement_term.get("output_interface")
        accept = statement_term["accept"]
        drop = statement_term["drop"]
        reject = statement_term["reject"]
        return_ = statement_term["return_"]
        if statement_term.get("jump") != "--Selects--":
            jump = statement_term["jump"]
        if statement_term.get("go_to") != "--Selects--":
            go_to = statement_term["go_to"]
        queue = statement_term["queue"]
    
    else:
        saddr = statement.get("src_ip")
        daddr = statement.get("dst_ip")
        sport = statement.get('src_port')
        dport = statement.get('dst_port')
        if statement.get('src_ip_objects') != '--Selects--':
            saddr_object = statement.get('src_ip_objects')
        if statement.get('dst_ip_objects') != '--Selects--':
            daddr_object = statement.get('dst_ip_object')
        if statement.get('src_port_objects') != '--Selects--':
            sport_object = statement.get('src_port_objects')
        if statement.get('dst_port_objects') != '--Selects--':
            dport_object = statement.get('dst_port_objects')
        input_interface = statement.get('input_interface')
        output_interface = statement.get('output_interface')
        log = statement.get("log")
        limit = statement.get("limit")
        limit_per = statement.get("limit_per")
        counter = statement.get("counter")
        masquerade = statement.get("masquerade")
        snat = statement.get("src_nat")
        dnat = statement.get("dst_nat")
        redirect = statement.get("redirect")
    
    # Agrega los elementos al diccionario expr
    if saddr:
        if family == "inet":
            if ":" in saddr:
                expr.append({"match":{"op":"==","left":{"payload":{"protocol":"ip6", "field":"saddr"}}, "right": saddr}})
            elif "." in saddr:
                expr.append({"match":{"op":"==","left":{"payload":{"protocol":"ip","field":"saddr" }}, "right": saddr}})
        elif family == "bridge":
            expr.append({"match":{"op":"==","left":{"payload":{"protocol":"ether", "field":"saddr"}}, "right": daddr}})
    if daddr:
        if family == "inet":
            if ":" in daddr:
                expr.append({"match":{"op":"==","left":{"payload":{"protocol":"ip6" ,"field":"daddr"}}, "right": daddr}})
            elif "." in daddr:
                expr.append({"match":{"op":"==","left":{"payload":{ "protocol":"ip", "field":"daddr"}}, "right": daddr}})
        elif family == "bridge":
            expr.append({"match":{"op":"==","left":{"payload":{"protocol":"ether", "field":"daddr" }}, "right": daddr}})
    if sport:
        expr.append({"match":{"op":"==","left":{"payload":{"protocol":"tcp", "field":"sport"}}, "right": sport}})
    if dport:
        expr.append({"match":{"op":"==","left":{"payload":{"protocol":"tcp","field":"dport"}}, "right": dport}})
    if input_interface:
        expr.append({"input_interface": input_interface})
    if output_interface:
        expr.append({"output_interface": output_interface})
    if counter:
        expr.append({"counter": None})
    if saddr_object:
        if service.check_set_or_map == "ipv4_addr":
            expr.append({"match":{"op":"in","left":{"payload":{"protocol": "ip","field":"saddr" }}, "right": "@"+saddr_object}})
        if service.check_set_or_map == "ipv6_addr":
            expr.append({"match":{"op":"in","left":{"payload":{ "protocol": "ip6", "field":"saddr"}}, "right": "@"+saddr_object}})
        if service.check_set_or_map == "ether_addr":
            expr.append({"match":{"op":"in","left":{"payload":{ "protocol": "ether", "field":"saddr"}}, "right": "@"+saddr_object}})
    if daddr_object:
        if service.check_set_or_map == "ipv4_addr":
            expr.append({"match":{"op":"in","left":{"payload":{"protocol": "ip","field":"daddr"}}, "right": "@"+daddr_object}})
        if service.check_set_or_map == "ipv6_addr":
            expr.append({"match":{"op":"in","left":{"payload":{"protocol": "ip6", "field":"daddr" }}, "right": "@"+daddr_object}})
        if service.check_set_or_map == "ether_addr":
            expr.append({"match":{"op":"in","left":{"payload":{"protocol": "ether", "field":"daddr" }}, "right": "@"+daddr_object}})
    if sport_object:
        expr.append({"match":{"op":"in","left":{"payload":{ "protocol":"tcp", "field":"sport"}}, "right": "@"+sport_object}})
    if dport_object:
        expr.append({"match":{"op":"in","left":{"payload":{ "protocol":"tcp", "field":"dport"}}, "right": "@"+sport_object}})
    if accept:
        expr.append({"accept": None})
    if drop:
        expr.append({"drop": None})
    if reject:
        expr.append({"reject": {'type': 'icmp', 'expr': 'port-unreachable'}})
    if return_:
        expr.append({"return": None})
    if jump:
        expr.append({"jump": {"target": jump}})
    if go_to:
        expr.append({"goto": {"target": go_to}})
    if queue:
        expr.append({"queue": {"num": queue}})
    if log: 
        expr.append({"log": {"prefix": "Rule" + str(rule_id)+ " " , "level": "info"}})
    if limit:
        expr.append({"limit": {"rate": limit, "burst": 50, "per": limit_per}})
    if masquerade:
        expr.append({"masquerade": None})
    if snat:
        if(family == "inet"):
            if ":" in snat:
                expr.append({"snat": {"family": "ip6","addr": snat}})
            elif "." in snat:
                expr.append({"snat": {"family": "ip","addr": snat}})
        else:
            expr.append({"snat": {"addr": snat}})
    if dnat:
        if(family == "inet"):
            if ":" in dnat:
                expr.append({"dnat": {"family": "ip6","addr": dnat}})
            elif "." in dnat:
                expr.append({"dnat": {"family": "ip","addr": dnat}})
        else:
            expr.append({"dnat": {"addr": dnat}})
                    
    if redirect:
        if ":" in redirect:
            expr.append({"redirect": {"to": redirect.split(":")[0], "port": redirect.split(":")[1]}})
        else:
            expr.append({"redirect": {"port": redirect}}) 
    json_data = {
        "json_data": {
            "nftables": [{
                "add": {
                    "rule": {
                        "chain": chain_name,
                        "table": chain_table,
                        "family": family,
                        "expr": expr
                    }
                }
            }]
        }
    }
    if expr != []:
        response = requests.post('http://localhost:8000/rules/create_rule', json=json_data)
    else:
        return [], "Error creating rule."
    if response.json()["status"] == "success":
        return expr, "Success"
    else:
        return [], response.json()
    
def delete_rule_request(rule_id):
    rule= service.get_rule(rule_id)
    chain = service.get_chain_by_id(rule.chain_id)
    json_data = {"json_data": {"nftables": [{"delete": {"rule": {"chain": chain.name ,"table":rule.table().name, "family":rule.family, "handle": int(rule.handle)}}}]}}
    response = requests.post('http://localhost:8000/rules/delete_rule', json=json_data)
    if(response.json()["status"] == "success"):
        return "Success"
    else:
        return "Error deleting rule."

def list_sets_request():
    response = requests.get('http://localhost:8000/sets/list_sets')
    return response.json()[1]["nftables"]

def list_elements_in_set(set_name, set_family, set_table):
    json_data = {"json_data": {"nftables": [{"list": {"set": {"name": set_name, "family": set_family, "table": set_table}}}]}}
    response = requests.get('http://localhost:8000/sets/list_elements_in_set', json=json_data)
    return response.json()

def add_element_to_set_request(set_name, set_family, set_table, element):
    json_data = {"json_data": {"nftables": [{"add": {"element": {"family": set_family,  "table": set_table, "name": set_name,  "elem": element}}}]}}
    response = requests.post('http://localhost:8000/sets/add_element_to_set', json=json_data)
    if(response.json()[0] == 0):
        return "Success"
    else:
        return "Error adding element to set."
    
def create_set_request(set_name, set_family, set_table, set_type):
    json_data = {"json_data": {"nftables": [{"add": {"set": {"name": set_name, "family": set_family, "table": set_table, "type": set_type}}}]}}
    response = requests.post('http://localhost:8000/sets/create_set', json=json_data)
    if(response.json()[0] == 0):
        return "Success"
    else:
        return "Error creating set."
    
def delete_set_request(set_name, set_family, set_table):
    json_data = {"json_data": {"nftables": [{"delete": {"set": {"name": set_name, "family": set_family, "table": set_table}}}]}}
    response = requests.post('http://localhost:8000/sets/delete_set', json=json_data)
    if(response.json()[0] == 0):
        return "Success"
    else:
        return "Error deleting set."
def delete_element_from_set_request(set_name, set_family, set_table, element):
    json_data = {"json_data": {"nftables": [{"delete": {"element": {"family": set_family,  "table": set_table, "name": set_name,  "elem": element}}}]}}
    response = requests.post('http://localhost:8000/sets/delete_element_from_set', json=json_data)
    if(response.json()[0] == 0):
        return "Success"
    else:
        return "Error deleting element from set."
    
def list_maps_request():
    json_data = {"json_data": {"nftables": [{"list": {"maps": {}}}]}}
    response = requests.get('http://localhost:8000/maps/list_maps', json=json_data)
    return response.json()[1]["nftables"]

def list_elements_in_map(map_name, map_family, map_table):
    json_data = {"json_data": {"nftables": [{"list": {"map": { "family": map_family, "table": map_table, "name": map_name}}}]}}
    response = requests.get('http://localhost:8000/maps/list_elements_in_map', json=json_data)
    return response.json()

def create_map_request(map_name,type, map_family, map_table, map_type):
    json_data = {"json_data": {"nftables": [{"add": {"map": {"name": map_name, "family": map_family, "table": map_table, "type": type, "map": map_type}}}]}}
    response = requests.post('http://localhost:8000/maps/create_map', json=json_data)
    if(response.json()[0] == 0):
        return "Success"
    else:
        return "Error creating map."
    
def delete_map_request(map_name, map_family, map_table):
    json_data = {"json_data": {"nftables": [{"delete": {"map": {"name": map_name, "family": map_family, "table": map_table}}}]}}
    response = requests.post('http://localhost:8000/maps/delete_map', json=json_data)
    if(response.json()[0] == 0):
        return "Success"
    else:
        return "Error deleting map."
    
def add_element_to_map_request(map_name, map_family, map_table, key, value):
    json_data = {"json_data": {"nftables": [{"add": {"element": {"family": map_family,  "table": map_table, "name": map_name,  "elem": [[key, {"concat": [value]}]]
                                                                 }}}]}}    
    response = requests.post('http://localhost:8000/maps/add_element_to_map', json=json_data)
    if(response.json()[0] == 0):
        return "Success"
    else:
        return "Error adding element to map."
    
def delete_element_from_map_request(map_name, map_family, map_table, key, value):
    json_data = {"json_data": {"nftables": [{"delete": {"element": {"family": map_family,  "table": map_table, "name": map_name,  "elem": [[key, {"concat": [value]}]]}}}]}}
    response = requests.post('http://localhost:8000/maps/delete_element_from_map', json=json_data)
    if(response.json()[0] == 0):
        return "Success"
    else:
        return "Error deleting element from map."
    
def reload_service():
    response = requests.get('http://localhost:8000/service/reload_service')
    if(response.json()["status"] == "success"):
        return "Success"
    else:
        return "Error reloading service."
    
def save_service():
    response = requests.get('http://localhost:8000/service/save_service')
    if(response.json()["status"] == "success"):
        return "Success"
    else:
        return "Error saving service."
    
def save_service_temp():
    response = requests.get('http://localhost:8000/service/save_service_temp')
    if(response.json()["status"] == "success"):
        return "Success"
    else:
        return "Error saving service temp."
=== ./background/nftables-gui/nftables-frontend/app.py ===

from flask import Flask, render_template
from views import visualization_bp, creation_bp
from flask_bootstrap import Bootstrap
from models import db
from flask_migrate import Migrate
import os
from service import create_default_user, login_manager

ERROR = 'error.html'

app = Flask(__name__)
app.register_blueprint(visualization_bp)
app.register_blueprint(creation_bp)
dir_path = os.path.dirname(os.path.realpath(__file__))
app.config['SECRET_KEY'] = 'hfds732klejds90ahg'
app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{dir_path}/instance/nftables.db'
app.config['SESSION_COOKIE_SAMESITE'] = 'Strict'
app.config['SESSION_COOKIE_SECURE'] = True
login_manager.init_app(app)
db.init_app(app)

with app.app_context():
    db.create_all()
    create_default_user()

migrate = Migrate(app, db)
Bootstrap(app)

@app.errorhandler(404)
def page_not_found(e):
    return render_template(ERROR, message='Page not found'), 404

@app.errorhandler(500)
def internal_error(e):
    return render_template(ERROR, message="Internal server error"), 500

@app.route('/favicon.ico')
def favicon():
    return app.send_static_file('favicon.ico')

def create_app():
    app = Flask(__name__)
    app.register_blueprint(visualization_bp)
    app.register_blueprint(creation_bp)
    dir_path = os.path.dirname(os.path.realpath(__file__))
    app.config['SECRET_KEY'] = 'hfds732klejds90ahg'
    app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{dir_path}/instance/nftables.db'
    app.config['SESSION_COOKIE_SAMESITE'] = 'Strict'
    app.config['SESSION_COOKIE_SECURE'] = True
    login_manager.init_app(app)
    db.init_app(app)

    with app.app_context():
        db.create_all()
        create_default_user()

    migrate = Migrate(app, db)
    Bootstrap(app)
    
    @app.errorhandler(404)
    def page_not_found(e):
        return render_template(ERROR, message='Page not found'), 404
    
    @app.errorhandler(500)
    def internal_error(e):
        return render_template(ERROR, message="Internal server error"), 500

    @app.route('/favicon.ico')
    def favicon():
        return app.send_static_file('favicon.ico')

    return app

if __name__ == '__main__':
    app.run(debug=False, host='0.0.0.0')

=== ./background/nftables-gui/nftables-frontend/forms/forms.py ===

from ipaddress import ip_address
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, SubmitField, SelectField, IntegerField, FormField, FieldList, BooleanField
from wtforms.validators import DataRequired, Email, EqualTo, Optional
from wtforms import ValidationError
from models import Chain, Table, User
import service

class LoginForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    password = PasswordField('Password', validators=[DataRequired()])
    submit = SubmitField('Login')
    
    def validate_username(self, username):
        user = User.query.filter_by(username=username.data).first()
        if not user:
            raise ValidationError('User does not exist.')
    
    def validate_password(self, password):
        user = User.query.filter_by(username=self.username.data).first()
        if user and not user.check_password(password.data):
            raise ValidationError('Invalid password.')
        
    class Meta:
        csrf = False
class CreateUserForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    password = PasswordField('Password', validators=[DataRequired(), EqualTo('confirm_password', message='Passwords must match.')])
    confirm_password = PasswordField('Confirm Password', validators=[DataRequired()])
    role = StringField('Role', validators=[DataRequired()])
    submit = SubmitField('Create User')
    
    def validate_username(self, username):
        user = User.query.filter_by(username=username.data).first()
        if user:
            raise ValidationError('User already exists.')
        
    def validate_role(self, role):
        if role.data not in ['administrator', 'user', 'guest']:
            raise ValidationError('Role must be one of: administrator, user, guest.')
        
    def validate_password(self, password):
        if len(password.data) < 8:
            raise ValidationError('Password must be at least 8 characters long.')
    class Meta:
        csrf = False        
class UpdateUserForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    role = StringField('Role', validators=[DataRequired()])
    submit = SubmitField('Update User')
    
    def validate_role(self, role):
        if role.data not in ['administrator', 'user', 'guest']:
            raise ValidationError('Role must be one of: administrator, user, guest.')
    class Meta:
        csrf = False        
        
class TableForm(FlaskForm):
    name = StringField('Name', validators=[DataRequired()])
    family = SelectField('Family', choices=[('ip', 'ipv4'), ('inet', 'ipv4 and ipv6'), ('arp', 'arp'), ('bridge', 'bridge'), ('netdev', 'netdev')], validators=[DataRequired()])
    description = StringField('Description')
    submit = SubmitField('Create Table')
    
    def validate_family(self, family):
        if family.data not in ['ip', 'inet', 'arp', 'bridge', 'netdev']:
            raise ValidationError('Family must be one of: ip, inet, arp, bridge, netdev.')

    def validate_name(self, name):
        table = Table.query.filter_by(name=name.data).first()
        if table or " " in name.data or "-" in name.data or "/" in name.data or "." in name.data or "," in name.data or ";" in name.data or ":" in name.data or "@" in name.data or "#" in name.data or "$" in name.data or "%" in name.data or "^" in name.data or "&" in name.data or "*" in name.data or "(" in name.data or ")" in name.data or "+" in name.data or "=" in name.data or "[" in name.data or "]" in name.data or "{" in name.data or "}" in name.data or "|" in name.data or "<" in name.data or ">" in name.data or "?" in name.data or "!" in name.data or "'" in name.data or '"' in name.data or "\\" in name.data or "`" in name.data or "~" in name.data:
            raise ValidationError('Table name invalid. (Must not contain special characters or spaces.)')
    class Meta:
        csrf = False
class ChainForm(FlaskForm):
    name = StringField('Name', validators=[DataRequired()])
    table = StringField('Table', validators=[DataRequired()])
    family = StringField('Family', validators=[DataRequired()])
    policy = SelectField('Policy', choices=[
        ('accept', 'accept'),
        ('drop', 'drop'),
        ('reject', 'reject')    ], validators=[DataRequired()])    
    submit = SubmitField('Create Chain')
    
    def validate_name(self, name):
        if " " in name.data or "-" in name.data or "/" in name.data or "." in name.data or "," in name.data or ";" in name.data or ":" in name.data or "@" in name.data or "#" in name.data or "$" in name.data or "%" in name.data or "^" in name.data or "&" in name.data or "*" in name.data or "(" in name.data or ")" in name.data or "+" in name.data or "=" in name.data or "[" in name.data or "]" in name.data or "{" in name.data or "}" in name.data or "|" in name.data or "<" in name.data or ">" in name.data or "?" in name.data or "!" in name.data or "'" in name.data or '"' in name.data or "\\" in name.data or "`" in name.data or "~" in name.data:
            raise ValidationError('Chain name invalid. (Must not contain special characters or spaces.)')

    def validate_table(self, table):
        table = Table.query.filter_by(id=table.data).first()
        if not table:
            raise ValidationError('Table does not exist.')
 
    def validate_family(self, family):
        if family.data not in ['ip', 'inet', 'arp', 'bridge', 'netdev']:
            raise ValidationError('Family must be one of: ip, inet, arp, bridge, netdev.')

    def validate_policy(self, policy):
        if policy.data not in ['accept', 'drop', 'reject', 'dnat', 'snat', 'masquerade', 'redirect', 'log', 'return', 'jump', 'queue', 'unreachable', 'error', 'broadcast', 'dnat', 'snat', 'redirect', 'mirror', 'tproxy', 'netmap', 'nfqueue', 'nfacct', 'nfct', 'nftrace', 'nftlb']:
            raise ValidationError('Policy must be one of: accept, drop, reject, dnat, snat, masquerade, redirect, log, return, jump, queue, unreachable, error, broadcast, dnat, snat, redirect, mirror, tproxy, netmap, nfqueue, nfacct, nfct, nftrace, nftlb.')

    def validate_type(self, type):
        if type.data not in ['filter', 'nat', 'route', 'mangle', 'raw']:
            raise ValidationError('Type must be one of: filter, nat, route, mangle, raw.')

    class Meta:
        csrf = False        
        
class BaseChainForm(ChainForm):
    hook_type = SelectField('Hook Type', choices=[('prerouting', 'prerouting'), ('input', 'input'), ('forward', 'forward'), ('output', 'output'), ('postrouting', 'postrouting')], validators=[DataRequired()])
    priority = IntegerField('Priority', validators=[Optional()])
    type = SelectField('Type', choices=[('filter', 'filter'), ('nat', 'nat'), ('route', 'route'), ('mangle', 'mangle'), ('raw', 'raw')], validators=[DataRequired()])
    
    def validate_hook_type(self, hook_type):
        if hook_type.data not in ['prerouting', 'input', 'forward', 'output', 'postrouting']:
            raise ValidationError('Hook type must be one of: prerouting, input, forward, output, postrouting.')
          
    def validate_priority(self, priority):
        if priority.data > 300 or priority.data < -400 :
            raise ValidationError('Priority must be between -400 and 300.')
    class Meta:
        csrf = False
class StatementForm(FlaskForm):
    src_ip = StringField('Source IP', validators=[Optional()])
    dst_ip = StringField('Destination IP', validators=[Optional()])
    src_ip_objects = StringField('Source Sets or Maps', validators=[Optional()])
    dst_ip_objects = StringField('Destination Sets or Maps', validators=[Optional()])
    src_port = StringField('Source Port', validators=[Optional()])
    dst_port = StringField('Destination Port', validators=[Optional()])
    src_port_objects = StringField('Source Port Sets or Maps', validators=[Optional()])
    dst_port_objects = StringField('Destination Port Sets or Maps', validators=[Optional()])
    submit = SubmitField('Add Statement', validators=[Optional()])
    
    def validate_src_ip(self, src_ip):
        try:
            ip_address(src_ip.data)
        except ValueError:
            raise ValidationError('Source IP must be a valid IP address with a network mask.')

    def validate_dst_ip(self, dst_ip):
        try:
            ip_address(dst_ip.data)
        except ValueError:
            raise ValidationError('Destination IP must be a valid IP address with a network mask.')
                
    def validate_src_ip_objects(self, src_ip_objects):
        if src_ip_objects.data != "--Selects--" and self.src_ip.data:
            raise ValidationError('Source IP and Source IP Sets or Maps cannot be used together.')
                
    def validate_dst_ip_objects(self, dst_ip_objects):
        if dst_ip_objects.data != "--Selects--" and self.dst_ip.data:
            raise ValidationError('Destination IP and Destination IP Sets or Maps cannot be used together.')
    
    def validate_src_port_objects(self, src_port_objects):
        if src_port_objects.data != "--Selects--" and self.src_port.data:
            raise ValidationError('Source Port and Source Port Sets or Maps cannot be used together.')
        
    def validate_dst_port_objects(self, dst_port_objects):
        if dst_port_objects.data != "--Selects--" and self.dst_port.data:
            raise ValidationError('Destination Port and Destination Port Sets or Maps cannot be used together.')
        
    def validate_src_port(self, src_port):
        if src_port.data and (not src_port.data.isdigit() or not 0 <= int(src_port.data) <= 65535):
            raise ValidationError('Source Port must be a valid port number between 0 and 65535.')

    def validate_dst_port(self, dst_port):
        if dst_port.data and (not dst_port.data.isdigit() or not 0 <= int(dst_port.data) <= 65535):
            raise ValidationError('Destination Port must be a valid port number between 0 and 65535.')        
    class Meta:
        csrf = False
class TerminalStatementForm(StatementForm):
    reject = BooleanField('Reject',validators=[Optional()])
    drop = BooleanField('Drop',  validators=[Optional()])
    accept = BooleanField('Accept', validators=[Optional()])
    queue = IntegerField('Queue', validators=[Optional()])
    return_ = BooleanField('Return',  validators=[Optional()])
    jump = StringField('Jump', validators=[Optional()])
    go_to = StringField('Go To', validators=[Optional()])
    
    def validate_not_all_empty(self, reject, drop, accept, queue, return_, jump, go_to):
        if not (reject.data or drop.data or accept.data or queue.data or return_.data or jump.data or go_to.data):
            raise ValidationError('At least one field must be filled.')
    
    def validate_queue(self, queue):
        if queue.data and not isinstance(queue.data, int):
            raise ValidationError('Queue must be a valid number.')
        
    def validate_jump(self, jump):
        if jump.data and not jump.data.replace(":", "").replace("-", "").replace("_", "").replace(".", "").replace("/", "").replace(" ", "").isalnum():
            raise ValidationError('Jump must be a valid chain name.')
        
        
    def validate_go_to(self, go_to):
        if go_to.data and not go_to.data.replace(":", "").replace("-", "").replace("_", "").replace(".", "").replace("/", "").replace(" ", "").isalnum():
            raise ValidationError('Go To must be a valid chain name.')
    class Meta:
        csrf = False        
class NotTerminalStatementForm(StatementForm):
    limit = IntegerField('Limit', validators=[Optional()] )
    log = BooleanField('Log', validators=[Optional()])
    counter = BooleanField('Counter', validators=[Optional()])
    masquerade = BooleanField('Masquerade', validators=[Optional()])
    redirect = StringField('Redirect', validators=[Optional()])
    src_nat = StringField('SRC_NAT', validators=[Optional()])
    dst_nat = StringField('DST_NAT', validators=[Optional()])
    limit_per = StringField('Limit Per', validators=[Optional()])
    
    def validate_not_all_empty(self, limit, log, counter, masquerade, redirect, src_nat, dst_nat, limit_per):
        if not (limit.data or log.data or counter.data or masquerade.data or redirect.data or src_nat.data or dst_nat.data or limit_per.data):
            raise ValidationError('At least one field must be filled.')
    
    def validate_limit_per(self, limit_per):
        if limit_per.data and not limit_per.data.replace(":", "").replace("-", "").replace("_", "").replace(".", "").replace("/", "").replace(" ", "").isalnum():
            raise ValidationError('Limit Per must be a valid chain name.')
        if limit_per.data not in ['second', 'minute', 'hour']:
            raise ValidationError('Limit Per must be one of: second, minute, hour.')
    
    def validate_src_nat(self, src_nat):
        try:
            ip_address(src_nat.data)
        except ValueError:
            raise ValidationError('Source IP must be a valid IP address with a network mask.')

    def validate_dst_nat(self,dst_nat):
        try:
            if ":" in dst_nat.data:
                ip_address(dst_nat.data.split(":")[0])
                if not dst_nat.data.split(":")[1].isdigit() or not 0 <= int(dst_nat.data.split(":")[1]) <= 65535:
                    raise ValidationError('Destination IP must be a valid IP address or port number between 0 and 65535.')
            elif (dst_nat.data and (not dst_nat.data.isdigit() or not 0 <= int(dst_nat.data) <= 65535) or ip_address(dst_nat.data)):
                ValidationError('Destination IP must be a valid IP address or port number between 0 and 65535.')
        except ValueError:
            raise ValidationError('Destination IP must be a valid IP address or port number between 0 and 65535.')

    
    def validate_limit(self, limit):
        if limit.data and not isinstance(limit.data, int) or 0 > limit.data:
            raise ValidationError('Limit must be a valid number.')   
        if limit.data and self.limit_per.data == "":
            raise ValidationError('Limit Per must be specified if limit is specified.')
        
    def validate_redirect(self, redirect):
        try:
            if redirect.data and not (self.dst_port.data or self.src_port.data):
                raise ValidationError('Condition on dst or src port must be especified to create redirect.')
            elif not isinstance(int(redirect.data), int) or not 0 <= int(redirect.data) <= 65535:
                raise ValidationError('Redirect must be a port number between 0 and 65535.')
        except ValueError:
            raise ValidationError('Condition on dst or src port must be especified to create redirect and must be a valid port number between 0 and 65535.')
    class Meta:
        csrf = False
class RuleForm(FlaskForm):
    chain = StringField('Chain', validators=[DataRequired()])
    handle = StringField('Handle', validators=[Optional()])
    statements = FormField(NotTerminalStatementForm)
    statements_term = FormField(TerminalStatementForm)
    description = StringField('Description', validators=[Optional()])
    statement_select = SelectField('Statement Type', choices=[('terminal', 'Terminal'), ('not_terminal', 'Not Terminal')], validators=[DataRequired()])
    submit = SubmitField('Add Rule')
            
    def validate_family(self, family):
        if family.data not in ['ip', 'inet', 'arp', 'bridge', 'netdev']:
            raise ValidationError('Family must be one of: ip, inet, arp, bridge, netdev.')
        
    def validate_expr(self, expr):
        if expr.data and not expr.data.replace(":", "").replace("-", "").replace("_", "").replace(".", "").replace("/", "").replace(" ", "").isalnum():
            raise ValidationError('Expression must be a valid expression.')
        
    def validate_handle(self, handle):
        if handle.data and not handle.data.replace(":", "").replace("-", "").replace("_", "").replace(".", "").replace("/", "").replace(" ", "").isalnum():
            raise ValidationError('Handle must be a valid handle.')
    class Meta:
        csrf = False        
class AddElementSetForm(FlaskForm):
    element = StringField('Element', validators=[DataRequired()])
    class Meta:
        csrf = False    
class SetForm(FlaskForm):
    VALID_TYPES = [('ipv4_addr', 'ipv4_addr'), ('ipv6_addr', 'ipv6_addr'), ('ether_addr', 'ether_addr'), ('inet_service', 'inet_service'), ('inet_proto', 'inet_proto'), ('mark', 'mark')]

    name = StringField('Name', validators=[DataRequired()])
    family = StringField('Family', validators=[DataRequired()])
    table = StringField('Table Name', validators=[DataRequired()])
    type = SelectField('Type', choices=VALID_TYPES, validators=[DataRequired()])
    description = StringField('Description', validators=[Optional()])
    submit = SubmitField('Create Set')
    
    def validate_family(self, family):
        if family.data not in ['ip', 'inet', 'arp', 'bridge', 'netdev']:
            raise ValidationError('Family must be one of: ip, inet, arp, bridge, netdev.')
        
    def validate_name(self, name):
        if " " in name.data or "-" in name.data or "/" in name.data or "." in name.data or "," in name.data or ";" in name.data or ":" in name.data or "@" in name.data or "#" in name.data or "$" in name.data or "%" in name.data or "^" in name.data or "&" in name.data or "*" in name.data or "(" in name.data or ")" in name.data or "+" in name.data or "=" in name.data or "[" in name.data or "]" in name.data or "{" in name.data or "}" in name.data or "|" in name.data or "<" in name.data or ">" in name.data or "?" in name.data or "!" in name.data or "'" in name.data or '"' in name.data or "\\" in name.data or "`" in name.data or "~" in name.data:
            raise ValidationError('Set name invalid. (Must not contain special characters or spaces.)')
        
    def validate_type(self, type):
        if type.data not in [choice[0] for choice in self.VALID_TYPES]:
            raise ValidationError('Type must be one of: ' + ', '.join([choice[0] for choice in self.VALID_TYPES]))    
    class Meta:
        csrf = False        
class DeleteElementSet(FlaskForm):
    element = StringField('Element', validators=[DataRequired()])
    class Meta:
        csrf = False    
class MapForm(FlaskForm):
    VALID_TYPES = [('ipv4_addr', 'ipv4_addr'), ('ipv6_addr', 'ipv6_addr'), ('ether_addr', 'ether_addr'), ('inet_service', 'inet_service'), ('inet_proto', 'inet_proto'), ('mark', 'mark')]
    name = StringField('Name', validators=[DataRequired()])
    family = StringField('Family', validators=[DataRequired()])
    table = StringField('Table Name', validators=[DataRequired()])
    type = SelectField('Type', choices=VALID_TYPES, validators=[DataRequired()])
    description = StringField('Description', validators=[Optional()])
    map_type = SelectField('Map Type', choices=VALID_TYPES, validators=[DataRequired()])
    
    def validate_family(self, family):
        if family.data not in ['ip', 'inet', 'arp', 'bridge', 'netdev']:
            raise ValidationError('Family must be one of: ip, inet, arp, bridge, netdev.')
        
    def validate_name(self, name):
        if " " in name.data or "-" in name.data or "/" in name.data or "." in name.data or "," in name.data or ";" in name.data or ":" in name.data or "@" in name.data or "#" in name.data or "$" in name.data or "%" in name.data or "^" in name.data or "&" in name.data or "*" in name.data or "(" in name.data or ")" in name.data or "+" in name.data or "=" in name.data or "[" in name.data or "]" in name.data or "{" in name.data or "}" in name.data or "|" in name.data or "<" in name.data or ">" in name.data or "?" in name.data or "!" in name.data or "'" in name.data or '"' in name.data or "\\" in name.data or "`" in name.data or "~" in name.data:
            raise ValidationError('Set name invalid. (Must not contain special characters or spaces.)')

    def validate_type(self, type):
        if type.data not in [choice[0] for choice in self.VALID_TYPES]:
            raise ValidationError('Type must be one of: ' + ', '.join([choice[0] for choice in self.VALID_TYPES]))
    def validate_map_type(self, map_type):
        if map_type.data not in [choice[0] for choice in self.VALID_TYPES]:
            raise ValidationError('Map Type must be one of: ' + ', '.join([choice[0] for choice in self.VALID_TYPES]))
    class Meta:
        csrf = False        
class AddElementMap(FlaskForm):
    key = StringField('Key', validators=[DataRequired()])
    value = StringField('Value', validators=[DataRequired()])
    class Meta:
        csrf = False    
class DeleteElementMap(FlaskForm):
    key = StringField('Key', validators=[DataRequired()])
    class Meta:
        csrf = False    
class AddListForm(FlaskForm):
    name = StringField('Name', validators=[DataRequired()])
    family = StringField('Family', validators=[DataRequired()])
    element = StringField('Element', validators=[DataRequired()])
    table = StringField('Table Name', validators=[DataRequired()])
    type = SelectField('Type', choices=[('ipv4_addr', 'ipv4_addr')], validators=[DataRequired()])
    description = StringField('Description', validators=[Optional()])

    def validate_family(self, family):
        if family.data not in ['ip', 'inet', 'arp', 'bridge', 'netdev']:
            raise ValidationError('Family must be one of: ip, inet, arp, bridge, netdev.')
    def validate_name(self, name):
        if " " in name.data or "-" in name.data or "/" in name.data or "." in name.data or "," in name.data or ";" in name.data or ":" in name.data or "@" in name.data or "#" in name.data or "$" in name.data or "%" in name.data or "^" in name.data or "&" in name.data or "*" in name.data or "(" in name.data or ")" in name.data or "+" in name.data or "=" in name.data or "[" in name.data or "]" in name.data or "{" in name.data or "}" in name.data or "|" in name.data or "<" in name.data or ">" in name.data or "?" in name.data or "!" in name.data or "'" in name.data or '"' in name.data or "\\" in name.data or "`" in name.data or "~" in name.data:
            raise ValidationError('Set name invalid. (Must not contain special characters or spaces.)')
    def validate_type(self, type):
        if type.data not in ['ipv4_addr']:
            raise ValidationError('Type must be one of: ipv4_addr.')
    def validate_table(self, table):
        table = Table.query.filter_by(id=table.data).first()
        if not table:
            raise ValidationError('Table does not exist.')
    class Meta:
        csrf = False
=== ./background/nftables-gui/nftables-frontend/gunicorn.conf.py ===

import subprocess
import sys
import os
import multiprocessing

res = None
workers = multiprocessing.cpu_count() * 2 + 1
wsgi_app = "app:app"
bind = "0.0.0.0:10001"


def on_starting(server):
    global res
    res = subprocess.Popen(["/usr/bin/hug", "-f", "main.py"], cwd=os.path.abspath("../nftables-parser"), shell=False,
                           stdout=sys.stdout, stderr=sys.stderr)


def on_exit(server):
    res.terminate()

=== ./background/nftables-gui/nftables-frontend/migrations/env.py ===

import logging
from logging.config import fileConfig

from flask import current_app

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')


def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine


def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # this callback is used to prevent an auto-migration from being generated
    # when there are no changes to the schema
    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
    def process_revision_directives(context, revision, directives):
        if getattr(config.cmd_opts, 'autogenerate', False):
            script = directives[0]
            if script.upgrade_ops.is_empty():
                directives[:] = []
                logger.info('No changes in schema detected.')

    conf_args = current_app.extensions['migrate'].configure_args
    if conf_args.get("process_revision_directives") is None:
        conf_args["process_revision_directives"] = process_revision_directives

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=get_metadata(),
            **conf_args
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

=== ./background/nftables-gui/nftables-frontend/migrations/versions/595b12df49f7_first_populate.py ===

"""first populate

Revision ID: 595b12df49f7
Revises: 
Create Date: 2024-04-10 00:18:36.668501

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '595b12df49f7'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('user',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('username', sa.String(length=80), nullable=False),
    sa.Column('password', sa.String(length=120), nullable=False),
    sa.Column('email', sa.String(length=120), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('email'),
    sa.UniqueConstraint('username')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('user')
    # ### end Alembic commands ###

=== ./background/nftables-gui/nftables-frontend/models.py ===


from flask_sqlalchemy import SQLAlchemy
from flask_login import UserMixin


db = SQLAlchemy(session_options={"autoflush": False})

class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password = db.Column(db.String(120), nullable=False)
    role = db.Column(db.String(120), nullable=False)
    is_active = db.Column(db.Boolean, nullable=False)

    def __repr__(self):
        return '<User %r>' % self.username
    
    
    def check_password(self, password):
        return self.password == password

class Table(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), nullable=False)
    family = db.Column(db.String(80), nullable=False)
    description = db.Column(db.String(120), nullable=True)
    chains = db.relationship('Chain', backref='table', lazy=False, cascade="all, delete-orphan")
    username = db.Column(db.String(80), db.ForeignKey('user.username'), nullable=True)
    
    def save(self):
        db.session.add(self)
        db.session.commit()

    def __repr__(self):
        return '<Table %r>' % self.name
    
class Chain(db.Model):
    __tablename__ = 'chain'
    id= db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), nullable=False)
    table_id = db.Column(db.Integer, db.ForeignKey('table.id'), nullable=False)
    policy = db.Column(db.String(120), nullable=True)
    rules = db.relationship('Rule', backref='chain', lazy=False, cascade="all, delete-orphan")

    def get_table(self):
        return Table.query.filter_by(name=self.table_id, family=self.family).first()


    def __repr__(self):
        return '<Chain %r>' % self.name

class UserChain(Chain):


    def __repr__(self):
        return '<UserChain %r>' % self.name

class BaseChain(Chain):
    type = db.Column(db.String(120), nullable=True)
    hook_type = db.Column(db.String(120), nullable=True)
    priority = db.Column(db.Integer, nullable=True)


    def __repr__(self):
        return '<BaseChain %r>' % self.name
class Rule(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    chain_id = db.Column(db.Integer, db.ForeignKey('chain.id'), nullable=False)
    expr = db.Column(db.String(120), nullable=False)
    handle = db.Column(db.String(120), nullable=True)
    description = db.Column(db.String(120), nullable=True)
    statement = db.relationship('Statement', backref='rule', lazy=True, cascade="all, delete-orphan")

    def __repr__(self):
        return '<Rule %r>' % self.handle
    
    def statements(self):
        return Statement.query.filter_by(rule_id=self.id).all()
    
    def table(self):
        chain = Chain.query.filter_by(id=self.chain_id).first()
        base_chain = BaseChain.query.filter_by(id=self.chain_id).first()
        if base_chain:
            return base_chain.table
        else:
            return chain.table
        
    def to_string(self):
        statements = ', '.join([str(statement) for statement in self.statements()])
        table = self.table()
        return f"Rule ID: {self.id}, Chain ID: {self.chain_id}, Expression: {self.expr}, Handle: {self.handle}, Description: {self.description}, Statements: {statements}, Table: {table}"
    
class Statement(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    rule_id = db.Column(db.Integer, db.ForeignKey('rule.id'), nullable=False)
    src_ip = db.Column(db.String(120), nullable=True)
    dst_ip = db.Column(db.String(120), nullable=True)
    src_port = db.Column(db.String(120), nullable=True)
    dst_port = db.Column(db.String(120), nullable=True)
    input_interface = db.Column(db.String(120), nullable=True)
    output_interface = db.Column(db.String(120), nullable=True)
    protocol = db.Column(db.String(120), nullable=True)
    
    def __repr__(self):
        return '<Statement %r>' % self.id
    
    def is_empty(self):
        return not any([self.src_ip, self.dst_ip, self.src_port, self.dst_port, self.input_interface, self.output_interface, self.protocol])

class TerminalStatement(Statement):
    reject = db.Column(db.String(120), nullable=True)
    drop = db.Column(db.String(120), nullable=True)
    accept = db.Column(db.String(120), nullable=True)
    queue = db.Column(db.String(120), nullable=True)
    return_ = db.Column(db.Boolean(), nullable=True)
    jump = db.Column(db.String(120), nullable=True)
    go_to = db.Column(db.String(120), nullable=True)

    def __repr__(self):
        return '<TerminalStatement %r>' % self.id
    
    def is_empty(self):
        return not any([self.reject, self.drop, self.accept, self.queue, self.return_, self.jump, self.go_to])

class NotTerminalStatement(Statement):
    limit = db.Column(db.String(120), nullable=True)
    log = db.Column(db.String(120), nullable=True)
    counter = db.Column(db.String(120), nullable=True)
    masquerade = db.Column(db.Boolean(), nullable=True)
    snat = db.Column(db.String(120), nullable=True)
    dnat = db.Column(db.String(120), nullable=True)
    redirect = db.Column(db.String(120), nullable=True)


    def __repr__(self):
        return '<NotTerminalStatement %r>' % self.id

    def is_empty(self):
        return not any([self.limit, self.log, self.counter, self.masquerade, self.snat, self.dnat, self.redirect])
   

    
class Set(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(120), nullable=False)
    type = db.Column(db.String(120), nullable=False)
    elements = db.Column(db.String(120), nullable=True)
    description = db.Column(db.String(120), nullable=True)
    table_id = db.Column(db.Integer, db.ForeignKey('table.id'), nullable=False)
    
    def __repr__(self):
        return '<Set %r>' % self.name
    
class Map(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    table_id = db.Column(db.Integer, db.ForeignKey('table.id'), nullable=False)
    name = db.Column(db.String(120), nullable=False)
    description = db.Column(db.String(120), nullable=True)
    type = db.Column(db.String(120), nullable=True)
    map = db.Column(db.String(120), nullable=True)
    elements = db.Column(db.String(120), nullable=True)
    
    def __repr__(self):
        return '<Map %r>' % self.name

=== ./background/nftables-gui/nftables-frontend/service.py ===

import glob
import json
import re
from models import Chain, Map, NotTerminalStatement, Rule, Statement, Table, BaseChain, TerminalStatement, db, User, Set
from flask_login import LoginManager
import api, os
import ipaddress
import ast
from Levenshtein import ratio


login_manager = LoginManager()

def create_default_user():
    user = User.query.filter_by(username='default').first()
    if not user:
        user = User(username='default',password="defaultpassword" ,role="administrator" ,is_active=True)
        db.session.add(user)
        db.session.commit()
        
def clean_table(table_id, family):
    table = Table.query.filter_by(name=table_id, family=family).first()
    chains = table.chains
    for chain in chains:
        rules = chain.rules
        for rule in rules:
            statements = rule.statement
            for statement in statements:
                db.session.delete(statement)
            db.session.delete(rule)
        db.session.delete(chain)
    db.session.commit()
        
def create_user(username, password, role, is_active):
    user = User(username=username, password=password, role=role, is_active=is_active)
    db.session.add(user)
    db.session.commit()
    
def check_existing_table(name, family):
    table = Table.query.filter_by(name=name, family=family).first()
    if table:
        return True
    return False
    
@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

def get_table(table_id):
    table = Table.query.filter_by(name=table_id).first()
    return table

def get_table(table_id, family):  
    table = Table.query.filter_by(name=table_id, family=family).first()
    return table


def get_users():
    return User.query.all()

def get_user(user_id):
    user = User.query.get(user_id)
    return user

def delete_user(user_id):
    user = User.query.get(user_id)
    db.session.delete(user)
    db.session.commit()


def insert_in_table(name, family, description=None, username=None):
    try:
        Table(name=name, family=family, description=description, username=username).save()
    except Exception as e:
        db.session.rollback()
        return str(e)
    return "Success"

def delete_table(table_id, family):
    table = Table.query.filter_by(name=table_id, family=family).first()
    db.session.delete(table)
    db.session.commit()
    

def get_tables():
    return Table.query.all()

def insert_chains(table_id, chains):
    table = Table.query.get(table_id)
    table.chains = chains
    db.session.commit()
    
def insert_chain(chain_name, family, policy, table_id, type, hook_type=None, priority=None):
    table = Table.query.filter_by(name=table_id, family=family).first()
    if table is not None:
        if hook_type is not None and priority is not None:
            chain = BaseChain(name=chain_name, type=type, policy=policy, table_id=table.id, hook_type=hook_type, priority=priority)
        else:
            chain = Chain(name=chain_name, table_id=table.id, policy=policy)
        db.session.add(chain)
        db.session.commit()

def check_existing_chain(chain_name, table_id, family):
    table = Table.query.filter_by(name=table_id, family=family).first()
    chain = Chain.query.filter_by(name=chain_name, table_id=table.id).first()
    if chain in table.chains:
        return False
    return True

def get_chains_from_table(table_id, family):
    table = Table.query.filter_by(name=table_id, family=family).first()
    return table.chains

def get_chains():
    return Chain.query.all()


def get_chain(chain_id, table):
    chain = Chain.query.filter_by(name=chain_id, table_id=table).first()
    base_chain = BaseChain.query.filter_by(name=chain_id, table_id=table).first()
    if base_chain:
        return base_chain
    return chain

def get_chain_by_id(chain_id):
    chain = Chain.query.filter_by(id=chain_id).first()
    return chain


def check_existing_rule(chain_id, handle=None, family=None, expr=None):
    rules = Rule.query.filter_by(chain_id=chain_id).all()
    chain = Chain.query.filter_by(id=chain_id).first()
    if handle:
        rule = Rule.query.filter_by(handle=handle, chain_id=chain_id, expr=str(expr)).first()
        if rule in chain.rules:
            return True
    for rule in rules:
        if rule.handle == None and (rule in chain.rules and ratio(str(rule.expr), str(expr)) > 0.5):
            rule.handle = handle
            db.session.commit()
            return True
        if rule in chain.rules and str(rule.handle) == handle:  # Ajusta el umbral según tus necesidades
            return True
        if (rule in chain.rules and ratio(str(rule.expr), str(expr)) > 0.98):
            return True
        
    return False

def get_chain_id(chain_id, table):
    chain = Chain.query.filter_by(id=chain_id, table_id=table).first()
    base_chain = BaseChain.query.filter_by(id=chain_id, table_id=table).first()
    if base_chain:
        return base_chain
    return chain

def insert_rule_with_table(chain_id, expr, table_id, description=None):
    chain = get_chain_id(chain_id, table_id)
    if description == "":
        description = None
    rule = Rule(chain_id=chain.id, expr=expr, description=description)
    db.session.add(rule)
    db.session.commit()
    return rule.id

def insert_rule(chain_id, expr, handle, description=None):
    rule = Rule(chain_id=chain_id, expr=expr, handle=handle, description=description)
    db.session.add(rule)
    db.session.commit()
    return rule.id
    
def get_rules_from_chain(chain_id):
    chain = Chain.query.get(chain_id)
    return chain.rules

def get_rules():
    return Rule.query.all()
    
def delete_chain(chain_id):
    chain = Chain.query.get(chain_id)
    db.session.delete(chain)
    db.session.commit()
    
def delete_rule(rule_id):
    rule = get_rule(rule_id)
    db.session.delete(rule)
    db.session.commit()
    
def delete_rules_form_chain(chain_id):
    chain = Chain.query.get(chain_id)
    rules = chain.rules
    for rule in rules:
        db.session.delete(rule)
    db.session.commit()
    
def insert_statement(rule_id, saddr, daddr, sport, dport, protocol, reject=None, log=None, drop=None, accept=None, queue=None, limit=None, counter=None, return_=None, jump=None, go_to=None, masquerade=None, snat=None, dnat=None, redirect=None, input_interface=None, output_interface=None):
    statement_ = None
    statement = None
    
    if limit != None or log != None or counter != None or masquerade != None or snat != None or dnat != None or redirect != None:
        statement = NotTerminalStatement(rule_id=rule_id, src_ip=saddr, dst_ip=daddr, src_port=sport, dst_port=dport,input_interface=input_interface, output_interface=output_interface, protocol=protocol, limit=limit, log=log, counter=counter, masquerade=masquerade, snat=snat, dnat=dnat, redirect=redirect)
        db.session.add(statement)
    if reject != None or drop != None or accept != None or queue != None or return_ != None or jump != None or go_to != None :
        statement_ = TerminalStatement(rule_id=rule_id, src_ip=saddr, dst_ip=daddr, src_port=sport, dst_port=dport, input_interface=input_interface, output_interface=output_interface, protocol=protocol, reject=reject, drop=drop, accept=accept, queue=queue, return_=return_, jump=jump, go_to=go_to)
        db.session.add(statement_)
    else:
        statement_2 = Statement(rule_id=rule_id, src_ip=saddr, dst_ip=daddr, src_port=sport, dst_port=dport,input_interface=input_interface, output_interface=output_interface, protocol=protocol)
        db.session.add(statement_2)
    db.session.commit()

def check_terminal_or_not_terminal(statement):
    if statement.reject != None or statement.drop != None or statement.accept != None or statement.queue != None or statement.return_ != None or statement.jump != None or statement.go_to != None:
        return "terminal"
    return "not_terminal"

def get_statements_from_rule(rule_id):
    rule = Rule.query.filter_by(id=rule_id).first()
    statements = []
    for statement in rule.statement:
        not_terminal = NotTerminalStatement.query.filter_by(id=statement.id).first()
        terminal = TerminalStatement.query.filter_by(id=statement.id).first()
        if check_terminal_or_not_terminal(terminal) == "not_terminal":
            statements.append(not_terminal)
        elif check_terminal_or_not_terminal(terminal) == "terminal":
            statements.append(terminal)
        else:
            statements.append(statement)
    return statements

def delete_statements_from_rule(rule_id):
    rule = Rule.query.filter_by(id=rule_id).first()
    statements = rule.statement
    for statement in statements:
        db.session.delete(statement)
    db.session.commit()

def iteration_on_chains(rule, chain_id, family, handle=None, rule_id=None):
    if rule_id != None:
        rule_ = Rule.query.filter_by(id=rule_id).first()
        rule_.expr = str(rule["rule"]["expr"])
        db.session.commit()
    elif check_existing_rule(handle=str(rule["rule"]["handle"]), chain_id=chain_id, family=family, expr=rule["rule"]["expr"]) == False :   
        rule_id = insert_rule(handle=str(rule["rule"]["handle"]), chain_id=rule["rule"]["chain"], family=rule["rule"]["family"], expr=str(rule["rule"]["expr"]))
    elif check_existing_rule(handle=str(rule["rule"]["handle"]), chain_id=chain_id, family=family, expr=str(rule["rule"]["expr"])) == True: 
        rule_ = Rule.query.filter_by(handle=str(rule["rule"]["handle"]), chain_id=chain_id, family=family, expr=str(rule["rule"]["expr"])).first()
        rule_id = rule_.id
        rule_.expr = str(rule["rule"]["expr"])
        db.session.commit()
    else:
        rule_id = insert_rule(handle=str(rule["rule"]["handle"]), chain_id=rule["rule"]["chain"], family=rule["rule"]["family"], expr=str(rule["rule"]["expr"]))
    saddr = None
    daddr = None
    sport = None
    dport = None
    accept = None
    drop = None
    reject = None
    log = None
    limit = None
    return_ = None
    jump = None
    masquerade = None
    go_to = None
    queue = None
    counter = None
    protocol = None
    protocol = None
    snat = None
    dnat = None
    input_interface = None
    output_interface = None
    redirect = None
    for j, expr in enumerate(rule["rule"]["expr"]):
        
        if expr.get("match", None) != None and expr.get("match").get("left", None) != None and expr.get("match").get("left").get("payload", None) != None:
            match = expr.get("match")
            payload = match.get("left").get("payload")
            right = match.get("right")
            if payload.get("field") == "saddr":
                saddr = str(right)
            if payload.get("field") == "daddr":
                daddr = str(right)
            if payload.get("field") == "sport":
                sport = str(right)
            if payload.get("field") == "dport":
                dport = str(right)
            if payload.get("protocol", None) != None :
                protocol = str(payload.get("protocol"))
        if expr.get("match", None) != None and expr.get("match").get("left", None) != None and expr.get("match").get("left").get("meta", None) != None and expr.get("match").get("left").get("meta").get("key", None) != None:
            meta = expr.get("match").get("left").get("meta")
            if "iifname" in meta.get("key"): 
                input_interface = str(expr.get("match").get("op") + " " + expr.get("match").get("right"))
            if "oifname" in meta.get("key") :
                output_interface = str(expr.get("match").get("op") + " " + expr.get("match").get("right"))
        if expr.get("counter", None) != None:
            counter = str(expr.get("counter"))
        if "accept" in expr:
            accept = True
        if "drop" in expr:
            drop = True
        if expr.get("reject", None) != None:
            reject = str(expr.get("reject"))
        if expr.get("log", None) != None:
            log = str(expr.get("log"))
        if expr.get("limit", None) != None:
            limit = str(expr.get("limit"))
        if expr.get("snat", None) != None:
            snat = str(expr.get("snat"))
        if expr.get("dnat", None) != None:
            dnat = str(expr.get("dnat"))
        if "redirect" in expr:
            redirect = True
            if expr.get("redirect", None) != None:
                redirect = str(expr.get("redirect"))
        if "masquerade" in expr:
            masquerade = True
        if "return" in expr:
            return_ = True
        if expr.get("jump", None) != None:
            jump = str(expr.get("jump"))
        if expr.get("goto", None) != None:
            go_to = str(expr.get("goto"))
        if expr.get("queue", None) != None:
            queue = str(expr.get("queue"))
    if saddr != None or daddr != None or sport  != None or dport != None or protocol != None or counter != None or limit != None or log != None or reject != None or drop != None or accept != None or queue != None or return_ != None or jump != None or go_to != None or masquerade != None or snat != None or dnat != None or redirect != None or input_interface != None or output_interface != None:
        if str(get_rule(rule_id).handle) == str(handle):
            insert_statement(rule_id=rule_id, sport=sport, dport=dport, saddr=saddr, daddr=daddr, protocol=protocol, accept=accept, drop=drop, reject=reject, log=log, limit=limit, counter=counter, return_=return_, jump=jump, go_to=go_to, queue=queue, masquerade=masquerade, snat=snat, dnat=dnat, redirect=redirect, input_interface=input_interface, output_interface=output_interface)

                
                
def get_statements_from_chain(chain_id, family,  table_id):
    table = Table.query.filter_by(id=table_id, family=family).first()
    chain = Chain.query.filter_by(name=chain_id, table_id=table_id).first()
    rules = chain.rules
    if chain in table.chains:    
        statements = []
        for rule in rules:
            for statement in rule.statement:
                statements.append(statement)
                
    return statements

def get_rules_from_api():
    result = api.list_tables_request()
    return result

def load_data(condicion):
    result_tables = api.list_tables_request()
    result_chains = api.list_chains_request()
    family = []
    names = []
    for line in result_tables.split("table "):
        family.append(line.split(" ")[0])
        variable = line.split(" ")[-1]
        variable = str(variable)
        names.append(variable)
    for i in range(len(names)):
        names[i] = names[i].replace("\n", "")
        if(i != 0) and check_existing_table(names[i], family[i]) == False:
            insert_in_table(names[i], family[i])
    insert_sets()
    insert_maps()
    for item in result_chains["chains"]["nftables"]:
        if("chain" in item):
            if(check_existing_chain(item["chain"]["name"], item["chain"]["table"], item["chain"]["family"]) == True):
                prio = None
                hook = None
                type = None
                if("prio" in item["chain"]):
                    prio = item["chain"]["prio"]
                if("hook" in item["chain"]):
                    hook = item["chain"]["hook"]
                if("policy" not in item["chain"]):
                    item["chain"]["policy"] = None
                if("type" in item["chain"]):
                    type = item["chain"]["type"]
                
                insert_chain(item["chain"]["name"], item["chain"]["family"] ,item["chain"]["policy"], item["chain"]["table"],type=type,  priority=prio, hook_type=hook)
    chains = get_chains()
    for chain in chains:
        result_rules = api.list_chain_request(chain.name, chain.table.family, chain.table.name)
        if(result_rules["rules"] != ""):
            result_rules = result_rules["rules"]["nftables"]
            for i, rule in enumerate(result_rules):
                if i ==0 or i ==1:
                    continue
                else:
                    if check_existing_rule(handle=str(rule["rule"]["handle"]), expr=rule["rule"]["expr"], chain_id=chain.id, family=chain.table.family) == False:
                        insert_rule(handle=str(rule["rule"]["handle"]), chain_id=chain.id, expr=str(rule["rule"]["expr"]))
    return  [Rule.query.count(), Chain.query.count(), Table.query.count()]
    
def get_rule(rule_id):
    rule = Rule.query.filter_by(id=rule_id).first()
    return rule

def delete_all_statements():
    statements = Statement.query.all()
    for statement in statements:
        db.session.delete(statement)
    db.session.commit()

def get_rules_by_chain_and_table(chain_id, family, table):
    chain = get_chain(chain_id, family, table)
    rules = chain.rules
    return rules
def get_rule_by_chain_and_table(chain_id, family, table):
    rule = Rule.query.filter_by(chain_id=chain_id, family=family).first()
    return rule
def get_rule_by_chain_and_handle(chain_id, family, handle):
    rule = Rule.query.filter_by(chain_id=chain_id, family=family, handle=handle).first()
    return rule

def insert_sets():
    result = api.list_sets_request()
    for i, item in enumerate(result):
        if("set" in item):
            table = get_table(item["set"]["table"], item["set"]["family"])
            if(check_existing_set(item["set"]["name"], table.id) == True):
                
                insert_set(item["set"]["name"],table.id, item["set"]["type"])
    return "Success"

def check_existing_set(name, table):
    _set = Set.query.filter_by(name=name, table_id=table).first()
    if _set:
        return False
    return True

def insert_set(name, table_id, type):
    _set = Set(name=name, table_id=table_id, type=type)
    db.session.add(_set)
    db.session.commit()
    
def get_sets():
    return Set.query.all()

def get_set(set_id):
    _set = Set.query.get(set_id)
    return _set

def insert_elements_in_set(set_id, elements):
    _set = get_set(set_id)
    _set.elements = elements
    db.session.commit()
    
def validate_element(element, set_id):
    _set = get_set(set_id)
    
    if element in _set.elements:
        return False
    if _set.type == 'ipv4_addr':
        try:
            ipaddress.IPv4Address(element)
        except ipaddress.AddressValueError:
            return False
    elif _set.type == 'ipv6_addr':
        try:
            ipaddress.IPv6Address(element)
        except ipaddress.AddressValueError:
            return False
    elif _set.type == 'inet_service':
        try:
            if not isinstance(int(element), int) or not (0 <= int(element) <= 65535):
                return False
        except ValueError:
            return False
    elif _set.type == 'inet_proto':
        try:
            if not isinstance(int(element), int) or not (0 <= int(element) <= 255):
                return False
        except ValueError: 
            return False
    elif _set.type == 'mark':
        try:
            if not isinstance(int(element), int):
                return False
        except ValueError:
            return False
    elif _set.type == 'ether_addr':
        if not isinstance(element, str) or not validate_mac_address(element):
            return False
    return True

def validate_mac_address(mac):
    return bool(re.match("^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$", mac))

def insert_set_form(set_name, table, type, description=None):
    if description == "":
        description = None
    if check_existing_set(set_name, table) == False:
        return "Set already exists"
    _set = Set(name=set_name, table_id=table, type=type, description=description)
    db.session.add(_set)
    db.session.commit()

    return "Success"
 
def delete_set(set_id):
    _set = get_set(set_id)
    db.session.delete(_set)
    db.session.commit()
    
def get_elements_from_set(set_id):
    _set = get_set(set_id)
    return _set.elements

def insert_maps():
    result = api.list_maps_request()
    for i, item in enumerate(result):
        if("map" in item):
            table = get_table(item["map"]["table"], item["map"]["family"])
            if(check_existing_map(item["map"]["name"], table.id) == True):
                insert_map(name=item["map"]["name"], table_id=table.id, type=item["map"]["type"], map=item["map"]["map"])
    return "Success"

def check_existing_map(name, table):
    _map = Map.query.filter_by(name=name, table_id=table).first()
    if _map:
        return False
    return True

def insert_map(name, table_id, type, map):
    _map = Map(name=name, table_id=table_id, type=type, map=map)
    db.session.add(_map)
    db.session.commit()
    
def get_maps():
    return Map.query.all()

def insert_elements_in_map(map_id, elements):
    _map = get_map(map_id)
    if(elements != ""):
        list_elements = ast.literal_eval(elements)
        dict_elements = {item[0]: item[1] for item in list_elements}
        _map.elements = str(dict_elements)
    db.session.commit()
    
def get_map(map_id):
    _map = Map.query.get(map_id)
    return _map

def insert_map_form(map_name, table, type, map_type, description=None):
    if description == "":
        description = None
    if check_existing_map(map_name, table) == False:
        return "Map already exists"
    _map = Map(name=map_name, table_id=table, type=type, description=description, map=map_type)
    db.session.add(_map)
    db.session.commit()

    return "Success"

def delete_map(map_id):
    _map = get_map(map_id)
    db.session.delete(_map)
    db.session.commit()
    
def validate_element_map(element , element_map, map_id):
    _map = get_map(map_id)
    if _map.type == 'ipv4_addr':
        try:
            ipaddress.IPv4Address(element)
        except ipaddress.AddressValueError:
            return False
    elif _map.type == 'ipv6_addr':
        try:
            ipaddress.IPv6Address(element)
        except ipaddress.AddressValueError:
            return False
    elif _map.type == 'inet_service':
        try:
            if not isinstance(int(element), int) or not (0 <= int(element) <= 65535):
                return False
        except ValueError:
            return False
    elif _map.type == 'inet_proto':
        try:
            if not isinstance(int(element), int) or not (0 <= int(element) <= 255):
                return False
        except ValueError: 
            return False
    elif _map.type == 'mark':
        try:
            if not isinstance(int(element), int):
                return False
        except ValueError:
            return False
    elif _map.type == 'ether_addr':
        if not isinstance(element, str) or not validate_mac_address(element):
            return False
    elif _map.map == 'ipv4_addr':
        try:
            ipaddress.IPv4Address(element_map)
        except ipaddress.AddressValueError:
            return False
    elif _map.map == 'ipv6_addr':
        try:
            ipaddress.IPv6Address(element_map)
        except ipaddress.AddressValueError:
            return False
    elif _map.map == 'inet_service':
        try:
            if not isinstance(int(element_map), int) or not (0 <= int(element_map) <= 65535):
                return False
        except ValueError:
            return False
    elif _map.map == 'inet_proto':
        try:
            if not isinstance(int(element_map), int) or not (0 <= int(element_map) <= 255):
                return False
        except ValueError: 
            return False
    elif _map.map == 'mark':
        try:
            if not isinstance(int(element_map), int):
                return False
        except ValueError:
            return False
    elif _map.map == 'ether_addr':
        if not isinstance(element_map, str) or not validate_mac_address(element_map):
            return False
    return True

def get_elements_from_map(map_id):
    _map = get_map(map_id)
    return _map.elements

def  delete_element_from_map(map_id, element):
    _map = get_map(map_id)
    elements = _map.elements
    if elements != "" and elements != None:
        elements = ast.literal_eval(elements)
        elements.pop(element)
        _map.elements = str(elements)
        db.session.commit()
    
def get_element_from_map(map_id, element):
    _map = get_map(map_id)
    elements = _map.elements
    if elements != "" and elements != None:
        elements = ast.literal_eval(elements)
    else:
        return "" 
    return elements[element]

def delete_all_data():
    meta = db.metadata
    for table in reversed(meta.sorted_tables):
        if table.name != 'user':
            db.session.execute(table.delete())
    db.session.commit()
    
def get_objects():
    names = [] 
    set_ = Set.query.all()
    map_ = Map.query.all()
    for item in set_:
        names.append(item)
    for item in map_:
        names.append(item)
    return names
        
def check_set_or_map(name):
    _set = Set.query.filter_by(name=name).first()
    _map = Map.query.filter_by(name=name).first()
    if _set:
        return _set.type
    if _map:
        return _map.type
    return None
    
def save_changes_on_file():
    files = glob.glob("./temp_config/nftables_temp*.conf")
    numbers = [int(f.replace("./temp_config/nftables_temp", "").replace(".conf", "")) for f in files]
    highest_number = max(numbers) if numbers else 0
    os.system(f"sudo nft list ruleset > ./temp_config/nftables_temp{highest_number + 1}.conf")
    
def delete_all_data_except_users():
    meta = db.metadata
    for table in reversed(meta.sorted_tables):
        if table.name != 'user':
            db.session.execute(table.delete())
    db.session.commit()
    
def create_list(name, family, table_name, type, elements):
    if check_existing_set(name, table_name) == False:
        return "Set already exists"
    _set = Set(name=name, table_id=table_name, type=type)
    if elements != "" or elements != None:
        elements = str(elements)
        _set.elements = elements
    db.session.add(_set)
    db.session.commit()
    return "Success"

def reload_service():
    delete_all_data_except_users
    os.system("sudo systemctl restart nftables")
    
def edit_description(rule_id, descripcion):
    rule = Rule.query.filter_by(id=rule_id).first()
    rule.description = descripcion
    db.session.commit()
=== ./background/nftables-gui/nftables-frontend/tests/test_chains.py ===

import pytest
from app import create_app
from models import db, User
from unittest.mock import patch
from api import parse_chains

@pytest.fixture()
def app():
    app = create_app()
    app.config.update({
        "TESTING": True,
        "WTF_CSRF_ENABLED": False,
        "SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:"

    })
    with app.app_context():
        db.create_all()  # Crear las tablas de la base de datos
    yield app
    with app.app_context():
        db.drop_all()


@pytest.fixture()
def client(app):
    return app.test_client()

@pytest.fixture()
def runner(app):
    return app.test_cli_runner()

@pytest.fixture()
def init_database():
    meta = db.metadata
    for table in reversed(meta.sorted_tables):
        db.session.execute(table.delete())
    user = User(username='default', password='defaultpassword')
    db.session.add(user)
    db.session.commit()

@pytest.fixture()
def logged_in_client(client):
    data = {"username": "default", "password": "defaultpassword"}
    client.post('/login', data=data)
    return client
@pytest.fixture()
@patch('api.create_table_request')
def created_table(mock_create_table_request, logged_in_client):
    data = {"name": "creada", "family": "inet", "description": "filter table"}
    mock_create_table_request.return_value = "Success"
    logged_in_client.post('/add_table', data=data)
    return logged_in_client

@patch('api.create_chain_request')
@patch('api.create_table_request')
def test_create_chain(mock_create_chain_request, mock_create_table_request ,logged_in_client):
    data = {"name": "creada", "family": "inet", "description": "filter table"}
    mock_create_table_request.return_value = "Success"
    logged_in_client.post('/add_table', data=data)
    mock_create_chain_request.return_value = "Success"
    data = {"table": "1&&inet", "name": "chain1", "policy": "accept", "family": "inet"}
    response = logged_in_client.post('/create_chain/', data=data)
    mock_create_chain_request.assert_called_once()
    assert response.status_code == 302
    assert response.location == '/chains'
    
def test_create_chain_view(logged_in_client):
    response = logged_in_client.get('/create_chain')
    assert response.status_code == 200
    
def test_create_base_chain_view(logged_in_client):
    response = logged_in_client.get('/create_base_chain')
    assert response.status_code == 200
    
@patch('api.create_base_chain_request')
def test_create_base_chain(mock_create_base_chain_request, created_table):
    mock_create_base_chain_request.return_value = "Success"
    data = {"table": "inet&&1", "name": "chain1", "family": "inet", "type": "filter", "hook_type": "input", "prio": 0, "policy": "accept"}
    response = created_table.post('/create_base_chain/', data=data)
    assert response.status_code == 302
    assert response.location == '/chains'
    mock_create_base_chain_request.assert_called_once()

    
@patch('api.create_chain_request')
@patch('api.list_chains_request')   
@patch('api.flush_chain_request')
def test_flush_chain(mock_flush_chain_request, mock_list_chains_request, mock_create_chain_request, created_table):
    mock_create_chain_request.return_value = "Success"
    data = {"table": "1&&inet", "name": "chain1", "policy": "accept", "family": "inet"}
    created_table.post('/create_chain/', data=data)
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "creada", "name": "chain1", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}]}}
    mock_list_chains_request.return_value = chains
    created_table.get('/chains')
    mock_list_chains_request.assert_called_once()
    response = created_table.get('/chains/1/creada/flush') 
    assert response.status_code == 302
    mock_flush_chain_request.assert_called_once()
    
@patch('api.create_chain_request')
@patch('api.list_chains_request')
def test_list_chains(mock_list_chains_request, mock_create_chain_request, created_table):
    mock_create_chain_request.return_value = "Success"
    data = {"table": "1&&inet", "name": "chain1", "policy": "accept", "family": "inet"}
    created_table.post('/create_chain/', data=data)
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "creada", "name": "chain1", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}]}}
    mock_list_chains_request.return_value = chains
    response = created_table.get('/chains')
    assert response.status_code == 200
    assert b'Chains' in response.data
    assert b'chain1' in response.data
    
@patch('api.create_chain_request')
@patch('api.list_chains_request')
def test_view_chain(mock_list_chains_request, mock_create_chain_request, created_table):
    mock_create_chain_request.return_value = "Success"
    data = {"table": "1&&inet", "name": "chain1", "policy": "accept", "family": "inet"}
    created_table.post('/create_chain/', data=data)
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "creada", "name": "chain1", "handle": 1, "type": "filter", "prio": 0, "policy": "accept"}}]}}
    mock_list_chains_request.return_value = chains
    created_table.get('/chains')
    response = created_table.get('/chain/chain1/inet/1')
    assert response.status_code == 200
    assert b'Chain' in response.data
    assert b'chain1' in response.data
    assert b'accept' in response.data
    assert b'0' in response.data
    
@patch('api.create_chain_request')
@patch('api.delete_chain_request')
@patch('api.list_chains_request')
def test_delete_chain(mock_list_chains_request, mock_delete_chain_request, mock_create_chain_request, created_table):
    mock_create_chain_request.return_value = "Success"
    data = {"table": "1&&inet", "name": "chain1", "policy": "accept", "family": "inet"}
    created_table.post('/create_chain/', data=data)
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "creada", "name": "chain1", "handle": 1, "type": "filter", "prio": 0, "policy": "accept"}}]}}
    mock_list_chains_request.return_value = chains
    created_table.get('/chains')
    response = created_table.get('/chains/1/creada/delete')
    assert response.status_code == 302
    mock_delete_chain_request.assert_called_once()
=== ./background/nftables-gui/nftables-frontend/tests/test_main.py ===

import pytest
from app import create_app
from models import db, User
from unittest.mock import patch

@pytest.fixture()
def app():
    app = create_app()
    app.config.update({
        "TESTING": True,
        "WTF_CSRF_ENABLED": False, 
        "SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:"

    })
    with app.app_context():
        db.create_all()  # Crear las tablas de la base de datos
    yield app
    with app.app_context():
        db.drop_all()  # Limpiar después de cada prueba
    
    
@pytest.fixture()
def client(app):
    return app.test_client()

@pytest.fixture()
def runner(app):
    return app.test_cli_runner()

@pytest.fixture()
def init_database():
    user = User(username='default', password='defaultpassword')
    db.session.add(user)
    db.session.commit()
    
@pytest.fixture()    
def logued_client(client):
    data = {"username": "default", "password": "defaultpassword"}
    client.post('/login', data=data)
    return client

@patch('api.list_tables_request')
@patch('api.list_chains_request')
@patch('api.list_sets_request')
@patch('api.list_maps_request')
@patch('api.list_chain_request')
@pytest.mark.order("last")
def test_main_login(mock_list_chain_request,mock_list_maps_request, mock_list_sets_request , mock_list_chains_requests, mock_list_tables_request , logued_client):
    tables = {"tables": "table inet filter\ntable ip nat\ntable ip filter\n"}
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "filter", "name": "input", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "forward", "handle": 2, "type": "filter", "hook": "forward", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "output", "handle": 3, "type": "filter", "hook": "output", "prio": 0, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "nat", "name": "POSTROUTING", "handle": 2, "type": "nat", "hook": "postrouting", "prio": 100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "PREROUTING", "handle": 3, "type": "nat", "hook": "prerouting", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "OUTPUT", "handle": 4, "type": "nat", "hook": "output", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-1", "handle": 2}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-USER", "handle": 5}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-2", "handle": 40}}]}}
    sets = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 4}}]}, ""]
    maps = [0, {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"map": {"family": "ip", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 62, "map": "ipv4_addr"}}]}}]
    mock_list_sets_request.return_value = sets[1]["nftables"]
    mock_list_maps_request.return_value = maps[1]["chains"]["nftables"]
    mock_list_chain_request.return_value ={"rules": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 61, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 58, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 57, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"xt": None}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 56, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 55, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 54, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 50, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"xt": None}, {"counter": {"packets": 136, "bytes": 41906}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 20, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 21, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 22, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 23, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 24, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 25, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 26, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 27, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 28, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 29, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 30, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 31, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 32, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 33, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 34, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 35, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 36, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 37, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"accept": None}]}}]}}
    mock_list_chains_requests.return_value = chains
    mock_list_tables_request.return_value = tables["tables"]
    response = logued_client.get('/')
    assert response.status_code == 200
    mock_list_tables_request.assert_called_once()
    mock_list_chain_request.assert_called()
    mock_list_chains_requests.assert_called_once()
    mock_list_sets_request.assert_called_once()
    mock_list_maps_request.assert_called_once()
    
    
    
@patch('api.list_ruleset_request')
def test_list_ruleset(mock_list_ruleset_request, logued_client):
    ruleset = {"rules": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 61, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 58, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 57, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"xt": None}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 56, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}]}}
    mock_list_ruleset_request.return_value = ruleset
    response = logued_client.get('/list_ruleset')
    assert response.status_code == 200
    mock_list_ruleset_request.assert_called_once()
    
@patch('api.list_ruleset_request')
@patch('api.list_tables_request')
@patch('api.list_chains_request')
@patch('api.list_sets_request')
@patch('api.list_maps_request')
@patch('api.list_chain_request')
def test_list_ruleset_post(mock_list_chain_request,mock_list_maps_request, mock_list_sets_request , mock_list_chains_requests, mock_list_tables_request, mock_list_ruleset_request , logued_client):
    ruleset = {"rules": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 61, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 58, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 57, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"xt": None}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 56, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}]}}
    mock_list_ruleset_request.return_value = ruleset
    tables = {"tables": "table inet filter\ntable ip nat\ntable ip filter\n"}
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "filter", "name": "input", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "forward", "handle": 2, "type": "filter", "hook": "forward", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "output", "handle": 3, "type": "filter", "hook": "output", "prio": 0, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "nat", "name": "POSTROUTING", "handle": 2, "type": "nat", "hook": "postrouting", "prio": 100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "PREROUTING", "handle": 3, "type": "nat", "hook": "prerouting", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "OUTPUT", "handle": 4, "type": "nat", "hook": "output", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-1", "handle": 2}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-USER", "handle": 5}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-2", "handle": 40}}]}}
    sets = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 4}}]}, ""]
    maps = [0, {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"map": {"family": "ip", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 62, "map": "ipv4_addr"}}]}}]
    mock_list_sets_request.return_value = sets[1]["nftables"]
    mock_list_maps_request.return_value = maps[1]["chains"]["nftables"]
    mock_list_chain_request.return_value ={"rules": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 61, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 58, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 57, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"xt": None}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 56, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 55, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 54, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 50, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"xt": None}, {"counter": {"packets": 136, "bytes": 41906}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 20, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 21, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 22, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 23, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 24, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 25, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 26, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 27, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 28, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 29, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 30, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 31, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 32, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 33, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 34, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 35, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 36, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 37, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"accept": None}]}}]}}
    mock_list_chains_requests.return_value = chains
    mock_list_tables_request.return_value = tables["tables"]    
    response = logued_client.post('/list_ruleset')
    assert response.status_code == 200
    mock_list_tables_request.assert_called_once()

=== ./background/nftables-gui/nftables-frontend/tests/test_maps.py ===

import pytest
from app import create_app
from models import db, User
from unittest.mock import patch
from api import parse_chains

@pytest.fixture()
def app():
    app = create_app()
    app.config.update({
        "TESTING": True,
        "WTF_CSRF_ENABLED": False,
        "SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:"

    })
    with app.app_context():
        db.create_all()  # Crear las tablas de la base de datos
    yield app
    with app.app_context():
        db.drop_all()


@pytest.fixture()
def client(app):
    return app.test_client()

@pytest.fixture()
def runner(app):
    return app.test_cli_runner()

@pytest.fixture()
def init_database():
    meta = db.metadata
    for table in reversed(meta.sorted_tables):
        db.session.execute(table.delete())
    user = User(username='default', password='defaultpassword')
    db.session.add(user)
    db.session.commit()

@pytest.fixture()
def logged_in_client(client):
    data = {"username": "default", "password": "defaultpassword"}
    client.post('/login', data=data)
    return client

def test_create_map_view(logged_in_client):
    response = logged_in_client.get('/maps/new')
    assert response.status_code == 200
 
@patch('api.list_tables_request')
@patch('api.list_chains_request')
@patch('api.list_sets_request')
@patch('api.list_maps_request')
@patch('api.list_chain_request')   
def test_list_maps(mock_list_chain_request,mock_list_maps_request, mock_list_sets_request , mock_list_chains_requests, mock_list_tables_request , logged_in_client):
    tables = {"tables": "table inet filter\ntable ip nat\ntable ip filter\n"}
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "filter", "name": "input", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "forward", "handle": 2, "type": "filter", "hook": "forward", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "output", "handle": 3, "type": "filter", "hook": "output", "prio": 0, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "nat", "name": "POSTROUTING", "handle": 2, "type": "nat", "hook": "postrouting", "prio": 100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "PREROUTING", "handle": 3, "type": "nat", "hook": "prerouting", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "OUTPUT", "handle": 4, "type": "nat", "hook": "output", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-1", "handle": 2}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-USER", "handle": 5}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-2", "handle": 40}}]}}
    sets = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 4}}]}, ""]
    maps = [0, {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"map": {"family": "ip", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 62, "map": "ipv4_addr"}}]}}]
    mock_list_sets_request.return_value = sets[1]["nftables"]
    mock_list_maps_request.return_value = maps[1]["chains"]["nftables"]
    mock_list_chain_request.return_value ={"rules": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 61, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 58, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 57, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"xt": None}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 56, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 55, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 54, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 50, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"xt": None}, {"counter": {"packets": 136, "bytes": 41906}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 20, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 21, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 22, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 23, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 24, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 25, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 26, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 27, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 28, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 29, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 30, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 31, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 32, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 33, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 34, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 35, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 36, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 37, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"accept": None}]}}]}}
    mock_list_chains_requests.return_value = chains
    mock_list_tables_request.return_value = tables["tables"]
    logged_in_client.get('/')
    response = logged_in_client.get('/maps')
    assert response.status_code == 200
    
@patch('api.list_tables_request')
@patch('api.list_chains_request')
@patch('api.list_sets_request')
@patch('api.list_maps_request')
@patch('api.list_chain_request')   
@patch('api.list_elements_in_map')
def test_get_map(mock_list_element_in_map ,mock_list_chain_request,mock_list_maps_request, mock_list_sets_request , mock_list_chains_requests, mock_list_tables_request , logged_in_client):
    tables = {"tables": "table inet filter\ntable ip nat\ntable ip filter\n"}
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "filter", "name": "input", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "forward", "handle": 2, "type": "filter", "hook": "forward", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "output", "handle": 3, "type": "filter", "hook": "output", "prio": 0, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "nat", "name": "POSTROUTING", "handle": 2, "type": "nat", "hook": "postrouting", "prio": 100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "PREROUTING", "handle": 3, "type": "nat", "hook": "prerouting", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "OUTPUT", "handle": 4, "type": "nat", "hook": "output", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-1", "handle": 2}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-USER", "handle": 5}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-2", "handle": 40}}]}}
    sets = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 4}}]}, ""]
    maps = [0, {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"map": {"family": "ip", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 62, "map": "ipv4_addr"}}]}}]
    mock_list_sets_request.return_value = sets[1]["nftables"]
    mock_list_maps_request.return_value = maps[1]["chains"]["nftables"]
    mock_list_chain_request.return_value ={"rules": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 61, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 58, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 57, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"xt": None}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 56, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 55, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 54, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 50, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"xt": None}, {"counter": {"packets": 136, "bytes": 41906}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 20, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 21, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 22, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 23, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 24, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 25, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 26, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 27, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 28, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 29, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 30, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 31, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 32, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 33, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 34, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 35, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 36, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 37, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"accept": None}]}}]}}
    mock_list_chains_requests.return_value = chains
    mock_list_tables_request.return_value = tables["tables"]
    logged_in_client.get('/')
    logged_in_client.get('/maps')
    response = logged_in_client.get('/maps/1')
    assert response.status_code == 200
    
@patch('api.list_tables_request')
@patch('api.list_chains_request')
@patch('api.list_sets_request')
@patch('api.list_maps_request')
@patch('api.list_chain_request')   
@patch('api.list_elements_in_map')
@patch('api.add_element_to_map_request')
def test_add_element_map(mock_add_element_to_map_request,mock_list_element_in_map ,mock_list_chain_request,mock_list_maps_request, mock_list_sets_request , mock_list_chains_requests, mock_list_tables_request , logged_in_client):
    tables = {"tables": "table inet filter\ntable ip nat\ntable ip filter\n"}
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "filter", "name": "input", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "forward", "handle": 2, "type": "filter", "hook": "forward", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "output", "handle": 3, "type": "filter", "hook": "output", "prio": 0, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "nat", "name": "POSTROUTING", "handle": 2, "type": "nat", "hook": "postrouting", "prio": 100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "PREROUTING", "handle": 3, "type": "nat", "hook": "prerouting", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "OUTPUT", "handle": 4, "type": "nat", "hook": "output", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-1", "handle": 2}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-USER", "handle": 5}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-2", "handle": 40}}]}}
    sets = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 4}}]}, ""]
    maps = [0, {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"map": {"family": "ip", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 62, "map": "ipv4_addr"}}]}}]
    mock_list_sets_request.return_value = sets[1]["nftables"]
    mock_list_maps_request.return_value = maps[1]["chains"]["nftables"]
    mock_list_chain_request.return_value ={"rules": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 61, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 58, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 57, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"xt": None}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 56, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 55, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 54, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 50, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"xt": None}, {"counter": {"packets": 136, "bytes": 41906}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 20, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 21, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 22, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 23, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 24, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 25, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 26, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 27, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 28, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 29, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 30, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 31, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 32, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 33, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 34, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 35, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 36, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 37, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"accept": None}]}}]}}
    mock_list_chains_requests.return_value = chains
    mock_list_tables_request.return_value = tables["tables"]
    logged_in_client.get('/')
    logged_in_client.get('/maps')
    logged_in_client.get('/maps/1')
    mock_add_element_to_map_request.return_value = "Success"
    response = logged_in_client.post('/maps/1/add_element', data={"key": "32.53.23.43", "value": "84.23.67.12"})
    assert response.status_code == 302
    assert response.location == '/maps/1'       

def test_add_element_map_view(logged_in_client):
    response = logged_in_client.get('/maps/1/add_element')
    assert response.status_code == 200
    
@patch('api.list_tables_request')
@patch('api.list_chains_request')
@patch('api.list_sets_request')
@patch('api.list_maps_request')
@patch('api.list_chain_request')   
@patch('api.list_elements_in_map')
@patch('api.add_element_to_map_request')
@patch('api.delete_element_from_map_request')
def test_delete_element_map(mock_delete_element_from_map_request, mock_add_element_to_map_request,mock_list_element_in_map ,mock_list_chain_request,mock_list_maps_request, mock_list_sets_request , mock_list_chains_requests, mock_list_tables_request , logged_in_client):
    tables = {"tables": "table inet filter\ntable ip nat\ntable ip filter\n"}
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "filter", "name": "input", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "forward", "handle": 2, "type": "filter", "hook": "forward", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "output", "handle": 3, "type": "filter", "hook": "output", "prio": 0, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "nat", "name": "POSTROUTING", "handle": 2, "type": "nat", "hook": "postrouting", "prio": 100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "PREROUTING", "handle": 3, "type": "nat", "hook": "prerouting", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "OUTPUT", "handle": 4, "type": "nat", "hook": "output", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-1", "handle": 2}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-USER", "handle": 5}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-2", "handle": 40}}]}}
    sets = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 4}}]}, ""]
    maps = [0, {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"map": {"family": "ip", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 62, "map": "ipv4_addr"}}]}}]
    mock_list_sets_request.return_value = sets[1]["nftables"]
    mock_list_maps_request.return_value = maps[1]["chains"]["nftables"]
    mock_list_chain_request.return_value ={"rules": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 61, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 58, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 57, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"xt": None}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 56, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 55, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 54, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 50, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"xt": None}, {"counter": {"packets": 136, "bytes": 41906}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 20, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 21, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 22, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 23, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 24, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 25, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 26, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 27, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 28, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 29, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 30, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 31, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 32, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 33, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 34, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 35, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 36, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 37, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"accept": None}]}}]}}
    mock_list_chains_requests.return_value = chains
    mock_list_tables_request.return_value = tables["tables"]
    logged_in_client.get('/')
    logged_in_client.get('/maps')
    logged_in_client.get('/maps/1')
    mock_add_element_to_map_request.return_value = "Success"
    logged_in_client.post('/maps/1/add_element', data={"key": "32.53.23.43", "value": "84.23.67.12"})
    mock_delete_element_from_map_request.return_value = "Success"
    logged_in_client.get('/maps/1')

    response = logged_in_client.post('/maps/1/delete_element', data={"key": "32.53.23.43"})
    assert response.status_code == 302
    assert response.location == '/maps/1'

@patch('api.list_tables_request')
@patch('api.list_chains_request')
@patch('api.list_sets_request')
@patch('api.list_maps_request')
@patch('api.list_chain_request')   
@patch('api.list_elements_in_map')
def test_delete_element_map_view(mock_list_element_in_map ,mock_list_chain_request,mock_list_maps_request, mock_list_sets_request , mock_list_chains_requests, mock_list_tables_request , logged_in_client):
    tables = {"tables": "table inet filter\ntable ip nat\ntable ip filter\n"}
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "filter", "name": "input", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "forward", "handle": 2, "type": "filter", "hook": "forward", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "output", "handle": 3, "type": "filter", "hook": "output", "prio": 0, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "nat", "name": "POSTROUTING", "handle": 2, "type": "nat", "hook": "postrouting", "prio": 100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "PREROUTING", "handle": 3, "type": "nat", "hook": "prerouting", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "OUTPUT", "handle": 4, "type": "nat", "hook": "output", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-1", "handle": 2}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-USER", "handle": 5}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-2", "handle": 40}}]}}
    sets = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 4}}]}, ""]
    maps = [0, {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"map": {"family": "ip", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 62, "map": "ipv4_addr"}}]}}]
    mock_list_sets_request.return_value = sets[1]["nftables"]
    mock_list_maps_request.return_value = maps[1]["chains"]["nftables"]
    mock_list_chain_request.return_value ={"rules": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 61, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 58, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 57, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"xt": None}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 56, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 55, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 54, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 50, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"xt": None}, {"counter": {"packets": 136, "bytes": 41906}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 20, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 21, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 22, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 23, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 24, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 25, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 26, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 27, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 28, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 29, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 30, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 31, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 32, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 33, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 34, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 35, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 36, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 37, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"accept": None}]}}]}}
    mock_list_chains_requests.return_value = chains
    mock_list_tables_request.return_value = tables["tables"]
    logged_in_client.get('/')
    logged_in_client.get('/maps/1')
    response = logged_in_client.get('/maps/1/delete_element')
    assert response.status_code == 200
    
@patch('api.list_tables_request')
@patch('api.list_chains_request')
@patch('api.list_sets_request')
@patch('api.list_maps_request')
@patch('api.list_chain_request')   
@patch('api.create_map_request')
def test_create_map(mock_create_map_request ,mock_list_chain_request,mock_list_maps_request, mock_list_sets_request , mock_list_chains_requests, mock_list_tables_request , logged_in_client):
    tables = {"tables": "table inet filter\ntable ip nat\ntable ip filter\n"}
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "filter", "name": "input", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "forward", "handle": 2, "type": "filter", "hook": "forward", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "output", "handle": 3, "type": "filter", "hook": "output", "prio": 0, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "nat", "name": "POSTROUTING", "handle": 2, "type": "nat", "hook": "postrouting", "prio": 100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "PREROUTING", "handle": 3, "type": "nat", "hook": "prerouting", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "OUTPUT", "handle": 4, "type": "nat", "hook": "output", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-1", "handle": 2}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-USER", "handle": 5}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-2", "handle": 40}}]}}
    sets = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 4}}]}, ""]
    maps = [0, {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"map": {"family": "ip", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 62, "map": "ipv4_addr"}}]}}]
    mock_list_sets_request.return_value = sets[1]["nftables"]
    mock_list_maps_request.return_value = maps[1]["chains"]["nftables"]
    mock_list_chain_request.return_value ={"rules": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 61, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 58, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 57, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"xt": None}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 56, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 55, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 54, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 50, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"xt": None}, {"counter": {"packets": 136, "bytes": 41906}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 20, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 21, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 22, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 23, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 24, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 25, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 26, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 27, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 28, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 29, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 30, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 31, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 32, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 33, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 34, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 35, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 36, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 37, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"accept": None}]}}]}}
    mock_list_chains_requests.return_value = chains
    mock_list_tables_request.return_value = tables["tables"]
    logged_in_client.get('/')
    mock_create_map_request.return_value = "Success"
    response = logged_in_client.post('/maps/new', data={"table": "1&&inet", "name": "my_map", "type": "ipv4_addr", "map_type": "ipv4_addr"})
    assert response.status_code == 302
    assert response.location == '/maps'
=== ./background/nftables-gui/nftables-frontend/tests/test_rules.py ===

import pytest
from app import create_app
from models import db, User
from unittest.mock import patch
from api import parse_chains
from flask import request
from forms.forms import RuleForm, NotTerminalStatementForm
import views

@pytest.fixture()
def app():
    app = create_app()
    app.config.update({
        "TESTING": True,
        "WTF_CSRF_ENABLED": False,
        "SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:"

    })
    with app.app_context():
        db.create_all()  # Crear las tablas de la base de datos
    yield app
    with app.app_context():
        db.drop_all()


@pytest.fixture()
def client(app):
    return app.test_client()

@pytest.fixture()
def runner(app):
    return app.test_cli_runner()

@pytest.fixture()
def init_database():
    meta = db.metadata
    for table in reversed(meta.sorted_tables):
        db.session.execute(table.delete())
    user = User(username='default', password='defaultpassword')
    db.session.add(user)
    db.session.commit()

@pytest.fixture()
def logged_in_client(client):
    data = {"username": "default", "password": "defaultpassword"}
    client.post('/login', data=data)
    return client

@pytest.fixture()
@patch('api.create_table_request')
@patch('api.create_chain_request')
def created_chain(mock_create_chain_request ,mock_create_table_request, logged_in_client):
    data = {"name": "creada", "family": "inet", "description": "filter table"}
    mock_create_table_request.return_value = "Success"
    logged_in_client.post('/add_table', data=data)
    mock_create_chain_request.return_value = "Success"
    data = {"table": "1&&inet", "name": "chain1", "policy": "accept", "family": "inet"}
    logged_in_client.post('/create_chain/', data=data)
    return logged_in_client

def test_create_rule_view(logged_in_client):
    response = logged_in_client.get('/rules/create_rule')
    assert response.status_code == 200
    assert b"Create Rule" in response.data

@patch('api.list_tables_request')
@patch('api.list_chains_request')
@patch('api.list_sets_request')
@patch('api.list_maps_request')
@patch('api.list_chain_request')            
@patch('api.create_rule_request')
def test_create_rule_error(mock_create_rule_request, mock_list_chain_request,mock_list_maps_request, mock_list_sets_request , mock_list_chains_requests, mock_list_tables_request, created_chain, app):
    tables = {"tables": "table inet creada\ntable ip nat\ntable ip filter\n"}
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "creada", "name": "filter1", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}]}}
    sets = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "creada", "type": "ipv4_addr", "handle": 4}}]}, ""]
    maps = [0, {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"map": {"family": "inet", "name": "my_map", "table": "creada", "type": "ipv4_addr", "handle": 62, "map": "ipv4_addr"}}]}}]
    mock_list_sets_request.return_value = sets[1]["nftables"]
    mock_list_maps_request.return_value = maps[1]["chains"]["nftables"]
    mock_list_chain_request.return_value ={"rules": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 61, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 58, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 57, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"xt": None}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 56, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 55, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 54, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 50, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"xt": None}, {"counter": {"packets": 136, "bytes": 41906}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 20, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 21, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 22, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 23, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 24, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 25, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 26, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 27, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 28, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 29, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 30, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 31, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 32, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 33, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 34, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 35, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 36, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 37, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"accept": None}]}}]}}
    mock_list_chains_requests.return_value = chains
    mock_list_tables_request.return_value = tables["tables"]
    created_chain.get('/')
    with app.test_request_context('/rules/create_rule'):
            request.form = {
                "chain": "1&&inet&&creada&&chain1",
                "handle": None,
                "statements": {
                    "counter": True
                },
                "statement_select": "not_terminal",
                "description": "rule1 description",
                "submit": True
            }
            mock_create_rule_request.return_value = "Success", [{'counter': True}] 

            response = views.create_rule_post()
            assert "<h1>Create Rule</h1>" in response
           
@patch('api.list_tables_request')
@patch('api.list_chains_request')
@patch('api.list_sets_request')
@patch('api.list_maps_request')
@patch('api.list_chain_request')            
@patch('api.create_rule_request')
def test_create_rule_post(mock_create_rule_request, mock_list_chain_request,mock_list_maps_request, mock_list_sets_request , mock_list_chains_requests, mock_list_tables_request, created_chain, app):
    tables = {"tables": "table inet creada\ntable ip nat\ntable ip filter\n"}
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "creada", "name": "filter1", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}]}}
    sets = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "creada", "type": "ipv4_addr", "handle": 4}}]}, ""]
    maps = [0, {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"map": {"family": "inet", "name": "my_map", "table": "creada", "type": "ipv4_addr", "handle": 62, "map": "ipv4_addr"}}]}}]
    mock_list_sets_request.return_value = sets[1]["nftables"]
    mock_list_maps_request.return_value = maps[1]["chains"]["nftables"]
    mock_list_chain_request.return_value ={"rules": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 61, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 58, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 57, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"xt": None}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 56, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 55, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 54, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 50, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"xt": None}, {"counter": {"packets": 136, "bytes": 41906}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 20, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 21, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 22, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 23, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 24, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 25, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 26, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 27, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 28, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 29, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 30, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 31, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 32, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 33, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 34, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 35, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 36, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 37, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"accept": None}]}}]}}
    mock_list_chains_requests.return_value = chains
    mock_list_tables_request.return_value = tables["tables"]
    created_chain.get('/')
    with app.test_request_context('/rules/create_rule'):
        request.form = {
            "chain": "1&&inet&&creada&&chain1",
            "handle": None,
            "statements": {
                "counter": True,
                "log": "log_prefix",
                
                
            },
            "statements_term": {
                "drop": True,
                "accept": True,
                "reject": "icmp-port-unreachable",
                "return": True,
                "queue": "num 1",
                "jump": "--Selects--",
                "go_to": "--Selects--"
                
            },
            "statement_select": "terminal",
            "description": "rule1 description",
            "submit": True
        }
        mock_create_rule_request.return_value = [{'counter': True}],"Success"

        response = views.create_rule_post()
        assert response.status_code == 302
        assert response.location == "/rules"

@patch('api.list_tables_request')
@patch('api.list_chains_request')
@patch('api.list_sets_request')
@patch('api.list_maps_request')
@patch('api.list_chain_request')
def test_list_rules(mock_list_chain_request,mock_list_maps_request, mock_list_sets_request , mock_list_chains_requests, mock_list_tables_request , logged_in_client):
    tables = {"tables": "table inet filter\ntable ip nat\ntable ip filter\n"}
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "filter", "name": "input", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "forward", "handle": 2, "type": "filter", "hook": "forward", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "output", "handle": 3, "type": "filter", "hook": "output", "prio": 0, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "nat", "name": "POSTROUTING", "handle": 2, "type": "nat", "hook": "postrouting", "prio": 100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "PREROUTING", "handle": 3, "type": "nat", "hook": "prerouting", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "OUTPUT", "handle": 4, "type": "nat", "hook": "output", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-1", "handle": 2}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-USER", "handle": 5}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-2", "handle": 40}}]}}
    sets = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 4}}]}, ""]
    maps = [0, {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"map": {"family": "ip", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 62, "map": "ipv4_addr"}}]}}]
    mock_list_sets_request.return_value = sets[1]["nftables"]
    mock_list_maps_request.return_value = maps[1]["chains"]["nftables"]
    mock_list_chain_request.return_value ={"rules": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 61, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 58, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 57, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"xt": None}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 56, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 55, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 54, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 50, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"xt": None}, {"counter": {"packets": 136, "bytes": 41906}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 20, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 21, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 22, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 23, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 24, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 25, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 26, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 27, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 28, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 29, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 30, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 31, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 32, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 33, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 34, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 35, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 36, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 37, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"accept": None}]}}]}}
    mock_list_chains_requests.return_value = chains
    mock_list_tables_request.return_value = tables["tables"]
    response = logged_in_client.get('/rules')
    assert response.status_code == 200
    response = logged_in_client.get('/rules/1')
    assert response.status_code == 200
    
@patch('api.list_tables_request')
@patch('api.list_chains_request')
@patch('api.list_sets_request')
@patch('api.list_maps_request')
@patch('api.list_chain_request')
@patch('api.delete_rule_request')
def test_delete_rule(mock_delete_rule_request,mock_list_chain_request,mock_list_maps_request, mock_list_sets_request , mock_list_chains_requests, mock_list_tables_request , logged_in_client):
    tables = {"tables": "table inet filter\ntable ip nat\ntable ip filter\n"}
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "filter", "name": "input", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "forward", "handle": 2, "type": "filter", "hook": "forward", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "output", "handle": 3, "type": "filter", "hook": "output", "prio": 0, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "nat", "name": "POSTROUTING", "handle": 2, "type": "nat", "hook": "postrouting", "prio": 100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "PREROUTING", "handle": 3, "type": "nat", "hook": "prerouting", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "OUTPUT", "handle": 4, "type": "nat", "hook": "output", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-1", "handle": 2}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-USER", "handle": 5}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-2", "handle": 40}}]}}
    sets = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 4}}]}, ""]
    maps = [0, {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"map": {"family": "ip", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 62, "map": "ipv4_addr"}}]}}]
    mock_list_sets_request.return_value = sets[1]["nftables"]
    mock_list_maps_request.return_value = maps[1]["chains"]["nftables"]
    mock_list_chain_request.return_value ={"rules": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 61, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 58, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 57, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"xt": None}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 56, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 55, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 54, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 50, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"xt": None}, {"counter": {"packets": 136, "bytes": 41906}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 20, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 21, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 22, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 23, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 24, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 25, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 26, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 27, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 28, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 29, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 30, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 31, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 32, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 33, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 34, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 35, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 36, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 37, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"accept": None}]}}]}}
    mock_list_chains_requests.return_value = chains
    mock_list_tables_request.return_value = tables["tables"]
    mock_delete_rule_request.return_value = "Success"
    logged_in_client.get("/rules")
    response = logged_in_client.get('/rules/1/delete')
    assert response.status_code == 302
    assert response.location == "/rules"
    


=== ./background/nftables-gui/nftables-frontend/tests/test_sets.py ===

import pytest
from app import create_app
from models import db, User
from unittest.mock import patch
from api import parse_chains

@pytest.fixture()
def app():
    app = create_app()
    app.config.update({
        "TESTING": True,
        "WTF_CSRF_ENABLED": False,
        "SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:"

    })
    with app.app_context():
        db.create_all()  # Crear las tablas de la base de datos
    yield app
    with app.app_context():
        db.drop_all()


@pytest.fixture()
def client(app):
    return app.test_client()

@pytest.fixture()
def runner(app):
    return app.test_cli_runner()

@pytest.fixture()
def init_database():
    meta = db.metadata
    for table in reversed(meta.sorted_tables):
        db.session.execute(table.delete())
    user = User(username='default', password='defaultpassword')
    db.session.add(user)
    db.session.commit()

@pytest.fixture()
def logged_in_client(client):
    data = {"username": "default", "password": "defaultpassword"}
    client.post('/login', data=data)
    return client

def test_create_set_view(logged_in_client):
    response = logged_in_client.get('/sets/new')
    assert response.status_code == 200

@patch('api.create_table_request')
@patch('api.create_set_request')
def test_create_set(mock_create_set_request,mock_create_table_request ,logged_in_client):
    mock_create_table_request.return_value = "Success"
    data = {"name": "filter", "family": "inet", "description": "filter table"}
    logged_in_client.post('/add_table', data=data)
    data = {
        "name": "test_set",
        "type": "ipv4_addr",
        "elements": "",
        "table": "1&&inet"
    }
    mock_create_set_request.return_value = "Success"
    response = logged_in_client.post('/sets/new', data=data)
    assert response.status_code == 302
    assert response.headers['Location'] == '/sets'


@patch('api.create_table_request')
@patch('api.create_set_request')
@patch('api.delete_set_request')
def test_delete_set(mock_delete_set_request,mock_create_set_request,mock_create_table_request ,logged_in_client):
    mock_create_table_request.return_value = "Success"
    data = {"name": "filter", "family": "inet", "description": "filter table"}
    logged_in_client.post('/add_table', data=data)
    data = {
        "name": "test_set",
        "type": "ipv4_addr",
        "elements": "",
        "table": "1&&inet"
    }
    mock_create_set_request.return_value = "Success"
    logged_in_client.post('/sets/new', data=data)
    mock_delete_set_request.return_value = "Success"
    response = logged_in_client.get('/sets/1/delete')
    assert response.status_code == 302
    assert response.headers['Location'] == '/sets'
    
@patch('api.create_table_request')
@patch('api.create_set_request')
def test_edit_set_view(mock_create_set_request,mock_create_table_request,logged_in_client):
    mock_create_table_request.return_value = "Success"
    data = {"name": "filter", "family": "inet", "description": "filter table"}
    logged_in_client.post('/add_table', data=data)
    data = {
        "name": "test_set",
        "type": "ipv4_addr",
        "elements": "",
        "table": "1&&inet"
    }
    mock_create_set_request.return_value = "Success"
    logged_in_client.post('/sets/new', data=data)
    response = logged_in_client.get('/sets/1/add_element')
    assert response.status_code == 200
    
    
@patch('api.create_table_request')
@patch('api.create_set_request')
@patch('api.list_elements_in_set')
@patch('api.add_element_to_set_request')
def test_add_element(mock_add_element_to_set_request,mock_list_elements_in_set, mock_create_set_request,mock_create_table_request,logged_in_client):
    mock_create_table_request.return_value = "Success"
    data = {"name": "filter", "family": "inet", "description": "filter table"}
    logged_in_client.post('/add_table', data=data)
    data = {
        "name": "test_set",
        "type": "ipv4_addr",
        "table": "1&&inet"
    }
    mock_create_set_request.return_value = "Success"
    logged_in_client.post('/sets/new', data=data)
    mock_list_elements_in_set.return_value = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 4, "elements": ""}}]}, ""]
    logged_in_client.get('/sets/1')
    mock_add_element_to_set_request.return_value = "Success"
    data = {"element": "21.34.65.23"}
    response = logged_in_client.post('/sets/1/add_element', data=data)
    assert response.status_code == 302

@patch('api.create_table_request')
@patch('api.create_set_request')
@patch('api.list_elements_in_set')
def test_delete_element_view(mock_list_elements_in_set, mock_create_set_request, mock_create_table_request ,logged_in_client):
    mock_create_table_request.return_value = "Success"
    data = {"name": "filter", "family": "inet", "description": "filter table"}
    logged_in_client.post('/add_table', data=data)
    data = {
        "name": "test_set",
        "type": "ipv4_addr",
        "table": "1&&inet"
    }
    mock_create_set_request.return_value = "Success"
    logged_in_client.post('/sets/new', data=data)
    mock_list_elements_in_set.return_value = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 4, "elements": ""}}]}, ""]
    logged_in_client.get('/sets/1')
    response = logged_in_client.get('/sets/1/add_element')
    assert response.status_code == 200
    
@patch('api.create_table_request')
@patch('api.create_set_request')
@patch('api.list_elements_in_set')
@patch('api.add_element_to_set_request')
@patch('api.delete_element_from_set_request')
def test_delete_element(mock_delete_element_from_set_request, mock_add_element_to_set_request,mock_list_elements_in_set, mock_create_set_request,mock_create_table_request,logged_in_client):
    mock_create_table_request.return_value = "Success"
    data = {"name": "filter", "family": "inet", "description": "filter table"}
    logged_in_client.post('/add_table', data=data)
    data = {
        "name": "test_set",
        "type": "ipv4_addr",
        "table": "1&&inet"
    }
    mock_create_set_request.return_value = "Success"
    logged_in_client.post('/sets/new', data=data)
    mock_list_elements_in_set.return_value = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 4, "elements": ""}}]}, ""]
    logged_in_client.get('/sets/1')
    mock_add_element_to_set_request.return_value = "Success"
    data = {"element": "21.34.65.23"}
    logged_in_client.post('/sets/1/add_element', data=data)
    response = logged_in_client.post('/sets/1/delete_element', data=data)
    assert response.status_code == 302
    assert response.headers['Location'] == '/sets/1'

=== ./background/nftables-gui/nftables-frontend/tests/test_tablas.py ===

import pytest
from app import create_app
from models import db, User
from unittest.mock import patch
from api import parse_chains

@pytest.fixture()
def app():
    app = create_app()
    app.config.update({
        "TESTING": True,
        "WTF_CSRF_ENABLED": False,
        "SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:"

    })
    with app.app_context():
        db.create_all()  # Crear las tablas de la base de datos
    yield app
    with app.app_context():
        db.drop_all()


@pytest.fixture()
def client(app):
    return app.test_client()

@pytest.fixture()
def runner(app):
    return app.test_cli_runner()

@pytest.fixture()
def init_database():
    meta = db.metadata
    for table in reversed(meta.sorted_tables):
        db.session.execute(table.delete())
    user = User(username='default', password='defaultpassword')
    db.session.add(user)
    db.session.commit()

@pytest.fixture()
def logged_in_client(client):
    data = {"username": "default", "password": "defaultpassword"}
    client.post('/login', data=data)
    return client

@patch('api.list_tables_request')
def test_list_tables(mock_list_tables_request ,logged_in_client):
    data = {"tables": "table inet filter\ntable ip nat\ntable ip filter\n"}
    mock_list_tables_request.return_value = data["tables"]
    response = logged_in_client.get('/tables')
    assert response.status_code == 200
    assert b'Tables' in response.data


@patch('api.create_table_request')
def test_create_table(mock_create_table_request, logged_in_client):
    data = {"name": "creada", "family": "inet", "description": "filter table"}
    mock_create_table_request.return_value = "Success"
    response = logged_in_client.post('/add_table', data=data)
    assert response.status_code == 302
    mock_create_table_request.assert_called_once()

def test_view_create_table(logged_in_client):
    response = logged_in_client.get('/add_table')
    assert response.status_code == 200
    assert b'Create Table' in response.data

@patch('api.delete_table_request')
@patch('api.create_table_request')
def test_delete_table(mock_delete_table_request, mock_create_table_request, logged_in_client):
    mock_delete_table_request.return_value = "Success"
    mock_create_table_request.return_value = "Success"
    data = {"name": "filter", "family": "inet", "description": "filter table"}
    logged_in_client.post('/add_table', data=data)
    response = logged_in_client.get('/delete_table/filter/inet')
    assert response.status_code == 302
    mock_delete_table_request.assert_called_once()

@patch('api.list_tables_request')
@patch('api.list_chains_request')
@patch('api.list_sets_request')
@patch('api.list_maps_request')
@patch('api.list_chain_request')
@patch('api.flush_table_request')
def test_flush_table( mock_flush_table_request,mock_list_chain_request,mock_list_maps_request, mock_list_sets_request , mock_list_chains_requests, mock_list_tables_request , logged_in_client):
    tables = {"tables": "table inet filter\ntable ip nat\ntable ip filter\n"}
    chains = {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "inet", "table": "filter", "name": "input", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "forward", "handle": 2, "type": "filter", "hook": "forward", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "output", "handle": 3, "type": "filter", "hook": "output", "prio": 0, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "nat", "name": "POSTROUTING", "handle": 2, "type": "nat", "hook": "postrouting", "prio": 100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "PREROUTING", "handle": 3, "type": "nat", "hook": "prerouting", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "nat", "name": "OUTPUT", "handle": 4, "type": "nat", "hook": "output", "prio": -100, "policy": "accept"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER", "handle": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-1", "handle": 2}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-USER", "handle": 5}}, {"chain": {"family": "ip", "table": "filter", "name": "DOCKER-ISOLATION-STAGE-2", "handle": 40}}]}}
    sets = [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"set": {"family": "inet", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 4}}]}, ""]
    maps = [0, {"chains": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"map": {"family": "ip", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 62, "map": "ipv4_addr"}}]}}]
    mock_list_sets_request.return_value = sets[1]["nftables"]
    mock_list_maps_request.return_value = maps[1]["chains"]["nftables"]
    mock_list_chain_request.return_value ={"rules": {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"chain": {"family": "ip", "table": "filter", "name": "FORWARD", "handle": 4, "type": "filter", "hook": "forward", "prio": 0, "policy": "drop"}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 61, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 58, "expr": [{"counter": {"packets": 137, "bytes": 41966}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 57, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"xt": None}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 56, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 55, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 54, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 50, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"xt": None}, {"counter": {"packets": 136, "bytes": 41906}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 20, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 21, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 22, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 23, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 24, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 25, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 26, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 27, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 2, "bytes": 120}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 28, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-USER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 29, "expr": [{"counter": {"packets": 132, "bytes": 41706}}, {"jump": {"target": "DOCKER-ISOLATION-STAGE-1"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 30, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 31, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 32, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 33, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "docker0"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "docker0"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 34, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "in", "left": {"ct": {"key": "state"}}, "right": ["established", "related"]}}, {"counter": {"packets": 131, "bytes": 41646}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 35, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"jump": {"target": "DOCKER"}}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 36, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "!=", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 0, "bytes": 0}}, {"accept": None}]}}, {"rule": {"family": "ip", "table": "filter", "chain": "FORWARD", "handle": 37, "expr": [{"match": {"op": "==", "left": {"meta": {"key": "iifname"}}, "right": "br-e68c7fe6e768"}}, {"match": {"op": "==", "left": {"meta": {"key": "oifname"}}, "right": "br-e68c7fe6e768"}}, {"counter": {"packets": 1, "bytes": 60}}, {"accept": None}]}}]}}
    mock_list_chains_requests.return_value = chains
    mock_list_tables_request.return_value = tables["tables"]
    mock_flush_table_request.return_value = "Success"
    response = logged_in_client.get('/')
    response = logged_in_client.get('/flush_table/filter/ip')
    assert response.status_code == 302
    mock_flush_table_request.assert_called_once()
    
@patch('api.create_table_request')
@patch('api.list_table_request')
def test_view_table(mock_list_table_request ,mock_create_table_request, logged_in_client):
    mock_create_table_request.return_value = "Success"
    data = {"name": "filter", "family": "inet", "description": "filter table"}
    logged_in_client.post('/add_table', data=data)
    data = {"status": "success", "result": [0, {"nftables": [{"metainfo": {"version": "1.0.2", "release_name": "Lester Gooch", "json_schema_version": 1}}, {"table": {"family": "inet", "name": "filter", "handle": 15}}, {"set": {"family": "inet", "name": "my_map", "table": "filter", "type": "ipv4_addr", "handle": 4}}, {"chain": {"family": "inet", "table": "filter", "name": "input", "handle": 1, "type": "filter", "hook": "input", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "forward", "handle": 2, "type": "filter", "hook": "forward", "prio": 0, "policy": "accept"}}, {"chain": {"family": "inet", "table": "filter", "name": "output", "handle": 3, "type": "filter", "hook": "output", "prio": 0, "policy": "accept"}}]}, ""]}
    mock_list_table_request.return_value = parse_chains(data["result"][1]["nftables"])
    response = logged_in_client.get('/table/filter/inet')
    assert response.status_code == 200
    assert b'Table' in response.data
    assert b'filter' in response.data
    mock_list_table_request.assert_called_once()
=== ./background/nftables-gui/nftables-frontend/tests/test_users.py ===

import pytest
from app import create_app
from models import db, User
from unittest.mock import patch
from api import parse_chains

@pytest.fixture()
def app():
    app = create_app()
    app.config.update({
        "TESTING": True,
        "WTF_CSRF_ENABLED": False,
        "SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:"

    })
    with app.app_context():
        db.create_all()  # Crear las tablas de la base de datos
    yield app
    with app.app_context():
        db.drop_all()


@pytest.fixture()
def client(app):
    return app.test_client()

@pytest.fixture()
def runner(app):
    return app.test_cli_runner()

@pytest.fixture()
def init_database():
    meta = db.metadata
    for table in reversed(meta.sorted_tables):
        db.session.execute(table.delete())
    user = User(username='default', password='defaultpassword')
    db.session.add(user)
    db.session.commit()

@pytest.fixture()
def logged_in_client(client):
    data = {"username": "default", "password": "defaultpassword"}
    client.post('/login', data=data)
    return client

def test_view_users(logged_in_client):
    response = logged_in_client.get('/users')
    assert response.status_code == 200
    assert b'Users' in response.data
    
def test_add_user(logged_in_client):
    data = {"username": "test", "password": "testpassword","confirm_password": "testpassword" , "role": "administrator"}
    response = logged_in_client.post('/create_user', data=data)
    assert response.status_code == 302
    
def test_delete_user(logged_in_client):
    data = {"username": "test", "password": "testpassword","confirm_password": "testpassword" , "role": "administrator"}
    logged_in_client.post('/create_user', data=data)
    response = logged_in_client.get('/delete_user/2')
    assert response.status_code == 302
    assert response.location == '/users'
    

=== ./background/nftables-gui/nftables-frontend/views.py ===

import ast
from flask import Blueprint, render_template, flash, redirect, url_for, request
from flask_login import login_user, logout_user, login_required, current_user
from models import BaseChain, Chain, Rule, Statement, Table, User, db
from forms.forms import AddElementMap, AddElementSetForm, AddListForm, BaseChainForm, ChainForm, DeleteElementMap, DeleteElementSet, LoginForm, CreateUserForm, MapForm, NotTerminalStatementForm, RuleForm, SetForm, TableForm, UpdateUserForm
import service, api, os, matplotlib
matplotlib.use('Agg')
from sqlalchemy.orm import joinedload
import matplotlib.pyplot as plt
from Levenshtein import ratio


visualization_bp = Blueprint('visualization', __name__)
creation_bp = Blueprint('creation', __name__)

@visualization_bp.route('/list_ruleset')
@login_required
def list_ruleset():
    result = api.list_ruleset_request()    
    
    return render_template('ruleset.html', ruleset=result)

@creation_bp.route('/list_ruleset', methods=['POST'])
@login_required
def list_ruleset_post():
    result = api.list_ruleset_request()
    service.delete_all_data()
    service.load_data(True)
    return render_template('ruleset.html', ruleset=result)

@visualization_bp.route('/')
def main_view():
    if current_user.is_authenticated:
        host = os.uname().nodename
        ip_address = os.popen('hostname -I').read().split(" ")[0] 
        categories = ['Rules', 'Chains', 'Tables']
        # Get the number of rules, chains and tables
        values = service.load_data(False)
        # Obtén la ruta del directorio actual
        dir_path = os.path.dirname(os.path.realpath(__file__))

        # Construye la ruta absoluta al archivo
        image_path = os.path.join(dir_path, 'static/img/nftables_info.png')
        plt.figure(figsize=(8, 6))
        plt.bar(categories, values, color=['blue', 'green', 'orange'])
        plt.xlabel('nftables elements')
        plt.ylabel('Number')
        plt.title('Number of nftables elements')
        plt.grid(axis='y')
        if os.path.exists(image_path):
            os.remove(image_path)
        plt.savefig(image_path)
        plt.close()       
        return render_template('main.html', nftables_info_image=url_for('static', filename='/img/nftables_info.png') , current_user=current_user, hostname=host, ip_address=ip_address)
    else:
        form = LoginForm()
        return render_template('login.html', form=form)
    
@visualization_bp.route('/users', methods=['GET'])  
@login_required
def users():
    users = User.query.all()
    return render_template('users/users.html', users=users)

@visualization_bp.route('/table/<table_id>/<family>')
def get_table(table_id, family):
    table = service.get_table(table_id,family=family)
    chains = api.list_table_request(table.name, table.family)
    for chain in chains:    
        if(service.check_existing_chain(chain["name"], table_id, table.family) == True):
            hook_type = None
            priority = None
            type = None
            if("hook_type" in chain):
                hook_type = chain['hook_type']
            if("priority" in chain):
                priority = chain['priority']
            if("type" in chain):
                type = chain['type']
            if("policy" not in chain):
                chain["policy"] = None
            service.insert_chain(chain_name=chain["name"], family=chain["family"], type=type, policy=chain['policy'], table_id=table_id, hook_type=hook_type, priority=priority)
    chains = service.get_chains_from_table(table_id,family=table.family)
    return render_template('tables/table.html', table=table, chains=chains)

@visualization_bp.route('/flush_table/<table_id>/<family>')
def flush_table(table_id, family):
    table = service.get_table(table_id, family)
    response = api.flush_table_request(table.name, table.family)
    service.clean_table(table_id, family)
    return redirect('/tables')


@visualization_bp.route('/delete_user/<user_id>')
def delete_user(user_id):
    user = User.query.get(user_id)
    if(user != None):
        service.delete_user(user_id)
    return redirect('/users')

@visualization_bp.route('/create_base_chain')
def create_base_chain():
    form = BaseChainForm()
    tables = Table.query.all()
    return render_template('chains/create_base_chain.html', form=form, tables=tables)

@visualization_bp.route('/create_chain')
def create_chain():
    form = ChainForm()
    tables = Table.query.all()
    return render_template('chains/create_chain.html', form=form, tables=tables)



@visualization_bp.route('/chain/<chain_id>/<family>/<table>')
def get_chain(chain_id, family, table):
    chain = service.get_chain(chain_id, table)
    statements = service.get_statements_from_chain(chain_id=chain.name, table_id=table, family=family)
    for rule_ in chain.rules:
        rule_.expr = ast.literal_eval(rule_.expr)
    return render_template('chains/chain.html', chain=chain, statements=statements)

@creation_bp.route('/create_base_chain/', methods=['POST'])
def create_base_chain_post():
    form = BaseChainForm()
    form.family.data = form.table.data.split("&&")[0]
    form.table.data = form.table.data.split("&&")[1]
    table_name = Table.query.get(form.table.data).name
    if form.priority.data == None:
        form.priority.data = 0
    table = service.get_table(form.table.data, form.family.data)
    if form.validate_on_submit():
        response = api.create_base_chain_request(form.name.data, form.family.data, table_name, priority=form.priority.data, hook_type=form.hook_type.data, policy=form.policy.data, type=form.type.data)
        if(response == "Success"):
            flash('Base chain created successfully.')
        else:
            flash('Error creating base chain.')
            return render_template('chains/create_base_chain.html', form=form, tables=Table.query.all())
    else:
        return render_template('chains/create_base_chain.html', form=form, tables=Table.query.all())

    return redirect('/chains')

@creation_bp.route('/create_chain/', methods=['POST'])
def create_chain_post():
    form = ChainForm()
    form.family.data = form.table.data.split("&&")[1]
    form.table.data = form.table.data.split("&&")[0]
    table_name = Table.query.get(form.table.data).name
    if form.validate_on_submit():
        response = api.create_chain_request(form.name.data, form.family.data, table_name, policy=form.policy.data)
    else:
        return render_template('chains/create_chain.html', form=form, tables=Table.query.all())
    if response == "Success":
        flash('Chain created successfully.')
    else:
        flash('Error creating chain.')
        return render_template('chains/create_chain.html', form=form, tables=Table.query.all())
    return redirect('/chains')

@visualization_bp.route('/login')
def login_view():
    form = LoginForm()
    return render_template('login.html', form=form)

@visualization_bp.route('/tables')
@login_required
def tables():
    result = api.list_tables_request()
    family = []
    names = []
    for line in result.split("table "):
        family.append(line.split(" ")[0])
        variable = line.split(" ")[-1]
        variable = str(variable)
        names.append(variable)
    for i in range(len(names)):
        names[i] = names[i].replace("\n", "")
        if(i != 0) and service.check_existing_table(names[i], family[i]) == False:
            service.insert_in_table(names[i], family[i])
    tables = service.get_tables()
    return render_template('tables/tables.html', tables=tables)

@creation_bp.route('/add_table')
def add_table_get():
    return render_template('tables/add_table.html', form=TableForm())

@creation_bp.route('/add_table', methods=['POST'])
def add_table_post():
    form = TableForm()
    if form.validate_on_submit():
        result = service.insert_in_table(form.name.data, form.family.data, form.description.data, current_user.username)
        if result == "Success":
            response = api.create_table_request(form.name.data, form.family.data)
            if(response == "Success"):
                flash('Table created successfully.')
                return redirect('/tables')
            else:
                flash('Error creating table.')
                return render_template('tables/add_table.html', form=form)
        else:
            flash('Error creating table.')
    else:
        flash('Error creating table.')
    return render_template('tables/add_table.html', form=form)

@creation_bp.route('/delete_table/<table_id>/<family>')
def delete_table(table_id, family):
    table = service.get_table(table_id, family)
    response = api.delete_table_request(table.name, table.family)
    service.delete_table(table_id, family)
    return redirect('/tables')

@creation_bp.route('/login', methods=['POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user is not None and user.check_password(form.password.data):
            login_user(user, remember=True)
            flash('Logged in successfully.')
            return redirect('/')
        else:
            form.validate_username(form.username)
            flash('Invalid username or password.')
    else:
        flash('Invalid username or password.')
    return render_template('login.html', form=form)

@visualization_bp.route('/create_user')
@login_required
def create_user():
    
    return render_template('users/create_user.html', form=CreateUserForm())

@creation_bp.route('/create_user', methods=['POST'])
@login_required
def create_user_post():
    form = CreateUserForm()
    if form.validate_on_submit():
        service.create_user(form.username.data, form.password.data, form.role.data, True)
        flash('User created successfully.')
        return redirect('/users')
    else:
        flash('Error creating user.')
        return render_template('users/create_user.html', form=form)

@creation_bp.route("/logout")
@login_required
def logout():
    '''Cerrar sesión'''
    logout_user()
    return redirect('/')

@visualization_bp.route("/chains")
@login_required
def get_chains():
    result = api.list_chains_request()
    for item in result["chains"]["nftables"]:
        if("chain" in item):
            if(service.check_existing_chain(item["chain"]["name"], item["chain"]["table"], item["chain"]["family"]) == True):
                prio = None
                hook = None
                type_ = None
                if("prio" in item["chain"]):
                    prio = item["chain"]["prio"]
                if("hook" in item["chain"]):
                    hook = item["chain"]["hook"]
                if("policy" not in item["chain"]):
                    item["chain"]["policy"] = None
                if("type" in item["chain"]):
                    type_ = item["chain"]["type"]
                service.insert_chain(item["chain"]["name"], item["chain"]["family"], item["chain"]["policy"], item["chain"]["table"],type=type_,  priority=prio, hook_type=hook)
    chains = service.get_chains()
    return render_template('chains/chains.html', chains=chains)

@creation_bp.route('/chains/<chain_id>/<table>/delete')
@login_required
def delete_chain(chain_id, table):
    chain = Chain.query.get(chain_id)
    response = api.delete_chain_request(chain.name, chain.table.family, chain.table.name)
    service.delete_chain(chain_id)
    return redirect('/chains')

@creation_bp.route('/chains/<chain_id>/<table>/flush')
@login_required
def flush_chain(chain_id,table):
    chain = Chain.query.get(chain_id)
    response = api.flush_chain_request(chain.name, chain.table.family, chain.table.name)
    service.delete_rules_form_chain(chain_id)
    return redirect('/chains')

@visualization_bp.route('/rules')
@login_required
def get_rules():
        
    service.load_data(True)
    rules = Rule.query.options(joinedload('*')).all()
    return render_template('rules/rules.html', rules=rules)

@visualization_bp.route('/rules/<rule_id>')
@login_required
def get_rule(rule_id):
    rule = service.get_rule(rule_id)
    rule_result = api.list_chain_request(rule.chain.name, rule.chain.table.family, rule.chain.table.name)
    service.delete_statements_from_rule(rule_id)
    for i, rule_aux in enumerate(rule_result["rules"]["nftables"]):
        if i == 0 or i == 1:
            continue
        else:
            if service.get_rule(rule_id).handle == None and ratio(str(rule_aux["rule"]["expr"]), rule.expr) > 0.9:
                service.get_rule(rule_id).handle = rule_aux["rule"]["handle"]
                
            if str(rule.handle) == str(rule_aux["rule"]["handle"]):    
                service.iteration_on_chains(rule=rule_aux, chain_id=rule.chain.name, family=rule.chain.table.family, handle=rule_aux["rule"]["handle"], rule_id=rule_id)

    statements = service.get_statements_from_rule(rule_id)
    statements = [s for s in statements if s and not s.is_empty()]

    return render_template('rules/rule.html', rule=rule, statements=statements)

@visualization_bp.route('/rules/create_rule')
def create_rule():
    form = RuleForm()
    chains = service.get_chains()
    objects = service.get_objects()
    return render_template('rules/create_rule.html', form=form, chains=chains, objects=objects)

@visualization_bp.route('/rules/<rule_id>/delete')
@login_required
def delete_rule(rule_id):
    response = api.delete_rule_request(rule_id)
    service.delete_rule(rule_id)
    return redirect('/rules')

@creation_bp.route('/rules/create_rule', methods=['POST'])
def create_rule_post():
    form = RuleForm(data=request.form)
    chaind_id = form.chain.data.split("&&")[0]
    table_name = form.chain.data.split("&&")[2]
    family = form.chain.data.split("&&")[1]
    chain_name = form.chain.data.split("&&")[3]
    form.chain.data = chaind_id
    chains = service.get_chains()
    if form.validate():
        if (not (form.statements.limit.data or form.statements.log.data or form.statements.counter.data or form.statements.masquerade.data or form.statements.redirect.data or form.statements.src_nat.data or form.statements.dst_nat.data or form.statements.limit_per.data or form.statements_term.accept.data or form.statements_term.reject.data or form.statements_term.drop.data or form.statements_term.queue.data or form.statements_term.jump.data or form.statements_term.go_to.data or form.statements_term.return_.data) 
            or (form.statements.data == None and form.statements_term.data == None)):
            flash('Error creating rule.')
            objects = service.get_objects()
            return render_template('rules/create_rule.html', form=form, chains=chains, objects=objects)
        if form.statements_term.jump.data != "--Selects--":
            if service.get_chain(chain_id=form.statements_term.jump.data ,table=table_name) == None:
                flash('Error creating rule.')
                objects = service.get_objects()
                return render_template('rules/create_rule.html', form=form, chains=chains, objects=objects)
        if  form.statements_term.go_to.data != "--Selects--":
            if service.get_chain(chain_id=form.statements_term.go_to.data ,table=table_name) == None:
                flash('Error creating rule.')
                objects = service.get_objects()
                return render_template('rules/create_rule.html', form=form, chains=chains, objects=objects)
        if service.get_rules() != []:
            id_ = service.get_rules()[-1].id + 1
        else:
            id_ = 1
        result = api.create_rule_request(rule_id=id_, chain_name=chain_name, family=family, chain_table=table_name, statement=form.statements.data, statement_term=form.statements_term.data, statement_type=form.statement_select.data)
        chain = Chain.query.get(chaind_id)
        service.insert_rule_with_table(chain_id=form.chain.data, expr=str(result[0]), description=form.description.data, table_id=chain.table.id)    

        if(result[1] == "Success"):
            flash('Rule created successfully.')
        else:
            flash('Error creating rule.')
            
            objects = service.get_objects()
            return render_template('rules/create_rule.html', form=form, chains=chains, objects=objects, msg=result[1])
        return redirect('/rules')
    else:
        flash('Error creating rule.')

    return render_template('rules/create_rule.html', form=form, chains=chains)

@visualization_bp.route('/sets')
@login_required
def get_sets():
    service.insert_sets()
    return render_template('sets/sets.html', sets=service.get_sets())

@visualization_bp.route('/sets/<set_id>')
@login_required
def get_set(set_id):
    set_ = service.get_set(set_id)
    table = Table.query.get(set_.table_id)
    result = api.list_elements_in_set(set_.name, table.family, table.name)
    elements = ""
    for i, item in enumerate(result[1]["nftables"]):
        table = Table.query.get(set_.table_id)
        if("set" in item) and item["set"]["name"] == set_.name and item["set"]["family"] == table.family and item["set"]["table"] == table.name:
            if item.get("set").get("elem", None) != None:
                elements = str(item["set"]["elem"])
    service.insert_elements_in_set(set_id, elements)
    return render_template('sets/set.html', set=set_)

@visualization_bp.route('/sets/<set_id>/add_element')
@login_required
def add_element(set_id):
    form = AddElementSetForm()
    return render_template('sets/add_element.html', form=form)

@creation_bp.route('/sets/<set_id>/add_element', methods=['POST'])
@login_required
def add_element_post(set_id):
    form = AddElementSetForm()
    set_ = service.get_set(set_id)
    if service.validate_element(form.element.data, set_id) and (form.element.data != None or form.element.data != ""):
        table = Table.query.get(set_.table_id)
        response = api.add_element_to_set_request(set_family=table.family, element=str(form.element.data), set_name=set_.name, set_table=table.name)
        if response == "Success":
            flash('Element added successfully.')
        else:
            flash('Error adding element.')
            return render_template('sets/add_element.html', form=form)
        return redirect('/sets/' + set_id)
    else:
        flash('Error adding element.')
        return render_template('sets/add_element.html', form=form)
    
@visualization_bp.route('/sets/new')
@login_required
def add_set():
    form = SetForm()
    tables = service.get_tables()
    return render_template('sets/create_set.html', form=form, tables=tables)

@creation_bp.route('/sets/new', methods=['POST'])
@login_required
def add_set_post():
    form = SetForm()
    form.family.data = form.table.data.split("&&")[1]
    form.table.data = form.table.data.split("&&")[0]
    if form.validate_on_submit():
        service.insert_set_form(form.name.data, form.table.data, form.type.data, form.description.data)
        table = Table.query.get(form.table.data)
        response = api.create_set_request(set_name=form.name.data, set_family=form.family.data, set_table=table.name, set_type=form.type.data)
        if response == "Success":
            flash('Set created successfully.')
        else:
            flash('Error creating set.')
            tables = service.get_tables()
            return render_template('sets/create_set.html', form=form, tables=tables)
        return redirect('/sets')
    else:
        flash('Error creating set.')
        return render_template('sets/create_set.html', form=form)
    
@visualization_bp.route('/sets/<set_id>/delete')
@login_required
def delete_set(set_id):
    set_ = service.get_set(set_id)
    table = Table.query.get(set_.table_id)
    response = api.delete_set_request(set_name=set_.name, set_family=table.family , set_table=table.name)
    service.delete_set(set_id)
    return redirect('/sets')

@visualization_bp.route('/sets/<set_id>/delete_element')
@login_required
def delete_element_set(set_id):
    form = DeleteElementSet()
    elements = service.get_elements_from_set(set_id)
    if elements != "":
        elements = ast.literal_eval(elements)
    return render_template('sets/delete_element.html', form=form, aux=elements)

@creation_bp.route('/sets/<set_id>/delete_element', methods=['POST'])
@login_required
def delete_element_set_post(set_id):
    form = DeleteElementSet()
    set_ = service.get_set(set_id)
    if form.element.data != None or form.element.data != "":
        table = Table.query.get(set_.table_id)
        response = api.delete_element_from_set_request(set_family=table.family, element=form.element.data, set_name=set_.name, set_table=table.name)
        if response == "Success":
            flash('Element deleted successfully.')
        else:
            flash('Error deleting element.')
        return redirect('/sets/' + set_id)
    else:
        flash('Error deleting element.')
        elements = service.get_elements_from_set(set_id)
        elements = ast.literal_eval(elements)
        return render_template('sets/delete_element.html', form=form,aux=elements)
    
@visualization_bp.route('/maps')
@login_required
def get_maps():
    service.insert_maps()
    maps = service.get_maps()
    return render_template('maps/maps.html', maps=maps)

@visualization_bp.route('/maps/<map_id>')
@login_required
def get_map(map_id):
    map_ = service.get_map(map_id)
    table = Table.query.get(map_.table_id)
    result = api.list_elements_in_map(map_.name, table.family, table.name)
    elements = ""
    for i, item in enumerate(result[1]["nftables"]):
        if("map" in item) and item["map"]["name"] == map_.name and item["map"]["family"] == table.family and item["map"]["table"] == table.name:
            if item.get("map").get("elem", None) != None:
                elements = str(item["map"]["elem"])
    service.insert_elements_in_map(map_id, elements)
    return render_template('maps/map.html', map=map_)

@visualization_bp.route('/maps/new')
@login_required
def add_map():
    form = MapForm()
    tables = service.get_tables()
    return render_template('maps/create_map.html', form=form, tables=tables)

@creation_bp.route('/maps/new', methods=['POST'])
@login_required
def add_map_post():
    form = MapForm()
    form.family.data = form.table.data.split("&&")[1]
    form.table.data = form.table.data.split("&&")[0]
    table = Table.query.get(form.table.data)
    if form.validate_on_submit():
        service.insert_map_form(form.name.data, form.table.data, form.type.data, form.map_type.data, form.description.data)
        response = api.create_map_request(map_name=form.name.data, map_family=form.family.data, map_table=table.name, map_type=form.map_type.data, type=form.type.data)
        if response == "Success":
            flash('Map created successfully.')
        else:
            flash('Error creating map.')
            tables = service.get_tables()
            return render_template('maps/create_map.html', form=form, tables=tables)
        return redirect('/maps')
    else:
        flash('Error creating map.')
        return render_template('maps/create_map.html', form=form)
    
@visualization_bp.route('/maps/<map_id>/delete')
@login_required
def delete_map(map_id):
    map_ = service.get_map(map_id)
    table = Table.query.get(map_.table_id)
    response = api.delete_map_request(map_name=map_.name, map_family=table.family, map_table=table.name)
    service.delete_map(map_id)
    return redirect('/maps')

@visualization_bp.route('/maps/<map_id>/add_element')
def add_element_map(map_id):
    form = AddElementMap()
    map_ = service.get_map(map_id)
    return render_template('maps/add_element.html', form=form, map=map_)

@creation_bp.route('/maps/<map_id>/add_element', methods=['POST'])
@login_required
def add_element_map_post(map_id):
    form = AddElementMap()
    map_ = service.get_map(map_id)
    if service.validate_element_map(form.key.data, form.value.data, map_id) and (form.key.data != None or form.key.data != "") and (form.value.data != None or form.value.data != ""):
        table = Table.query.get(map_.table_id)
        response = api.add_element_to_map_request(map_family=table.family, key=form.key.data, value=form.value.data, map_name=map_.name, map_table=table.name)
        if response == "Success":
            flash('Element added successfully.')
        else:
            flash('Error adding element.')
            return render_template('maps/add_element.html', form=form)
        return redirect('/maps/' + map_id)
    else:
        flash('Error adding element.')
        return render_template('maps/add_element.html', form=form)
    
@visualization_bp.route('/maps/<map_id>/delete_element')
@login_required
def delete_element_map(map_id):
    form = DeleteElementMap()
    elements_str = service.get_elements_from_map(map_id)
    aux = ""
    if elements_str != "" and elements_str != None:
        elements_dict = ast.literal_eval(elements_str)
        keys = elements_dict.keys()
        aux = list(keys)

    return render_template('maps/delete_element.html', form=form, aux=aux)

@creation_bp.route('/maps/<map_id>/delete_element', methods=['POST'])
@login_required
def delete_element_map_post(map_id):
    form = DeleteElementMap()
    map_ = service.get_map(map_id)
    if form.key.data != None or form.key.data != "":
        table = Table.query.get(map_.table_id)
        valor = service.get_element_from_map(element=form.key.data, map_id=map_id)
        response = api.delete_element_from_map_request(map_family=table.family, key=form.key.data , value=valor, map_name=map_.name, map_table=table.name)
        if response == "Success":
            service.delete_element_from_map(element=form.key.data, map_id=map_id)
            flash('Element deleted successfully.')
        else:
            flash('Error deleting element.')
        return redirect('/maps/' + map_id)
    else:
        flash('Error deleting element.')
        elements_str = service.get_elements_from_map(map_id)
        elements_dict = ast.literal_eval(elements_str)
        keys = elements_dict.keys()
        aux = list(keys)
        return render_template('maps/delete_element.html', form=form, aux=aux)
    
@visualization_bp.route('/save-changes')
@login_required
def save_changes():
    return render_template('save-changes.html')

@creation_bp.route('/save-changes', methods=['POST'])
@login_required
def save_changes_post():
    type_ = request.form.get('save')
    if type_ != "" or type_ != None:
        if type_ == 'config':
            api.save_service()
            flash('Changes saved successfully.')
        elif type_ == 'file':
            api.save_service_temp()
            flash('Changes discarded successfully.')
        
    return redirect('/')

@visualization_bp.route('/add-list')
@login_required
def add_list():
    form = AddListForm()
    tables = service.get_tables()
    return render_template('sets/add-list.html', form=form, tables=tables)

@creation_bp.route('/add-list', methods=['POST'])
@login_required
def add_list_post():
    form = AddListForm()
    lista = request.files['list'].read().decode('utf-8').split("\n")
    form.element.data = lista
    if '.txt' not in request.files['list'].filename:

        flash('Error adding list.')
        tables = service.get_tables()
        return render_template('sets/add-list.html', form=form, tables=tables, mssg="The file must be a txt file.")
    form.family.data = form.table.data.split("&&")[1]
    form.table.data = form.table.data.split("&&")[0]
    table_name = Table.query.get(form.table.data).name

    if form.validate_on_submit():
        service.create_list(form.name.data, form.family.data, form.table.data, form.type.data, lista)
        api.create_set_request(set_name=form.name.data, set_family=form.family.data, set_table=table_name, set_type=form.type.data)
        for item in lista:
            api.add_element_to_set_request(set_family=form.family.data, element=item, set_name=form.name.data, set_table=form.table.data)
        flash('List added successfully.')
    else:
        flash('Error adding list.')
        tables = service.get_tables()
        return render_template('sets/add-list.html', form=form, tables=tables)
    return redirect('/sets')

@visualization_bp.route('/reload')
@login_required
def reload():
    service.delete_all_data_except_users()
    api.reload_service()
    return redirect('/')

@visualization_bp.route('/rules/<rule_id>/edit_description')
@login_required
def edit_description(rule_id):
    rule = service.get_rule(rule_id)
    return render_template('rules/edit_description.html', rule=rule)

@creation_bp.route('/rules/<rule_id>/edit_description', methods=['POST'])
@login_required
def edit_description_post(rule_id):
    description = request.form.get('description')
    service.edit_description(rule_id, description)
    return redirect('/rules/' + rule_id)
=== ./background/nftables-gui/nftables-parser/chains.py ===

import json
from nftables import Nftables
import sys
import hug

@hug.get('/list_chains')
def list_chains(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    return {"chains": result[1]}

@hug.post('/create_chain')
def create_chain(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    if(result[0] == 0):
        return {"status": "success"}
    else:
        return {"status": "error"}
    
@hug.post('/create_base_chain')
def create_base_chain(json_data: hug.types.json):
    nft = Nftables()
    result = nft.cmd("add table " + json_data["nftables"][0]["add"]["base_chain"]["family"] + " " + json_data["nftables"][0]["add"]["base_chain"]['table'])
    result = nft.cmd("add chain " + json_data["nftables"][0]["add"]["base_chain"]["family"] + " " + json_data["nftables"][0]["add"]["base_chain"]['table'] + " " + json_data["nftables"][0]["add"]["base_chain"]['name'] + " { type " + json_data["nftables"][0]["add"]["base_chain"]["type"] + " hook " + json_data["nftables"][0]["add"]["base_chain"]['hook_type'] + " priority " + str(json_data["nftables"][0]["add"]["base_chain"]['priority']) + " ; policy " + json_data["nftables"][0]["add"]["base_chain"]["policy"] + " ; }")    
    if(result[0] == 0):
        return {"status": "success"}
    else:
        return {"status": "error"}
    
@hug.get('/list_rule_chain')
def get_rule_chain(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    return {"rules": result[1]}

@hug.post('/delete_chain')
def delete_chain(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    if(result[0] == 0):
        return {"status": "success"}
    else:
        return {"status": "error"}
    
@hug.post('/flush_chain')
def flush_chain(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    if(result[0] == 0):
        return {"status": "success"}
    else:
        return {"status": "error"}
=== ./background/nftables-gui/nftables-parser/main.py ===

import hug
import tables, chains, rules, sets, maps, service

api = hug.API(__name__)
api.extend(tables, '/tables')
api.extend(chains, '/chains')
api.extend(rules, '/rules')
api.extend(sets, '/sets')
api.extend(maps, '/maps')
api.extend(service, '/service')

=== ./background/nftables-gui/nftables-parser/maps.py ===

from nftables import Nftables
import hug

@hug.get('/list_maps')
def list_maps(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    return result

@hug.get('/list_elements_in_map')
def list_elements_in_map(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    return result

@hug.post('/create_map')
def create_map(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    return result

@hug.post('/delete_map')
def delete_map(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    return result

@hug.post('/add_element_to_map')
def add_element_to_map(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    return result

@hug.post('/delete_element_from_map')
def delete_element_from_map(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    return result
=== ./background/nftables-gui/nftables-parser/rules.py ===

from nftables import Nftables
import hug


@hug.post('/create_rule')
def create_rule(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    if(result[0] == 0):
        return {"status": "success"}
    else:
        return {"status": "error", "result": result}  
    
@hug.post('/delete_rule')
def delete_rule(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    if(result[0] == 0):
        return {"status": "success"}
    else:
        return {"status": "error"}
=== ./background/nftables-gui/nftables-parser/service.py ===

import glob
import json
from nftables import Nftables
import sys, os
import hug

@hug.get('/reload_service')
def reload_service():
    os.system("sudo systemctl restart nftables")
    return {"status": "success"}

@hug.get('/save_service')
def save_service():
    os.system("sudo rm -f /etc/nftables.conf")
    os.system("sudo nft list ruleset > /etc/nftables.conf")
    os.system("sudo systemctl restart nftables")
    return {"status": "success"}

@hug.get('/save_service_temp')
def save_service_temp():
    files = glob.glob("./temp_config/nftables_temp*.conf")
    numbers = [int(f.replace("./temp_config/nftables_temp", "").replace(".conf", "")) for f in files]
    highest_number = max(numbers) if numbers else 0
    os.system(f"sudo nft list ruleset > ./temp_config/nftables_temp{highest_number + 1}.conf")
=== ./background/nftables-gui/nftables-parser/sets.py ===

from nftables import Nftables
import hug


@hug.get('/list_sets')
def list_sets():
    nft = Nftables()
    result = nft.json_cmd({'nftables': [{'list': {'sets': None}}]})
    return result

@hug.get('/list_elements_in_set')
def list_elements_in_set(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    return result

@hug.post('/add_element_to_set')
def add_element_to_set(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    return result

@hug.post('/create_set')
def create_set(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    return result

@hug.post('/delete_set')
def delete_set(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    return result

@hug.post('/delete_element_from_set')
def delete_element_from_set(json_data: hug.types.json):
    nft = Nftables()
    result = nft.json_cmd(json_data)
    return result
=== ./background/nftables-gui/nftables-parser/tables.py ===

import json
from nftables import Nftables
import sys
import hug

@hug.post('/create_table')
def create_table(json_data: hug.types.json):
    nft = Nftables()

    try:
        result = nft.json_cmd(json_data)
        if 'error' in result:
            return {'status': 'error', 'message': result['error']}
        else:
            return {'status': 'success', 'result': result}
    except Exception as e:
        return {'status': 'error', 'message': str(e)}
    
@hug.get('/list_ruleset')
def list_ruleset():
    nft = Nftables()
    result = nft.cmd("list ruleset")
    result = format_nftables_config(result[1])
    return {"ruleset": result}

def format_nftables_config(config_string):
    # Replace escape sequences with actual characters
    formatted_string = config_string.replace('\\n', '\n').replace('\\t', '\t')

    # Split the string into lines
    lines = formatted_string.split('\n')

    # Remove empty lines
    lines = [line for line in lines if line.strip() != '']

    # Join the lines back together with newline characters
    formatted_string = '\n'.join(lines)
    return formatted_string

@hug.get('/list_tables')
def list_tables():
    nft = Nftables()
    result = nft.cmd("list tables")
    return {"tables": result[1]}

@hug.post('/delete_table')
def delete_table(json_data: hug.types.json):
    nft = Nftables()

    try:
        result = nft.json_cmd(json_data)
        if 'error' in result:
            return {'status': 'error', 'message': result['error']}
        else:
            return {'status': 'success', 'result': result}
    except Exception as e:
        return {'status': 'error', 'message': str(e)}
    
@hug.get('/list_table')
def list_table(json_data: hug.types.json):
    nft = Nftables()
    try:
        result = nft.json_cmd(json_data)
        if 'error' in result:
            return {'status': 'error', 'message': result['error']}
        else:
            return {'status': 'success', 'result': result}
    except Exception as e:
        return {'status': 'error', 'message': str(e)}
    
@hug.get('/flush_table')
def flush_table(json_data: hug.types.json):
    nft = Nftables()

    try:
        result = nft.json_cmd(json_data)
        if 'error' in result:
            return {'status': 'error', 'message': result['error']}
        else:
            return {'status': 'success', 'result': result}
    except Exception as e:
        return {'status': 'error', 'message': str(e)}
=== ./background/nftables-gui/run.sh ===

#!/bin/bash

sudo apt install nftables python3-pip python3-hug python3-nftables

pip install -r requirements.txt

cd nftables-frontend

python3 app.py &

cd ../nftables-parser

sudo hug -f main.py

=== ./background/populate.sh ===

#!/bin/bash

set -e

# Create and populate background folder with project materials for Claude

mkdir -p relianoid
mkdir -p nftables-gui
mkdir -p webmin-docs
mkdir -p firewalld-docs
mkdir -p webmin-plugins
mkdir -p cockpit-extensions

# Clone relevant GitHub repositories

echo "Cloning Relianoid (Zevenet) ADC..."
git clone https://github.com/relianoid/adc-loadbalancer.git relianoid

echo "Cloning nftables-gui..."
git clone https://github.com/alegarsan11/nftables-gui.git nftables-gui

# Download Webmin developer docs

echo "Downloading Webmin developer documentation..."
curl -L -o webmin-docs/webmin-dev.html https://doxfer.webmin.com/Webmin/Webmin_Module_Development

# Download Firewalld rich rules documentation

echo "Downloading Firewalld rich rules documentation..."
curl -L -o firewalld-docs/rich-rules.html https://firewalld.org/documentation/howto/rich-language.html

# Optional: grab Webmin plugin examples

echo "Cloning example Webmin plugins..."
git clone https://github.com/webmin/webmin.git webmin-plugins

# Optional: grab Cockpit extensions for inspiration

echo "Cloning Cockpit packages (for extension reference)..."
git clone https://github.com/cockpit-project/cockpit.git cockpit-extensions

echo "✅ All background materials downloaded."
echo "You can now feed this folder into Claude or your preferred model to begin coding."


=== ./background/relianoid/build-deb.sh ===

#!/bin/bash
# Dependencies: rsync, fakeroot, dpkg-deb
set -Eeu

cd "$(dirname "${BASH_SOURCE[0]}")"

WORK_DIR="workdir"
rm -rf "$WORK_DIR"
mkdir "$WORK_DIR"

rsync --archive DEBIAN "$WORK_DIR/"
rsync --archive etc "$WORK_DIR/"
rsync --archive usr "$WORK_DIR/"

version=$(grep '^Version:' DEBIAN/control | awk '{print $2}')
package_name="relianoid_${version}_amd64.deb"

global_conf_template='usr/local/relianoid/share/global.conf.template'
sed -i "s/_VERSION_/$version/" "${WORK_DIR}/${global_conf_template}"

find "$WORK_DIR" -name .keep -exec rm {} \;

fakeroot dpkg-deb --build workdir "$package_name"

=== ./background/relianoid/etc/profile.d/relianoid.sh ===

#!/bin/bash

export PATH="${PATH}:/usr/local/relianoid/bin"

# If not using bash, it's most likely the load balancer is running a command 
# with environment variables
[ -z "$BASH_VERSION" ] && return

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

CLUSTER_STATUS=/etc/relianoid-ce-cluster.status

function cluster_node {
    [ -f $CLUSTER_STATUS ] && echo -n "[$(cat $CLUSTER_STATUS 2>/dev/null)] "
}

# set a fancy prompt (non-color, overwrite the one in /etc/profile)
# but only if not SUDOing and have SUDO_PS1 set; then assume smart user.
if ! [ -n "${SUDO_USER}" -a -n "${SUDO_PS1}" ]; then
    PS1='${debian_chroot:+($debian_chroot)}$(cluster_node)\u@\h:\w\$ '
fi

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
   PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD}\007"'
   ;;
*)
   ;;
esac


=== ./background/relianoid/usr/local/relianoid/bin/noid-cluster-notify.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use warnings;

use Linux::Inotify2;
use Sys::Hostname;

# Load configuration
require "/usr/local/relianoid/app/ucarp/etc/cluster.conf";

my $hostname = hostname();
my $sync     = "firstime";
my @alert    = "";
push(@alert, $configdir);
push(@alert, $rttables);

#log file
open STDERR, '>>', "$zeninolog" or die "Error creating log file";
open STDOUT, '>>', "$zeninolog" or die "Error creating log file";

print "Running the first replication...\n";
if ($exclude ne "") {
    my @commands = (
        "$rsync $rsync_args $exclude $configdir\/ root\@$remote_ip:$configdir\/",
        "$rsync $rsync_args $rttables root\@$remote_ip:$rttables",
    );

    for my $cmd (@commands) {
        print "$cmd\n";
        my @output = `$cmd`;
        print @output;
    }
}
print "First replication finished.\n";

my $inotify = Linux::Inotify2->new();

for (@alert) {
    $inotify->watch($_, IN_MODIFY | IN_CREATE | IN_DELETE);
}

while (1) {
    # By default this will block until some event is received
    my @events = $inotify->read();
    if (scalar(@events) == 0) {
        print "read error: $!";
        last;
    }

    for (@events) {
        unless ($_->name !~ /^\..*/ && $_->name !~ /.*\~$/) {
            next;
        }

        $action = sprintf("%d", $_->mask);
        $name   = sprintf($_->fullname);
        $file   = sprintf($_->name);

        if ($action eq 512) {
            $action = "DELETED";
        }
        if ($action eq 2) {
            $action = "MODIFIED";
        }
        if ($action eq 256) {
            $action = "CREATED";
        }

        printf "File: $file; Action: $action Fullname: $name\n";

        if ($name =~ /config/) {
            print "Exclude files: $exclude\n";
            my $cmd = "$rsync $rsync_args $exclude $configdir\/ root\@$remote_ip:$configdir\/";
            my @eject = `$cmd`;
            print @eject;
            print "ran replication process: $cmd\n";
        }

        if ($name =~ /iproute2/) {
            my $cmd = "$rsync $rsync_args $rttables root\@$remote_ip:$rttables";
            my @eject = `$cmd`;
            print @eject;
            print "ran replication process: $cmd\n";
        }
    }
}

=== ./background/relianoid/usr/local/relianoid/bin/noid-collector-cpu-rrd.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use RRDs;
use Relianoid::Config;
use Relianoid::Stats;

my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
my $db_cpu            = "cpu.rrd";
my $rrd_filename      = "${collector_rrd_dir}/${db_cpu}";

my @cpu = &getCPU();

my %cpu = ();
for my $array_ref (@cpu) {
    my ($key, $value) = @{$array_ref};
    $cpu{$key} = $value;
}

my $cpu_user    = $cpu{"CPUuser"};
my $cpu_nice    = $cpu{"CPUnice"};
my $cpu_sys     = $cpu{"CPUsys"};
my $cpu_iowait  = $cpu{"CPUiowait"};
my $cpu_irq     = $cpu{"CPUirq"};
my $cpu_softirq = $cpu{"CPUsoftirq"};
my $cpu_idle    = $cpu{"CPUidle"};
my $cpu_usage   = $cpu{"CPUusage"};

if (!$cpu_user || !$cpu_nice || !$cpu_sys || !$cpu_iowait || !$cpu_irq || !$cpu_softirq || !$cpu_idle || !$cpu_usage) {
    print STDERR "$0: Error: Unable to get the data\n";
    exit;
}

if (!-f $rrd_filename) {
    print "$0: Info: Creating the rrd database ${rrd_filename} ...\n";

    RRDs::create $rrd_filename,
      "--step", "300",
      "DS:user:GAUGE:600:0.00:100.00",
      "DS:nice:GAUGE:600:0.00:100.00",
      "DS:sys:GAUGE:600:0.00:100.00",
      "DS:iowait:GAUGE:600:0.00:100.00",
      "DS:irq:GAUGE:600:0.00:100.00",
      "DS:softirq:GAUGE:600:0.00:100.00",
      "DS:idle:GAUGE:600:0.00:100.00",
      "DS:tused:GAUGE:600:0.00:100.00", "RRA:LAST:0.5:1:288",    # daily - every 5 min - 288 reg
      "RRA:MIN:0.5:1:288",                                       # daily - every 5 min - 288 reg
      "RRA:AVERAGE:0.5:1:288",                                   # daily - every 5 min - 288 reg
      "RRA:MAX:0.5:1:288",                                       # daily - every 5 min - 288 reg
      "RRA:LAST:0.5:12:168",                                     # weekly - every 1 hour - 168 reg
      "RRA:MIN:0.5:12:168",                                      # weekly - every 1 hour - 168 reg
      "RRA:AVERAGE:0.5:12:168",                                  # weekly - every 1 hour - 168 reg
      "RRA:MAX:0.5:12:168",                                      # weekly - every 1 hour - 168 reg
      "RRA:LAST:0.5:96:93",                                      # monthly - every 8 hours - 93 reg
      "RRA:MIN:0.5:96:93",                                       # monthly - every 8 hours - 93 reg
      "RRA:AVERAGE:0.5:96:93",                                   # monthly - every 8 hours - 93 reg
      "RRA:MAX:0.5:96:93",                                       # monthly - every 8 hours - 93 reg
      "RRA:LAST:0.5:288:372",                                    # yearly - every 1 day - 372 reg
      "RRA:MIN:0.5:288:372",                                     # yearly - every 1 day - 372 reg
      "RRA:AVERAGE:0.5:288:372",                                 # yearly - every 1 day - 372 reg
      "RRA:MAX:0.5:288:372";                                     # yearly - every 1 day - 372 reg

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to generate the rrd database: ${error}\n";
    }
}

print "$0: Info: CPU Stats ...\n";
print "$0: Info:	user: ${cpu_user} %\n";
print "$0: Info:	nice: ${cpu_nice} %\n";
print "$0: Info:	sys: ${cpu_sys} %\n";
print "$0: Info:	iowait: ${cpu_iowait} %\n";
print "$0: Info:	irq: ${cpu_irq} %\n";
print "$0: Info:	softirq: ${cpu_softirq} %\n";
print "$0: Info:	idle: ${cpu_idle} %\n";
print "$0: Info:	total used: ${cpu_usage} %\n";
print "$0: Info: Updating data in ${rrd_filename} ...\n";

RRDs::update $rrd_filename,
  "-t", "user:nice:sys:iowait:irq:softirq:idle:tused",
  "N:${cpu_user}:${cpu_nice}:${cpu_sys}:${cpu_iowait}:${cpu_irq}:${cpu_softirq}:${cpu_idle}:${cpu_usage}";

if (my $error = RRDs::error) {
    print STDERR "$0: Error: Unable to update the rrd database: ${error}\n";
}

=== ./background/relianoid/usr/local/relianoid/bin/noid-collector-disk-rrd.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use RRDs;
use Relianoid::Config;
use Relianoid::Stats;

my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
my $db_hd             = "hd.rrd";

my @disks = getDiskSpace();

while (@disks) {
    my @total_ref = @{ shift @disks };
    my @used_ref  = @{ shift @disks };
    my @free_ref  = @{ shift @disks };

    my ($partition) = split("\ ", $total_ref[0]);
    my $rrd_filename = "${collector_rrd_dir}/${partition}${db_hd}";

    my $tot  = $total_ref[1];
    my $used = $used_ref[1];
    my $free = $free_ref[1];

    if ($tot =~ /^$/ || $used =~ /^$/ || $free =~ /^$/) {
        print STDERR "$0: Error: Unable to get the data for partition ${partition}\n";
        print STDERR "$0: tot:${tot} used:${used} free:${free}\n";
        next;
    }

    if (!-f $rrd_filename) {
        print "$0: Info: Creating the rrd database ${rrd_filename} ...\n";

        RRDs::create $rrd_filename,     #
          "--step", "300",              # data-point interval in seconds
          "DS:tot:GAUGE:600:0:U",       # total
          "DS:used:GAUGE:600:0:U",      # used
          "DS:free:GAUGE:600:0:U",      # free
          "RRA:LAST:0.5:1:288",         # daily - every 5 min - 288 reg
          "RRA:MIN:0.5:1:288",          # daily - every 5 min - 288 reg
          "RRA:AVERAGE:0.5:1:288",      # daily - every 5 min - 288 reg
          "RRA:MAX:0.5:1:288",          # daily - every 5 min - 288 reg
          "RRA:LAST:0.5:12:168",        # weekly - every 1 hour - 168 reg
          "RRA:MIN:0.5:12:168",         # weekly - every 1 hour - 168 reg
          "RRA:AVERAGE:0.5:12:168",     # weekly - every 1 hour - 168 reg
          "RRA:MAX:0.5:12:168",         # weekly - every 1 hour - 168 reg
          "RRA:LAST:0.5:96:93",         # monthly - every 8 hours - 93 reg
          "RRA:MIN:0.5:96:93",          # monthly - every 8 hours - 93 reg
          "RRA:AVERAGE:0.5:96:93",      # monthly - every 8 hours - 93 reg
          "RRA:MAX:0.5:96:93",          # monthly - every 8 hours - 93 reg
          "RRA:LAST:0.5:288:372",       # yearly - every 1 day - 372 reg
          "RRA:MIN:0.5:288:372",        # yearly - every 1 day - 372 reg
          "RRA:AVERAGE:0.5:288:372",    # yearly - every 1 day - 372 reg
          "RRA:MAX:0.5:288:372";        # yearly - every 1 day - 372 reg

        if (my $error = RRDs::error) {
            print STDERR "$0: Error: Unable to generate the rrd database for partition ${partition}: ${error}\n";
        }
    }

    print "$0: Info: Disk Stats for partition ${partition} ...\n";
    print "$0: Info:	Total: ${tot} Bytes\n";
    print "$0: Info:	Used: ${used} Bytes\n";
    print "$0: Info:	Free: ${free} Bytes\n";
    print "$0: Info: Updating data in ${rrd_filename} ...\n";

    RRDs::update $rrd_filename, "-t", "tot:used:free", "N:${tot}:${used}:${free}";

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to update the rrd database for partition ${partition}: ${error}\n";
    }
}

=== ./background/relianoid/usr/local/relianoid/bin/noid-collector-farm-rrd.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use RRDs;
use Relianoid::Farm::Base;
use Relianoid::Farm::Stats;
use Relianoid::Net::ConnStats;

my $eload = eval { require Relianoid::ELoad; };

my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');

foreach my $farmfile (&getFarmList()) {
    my $farm_name   = &getFarmName($farmfile);
    my $farm_type   = &getFarmType($farm_name);
    my $farm_status = &getFarmStatus($farm_name);

    if ($farm_type eq "datalink" || $farm_status ne "up") {
        next;
    }

    my $db_farm      = "${farm_name}-farm.rrd";
    my $rrd_filename = "${collector_rrd_dir}/${db_farm}";

    my $synconns;
    my $globalconns;

    if ($farm_type eq 'gslb' && $eload) {
        my $stats = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Stats',
            func   => 'getGSLBFarmStats',
            args   => [$farm_name],
        );

        $synconns    = $stats->{syn};
        $globalconns = $stats->{est};
    }
    elsif ($farm_type eq 'eproxy' && $eload) {
        my $stats = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Stats',
            func   => 'getEproxyFarmStats',
            args   => [ { 'farm_name' => $farm_name }],
        );

        $synconns    = $stats->{pending};
        $globalconns = $stats->{established};
    }
    else {
        my $vip = &getFarmVip("vip", $farm_name);
        my $netstat;

        if ($farm_type eq 'l4xnat') {
            $netstat = &getConntrack("", $vip, "", "", "");
        }

        $synconns    = &getFarmSYNConns($farm_name, $netstat);    # SYN_RECV connections
        $globalconns = &getFarmEstConns($farm_name, $netstat);    # ESTABLISHED connections
    }

    if ($globalconns eq '' || $synconns eq '') {
        print STDERR "$0: Error: Unable to get the data for farm ${farm_name}\n";
        exit;
    }

    if (!-f $rrd_filename) {
        print "$0: Info: Creating the rrd database ${rrd_filename} ...\n";

        RRDs::create $rrd_filename,                               #
          "--step", "300",                                        #
          "DS:pending:GAUGE:600:0:12500000",                      #
          "DS:established:GAUGE:600:0:12500000",                  #
          "RRA:LAST:0.5:1:288",                                   # daily - every 5 min - 288 reg
          "RRA:MIN:0.5:1:288",                                    # daily - every 5 min - 288 reg
          "RRA:AVERAGE:0.5:1:288",                                # daily - every 5 min - 288 reg
          "RRA:MAX:0.5:1:288",                                    # daily - every 5 min - 288 reg
          "RRA:LAST:0.5:12:168",                                  # weekly - every 1 hour - 168 reg
          "RRA:MIN:0.5:12:168",                                   # weekly - every 1 hour - 168 reg
          "RRA:AVERAGE:0.5:12:168",                               # weekly - every 1 hour - 168 reg
          "RRA:MAX:0.5:12:168",                                   # weekly - every 1 hour - 168 reg
          "RRA:LAST:0.5:96:93",                                   # monthly - every 8 hours - 93 reg
          "RRA:MIN:0.5:96:93",                                    # monthly - every 8 hours - 93 reg
          "RRA:AVERAGE:0.5:96:93",                                # monthly - every 8 hours - 93 reg
          "RRA:MAX:0.5:96:93",                                    # monthly - every 8 hours - 93 reg
          "RRA:LAST:0.5:288:372",                                 # yearly - every 1 day - 372 reg
          "RRA:MIN:0.5:288:372",                                  # yearly - every 1 day - 372 reg
          "RRA:AVERAGE:0.5:288:372",                              # yearly - every 1 day - 372 reg
          "RRA:MAX:0.5:288:372";                                  # yearly - every 1 day - 372 reg

        if (my $error = RRDs::error) {
            print STDERR "$0: Error: Unable to generate the swap rrd database: ${error}\n";
        }
    }

    print "$0: Info: ${farm_name} Farm Connections Stats ...\n";
    print "$0: Info:	Pending: ${synconns}\n";
    print "$0: Info:	Established: ${globalconns}\n";
    print "$0: Info: Updating data in ${rrd_filename} ...\n";

    RRDs::update($rrd_filename, "-t", "pending:established", "N:${synconns}:${globalconns}");

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to update the rrd database: ${error}\n";
    }
}

=== ./background/relianoid/usr/local/relianoid/bin/noid-collector-iface-rrd.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use RRDs;
use Relianoid::Config;
use Relianoid::Stats;

my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
my $db_if             = "iface.rrd";

my @net      = &getNetworkStats("hash");
my $net_size = scalar @net;

for (my $it = 0 ; $it < $net_size ; $it++) {
    my $row = shift @net;

    my $if_name = $row->{interface};

    if ($if_name eq 'lo' || $if_name =~ /:/) {
        next;
    }

    my $rrd_filename = "${collector_rrd_dir}/${if_name}${db_if}";
    my $in           = $row->{in} * 1000;
    my $out          = $row->{out} * 1000;

    if (! defined $in || ! defined $out) {
        print STDERR "$0: Error: Unable to get the data\n";
        next;
    }

    if (!-f $rrd_filename) {
        print "$0: Info: Creating the rrd database ${if_name} ${rrd_filename} ...\n";

        RRDs::create $rrd_filename,          #
          "--step",                          #
          "300",                             #
          "DS:in:DERIVE:600:0:12500000",     #
          "DS:out:DERIVE:600:0:12500000",    #
          "RRA:LAST:0.5:1:288",              # daily - every 5 min - 288 reg
          "RRA:MIN:0.5:1:288",               # daily - every 5 min - 288 reg
          "RRA:AVERAGE:0.5:1:288",           # daily - every 5 min - 288 reg
          "RRA:MAX:0.5:1:288",               # daily - every 5 min - 288 reg
          "RRA:LAST:0.5:12:168",             # weekly - every 1 hour - 168 reg
          "RRA:MIN:0.5:12:168",              # weekly - every 1 hour - 168 reg
          "RRA:AVERAGE:0.5:12:168",          # weekly - every 1 hour - 168 reg
          "RRA:MAX:0.5:12:168",              # weekly - every 1 hour - 168 reg
          "RRA:LAST:0.5:96:93",              # monthly - every 8 hours - 93 reg
          "RRA:MIN:0.5:96:93",               # monthly - every 8 hours - 93 reg
          "RRA:AVERAGE:0.5:96:93",           # monthly - every 8 hours - 93 reg
          "RRA:MAX:0.5:96:93",               # monthly - every 8 hours - 93 reg
          "RRA:LAST:0.5:288:372",            # yearly - every 1 day - 372 reg
          "RRA:MIN:0.5:288:372",             # yearly - every 1 day - 372 reg
          "RRA:AVERAGE:0.5:288:372",         # yearly - every 1 day - 372 reg
          "RRA:MAX:0.5:288:372";             # yearly - every 1 day - 372 reg

        if (my $error = RRDs::error) {
            print STDERR "$0: Error: Unable to generate the rrd database for interface ${if_name}: ${error}\n";
        }
    }

    print "$0: Info: Network Stats for interface ${if_name} ...\n";
    print "$0: Info:	in: ${in}\n";
    print "$0: Info:	out: ${out}\n";
    print "$0: Info: Updating data in ${rrd_filename} ...\n";

    RRDs::update $rrd_filename, "-t", "in:out", "N:${in}:${out}";

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to update the rrd database for interface ${if_name}: ${error}\n";
    }
}

=== ./background/relianoid/usr/local/relianoid/bin/noid-collector-load-rrd.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use RRDs;
use Relianoid::Config;
use Relianoid::Stats;

my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
my $db_load           = "load.rrd";
my $rrd_filename      = "${collector_rrd_dir}/${db_load}";

my @load = &getLoadStats();

my %load = ();
for my $array_ref (@load) {
    my ($key, $value) = @{$array_ref};
    $load{$key} = $value;
}

my $last   = $load{"Last"};
my $last5  = $load{"Last 5"};
my $last15 = $load{"Last 15"};

if (!$last || !$last5 || !$last15) {
    print STDERR "$0: Error: Unable to get the data\n";
    exit;
}

if (!-f $rrd_filename) {
    print "$0: Info: Creating the rrd database ${rrd_filename} ...\n";

    RRDs::create $rrd_filename,             #
      "--step",                             #
      "300",                                #
      "DS:load:GAUGE:600:0.00:100.00",      #
      "DS:load5:GAUGE:600:0.00:100.00",     #
      "DS:load15:GAUGE:600:0.00:100.00",    #
      "RRA:LAST:0.5:1:288",                 # daily - every 5 min - 288 reg
      "RRA:MIN:0.5:1:288",                  # daily - every 5 min - 288 reg
      "RRA:AVERAGE:0.5:1:288",              # daily - every 5 min - 288 reg
      "RRA:MAX:0.5:1:288",                  # daily - every 5 min - 288 reg
      "RRA:LAST:0.5:12:168",                # weekly - every 1 hour - 168 reg
      "RRA:MIN:0.5:12:168",                 # weekly - every 1 hour - 168 reg
      "RRA:AVERAGE:0.5:12:168",             # weekly - every 1 hour - 168 reg
      "RRA:MAX:0.5:12:168",                 # weekly - every 1 hour - 168 reg
      "RRA:LAST:0.5:96:93",                 # monthly - every 8 hours - 93 reg
      "RRA:MIN:0.5:96:93",                  # monthly - every 8 hours - 93 reg
      "RRA:AVERAGE:0.5:96:93",              # monthly - every 8 hours - 93 reg
      "RRA:MAX:0.5:96:93",                  # monthly - every 8 hours - 93 reg
      "RRA:LAST:0.5:288:372",               # yearly - every 1 day - 372 reg
      "RRA:MIN:0.5:288:372",                # yearly - every 1 day - 372 reg
      "RRA:AVERAGE:0.5:288:372",            # yearly - every 1 day - 372 reg
      "RRA:MAX:0.5:288:372";                # yearly - every 1 day - 372 reg

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to generate the rrd database: ${error}\n";
    }
}

print "$0: Info: Load Stats ...\n";
print "$0: Info:	Last minute: ${last}\n";
print "$0: Info:	Last 5 minutes: ${last5}\n";
print "$0: Info:	Last 15 minutes: ${last15}\n";
print "$0: Info: Updating data in ${rrd_filename} ...\n";

RRDs::update $rrd_filename, "-t", "load:load5:load15", "N:${last}:${last5}:${last15}";

if (my $error = RRDs::error) {
    print STDERR "$0: Error: Unable to update the rrd database: ${error}\n";
}

=== ./background/relianoid/usr/local/relianoid/bin/noid-collector-memory-rrd.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID SL, Sevilla (Spain)
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use RRDs;
use Relianoid::Config;
use Relianoid::Stats;

my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');

my $db_mem   = "mem.rrd";
my $db_memsw = "memsw.rrd";

my $ram_rrd_filename  = "${collector_rrd_dir}/${db_mem}";
my $swap_rrd_filename = "${collector_rrd_dir}/${db_memsw}";

my @mem = &getMemStats("b");

my %mem = ();
for my $array_ref (@mem) {
    my ($key, $value) = @{$array_ref};
    $mem{$key} = $value;
}

my $mvalue  = $mem{"MemTotal"};
my $mused   = $mem{"MemUsed"};
my $mfvalue = $mem{"MemFree"};
my $mbvalue = $mem{"Buffers"};
my $mcvalue = $mem{"Cached"};

my $swtvalue = $mem{"SwapTotal"};
my $swfvalue = $mem{"SwapFree"};
my $swused   = $mem{"SwapUsed"};
my $swcvalue = $mem{"SwapCached"};

if (!$mvalue || !$mused || !$mfvalue || !$mcvalue || !$swtvalue || !$swfvalue || !$swused || !$swcvalue) {
    print STDERR "$0: Error: Unable to get the data\n";
    exit;
}

if (!-f $ram_rrd_filename) {
    print "$0: Info: Creating the rrd database ${ram_rrd_filename} ...\n";

    RRDs::create $ram_rrd_filename,    #
      "--step", "300",                 # data-point interval in seconds
      "DS:memt:GAUGE:600:0:U",         # total
      "DS:memu:GAUGE:600:0:U",         # used
      "DS:memf:GAUGE:600:0:U",         # free
      "DS:memc:GAUGE:600:0:U",         # cache
      "RRA:LAST:0.5:1:288",            # daily - every 5 min - 288 reg
      "RRA:MIN:0.5:1:288",             # daily - every 5 min - 288 reg
      "RRA:AVERAGE:0.5:1:288",         # daily - every 5 min - 288 reg
      "RRA:MAX:0.5:1:288",             # daily - every 5 min - 288 reg
      "RRA:LAST:0.5:12:168",           # weekly - every 1 hour - 168 reg
      "RRA:MIN:0.5:12:168",            # weekly - every 1 hour - 168 reg
      "RRA:AVERAGE:0.5:12:168",        # weekly - every 1 hour - 168 reg
      "RRA:MAX:0.5:12:168",            # weekly - every 1 hour - 168 reg
      "RRA:LAST:0.5:96:93",            # monthly - every 8 hours - 93 reg
      "RRA:MIN:0.5:96:93",             # monthly - every 8 hours - 93 reg
      "RRA:AVERAGE:0.5:96:93",         # monthly - every 8 hours - 93 reg
      "RRA:MAX:0.5:96:93",             # monthly - every 8 hours - 93 reg
      "RRA:LAST:0.5:288:372",          # yearly - every 1 day - 372 reg
      "RRA:MIN:0.5:288:372",           # yearly - every 1 day - 372 reg
      "RRA:AVERAGE:0.5:288:372",       # yearly - every 1 day - 372 reg
      "RRA:MAX:0.5:288:372";           # yearly - every 1 day - 372 reg

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to generate the memory rrd database: ${error}\n";
    }
}

if (!-f $swap_rrd_filename) {
    print "$0: Info: Creating the rrd database ${swap_rrd_filename} ...\n";

    RRDs::create $swap_rrd_filename,    #
      "--step", "300",                  # data-point interval in seconds
      "DS:swt:GAUGE:600:0:U",           # total
      "DS:swu:GAUGE:600:0:U",           # used
      "DS:swf:GAUGE:600:0:U",           # free
      "DS:swc:GAUGE:600:0:U",           # cache
      "RRA:LAST:0.5:1:288",             # daily - every 5 min - 288 reg
      "RRA:MIN:0.5:1:288",              # daily - every 5 min - 288 reg
      "RRA:AVERAGE:0.5:1:288",          # daily - every 5 min - 288 reg
      "RRA:MAX:0.5:1:288",              # daily - every 5 min - 288 reg
      "RRA:LAST:0.5:12:168",            # weekly - every 1 hour - 168 reg
      "RRA:MIN:0.5:12:168",             # weekly - every 1 hour - 168 reg
      "RRA:AVERAGE:0.5:12:168",         # weekly - every 1 hour - 168 reg
      "RRA:MAX:0.5:12:168",             # weekly - every 1 hour - 168 reg
      "RRA:LAST:0.5:96:93",             # monthly - every 8 hours - 93 reg
      "RRA:MIN:0.5:96:93",              # monthly - every 8 hours - 93 reg
      "RRA:AVERAGE:0.5:96:93",          # monthly - every 8 hours - 93 reg
      "RRA:MAX:0.5:96:93",              # monthly - every 8 hours - 93 reg
      "RRA:LAST:0.5:288:372",           # yearly - every 1 day - 372 reg
      "RRA:MIN:0.5:288:372",            # yearly - every 1 day - 372 reg
      "RRA:AVERAGE:0.5:288:372",        # yearly - every 1 day - 372 reg
      "RRA:MAX:0.5:288:372";            # yearly - every 1 day - 372 reg

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to generate the swap rrd database: ${error}\n";
    }
}

print "$0: Info: Memory Stats ...\n";
print "$0: Info:	Total Memory: ${mvalue} Bytes\n";
print "$0: Info:	Used Memory: ${mused} Bytes\n";
print "$0: Info:	Free Memory: ${mfvalue} Bytes\n";
print "$0: Info:	Cached Memory: ${mcvalue} Bytes\n";
print "$0: Info:	Buffered Memory: ${mbvalue} Bytes\n";
print "$0: Info: Updating data in ${ram_rrd_filename} ...\n";

RRDs::update $ram_rrd_filename, "-t", "memt:memu:memf:memc", "N:${mvalue}:${mused}:${mfvalue}:" . ($mcvalue + $mbvalue);

if (my $error = RRDs::error) {
    print STDERR "$0: Error: Unable to update the rrd database: ${error}\n";
}

print "$0: Info: Swap Stats ...\n";
print "$0: Info:	Total Memory Swap: ${swtvalue} Bytes\n";
print "$0: Info:	Used Memory Swap: ${swused} Bytes\n";
print "$0: Info:	Free Memory Swap: ${swfvalue} Bytes\n";
print "$0: Info:	Cached Memory Swap: ${swcvalue} Bytes\n";
print "$0: Info: Updating data in $swap_rrd_filename ...\n";

RRDs::update $swap_rrd_filename, "-t", "swt:swu:swf:swc", "N:${swtvalue}:${swused}:${swfvalue}:${swcvalue}";

if (my $error = RRDs::error) {
    print STDERR "$0: Error: Unable to update the rrd database: ${error}\n";
}

=== ./background/relianoid/usr/local/relianoid/bin/noid-collector-temperature-rrd.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use RRDs;
use Relianoid::Config;
use Relianoid::SystemInfo;
use Relianoid::Stats;

my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
my $db_temp           = "temp.rrd";
my $rrd_filename      = "${collector_rrd_dir}/${db_temp}";

# this script is only for ZNA
if (&getApplianceVersion() !~ /ZNA/) {
    exit;
}

my $temp = &getCPUTemp();

if ($temp eq '') {
    print STDERR "$0: Error: Unable to get the data\n";
    exit;
}

if (!-f $rrd_filename) {
    print "$0: Info: Creating the rrd database ${rrd_filename} ...\n";

    RRDs::create $rrd_filename,     #
      "--step", "300",              # data-point interval in seconds
      "DS:temp:GAUGE:600:0:100",    # temperature
      "RRA:LAST:0.5:1:288",         # daily - every 5 min - 288 reg
      "RRA:MIN:0.5:1:288",          # daily - every 5 min - 288 reg
      "RRA:AVERAGE:0.5:1:288",      # daily - every 5 min - 288 reg
      "RRA:MAX:0.5:1:288",          # daily - every 5 min - 288 reg
      "RRA:LAST:0.5:12:168",        # weekly - every 1 hour - 168 reg
      "RRA:MIN:0.5:12:168",         # weekly - every 1 hour - 168 reg
      "RRA:AVERAGE:0.5:12:168",     # weekly - every 1 hour - 168 reg
      "RRA:MAX:0.5:12:168",         # weekly - every 1 hour - 168 reg
      "RRA:LAST:0.5:96:93",         # monthly - every 8 hours - 93 reg
      "RRA:MIN:0.5:96:93",          # monthly - every 8 hours - 93 reg
      "RRA:AVERAGE:0.5:96:93",      # monthly - every 8 hours - 93 reg
      "RRA:MAX:0.5:96:93",          # monthly - every 8 hours - 93 reg
      "RRA:LAST:0.5:288:372",       # yearly - every 1 day - 372 reg
      "RRA:MIN:0.5:288:372",        # yearly - every 1 day - 372 reg
      "RRA:AVERAGE:0.5:288:372",    # yearly - every 1 day - 372 reg
      "RRA:MAX:0.5:288:372";        # yearly - every 1 day - 372 reg

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to generate the rrd database: ${error}\n";
    }
}

print "$0: Info: Temperature Stats ...\n";
print "$0: Info:	Temp: ${temp}\n";
print "$0: Info: Updating data in ${rrd_filename} ...\n";

RRDs::update $rrd_filename, "-t", "temp", "N:${temp}";

if (my $error = RRDs::error) {
    print STDERR "$0: Error: Unable to update the rrd database: ${error}\n";
}

=== ./background/relianoid/usr/local/relianoid/migrations/000-interfaces.pl ===

#!/usr/bin/perl

use strict;
use warnings;
use feature qw(signatures say);

use Config::Tiny;
use Relianoid::Config;
use Relianoid::Net::Interface;
use Relianoid::Validate;
use Relianoid::Log;

my $iface_files_dir = "/usr/local/relianoid/config";

opendir(my $dir, $iface_files_dir);
my @iface_files = grep { /^if_.*_conf/ && -f "$iface_files_dir/$_" } readdir($dir);
closedir $dir;

for my $file (@iface_files) {
    #Parse filename to obtain file
    $file =~ /if_(?<iface>.*)_conf/;
    my $iface = $+{iface};

    #Trying to read, set the errstr error if in tiny format
    my $iface_file = Config::Tiny->read("$iface_files_dir/$file");

    #Don't migrate if is in tiny format ( there is no error when reading and the section is defined )
    next
      if (!(Config::Tiny->errstr =~ /$iface/)
        && defined $iface_file->{$iface});

    &log_info("Migrating $iface configuration files", "NETWORK");

    #Is not in Tiny format, if unset, delete file, if set, parse the file
    say "File $file not in tiny format";
    my $if_ref = &_getInterfaceConfig($iface);

    unlink "$iface_files_dir/$file";

    #Setted
    require Relianoid::Net::Interface;
    &setInterfaceConfig($if_ref) if (defined $if_ref);
}
&log_info("Interfaces configuration migration finished", "NETWORK");

sub _getInterfaceConfig    # \%iface ($if_name, $ip_version)
{
    my ($if_name) = @_;

    unless (defined $if_name) {
        &log_debug2('getInterfaceConfig got undefined interface name', 'network');
    }

    #~ &log_info( "[CALL] getInterfaceConfig( $if_name )" );

    my $ip_version;
    my $if_line;
    my $if_status;
    my $configdir       = &getGlobalConfiguration('configdir');
    my $config_filename = "$configdir/if_${if_name}_conf";

    if (open my $file, '<', "$config_filename") {
        my @lines = grep { !/^(\s*#|$)/ } <$file>;

        for my $line (@lines) {
            my (undef, $ip) = split ';', $line;

            if (defined $ip) {
                $ip_version =
                    ($ip =~ /:/)  ? 6
                  : ($ip =~ /\./) ? 4
                  :                 undef;
            }

            if (defined $ip_version && !$if_line) {
                $if_line = $line;
            }
            elsif ($line =~ /^status=/) {
                $if_status = $line;
                $if_status =~ s/^status=//;
                chomp $if_status;
            }
        }
        close $file;
    }

    # includes !$if_status to avoid warning
    if (!$if_line && (!$if_status || $if_status !~ /up/)) {
        return;
    }

    chomp($if_line);
    my @if_params = split(';', $if_line);

    # Example: eth0;10.0.0.5;255.255.255.0;up;10.0.0.1;

    require IO::Socket;
    my $socket = IO::Socket::INET->new(Proto => 'udp');

    my %iface;

    $iface{name}    = shift @if_params // $if_name;
    $iface{addr}    = shift @if_params;
    $iface{mask}    = shift @if_params;
    $iface{gateway} = shift @if_params;                        # optional
    $iface{status}  = $if_status;
    $iface{dev}     = $if_name;
    $iface{vini}    = undef;
    $iface{vlan}    = undef;
    $iface{mac}     = undef;
    $iface{type}    = &getInterfaceType($if_name);
    $iface{parent}  = &getParentInterfaceName($iface{name});
    $iface{ip_v} =
      ($iface{addr} =~ /:/) ? '6' : ($iface{addr} =~ /\./) ? '4' : 0;
    $iface{net} =
      &getAddressNetwork($iface{addr}, $iface{mask}, $iface{ip_v});

    if ($iface{dev} =~ /:/) {
        ($iface{dev}, $iface{vini}) = split ':', $iface{dev};
    }

    if (!$iface{name}) {
        $iface{name} = $if_name;
    }

    if ($iface{dev} =~ /./) {
        # dot must be escaped
        ($iface{dev}, $iface{vlan}) = split '\.', $iface{dev};
    }

    $iface{mac} = $socket->if_hwaddr($iface{dev});

    # Interfaces without ip do not get HW addr via socket,
    # in those cases get the MAC from the OS.
    unless ($iface{mac}) {
        open my $fh, '<', "/sys/class/net/$if_name/address";
        chomp($iface{mac} = <$fh>);
        close $fh;
    }

    # complex check to avoid warnings
    if ((!exists($iface{vini}) || !defined($iface{vini}) || $iface{vini} eq '')
        && $iface{addr})
    {
        require Config::Tiny;
        my $float = Config::Tiny->read(&getGlobalConfiguration('floatfile'));

        $iface{float} = $float->{_}{ $iface{name} } // '';
    }

    # for virtual interface, overwrite mask and gw with parent values
    if ($iface{type} eq 'vini') {
        my $if_parent = &getInterfaceConfig($iface{parent});
        $iface{mask}    = $if_parent->{mask};
        $iface{gateway} = $if_parent->{gateway};
    }

    return \%iface;
}

=== ./background/relianoid/usr/local/relianoid/migrations/001-zproxyng_2_pound.sh ===

#!/usr/bin/bash

source /usr/local/relianoid/bin/load_global_conf
load_global_conf

name="Name"
nfmark="NfMark"

for i in $(find /usr/local/relianoid/config/ -name "*_proxy.cfg" -or -name "*_pound.cfg");
do
	echo "Checking Name and NfMark directive in farm config file: $i"
	grep "^\s*Name\s*\"" $i &>/dev/null
	if [[ $? == 0 ]];then
		echo "Remove directive 'Name' to farm config file: $i"
		fname=`echo $i | cut -d"_" -f1 | cut -d"/" -f6`
		sed -i "/^\s*Name\s*\"/d" "$i"
	fi

	grep "^\s*NfMark\s*" $i &>/dev/null
	if [[ $? == 0 ]];then
		echo "Remove directive 'NfMark' to farm config file: $i"
		fname=`echo $i | cut -d"_" -f1 | cut -d"/" -f6`
		sed -i "/^\s*NfMark\s*/d" "$i"
	fi

	sed -i "s/usr.local.zevenet/usr\/local\/relianoid/g" "$i"
done

=== ./background/relianoid/usr/local/relianoid/migrations/002-certificates.sh ===

#!/usr/bin/bash
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

# Migrate certificates files to new directory
mv /usr/local/relianoid/config/{*.pem,*.csr,*.key} /usr/local/relianoid/config/certificates/ 2>/dev/null

# Migrate certificate of farm config file
for i in $(find /usr/local/relianoid/config/ -name "*_proxy.cfg" -o -name "*_pound.cfg");
do
	if grep 'Cert \"\/usr\/local\/relianoid\/config\/\w.*\.pem' $i | grep -qv certificates; then
		echo "Migrating certificate directory of config file"
		sed -i -e 's/Cert \"\/usr\/local\/relianoid\/config/Cert \"\/usr\/local\/relianoid\/config\/certificates/' $i
	fi
done

# Migrate http server certificate
http_conf="/usr/local/relianoid/app/cherokee/etc/cherokee/cherokee.conf"

grep -E "/usr/local/relianoid/config/[^\/]+.pem" $http_conf
if [ $? -eq 0 ]; then
	echo "Migrating certificate of http server"
	perl -E '
use strict;
use Tie::File;
tie my @fh, "Tie::File", "/usr/local/relianoid/app/cherokee/etc/cherokee/cherokee.conf";
for my $line (@fh)
{
	if ($line =~ m"/usr/local/relianoid/config/[^/]+\.(pem|csr|key)" )
	{

		unless( $line =~ s"/usr/local/relianoid/config"/usr/local/relianoid/config/certificates"m)
		{
			say "Error modifying: >$line<";
		}
		say "migrated $line";
	}
}
close @fh;
	'
fi


=== ./background/relianoid/usr/local/relianoid/migrations/003-dh2048_cherokee.sh ===

#!/usr/bin/bash
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

#Add DH param to 2048 in cherokee conf

cherokee_conf="/usr/local/relianoid/app/cherokee/etc/cherokee/cherokee.conf"

if [[ ! `grep "^vserver\!1\!ssl_dh_length.*" $cherokee_conf` ]]; then
	echo "DH param not found in cherokee conf, adding"
	sed -i '/server!user = root/a vserver!1!ssl_dh_length = 2048' $cherokee_conf
fi



=== ./background/relianoid/usr/local/relianoid/migrations/003-migrate-noid-default-cert.sh ===

#!/usr/bin/bash
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

if [ ! -f "/usr/local/relianoid/share/noid_ssl_cert.pem" ]; then
	echo "Default SSL certificate does not exist _/usr/local/relianoid/share/noid_ssl_cert.pem_"
	exit 1
fi

if [ ! -f "/usr/local/relianoid/config/certificates/noid_ssl_cert.key" ]; then
	cp /usr/local/relianoid/share/noid_ssl_cert.key /usr/local/relianoid/config/certificates/
fi
if [ ! -f "/usr/local/relianoid/config/certificates/noid_ssl_cert.pem" ]; then
	cp /usr/local/relianoid/share/noid_ssl_cert.pem /usr/local/relianoid/config/certificates/
fi

# Migrate cherokee default certificate
if [ -f "/usr/local/relianoid/app/cherokee/etc/cherokee/cherokee.conf" ] && [ "`grep zencert /usr/local/relianoid/app/cherokee/etc/cherokee/cherokee.conf`" != "" ]; then
	sed -i -e 's/zencert-c/noid_ssl_cert/g' /usr/local/relianoid/app/cherokee/etc/cherokee/cherokee.conf
	sed -i -e 's/zencert/noid_ssl_cert/g' /usr/local/relianoid/app/cherokee/etc/cherokee/cherokee.conf
fi

# Migrate HTTP/S farms default certificate
for i in $(find /usr/local/relianoid/config/ -name "*proxy.cfg");
do
	if [ "`grep zencert $i`" != "" ]; then
		sed -i -e 's/zencert.pem/noid_ssl_cert.pem/g' "$i"
	fi
done

# Finally, remove obsolete zencert
rm -rf /usr/local/zevenet/config/certificates/zencert-c.key /usr/local/zevenet/config/certificates/zencert.pem

=== ./background/relianoid/usr/local/relianoid/migrations/004-farmguardian.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

# Description:
# Migrate from old Farmguardian configuration file to new Farmguardian configuration format

use strict;
use warnings;

use Relianoid::Log;
use Relianoid::Config;

my $conf_dir = &getGlobalConfiguration('configdir');
my $fg_conf  = "$conf_dir/farmguardian.conf";

use Relianoid::File;
use Relianoid::FarmGuardian;

opendir(my $dir, $conf_dir) or return;
my $index = 0;
while (my $file = readdir($dir)) {
    if ($file =~ /_guardian\.conf$/) {
        print " + Migrating Farmguardian file $conf_dir/$file ...\n";
        my $file_content = &getFile("$conf_dir/$file");
        chomp $file_content;

        my $file_name;
        my $service;
        $file_name = $1 if $file =~ /^(.+)_guardian\.conf$/;
        my ($farm, $interval, $command, $cut, $log) =
          split(/:{3}/, $file_content);
        ($farm, $service) = split(/_/, $file_name);

        my @check_command     = split(/ /, $command);
        my $farmguardian_name = "migrated" . $index++ . "_" . $check_command[0];
        my $farmguardian_ref  = {
            "description" => "check migrated from community backup",
            "interval"    => $interval,
            "command"     => "$command",
            "cut_conns"   => "$cut",
            "log"         => "$log"
        };

        print "      Create Farmguardian $farmguardian_name ... ";
        my $error = &createFGBlank($farmguardian_name);
        if ($error) {
            print "ERROR\n";
            next;
        }
        print "OK\n";
        print "      Update Farmguardian $farmguardian_name ... ";
        $error = &setFGObject($farmguardian_name, $farmguardian_ref);

        #$error = &setTinyObj( $fg_conf, $farmguardian_name, $farmguardian_ref );
        if ($error) {
            print "ERROR\n";
            next;
        }
        print "OK\n";
        print "      Link farm : $farm ";
        print " service : $service " if $service;
        print " to Farmguardian : $farmguardian_name ...";
        $error = &linkFGFarm($farmguardian_name, $farm, $service);
        if ($error) {
            print "ERROR\n";
            next;
        }
        print "OK\n";
        print "      Delete old configuration file : $file ... ";
        unlink "$conf_dir/$file";
        if (-f "$conf_dir/$file") {
            print "ERROR\n";
        }
        else {
            print "OK\n";
        }
    }
}

closedir($dir);

=== ./background/relianoid/usr/local/relianoid/migrations/006-http_name.sh ===

#!/usr/bin/bash
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

source /usr/local/relianoid/bin/load_global_conf
load_global_conf

for i in $(find /usr/local/relianoid/config/ -name "*_proxy.cfg" -or -name "*_pound.cfg");
do
	fname=`echo $i | cut -d"_" -f1 | cut -d"/" -f6`

	echo "Checking User directive in farm config file: $i"
	grep "^User.*" $i &>/dev/null
	if [[ $? != 0 ]];then
		echo "Adding directive 'User' to farm config file: $i"
		sed -i "/^##GLOBAL OPTIONS/ aUser\t\t\"root\"" $i
	fi

	echo "Checking Group directive in farm config file: $i"
	grep "^Group.*" $i &>/dev/null
	if [[ $? != 0 ]];then
		echo "Adding directive 'Group' to farm config file: $i"
		sed -i "/^User/ aGroup\t\t\"root\"" $i
	fi

	echo "Checking Name directive in farm config file: $i"
	grep "^Name.*" $i &>/dev/null
	if [[ $? != 0 ]];then
		echo "Adding directive 'Name' to farm config file: $i"
		sed -i "/^Group/ aName\t\t${fname}" $i
	fi

	echo "Checking Control directive in farm config file: $i"
	grep "^Control.*" $i &>/dev/null
	if [[ $? != 0 ]];then
		echo "Adding directive 'Control' to farm config file: $i"
		sed -i "/^ThreadModel/ aControl\t\t\"/tmp/${fname}_proxy.socket\"" $i
	fi

done

=== ./background/relianoid/usr/local/relianoid/migrations/014-snmpd.sh ===

#!/usr/bin/bash

###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

perl -MRelianoid::SNMP -E "&setSnmpdDefaultConfig();"

=== ./background/relianoid/usr/share/perl5/Relianoid.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Core;
use Relianoid::Log;
use Relianoid::Config;
use Relianoid::Validate;
use Relianoid::Debug;
use Relianoid::Netfilter;
use Relianoid::Net::Interface;
use Relianoid::FarmGuardian;
use Relianoid::Backup;
use Relianoid::RRD;
use Relianoid::SNMP;
use Relianoid::Stats;
use Relianoid::SystemInfo;
use Relianoid::System;
use Relianoid::API;

require Relianoid::CGI if defined $ENV{GATEWAY_INTERFACE};

=pod

=head1 Module

Relianoid

=cut

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/API.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures state);

my $eload = eval { require Relianoid::ELoad; };

=pod

=head1 Module

Relianoid::API

=cut

=pod

=head1 getAPI

Get API status

Parameters:

    name - 'status' to get if the user 'api' is enabled, or 'api_key' to get the 'api_key'.

Returns:

    For 'status': Boolean. 'true' if the API user is enabled, or 'false' if it is disabled.

    For 'api_key': Returns the current api_key.

=cut

sub getAPI ($name) {
    require Relianoid::File;

    my $result = "false";

    if ($name eq "status") {
        if (grep { /^api:/ } readFileAsArray(&getGlobalConfiguration('htpass'))) {
            $result = "true";
        }
    }
    elsif ($name eq "api_key") {
        $result = &getGlobalConfiguration('api_key');
    }

    return $result;
}

=pod

=head1 setAPI

Set API values

Parameters:

    name - Actions to be taken: 'enable', 'disable', 'randomkey' to set a random key, or 'key' to set the key specified in value.

        enable    - Enables the user 'api'.
        disable   - Disables the user 'api'.
        randomkey - Generates a random key.
        key       - Sets $value a the api_key.

    value - New key to be used. Only apply when the action 'key' is used.

Returns:

    none

=cut

sub setAPI ($action, $value = undef) {
    if ($action eq "enable") {
        my $cmd = "adduser --system --shell /bin/false --no-create-home api";

        return &logAndRun($cmd);
    }
    elsif ($action eq "disable") {
        setGlobalConfiguration('api_key', "");

        # Update api_key global configuration
        &getGlobalConfiguration('api_key', 1);

        my $deluser_bin = &getGlobalConfiguration('deluser_bin');
        my $cmd         = "$deluser_bin api";

        return &logAndRun($cmd);
    }
    elsif ($action eq "randomkey") {
        my $random = &getAPIRandomKey(64);

        setGlobalConfiguration('api_key', $random);
    }
    elsif ($action eq "key") {
        if ($eload) {
            $value = &eload(
                module => 'Relianoid::EE::Code',
                func   => 'setCryptString',
                args   => [$value],
            );
        }

        setGlobalConfiguration('api_key', $value);

        # Update api_key global configuration
        &getGlobalConfiguration('api_key', 1);
    }

    return;
}

=pod

=head1 getAPIRandomKey

Generate random key for API user.

Parameters:

    length - Number of characters in the new key.

Returns: string - Random key.

=cut

sub getAPIRandomKey ($length) {
    my @alphanumeric = ('a' .. 'z', 'A' .. 'Z', 0 .. 9);
    my $randpassword = join '', map { $alphanumeric[ rand @alphanumeric ] } 0 .. $length;

    return $randpassword;
}

=pod

=head1 isApiKeyValid

Validates the API key received with the HTTP header API_KEY

Parameters: None

Returns: integer - integer used as boolean

=cut

sub isApiKeyValid () {
    require Relianoid::User;

    my $is_valid = 0;
    my $key      = get_http_api_key();

    if ($key) {
        if (&getAPI("status") eq "true" && &getAPI("api_key") eq $key) {
            &setUser('root');
            $is_valid = 1;
        }
        elsif ($eload) {
            my $user = &eload(
                module => 'Relianoid::EE::RBAC::User::Core',
                func   => 'validateRBACUserAPIKey',
                args   => [$key],
            );
            if ($user) {
                &setUser($user);
                $is_valid = 1;
            }
        }
    }

    return $is_valid;
}

=pod

=head1 getApiVersionsList

Parameters: None

Returns: string array - list of API versions (as strings)

=cut

sub getApiVersionsList () {
    return (sort split ' ', &getGlobalConfiguration("api_versions"));
}

=pod

=head1 getApiVersion

Parameters:

    none

Returns:

    string - API version or empty string.

=cut

sub getApiVersion () {
    return $ENV{API_VERSION} // "";
}

sub get_http_api_key () {
    return $ENV{HTTP_API_KEY} if $ENV{HTTP_API_KEY};

    state $warned_deprecation = 0;

    if (exists $ENV{HTTP_ZAPI_KEY}) {
        if (not $warned_deprecation) {
            log_warn("The HTTP header 'ZAPI_KEY' is deprecated and its use will be removed, use 'API_KEY' instead.");
            $warned_deprecation = 1;
        }

        return $ENV{HTTP_ZAPI_KEY};
    }

    return;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/API40/Routes.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::HTTP;

=pod

=head1 Module

Relianoid::API40::Routes

=cut

my $PATH_INFO      = $ENV{PATH_INFO};
my $REQUEST_METHOD = $ENV{REQUEST_METHOD};

if ($PATH_INFO =~ qr{^/ids$}) {
    require Relianoid::HTTP::Controllers::API::Ids;

    GET qr{^/ids$} => \&list_ids_controller;
}

require Relianoid::Validate;

if ($PATH_INFO =~ qr{^/certificates/letsencryptz?}) {
    require Relianoid::HTTP::Controllers::API::Letsencrypt;

    my $le_cert_re = &getValidFormat('le_certificate_name');

    GET qr{^/certificates/letsencryptz?/config$} => \&get_le_conf_controller;    #  GET config
    PUT qr{^/certificates/letsencryptz?/config$} => \&set_le_conf_controller;    #  Modify config

    GET qr{^/certificates/letsencryptz?$} => \&list_le_cert_controller;          #  List certificates
    POST qr{^/certificates/letsencryptz?$} => \&add_le_cert_controller;          #  Create certificate

    GET qr{^/certificates/letsencryptz?/($le_cert_re)$} => \&get_le_cert_controller;          #  GET certificate
    DELETE qr{^/certificates/letsencryptz?/($le_cert_re)$} => \&delete_le_cert_controller;    #  DELETE certificate
    PUT qr{^/certificates/letsencryptz?/($le_cert_re)$} => \&set_le_cert_controller;          #  Modify certificate

    POST qr{^/certificates/letsencryptz?/($le_cert_re)/actions$} => \&actions_le_cert_controller;  #  LE certificate actions
}

# SSL certificates
if ($PATH_INFO =~ qr{^/certificates}) {
    require Relianoid::HTTP::Controllers::API::Certificate;

    my $cert_name_re = &getValidFormat('certificate_name');

    GET qr{^/certificates$}                      => \&list_certificates_controller;       #  GET List SSL certificates
    GET qr{^/certificates/($cert_name_re)/info$} => \&get_certificate_info_controller;    #  GET SSL certificate information
    GET qr{^/certificates/($cert_name_re)$}      => \&download_certificate_controller;    #  Download SSL certificate
    POST qr{^/certificates$}     => \&create_csr_controller;                              #  Create CSR certificates
    POST qr{^/certificates/pem$} => \&create_certificate_controller;                      #  POST certificates

    if ($PATH_INFO !~ qr{^/certificates/letsencryptz?-wildcard$}) {
        POST qr{^/certificates/($cert_name_re)$} => \&upload_certificate_controller;      #  POST certificates
    }

    DELETE qr{^/certificates/($cert_name_re)$} => \&delete_certificate_controller;        #  DELETE certificate
}

my $farm_re    = &getValidFormat('farm_name');
my $service_re = &getValidFormat('service');
my $be_re      = &getValidFormat('backend');

if ($PATH_INFO =~ qr{^/farms/$farm_re/certificates}) {
    require Relianoid::HTTP::Controllers::API::Certificate;

    my $cert_pem_re = &getValidFormat('cert_pem');

    POST qr{^/farms/($farm_re)/certificates$} => \&add_farm_certificate_controller;
    DELETE qr{^/farms/($farm_re)/certificates/($cert_pem_re)$} => \&delete_farm_certificate_controller;
}

if (   $PATH_INFO =~ qr{^/monitoring/fg}
    or $PATH_INFO =~ qr{^/farms/$farm_re(?:/services/$service_re)?/fg})
{
    require Relianoid::HTTP::Controllers::API::Farm::Guardian;

    my $fg_name_re = &getValidFormat('fg_name');

    POST qr{^/farms/($farm_re)/services/($service_re)/fg$} => \&add_fg_to_farm_controller;
    POST qr{^/farms/($farm_re)/fg$}                        => \&add_fg_to_farm_controller;
    DELETE qr{^/farms/($farm_re)/services/($service_re)/fg/($fg_name_re)$} => \&delete_fg_from_farm_controller;
    DELETE qr{^/farms/($farm_re)/fg/($fg_name_re)$}                        => \&delete_fg_from_farm_controller;

    GET qr{^/monitoring/fg$} => \&list_farmguardian_controller;
    POST qr{^/monitoring/fg$} => \&create_farmguardian_controller;
    GET qr{^/monitoring/fg/($fg_name_re)$} => \&get_farmguardian_controller;
    PUT qr{^/monitoring/fg/($fg_name_re)$} => \&modify_farmguardian_controller;
    DELETE qr{^/monitoring/fg/($fg_name_re)$} => \&delete_farmguardian_controller;
}

if ($PATH_INFO =~ qr{^/farms/$farm_re/actions}) {
    require Relianoid::HTTP::Controllers::API::Farm::Action;

    PUT qr{^/farms/($farm_re)/actions$} => \&actions_farm_controller;
}

if ($PATH_INFO =~ qr{^/farms/$farm_re.*/backends/$be_re/maintenance}) {
    require Relianoid::HTTP::Controllers::API::Farm::Action;

    PUT qr{^/farms/($farm_re)/services/($service_re)/backends/($be_re)/maintenance$} =>
      \&set_service_backend_maintenance_controller;    #  (HTTP only)

    PUT qr{^/farms/($farm_re)/backends/($be_re)/maintenance$} => \&set_backend_maintenance_controller;    #  (L4xNAT only)
}

if ($PATH_INFO =~ qr{^/farms/$farm_re(?:/services/$service_re)?/backends}) {
    require Relianoid::HTTP::Controllers::API::Farm::Backend;

    GET qr{^/farms/($farm_re)/backends$} => \&list_farm_backends_controller;
    POST qr{^/farms/($farm_re)/backends$} => \&add_farm_backend_controller;
    PUT qr{^/farms/($farm_re)/backends/($be_re)$} => \&modify_farm_backend_controller;
    DELETE qr{^/farms/($farm_re)/backends/($be_re)$} => \&delete_farm_backend_controller;

    GET qr{^/farms/($farm_re)/services/($service_re)/backends$} => \&list_service_backends_controller;
    POST qr{^/farms/($farm_re)/services/($service_re)/backends$} => \&add_service_backend_controller;
    PUT qr{^/farms/($farm_re)/services/($service_re)/backends/($be_re)$} => \&modify_service_backends_controller;
    DELETE qr{^/farms/($farm_re)/services/($service_re)/backends/($be_re)$} => \&delete_service_backend_controller;
}

if ($PATH_INFO =~ qr{^/farms/$farm_re/services}) {
    require Relianoid::HTTP::Controllers::API::Farm::Service;

    POST qr{^/farms/($farm_re)/services$} => \&add_farm_service_controller;
    GET qr{^/farms/($farm_re)/services/($service_re)$} => \&get_farm_service_controller;
    PUT qr{^/farms/($farm_re)/services/($service_re)$} => \&modify_farm_service_controller;
    DELETE qr{^/farms/($farm_re)/services/($service_re)$} => \&delete_farm_service_controller;
}

if ($PATH_INFO =~ qr{^/farms}) {
    if ($REQUEST_METHOD eq 'GET') {
        require Relianoid::HTTP::Controllers::API::Farm::Get;

        GET qr{^/farms$} => \&list_farms_controller;

        GET qr{^/farms/modules/summary$} => \&get_farm_modules_controller;
        GET qr{^/farms/modules/lslb$}    => \&list_lslb_controller;
        GET qr{^/farms/modules/dslb$}    => \&list_dslb_controller;

        GET qr{^/farms/($farm_re)$}         => \&get_farm_controller;
        GET qr{^/farms/($farm_re)/status$}  => \&get_farm_status_controller;
        GET qr{^/farms/($farm_re)/summary$} => \&get_farm_summary_controller;
    }

    if ($REQUEST_METHOD eq 'POST') {
        require Relianoid::HTTP::Controllers::API::Farm::Post;
        POST qr{^/farms$} => \&add_farm_controller;
    }

    if ($REQUEST_METHOD eq 'PUT') {
        require Relianoid::HTTP::Controllers::API::Farm::Put;
        PUT qr{^/farms/($farm_re)$} => \&modify_farm_controller;
    }

    if ($REQUEST_METHOD eq 'DELETE') {
        require Relianoid::HTTP::Controllers::API::Farm::Delete;
        DELETE qr{^/farms/($farm_re)$} => \&delete_farm_controller;
    }
}

# Network Interfaces
my $nic_re  = &getValidFormat('nic_interface');
my $bond_re = &getValidFormat('bond_interface');
my $vlan_re = &getValidFormat('vlan_interface');

if ($PATH_INFO =~ qr{^/interfaces/nic}) {
    require Relianoid::HTTP::Controllers::API::Interface::NIC;

    GET qr{^/interfaces/nic$}           => \&list_nic_controller;
    GET qr{^/interfaces/nic/($nic_re)$} => \&get_nic_controller;
    PUT qr{^/interfaces/nic/($nic_re)$} => \&modify_nic_controller;
    DELETE qr{^/interfaces/nic/($nic_re)$} => \&delete_nic_controller;
    POST qr{^/interfaces/nic/($nic_re)/actions$} => \&actions_nic_controller;
}

if ($PATH_INFO =~ qr{^/interfaces/vlan}) {
    require Relianoid::HTTP::Controllers::API::Interface::VLAN;

    GET qr{^/interfaces/vlan$} => \&list_vlan_controller;
    POST qr{^/interfaces/vlan$} => \&add_vlan_controller;
    GET qr{^/interfaces/vlan/($vlan_re)$} => \&get_vlan_controller;
    PUT qr{^/interfaces/vlan/($vlan_re)$} => \&modify_vlan_controller;
    DELETE qr{^/interfaces/vlan/($vlan_re)$} => \&delete_vlan_controller;
    POST qr{^/interfaces/vlan/($vlan_re)/actions$} => \&actions_vlan_controller;
}

if ($PATH_INFO =~ qr{^/interfaces/virtual}) {
    require Relianoid::HTTP::Controllers::API::Interface::Virtual;

    GET qr{^/interfaces/virtual$} => \&list_virtual_controller;
    POST qr{^/interfaces/virtual$} => \&add_virtual_controller;

    my $virtual_re = &getValidFormat('virt_interface');

    GET qr{^/interfaces/virtual/($virtual_re)$} => \&get_virtual_controller;
    PUT qr{^/interfaces/virtual/($virtual_re)$} => \&modify_virtual_controller;
    DELETE qr{^/interfaces/virtual/($virtual_re)$} => \&delete_virtual_controller;
    POST qr{^/interfaces/virtual/($virtual_re)/actions$} => \&actions_virtual_controller;
}

if ($PATH_INFO =~ qr{^/interfaces/gateway/ipv(?:[46])$}) {
    require Relianoid::HTTP::Controllers::API::Interface::Gateway;

    GET qr{^/interfaces/gateway/ipv([46])$} => \&get_gateway_controller;
    PUT qr{^/interfaces/gateway/ipv([46])$} => \&modify_gateway_controller;
    DELETE qr{^/interfaces/gateway/ipv([46])$} => \&delete_gateway_controller;
}

if ($PATH_INFO =~ qr{^/interfaces$}) {
    require Relianoid::HTTP::Controllers::API::Interface::Generic;

    GET qr{^/interfaces$} => \&list_interfaces_controller;
}

# Statistics
if ($PATH_INFO =~ qr{^/stats}) {
    require Relianoid::HTTP::Controllers::API::Stats;

    GET qr{^/stats$}                => \&get_stats_controller;
    GET qr{^/stats/system/network$} => \&get_stats_network_controller;

    GET qr{^/stats/farms$}                     => \&list_farms_stats_controller;
    GET qr{^/stats/farms/($farm_re)$}          => \&get_farm_stats_controller;
    GET qr{^/stats/farms/($farm_re)/backends$} => \&get_farm_stats_controller;

    # Fixed: make 'service' or 'services' valid requests for compatibility with previous bug.
    GET qr{^/stats/farms/($farm_re)/services?/($service_re)/backends$} => \&get_farm_stats_controller;
}

# Graphs
if ($PATH_INFO =~ qr{^/graphs}) {
    require Relianoid::HTTP::Controllers::API::Graph;

    my $frequency_re = &getValidFormat('graphs_frequency');
    my $rrd_re       = &getValidFormat('rrd_time');

    GET qr{^/graphs$} => \&list_graphs_controller;

    GET qr{^/graphs/system$} => \&list_sys_graphs_controller;

    GET qr{^/graphs/system/(cpu)$}  => \&get_sys_graphs_controller;
    GET qr{^/graphs/system/(load)$} => \&get_sys_graphs_controller;
    GET qr{^/graphs/system/(ram)$}  => \&get_sys_graphs_controller;
    GET qr{^/graphs/system/(swap)$} => \&get_sys_graphs_controller;

    GET qr{^/graphs/system/(cpu)/($frequency_re)$}  => \&get_sys_graphs_freq_controller;
    GET qr{^/graphs/system/(load)/($frequency_re)$} => \&get_sys_graphs_freq_controller;
    GET qr{^/graphs/system/(ram)/($frequency_re)$}  => \&get_sys_graphs_freq_controller;
    GET qr{^/graphs/system/(swap)/($frequency_re)$} => \&get_sys_graphs_freq_controller;

    GET qr{^/graphs/system/(cpu)/custom/start/($rrd_re)/end/($rrd_re)$}  => \&get_sys_graphs_interval_controller;
    GET qr{^/graphs/system/(load)/custom/start/($rrd_re)/end/($rrd_re)$} => \&get_sys_graphs_interval_controller;
    GET qr{^/graphs/system/(ram)/custom/start/($rrd_re)/end/($rrd_re)$}  => \&get_sys_graphs_interval_controller;
    GET qr{^/graphs/system/(swap)/custom/start/($rrd_re)/end/($rrd_re)$} => \&get_sys_graphs_interval_controller;

    # $disk_re includes 'root' at the beginning
    my $disk_re = &getValidFormat('mount_point');

    GET qr{^/graphs/system/disk$}                                                 => \&list_disks_graphs_controller;
    GET qr{^/graphs/system/disk/($disk_re)/custom/start/($rrd_re)/end/($rrd_re)$} => \&get_disk_graphs_interval_controller;
    GET qr{^/graphs/system/disk/($disk_re)/($frequency_re)$}                      => \&get_disk_graphs_freq_controller;
    GET qr{^/graphs/system/disk/($disk_re)$}                                      => \&get_disk_graphs_controller;

    GET qr{^/graphs/interfaces$}                                    => \&list_iface_graphs_controller;
    GET qr{^/graphs/interfaces/($nic_re|$vlan_re)$}                 => \&get_iface_graphs_controller;
    GET qr{^/graphs/interfaces/($nic_re|$vlan_re)/($frequency_re)$} => \&get_iface_graphs_frec_controller;
    GET qr{^/graphs/interfaces/($nic_re|$vlan_re)/custom/start/($rrd_re)/end/($rrd_re)$} =>
      \&get_iface_graphs_interval_controller;

    GET qr{^/graphs/farms$}                                                 => \&list_farm_graphs_controller;
    GET qr{^/graphs/farms/($farm_re)$}                                      => \&get_farm_graphs_controller;
    GET qr{^/graphs/farms/($farm_re)/($frequency_re)$}                      => \&get_farm_graphs_frec_controller;
    GET qr{^/graphs/farms/($farm_re)/custom/start/($rrd_re)/end/($rrd_re)$} => \&get_farm_graphs_interval_controller;
}

# System
if ($PATH_INFO =~ qr{^/system/dns}) {
    require Relianoid::HTTP::Controllers::API::System::Service::DNS;

    GET qr{^/system/dns$} => \&get_dns_controller;
    POST qr{^/system/dns$} => \&set_dns_controller;
}

if ($ENV{PATH_INFO} =~ qr{^/system/proxy}) {
    require Relianoid::HTTP::Controllers::API::System::Service::Proxy;

    GET qr{^/system/proxy$} => \&get_proxy_controller;
    POST qr{^/system/proxy$} => \&set_proxy_controller;
}

if ($PATH_INFO =~ qr{^/system/snmp}) {
    require Relianoid::HTTP::Controllers::API::System::Service::SNMP;

    GET qr{^/system/snmp$} => \&get_snmp_controller;
    POST qr{^/system/snmp$} => \&set_snmp_controller;
}

if ($PATH_INFO =~ qr{^/system/ntp}) {
    require Relianoid::HTTP::Controllers::API::System::Service::NTP;

    GET qr{^/system/ntp$} => \&get_ntp_controller;
    POST qr{^/system/ntp$} => \&set_ntp_controller;
}

if ($PATH_INFO =~ qr{^/system/users}) {
    require Relianoid::HTTP::Controllers::API::System::User;

    GET qr{^/system/users$} => \&get_system_user_controller;     #  GET users
    POST qr{^/system/users$} => \&set_system_user_controller;    #  POST users
}

if ($PATH_INFO =~ qr{^/system/log}) {
    require Relianoid::HTTP::Controllers::API::System::Log;

    GET qr{^/system/logs$} => \&list_logs_controller;

    my $logs_re = &getValidFormat('log');
    GET qr{^/system/logs/($logs_re)$} => \&download_logs_controller;

    GET qr{^/system/logs/($logs_re)/lines/(\d+)$} => \&show_logs_controller;
}

if ($PATH_INFO =~ qr{^/system/backup}) {
    require Relianoid::HTTP::Controllers::API::System::Backup;

    GET qr{^/system/backup$} => \&list_backups_controller;      #  GET list backups
    POST qr{^/system/backup$} => \&create_backup_controller;    #  POST create backups

    my $backup_re = &getValidFormat('backup');
    GET qr{^/system/backup/($backup_re)$} => \&download_backup_controller;          #  GET download backups
    PUT qr{^/system/backup/($backup_re)$} => \&upload_backup_controller;            #  PUT  upload backups
    DELETE qr{^/system/backup/($backup_re)$} => \&delete_backup_controller;         #  DELETE  backups
    POST qr{^/system/backup/($backup_re)/actions$} => \&restore_backup_controller;    #  POST  restore backups
}

if ($PATH_INFO =~ qr{^/system/(?:version|info|license|supportsave|language|packages)}) {
    require Relianoid::HTTP::Controllers::API::System::Info;

    GET qr{^/system/version$}     => \&get_version_controller;
    GET qr{^/system/info$}        => \&get_system_info_controller;
    GET qr{^/system/supportsave$} => \&get_supportsave_controller;

    my $license_re = &getValidFormat('license_format');
    GET qr{^/system/license/($license_re)$} => \&get_license_controller;

    GET qr{^/system/language$} => \&get_language_controller;
    POST qr{^/system/language$} => \&set_language_controller;

    GET qr{^/system/packages$} => \&get_packages_info_controller;
}

if ($PATH_INFO =~ qr{/ciphers$}) {
    require Relianoid::HTTP::Controllers::API::Certificate;

    GET qr{^/ciphers$} => \&get_ciphers_controller;
}

if ($PATH_INFO =~ qr{^/farms/$farm_re/(?:addheader|headremove|addresponseheader|removeresponseheader)(:?/\d+)?$}) {
    require Relianoid::HTTP::Controllers::API::Farm::HTTP;

    POST qr{^/farms/($farm_re)/addheader$} => \&add_addheader_controller;
    PUT qr{^/farms/($farm_re)/addheader/(\d+)$} => \&modify_addheader_controller;
    DELETE qr{^/farms/($farm_re)/addheader/(\d+)$} => \&del_addheader_controller;

    POST qr{^/farms/($farm_re)/headremove$} => \&add_headremove_controller;
    PUT qr{^/farms/($farm_re)/headremove/(\d+)$} => \&modify_headremove_controller;
    DELETE qr{^/farms/($farm_re)/headremove/(\d+)$} => \&del_headremove_controller;

    POST qr{^/farms/($farm_re)/addresponseheader$} => \&add_addResHeader_controller;
    PUT qr{^/farms/($farm_re)/addresponseheader/(\d+)$} => \&modify_addResHeader_controller;
    DELETE qr{^/farms/($farm_re)/addresponseheader/(\d+)$} => \&del_addResHeader_controller;
    POST qr{^/farms/($farm_re)/removeresponseheader$} => \&add_delResHeader_controller;
    PUT qr{^/farms/($farm_re)/removeresponseheader/(\d+)$} => \&modify_delResHeader_controller;
    DELETE qr{^/farms/($farm_re)/removeresponseheader/(\d+)$} => \&del_delResHeader_controller;
}

##### Load modules dynamically #######################################
my $routes_path = &getGlobalConfiguration('lib_dir') . '/API40/Routes';
opendir(my $dir, $routes_path);

for my $file (readdir $dir) {
    next if $file !~ /\w\.pm$/;

    my $module = "$routes_path/$file";

    unless (eval { require $module; }) {
        &log_debug2("Error loading module: $module", "SYSTEM");
        &log_error($@, "SYSTEM");
        die $@;
    }
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Arrays.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::Arrays

=cut

=pod

=head1 moveByIndex

This function moves an element of an list to another position using its index.
This funcion uses the original array to apply the changes, so it does not return anything.

Parameters:

    list - Array reference with the list to modify.
    ori_index - Index of the element will be moved.
    dst_index - Position in the list that the element will have.

Returns:

    None

=cut

sub moveByIndex ($list, $ori_index, $dst_index) {
    my $elem = $list->[$ori_index];

    # delete item
    splice(@{$list}, $ori_index, 1);

    # add item
    splice(@{$list}, $dst_index, 0, $elem);

    return;
}

=pod

=head1 getArrayIndex

Retuns the first index matching the value given, evaluated as a string.

Parameters:

    haystack - Array reference with the list to look for.
    needle   - Value to get its index

Returns:

    undef   - When the needle was not found
    integer - index of array with the first match found

=cut

sub getArrayIndex ($haystack, $needle) {
    my $found_index;
    my $current_index = 0;

    for my $element (@{$haystack}) {
        if ($element eq $needle) {
            $found_index = $current_index;
            last;
        }
        $current_index++;
    }

    return $found_index;
}

=pod

=head1 uniqueArray

It gets an array for reference and it removes the items that are repeated.
The original input array is modified. This function does not return anything

Parameters:

    Array ref - It is the array is going to be managed

Returns:

    None

=cut

sub uniqueArray ($arr) {
    my %hold = ();
    my @hold;

    for my $v (@{$arr}) {
        unless (exists $hold{$v}) {
            $hold{$v} = 1;
            push @hold, $v;
        }
    }

    @{$arr} = @hold;

    return;
}

=pod

=head1 getArrayCollision

It checks if two arrays have some value repeted.
The arrays have to contain scalar values.

Parameters:

    Array ref 1 - List of values 1
    Array ref 2 - List of values 2

Returns:

    scalar - It returns the first value which is contained in both arrays

=cut

sub getArrayCollision ($arr1, $arr2) {
    for my $it (sort @{$arr1}) {
        if (grep { $it eq $_ } @{$arr2}) {
            return $it;
        }
    }

    return;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Backup.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use File::stat;
use File::Basename;

=pod

=head1 Module

Relianoid::Backup

=cut

=pod

=head1 getBackup

List the backups in the system.

Parameters:

    none

Returns:

    scalar - Array reference.

=cut

sub getBackup () {
    my @backups;
    my $backupdir = &getGlobalConfiguration('backupdir');
    my $backup_re = &getValidFormat('backup');

    opendir(my $directory, $backupdir);
    my @files = grep { /^backup.*/ } readdir($directory);
    closedir($directory);

    for my $line (@files) {
        my $filepath = "$backupdir/$line";
        chomp($filepath);

        $line =~ s/backup-($backup_re).tar.gz/$1/;

        use Time::localtime qw(ctime);

        my $datetime_string = ctime(stat($filepath)->mtime);
        $datetime_string = &logAndGet("date -d \"${datetime_string}\" +%F\"  \"%T\" \"%Z -u");
        chomp($datetime_string);
        push @backups,
          {
            'name'    => $line,
            'date'    => $datetime_string,
            'version' => &getBackupVersion($line)
          };
    }

    return \@backups;
}

=pod

=head1 getExistsBackup

Check if there is a backup with the given name.

Parameters:

    name - Backup name.

Returns:

    1     - if the backup exists.
    undef - if the backup does not exist.

=cut

sub getExistsBackup ($name) {
    my $find;

    for my $backup (@{ &getBackup() }) {
        if ($backup->{name} =~ /^$name/,) {
            $find = 1;
            last;
        }
    }
    return $find;
}

=pod

=head1 createBackup

Creates a backup with the given name

Parameters:

    name - Backup name.

Returns:

    integer - ERRNO or return code of backup creation process.

=cut

sub createBackup ($name) {
    my $backup_cmd = &getGlobalConfiguration('backup_cmd');
    return &logAndRun("$backup_cmd $name -c");
}

=pod

=head1 getBackupFilename

Get a backup file name, not includin the directory.

Parameters:

    backup - Backup name.

Returns: string - Backup's absolute path.

=cut

sub getBackupFilename ($backup) {
    return "backup-${backup}.tar.gz";
}

=pod

=head1 uploadBackup 

Store an uploaded backup.

Parameters:

    filename          - Uploaded backup file name.
    upload_filehandle - File handle or file content.

Returns:

    2 - The file is not a .tar.gz
    1 - on failure.
    0 - on success.

=cut

sub uploadBackup ($filename, $upload_filehandle) {
    my $error;
    my $backupdir = &getGlobalConfiguration('backupdir');
    my $tar       = &getGlobalConfiguration('tar');

    $filename = "backup-$filename.tar.gz";
    my $filepath = "$backupdir/$filename";

    if (!-f $filepath) {
        open(my $disk_fh, '>', $filepath) or die "$!";

        binmode $disk_fh;

        use MIME::Base64 qw( decode_base64 );
        print $disk_fh decode_base64($upload_filehandle);

        close $disk_fh;
    }
    else {
        return 1;
    }

    # check the file, looking for the global.conf config file
    my $config_path = &getGlobalConfiguration('globalcfg');

    # remove the first slash
    $config_path =~ s/^\///;

    $error = &logAndRun("$tar -tf $filepath $config_path");
    if (! $error) {
        return $error;
    }

    $error = &logAndRun("$tar -tf $filepath usr/local/zevenet/config/global.conf");
    if (! $error) {
        &log_info("Enable backup migration to RELIANOID", 'backup');
        &logAndRun("ln -sf /usr/local/relianoid /usr/local/zevenet");
        return $error;
    }

    &log_error("$filename looks being a not valid backup", 'backup');
    unlink $filepath;
    return 2;
}

=pod

=head1 deleteBackup

Delete a backup.

Parameters:

    file - Backup name.

Returns:

    1     - on failure.
    undef - on success.

=cut

sub deleteBackup ($file) {
    $file = "backup-$file.tar.gz";
    my $backupdir = &getGlobalConfiguration("backupdir");
    my $filepath  = "$backupdir/$file";
    my $error;

    if (-e $filepath) {
        unlink($filepath);
        &log_info("Deleted backup file $file", "SYSTEM");
    }
    else {
        &log_warn("File $file not found", "SYSTEM");
        $error = 1;
    }

    return $error;
}

=pod

=head1 restoreBackup

Restore files from a backup.

Parameters:

    backup - Backup name.

Returns:

    integer - 0 on success or another value on failure.

=cut

sub restoreBackup ($backup) {
    my $error;
    my $tar               = &getGlobalConfiguration('tar');
    my $file              = &getGlobalConfiguration('backupdir') . "/backup-$backup.tar.gz";
    my $relianoid_service = &getGlobalConfiguration('relianoid_service');
    my $systemctl         = &getGlobalConfiguration('systemctl');

    # get current version
    my $pre_restore_version = &getGlobalConfiguration('version');

    &log_info("Stopping Relianoid service", "SYSTEM");
    $error = &logAndRun("$systemctl stop $relianoid_service");
    if ($error) {
        &log_error("Problem stopping Relianoid Load Balancer service", "SYSTEM");
        return $error;
    }

    &log_info("Restoring backup $file", "SYSTEM");
    my $cmd   = "$tar -xvzf $file -C /";
    my $eject = &logAndGet($cmd, 'array');

    if (not @{$eject}) {
        &log_error("The backup $file could not be extracted", "SYSTEM");
        return $error;
    }

    &log_info("unpacked files: @{$eject}", "SYSTEM");

    my $backup_version = &getGlobalConfiguration('version');

    # Reference: https://pmhahn.github.io/dpkg-compare-versions/
    # From lower to greater version: 1.0~rc1 < 1.0 < 1.0-noid1 < 1.0+noid1

    system("dpkg --compare-versions $backup_version lt $pre_restore_version");
    my $backup_is_previous = $?;

    # Flag migration if the backup version is previous to the current version
    if ($backup_is_previous) {
        my $migration_flag = &getGlobalConfiguration('migration_flag');

        if (open(my $fh, '>', $migration_flag)) {
            close($fh);

            if (-e $migration_flag) {
                &log_info("Migration Flag enabled");
            }
        }
        else {
            log_error("Failed to open file $migration_flag: $!");
        }
    }

    system("dpkg --compare-versions $backup_version ne $pre_restore_version");
    my $version_changed = $?;

    if ($version_changed) {
        &setGlobalConfiguration('version', $pre_restore_version);
    }

    unlink '/relianoid_version';

    $error = &logAndRun("$systemctl start $relianoid_service");

    if (!$error) {
        &log_info("Backup applied and Relianoid Load Balancer restarted...", "SYSTEM");
    }
    else {
        &log_error("Problem restarting Relianoid Load Balancer service", "SYSTEM");
    }

    return $error;
}

=pod

=head1 getBackupVersion

It gets the version of relianoid from which the backup was created

Parameters:

    backup - Backup name.

Returns:

    String - Relianoid version

=cut

sub getBackupVersion ($backup) {
    my $tar         = &getGlobalConfiguration('tar');
    my $file        = &getGlobalConfiguration('backupdir') . "/backup-$backup.tar.gz";
    my $config_path = &getGlobalConfiguration('globalcfg');

    # remove the first slash
    $config_path =~ s/^\///;

    my $cmd = "${tar} -xOf ${file} ${config_path}";
    log_debug("Running: $cmd");
    my @lines = `$cmd`;
    if ($?) {
        log_error("errno: $?");
        $cmd = "${tar} -xOf ${file} usr/local/zevenet/config/global.conf";
        log_debug("Running: $cmd");
        @lines = `$cmd`;
        if ($?) {
            log_error("errno: $?");
        }
    }

    my $version = "";

    for my $line (@lines) {
        if ($line =~ /^\s*\$version\s*=\s*(?:"(.*)"|\'(.*)\');(?:\s*#update)?\s*$/) {
            $version = $1;
            last;
        }
    }

    &log_debug3("Backup: $backup, version: $version", "system");

    return $version;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/CGI.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

=pod

=head1 Module

Relianoid::CGI

=cut

use strict;
use warnings;
use feature qw(signatures state);
use CGI::Simple;

$CGI::Simple::DISABLE_UPLOADS = 0;                # enable uploads
$CGI::Simple::POST_MAX        = 1_048_576_000;    # allow 1000MB uploads

=pod

=head1 getCGI

Get a L<CGI::Simple> object. The object is reused if called more than once in the request.

Parameters: None

Returns: L<CGI::Simple> object

=cut

sub getCGI () {
    state $cgi = CGI::Simple->new();
    return $cgi;
}

=pod

=head1 getCgiParam

Get CGI variables. This functions can be used in two diferent ways:

1. When a variable name is passed as an argument, the variable value is returned:

    &getCgiParam(variableName);

2. When no arguments are passed, a hash reference with all the variables is returned:

    $hash_ref = &getCgiParam();
    $hash_ref->{variableName};

Parameters:

    param - string - Optional. CGI variable name.

Returns:

- When a variable name has been passed as an argument:

    &getCgiParam( 'variableName' );

  - If the variable is found: string - Variable value.
  - If the variable is not found: undefined

- When the function is run without arguments:

    &getCgiParam();

    hash reference - With all the CGI variables.

=cut

sub getCgiParam ($param = undef) {
    my $cgi = getCGI();

    return eval { $cgi->param($param) } if $param;
    return $cgi->Vars;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Certificate.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use File::stat;

use Relianoid::Core;
use Relianoid::Config;

my $openssl = &getGlobalConfiguration('openssl');

=pod

=head1 Module

Relianoid::Certificate

- Privacy-Enhanced Mail (PEM)
- Certificate Signing Request (CSR)

=cut

=pod

=head1 getCertFiles

Returns a list of all .pem and .csr certificate files in the config directory.

Parameters:

    none

Returns:

    list - certificate files in config/ directory.

=cut

sub getCertFiles () {
    my $configdir = &getGlobalConfiguration('certdir');
    my $dir;

    opendir($dir, $configdir);
    my @files = grep { /.*\.pem$/ } readdir($dir);
    @files = grep { !/_dh\d+\.pem$/ } @files;
    closedir($dir);

    opendir($dir, $configdir);
    push(@files, grep { /.*\.csr$/ } readdir($dir));
    closedir($dir);

    return @files;
}

=pod

=head1 getPemCertFiles

Returns a list of only .pem certificate files in the config directory.

Parameters:

    none

Returns:

    list - certificate files in config/ directory.

=cut

sub getPemCertFiles () {
    my $configdir = &getGlobalConfiguration('certdir');

    opendir(my $dir, $configdir);
    my @files = grep { /.*\.pem$/ } readdir($dir);
    @files = grep { !/_dh\d+\.pem$/ } @files;
    closedir($dir);

    return @files;
}

=pod

=head1 getCertType

Return the type of a certificate filename.

The certificate types are:

    Certificate - For .pem or .crt certificates
    CSR         - For .csr certificates
    none        - for any other file or certificate

Parameters:

    String - Certificate filename.

Returns:

    String - Certificate type.

=cut

sub getCertType ($certfile) {
    my $certtype = "none";

    if ($certfile =~ /\.pem/ || $certfile =~ /\.crt/) {
        $certtype = "Certificate";
    }
    elsif ($certfile =~ /\.csr/) {
        $certtype = "CSR";
    }

    return $certtype;
}

=pod

=head1 getCertExpiration

Return the expiration date of a certificate file

Parameters:

    String - Certificate filename.

Returns:

    String - Expiration date.

=cut

sub getCertExpiration ($certfile) {
    my $expiration_date = "";

    if (&getCertType($certfile) eq "Certificate") {
        my @eject  = `$openssl x509 -noout -in $certfile -dates`;
        my @dateto = split(/=/, $eject[1]);
        $expiration_date = $dateto[1];
    }
    else {
        $expiration_date = "NA";
    }

    return $expiration_date;
}

=pod

=head1 getFarmCertUsed

Get if a certificate file is being used by an HTTP farm

Parameters:

    String - Certificate filename.

Returns:

    Integer - 0 if the certificate is being used, or -1 if it is not.

=cut

sub getFarmCertUsed ($cfile) {
    require Relianoid::File;
    require Relianoid::Farm::Core;

    my $certdir   = &getGlobalConfiguration('certdir');
    my $configdir = &getGlobalConfiguration('configdir');
    my @farms     = &getFarmsByType("https");
    my $output    = -1;

    for my $fname (@farms) {
        my $farm_filename = &getFarmFile($fname);

        if (grep { /Cert \"$certdir\/\Q$cfile\E\"/ } readFileAsArray("$configdir/$farm_filename")) {
            $output = 0;
        }
    }

    return $output;
}

=pod

=head1 getCertFarmsUsed

Get HTTPS Farms list using the certificate file. 

Parameters:

    String - Certificate filename.

Returns:

    Array ref - Farm list using the certificate.

=cut

sub getCertFarmsUsed ($cfile) {
    require Relianoid::File;
    require Relianoid::Farm::Core;

    my $certdir   = &getGlobalConfiguration('certdir');
    my $configdir = &getGlobalConfiguration('configdir');
    my @farms     = &getFarmsByType("https");
    my $farms_ref = [];

    for my $farm_name (@farms) {
        my $farm_filename = &getFarmFile($farm_name);

        if (grep { /Cert \"$certdir\/\Q$cfile\E\"/ } readFileAsArray("$configdir/$farm_filename")) {
            push @{$farms_ref}, $farm_name;
        }
    }

    return $farms_ref;
}

=pod

=head1 checkFQDN

Check if a FQDN is valid

Parameters:

    certfqdn - FQDN.

Returns:

    String - Boolean 'true' or 'false'.

=cut

sub checkFQDN ($certfqdn) {
    my $valid = "true";

    if ($certfqdn =~ /^http:/) {
        $valid = "false";
    }
    if ($certfqdn =~ /^\./) {
        $valid = "false";
    }
    if ($certfqdn =~ /\.$/) {
        $valid = "false";
    }
    if ($certfqdn =~ /\//) {
        $valid = "false";
    }

    return $valid;
}

=pod

=head1 delCert

Removes a certificate file

Parameters:

    String - Certificate filename.

Returns:

    Integer - Number of files removed.

Bugs:

    Removes the _first_ file found _starting_ with the given certificate name.

=cut

sub delCert ($certname) {
    my $certdir = &getGlobalConfiguration('certdir');

    # escaping special caracters
    $certname =~ s/ /\ /g;

    my $files_removed;

    # verify existance in config directory for security reasons
    if (-f "$certdir/$certname") {
        $files_removed = unlink("$certdir/$certname");

        my $key_file = $certname;
        $key_file =~ s/\.pem$/\.key/;

        if (-f "$certdir/$key_file") {
            unlink("$certdir/$key_file");
        }

        # remove key file for CSR
        if ($certname =~ /.csr$/) {
            my $key_file = $certname;
            $key_file =~ s/\.csr$/\.key/;

            if (-f "$certdir/$key_file") {
                unlink "$certdir/$key_file";
            }
            else {
                &log_error("Key file was not found '$certdir/$key_file'", "LSLB");
            }
        }
    }

    &log_error("Error removing certificate '$certdir/$certname'", "LSLB")
      if !$files_removed;

    return $files_removed;
}

=pod

=head1 createCSR

Create a CSR file.

If the function run correctly two files will appear in the config/ directory:

certname.key and certname.csr.

Parameters:

    certname     - Certificate name, part of the certificate filename without the extension.
    certfqdn     - FQDN.
    certcountry  - Country.
    certstate    - State.
    certlocality - Locality.
    certorganization - Organization.
    certdivision - Division.
    certmail     - E-Mail.
    certkey      - Key. ?
    certpassword - Password. Optional.

Returns:

    Integer - Return code of openssl generating the CSR file..

=cut

sub createCSR ($name, $fqdn, $country, $state, $locality, $organization, $division, $mail, $key, $password) {
    my $configdir = &getGlobalConfiguration('certdir');
    my $output;

    my $subdomains = '';

    my @alternatives = split(/,/, $fqdn);
    my $cn_found     = 0;

    for my $dns (@alternatives) {
        next if $dns =~ /^\s*$/;
        if (not $cn_found) {
            $fqdn     = $dns;
            $cn_found = 1;
        }
        $subdomains .= "DNS:$dns,";
    }

    chop($subdomains);
    $subdomains = "-addext \"subjectAltName = $subdomains\"";

    return 1 if not $cn_found;

    ##sustituir los espacios por guiones bajos en el nombre de archivo###
    if ($password eq "") {
        $output =
          &logAndRun(
            "$openssl req -nodes -newkey rsa:$key -keyout $configdir/$name.key $subdomains -out $configdir/$name.csr -batch -subj \"/C=$country\/ST=$state/L=$locality/O=$organization/OU=$division/CN=$fqdn/emailAddress=$mail\"  2> /dev/null"
          );
        &log_info(
            "Creating CSR: $openssl req -nodes -newkey rsa:$key -keyout $configdir/$name.key $subdomains -out $configdir/$name.csr -batch -subj \"/C=$country\/ST=$state/L=$locality/O=$organization/OU=$division/CN=$fqdn/emailAddress=$mail\"",
            "LSLB"
        ) if (not $output);
    }
    else {
        $output =
          &logAndRun(
            "$openssl req -passout pass:$password -newkey rsa:$key -keyout $configdir/$name.key $subdomains -out $configdir/$name.csr $configdir/openssl.cnf -batch -subj \"/C=$country/ST=$state/L=$locality/O=$organization/OU=$division/CN=$fqdn/emailAddress=$mail\""
          );
        &log_info(
            "Creating CSR: $openssl req -passout pass:$password -newkey rsa:$key -keyout $configdir/$name.key $subdomains -out $configdir/$name.csr $configdir/openssl.cnf -batch -subj \"/C=$country\/ST=$state/L=$locality/O=$organization/OU=$division/CN=$fqdn/emailAddress=$mail\"",
            "LSLB"
        ) if (not $output);
    }
    return $output;
}

=pod

=head1 getCertData

Returns the information stored in a certificate.

Parameters:

    String - Certificate path.
    String - "true" for checking the Certificate.

Returns:

    string - It returns a string with the certificate content. It contains new line characters.

=cut

sub getCertData ($filepath, $check = undef) {
    my $cmd;
    my $filepath_orig = $filepath;
    $filepath = quotemeta($filepath);

    if (&getCertType($filepath) eq "Certificate") {
        $cmd = "$openssl x509 -in $filepath -text";
    }
    else {
        $cmd = "$openssl req -in $filepath -text";

        # request Certs do not need to be checked
        $check = 0;
    }

    my $cert = &logAndGet($cmd);
    $cert = $cert eq "" ? "This certificate is not valid." : $cert;
    if ($check) {
        my $status = checkCertPEMValid($filepath_orig);
        if ($status and $status->{code}) {
            $cert = $status->{desc};
        }
    }

    return $cert;
}

=pod

=head1 getCertInfo

It returns an object with the certificate information parsed

Parameters:

    certificate path - path to the certificate

Returns:

    hash ref - The hash contains the following keys:

    file:       name of the certificate with extension and without path. "zert.pem"
    type:       type of file. CSR or Certificate
    CN:         common name
    issuer:     name of the certificate authority
    creation:   date of certificate creation. "019-08-13 09:31:33 UTC"
    expiration: date of certificate expiration. "2020-07-11 09:31:33 UTC"
    status:     status of the certificate. 'unknown' if the file is not recognized as a certificate, 'expired' if the certificate is expired, 'about to expire' if the expiration date is in less than 15 days, 'valid' the expiration date is greater than 15 days, 'invalid' if the file is a not valid certificate

=cut

sub getCertInfo ($filepath) {
    my %response;

    my $certfile = "";
    if ($filepath =~ /([^\/]+)$/) {
        $certfile = $1;
    }

    # PEM
    if ($certfile =~ /\.pem$/) {
        require Crypt::OpenSSL::X509;
        my $status = "unknown";
        my $CN     = "no CN";
        my $ISSUER = "no issuer";
        my $x509;
        eval {
            $x509 = Crypt::OpenSSL::X509->new_from_file($filepath);

            my $time_offset = 60 * 60 * 24 * 15;    # 15 days
            if ($x509->checkend(0)) { $status = 'expired' }
            else {
                $status = ($x509->checkend($time_offset)) ? 'about to expire' : 'valid';
            }

            if (defined $x509->subject_name()->get_entry_by_type('CN')) {
                $CN = $x509->subject_name()->get_entry_by_type('CN')->value;
            }
            if (defined $x509->issuer_name()->get_entry_by_type('CN')) {
                $ISSUER = $x509->issuer_name()->get_entry_by_type('CN')->value;
            }
        };
        if ($@) {
            %response = (
                file       => $certfile,
                type       => 'Certificate',
                CN         => '-',
                issuer     => '-',
                creation   => '-',
                expiration => '-',
                status     => $status,
            );
        }
        else {
            $status   = "invalid" if (&checkCertPEMValid($filepath)->{code});
            %response = (
                file       => $certfile,
                type       => 'Certificate',
                CN         => $CN,
                issuer     => $ISSUER,
                creation   => $x509->notBefore(),
                expiration => $x509->notAfter(),
                status     => $status,
            );
        }
    }

    # CSR
    else {
        require Relianoid::File;

        my @cert_data = @{ &logAndGet("$openssl req -in $filepath -text -noout", "array") };

        my $cn = "";
        my ($string) = grep { /\sSubject: / } @cert_data;
        if ($string =~ /CN ?= ?([^,]+)/) {
            $cn = $1;
        }

        %response = (
            file       => $certfile,
            type       => 'CSR',
            CN         => $cn,
            issuer     => "NA",
            creation   => &getFileDateGmt($filepath),
            expiration => "NA",
            status     => 'valid',
        );
    }

    return \%response;
}

=pod

=head1 getDateEpoc

It converts a human date (2018-05-17 15:04:52 UTC) in a epoc date (1594459893)

Parameters:

    date - string with the date. The string has to be as "2018-05-17 15:04:52"

Returns:

    Integer - Time in epoc time. "1594459893"

=cut

sub getDateEpoc ($date_string) {
    # my @months      = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);

    my ($year, $month, $day, $hours, $min, $sec) = split /[ :-]+/, $date_string;

    return 0 if (! defined $year || ! defined $month || ! defined $day || ! defined $hours || ! defined $min || !defined $sec);

    # the range of the month is from 0 to 11
    $month-- if ($month > 0);

    require Time::Local;
    return Time::Local::timegm($sec, $min, $hours, $day, $month, $year);
}

=pod

=head1 getCertDaysToExpire

It calculates the number of days to expire the certificate.

Parameters:

    ending date - String with the ending date with the following format "2018-05-17 15:04:52 UTC"

Returns:

    Integer - Number of days to expire the certificate

=cut

sub getCertDaysToExpire ($cert_ends) {
    my $end       = &getDateEpoc($cert_ends);
    return 0 if ($end == 0);
    my $days_left = ($end - time()) / 86400;

    # leave only two decimals
    if ($days_left < 1) {
        $days_left *= 100;
        $days_left =~ s/\..*//g;
        $days_left /= 100;
    }
    else {
        $days_left =~ s/\..*//g;
    }

    return $days_left;
}

=pod

=head1 getCertPEM

It returns an object with all certificates: key, fullchain

Parameters:

    cert_path - path to the certificate

Returns:

    hash ref - List of certificates : key, fullchain

=cut

sub getCertPEM ($cert_path) {
    my $pem_config;

    if (-T $cert_path) {
        require Tie::File;
        use Fcntl 'O_RDONLY';

        tie my @cert_file, 'Tie::File', "$cert_path", mode => O_RDONLY;

        my $key_boundary         = 0;
        my $certificate_boundary = 0;
        my $cert;

        for (@cert_file) {
            if ($_ =~ /^-+BEGIN.*KEY-+/) {
                $key_boundary = 1;
            }
            if ($_ =~ /^-+BEGIN.*CERTIFICATE-+/) {
                $certificate_boundary = 1;
            }
            if ($key_boundary) {
                push @{ $pem_config->{key} }, $_;
            }
            if ($certificate_boundary) {
                push @{$cert}, $_;
            }
            if (($_ =~ /^-+END.*KEY-+/) and ($key_boundary)) {
                $key_boundary = 0;
                next;
            }
            if (($_ =~ /^-+END.*CERTIFICATE-+/) and ($certificate_boundary)) {
                push @{ $pem_config->{fullchain} }, $cert;
                $certificate_boundary = 0;
                $cert                 = undef;
                next;
            }
        }
    }

    return $pem_config;
}

=pod

=head1 checkCertPEMKeyEncrypted

Checks if a certificate private key in PEM format is encrypted.

Parameters:

    cert_path - path to the certificate

Returns:

    Integer - 0 if it is not encrypted, 1 if encrypted, -1 on error.

=cut

sub checkCertPEMKeyEncrypted ($cert_path) {
    my $rc         = -1;
    my $pem_config = &getCertPEM($cert_path);

    if (($pem_config) and ($pem_config->{key})) {
        use Net::SSLeay;
        $Net::SSLeay::trace = 1;

        $rc = 0;
        my $bio_key = Net::SSLeay::BIO_new_file($cert_path, 'r');

        # Loads PEM formatted private key via given BIO structure using empty password
        unless (Net::SSLeay::PEM_read_bio_PrivateKey($bio_key, undef, "")) {
            my $error     = Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
            my @strerr    = split(/:/, $error);
            my $error_str = $strerr[4];
            if ($error_str eq "bad decrypt") {
                &log_debug("Private Key Encrypted was found in '$cert_path': " . $strerr[4], "LSLB");
                $rc = 1;
            }
            else {
                &log_debug("Error checking Private Key Encrypted in '$cert_path': " . $strerr[4], "LSLB");
                $rc = -1;
            }
        }
        Net::SSLeay::BIO_free($bio_key);
    }

    return $rc;
}

=pod

=head1 checkCertPEMValid

Checks if a certificate is in PEM format and has a valid structure.
The certificates must be in PEM format and must be sorted starting with the subject's certificate (actual client or server certificate), followed by intermediate CA certificates if applicable, and ending at the highest level (root) CA. The Private key has to be unencrypted.

Parameters:

    cert_path - path to the certificate

Returns: hash reference

Error object.

    code - integer - Error code. 0 if the PEM file is valid.
    desc - string - Description of the error.

=cut

sub checkCertPEMValid ($cert_path) {
    use Net::SSLeay;
    $Net::SSLeay::trace = 1;

    my $error_ref->{code} = 0;
    my $ctx = Net::SSLeay::CTX_new_with_method(Net::SSLeay::SSLv23_method());

    if (!$ctx) {
        my $error_msg = "Error check PEM certificate";
        $error_ref->{code} = -1;
        $error_ref->{desc} = $error_msg;
        my $error     = Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
        my @strerr    = split(/:/, $error);
        my $error_str = $strerr[4];
        &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
        return $error_ref;
    }

    if (&checkCertPEMKeyEncrypted($cert_path) == 1) {
        Net::SSLeay::CTX_free($ctx);
        my $error_msg = "PEM file private key is encrypted";
        $error_ref->{code} = 1;
        $error_ref->{desc} = $error_msg;
        &log_debug("$error_msg in '$cert_path'", "LSLB");
        return $error_ref;
    }

    unless (Net::SSLeay::CTX_use_certificate_chain_file($ctx, "$cert_path")) {
        my $error  = Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
        my @strerr = split(/:/, $error);
        Net::SSLeay::CTX_free($ctx);
        my $error_str = $strerr[4];
        if ($error_str eq "no start line") {
            my $error_msg = "No Certificate found";
            $error_ref->{code} = 2;
            $error_ref->{desc} = $error_msg;
            &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
            return $error_ref;
        }
        elsif ($error_str eq "ca md too weak") {
            my $error_msg = "Cipher weak found";
            $error_ref->{code} = 3;
            $error_ref->{desc} = $error_msg;
            &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
            return $error_ref;
        }
        else {
            my $error_msg = "Error using Certificate";
            $error_ref->{code} = 4;
            $error_ref->{desc} = $error_msg;
            &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
            return $error_ref;
        }
    }

    unless (Net::SSLeay::CTX_use_PrivateKey_file($ctx, "$cert_path", Net::SSLeay::FILETYPE_PEM())) {
        my $error  = Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
        my @strerr = split(/:/, $error);
        Net::SSLeay::CTX_free($ctx);
        my $error_str = $strerr[4];
        if ($error_str eq "no start line") {
            my $error_msg = "No Private Key found";
            $error_ref->{code} = 5;
            $error_ref->{desc} = $error_msg;
            &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
            return $error_ref;
        }
        elsif ($error_str eq "key values mismatch") {
            my $error_msg = "Private Key is not valid for the first Certificate found";
            $error_ref->{code} = 6;
            $error_ref->{desc} = $error_msg;
            &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
            return $error_ref;
        }
        else {
            my $error_msg = "Error using Private Key";
            $error_ref->{code} = 7;
            $error_ref->{desc} = $error_msg;
            &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
            return $error_ref;
        }
    }

    unless (Net::SSLeay::CTX_check_private_key($ctx)) {
        my $error = Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
        Net::SSLeay::CTX_free($ctx);
        my @strerr    = split(/:/, $error);
        my $error_str = $strerr[4];
        my $error_msg = "Error checking Private Key";
        $error_ref->{code} = 8;
        $error_ref->{desc} = $error_msg;
        &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
        return $error_ref;
    }

    Net::SSLeay::CTX_free($ctx);
    return $error_ref;
}

=pod

=head1 createPEM

Create a valid PEM file.

Parameters:

    certname - Certificate name, part of the certificate filename without the extension.
    key      - String. Private Key.
    ca       - String. CA Certificate or fullchain certificates.
    intermediates - CA Intermediates Certificates.

Returns: hash reference

Error object.

    code - integer - Error code. 0 if the PEM file is created.
    desc - string - Description of the error.

=cut

sub createPEM ($cert_name, $cert_key, $cert_ca, $cert_intermediates) {
    my $error_ref->{code} = 0;

    if (not $cert_name or not $cert_key or not $cert_ca) {
        my $error_msg = "A required parameter is missing";
        $error_ref->{code} = 1;
        $error_ref->{desc} = $error_msg;
        return $error_ref;
    }

    # check certificate exists
    my $configdir = &getGlobalConfiguration('certdir');
    my $cert_file = $configdir . "/" . $cert_name . ".pem";

    if (-T $cert_file) {
        my $error_msg = "Certificate already exists";
        $error_ref->{code} = 2;
        $error_ref->{desc} = $error_msg;
        return $error_ref;
    }

    # create temp certificate
    my $tmp_cert  = "/tmp/cert_$cert_name.tmp";
    my $lock_file = &getLockFile($tmp_cert);
    my $lock_fh   = &openlock($lock_file, 'w');
    my $fh        = &openlock($tmp_cert,  'w');
    print $fh $cert_key . "\n";
    print $fh $cert_ca . "\n";
    print $fh $cert_intermediates . "\n" if (defined $cert_intermediates);
    close $fh;

    unless (-T $tmp_cert) {
        close $lock_fh;
        my $error_msg = "Error creating Temp Certificate File";
        $error_ref->{code} = 3;
        $error_ref->{desc} = $error_msg;
        return $error_ref;
    }

    # check temp certificate
    my $cert_conf = &getCertPEM($tmp_cert);
    if (!$cert_conf->{key}) {
        unlink $tmp_cert;
        close $lock_fh;
        my $error_msg = "No Private Key in PEM format found";
        $error_ref->{code} = 4;
        $error_ref->{desc} = $error_msg;
        return $error_ref;
    }
    if (!$cert_conf->{fullchain}) {
        unlink $tmp_cert;
        close $lock_fh;
        my $error_msg = "No Certificate in PEM format found";
        $error_ref->{code} = 4;
        $error_ref->{desc} = $error_msg;
        return $error_ref;
    }

    my $error = &checkCertPEMValid($tmp_cert);
    if ($error->{code}) {
        unlink $tmp_cert;
        close $lock_fh;
        $error_ref->{code} = 5;
        $error_ref->{desc} = $error->{desc} . " in generated PEM";
        return $error_ref;
    }

    # copy temp certificate
    if (&copyLock($tmp_cert, $cert_file)) {
        unlink $tmp_cert;
        close $lock_fh;
        my $error_msg = "Error creating Certificate File";
        $error_ref->{code} = 5;
        $error_ref->{desc} = $error_msg;
        return $error_ref;
    }

    unlink $tmp_cert;
    close $lock_fh;
    return $error_ref;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Config.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(say signatures state);

use Relianoid::Log;

=pod

=head1 Module

Relianoid::Config

=cut

=pod

=head1 getGlobalConfiguration

Get the value of a configuration variable. The global.conf is parsed only the first time

Parameters:

    parameter - Name of the global configuration variable. Optional.
    Force_relad - This parameter is a flag that force a reload of the global.conf structure, useful to reload the struct when it has been modified. Optional

Returns:

    scalar - Value of the configuration variable when a variable name is passed as an argument.
    scalar - Hash reference to all global configuration variables when no argument is passed.

See Also:

    Widely used.

=cut

sub getGlobalConfiguration ($parameter, $force_reload = 0) {
    state $global_conf = &parseGlobalConfiguration();

    if ($force_reload) {
        $global_conf = &parseGlobalConfiguration();
    }

    if ($parameter) {
        if (defined $global_conf->{$parameter}) {
            return $global_conf->{$parameter};
        }
        elsif ($parameter eq 'debug') {
            # workaround: no message is logged when the 'debug' parameter is not defined in global.conf.
            return;
        }
        else {
            &log_warn("The global configuration parameter '$parameter' has not been found", 'Configuration');

            return;
        }
    }

    return $global_conf;
}

=pod

=head1 parseGlobalConfiguration

Parse the global.conf file. It expands the variables too.

Parameters:

    none

Returns:

    scalar - Hash reference to all global configuration variables when no argument is passed.

See Also:

    Widely used.

=cut

sub parseGlobalConfiguration () {
    my $global_conf_filepath = "/usr/local/relianoid/config/global.conf";
    my $global_conf;

    if (open(my $global_conf_file, '<', $global_conf_filepath)) {
        my @lines = <$global_conf_file>;
        close $global_conf_file;

        # build globalconf struct
        for my $conf_line (@lines) {
            # extract variable name and value
            if ($conf_line =~ /^\s*\$(\w+)\s*=\s*(?:"(.*)"|\'(.*)\');(?:\s*#update)?\s*$/) {
                $global_conf->{$1} = $2;
            }
        }
    }
    else {
        my $msg = "Could not open $global_conf_filepath: $!";
        &log_error($msg, "SYSTEM");
        die $msg;
    }

    # expand the variables, by replacing every variable used in the $var_value by its content
    for my $param (keys %{$global_conf}) {
        while ($global_conf->{$param} =~ /\$(\w+)/) {
            my $var   = $1;
            my $value = $global_conf->{$var} // '';
            $global_conf->{$param} =~ s/\$$var/$value/;
        }
    }

    return $global_conf;
}

=pod

=head1 setGlobalConfiguration

Set a value to a configuration variable

Parameters:

    param - Configuration variable name.
    value - New value to be set on the configuration variable.

Returns:

    scalar - 0 on success, or -1 if the variable was not found.

FIXME:

- Receive a hash, to be able to set a list of settings
- Control file handling errors.

See Also:

    API v4: <set_ntp>

=cut

sub setGlobalConfiguration ($param, $value) {
    my $global_conf_file = &getGlobalConfiguration('globalcfg');
    my $output           = -1;

    use Fcntl qw(:flock);

    if (open(my $fh, '+<', $global_conf_file)) {    ## no critic (InputOutput::RequireBriefOpen)
        flock($fh, LOCK_EX) or die "Cannot lock file ${global_conf_file}: $!\n";
        my @lines = <$fh>;

        for my $line (@lines) {
            if ($line =~ /^\$$param\s*=/) {
                $line   = "\$${param}=\"${value}\";\n";
                $output = 0;
                last;
            }
        }

        seek $fh, 0, 0;
        truncate $fh, 0;    # reduce file size to 0
        print {$fh} join("", @lines);
        close $fh;
    }
    else {
        log_error("Could not open file ${global_conf_file}: $!");
    }

    # reload global.conf struct
    &getGlobalConfiguration(undef, 1);

    return $output;
}

=pod

=head1 setConfigStr2Arr

Put a list of string parameters as array references

Parameters:

    object - reference to a hash
    parameters - list of parameters to change from string to array

Returns:

    hash ref - Object updated

=cut

sub setConfigStr2Arr ($obj, $param_list) {
    for my $param_name (@{$param_list}) {
        my @list = ();

        # split parameter if it is not a blank string
        @list = sort split(' ', $obj->{$param_name})
          if ($obj->{$param_name});
        $obj->{$param_name} = \@list;
    }

    return $obj;
}

=pod

=head1 getTinyObj

Get a Config::Tiny object from a file name.
This function has 3 behaviors:

it can returns all parameters from all groups
or it can returns all parameters from a group
or it can returns only selected parameters.
selected parameters can be ignored,undef or error if they do not exists

Parameters:

    file_path - Path to file.
    section - Group to get. Empty means all groups.
    key_ref - Array of parameters to get. Empty means all parameters
    key_action - string define the action. Possible values are "ignored|undef|error".Empty means error.

Returns:

    hash ref - a reference to Config::Tiny object when success, undef on failure.

=cut

sub getTinyObj ($filepath, $section = undef, $key_ref = undef, $key_action = "error") {
    if (!-f "$filepath") {
        return;
    }
    require Config::Tiny;
    my $conf = Config::Tiny->read($filepath);
    if (not defined $conf) {
        return;
    }

    if (not defined $section) {
        return $conf;
    }

    if (not exists $conf->{$section}) {
        return;
    }

    if (not defined $key_ref) {
        return $conf->{$section};
    }

    if (ref $key_ref ne 'ARRAY') {
        return;
    }

    my $filtered_conf = {};
    $conf = $conf->{$section};
    for my $param (@{$key_ref}) {
        if (defined $conf->{$param}) {
            $filtered_conf->{$param} = $conf->{$param};
        }
        else {
            if ($key_action eq "error") {
                return;
            }

            if ($key_action eq "undef") {
                $filtered_conf->{$param} = undef;
            }
        }
    }

    return $filtered_conf;
}

=pod

=head1 setTinyObj

Save a change in a config file. The file is locker before than applying the changes
This function has 2 behaviors:

it can receives a hash ref to save a struct
or it can receive a key and parameter to replace a value

Parameters:

    path   - Tiny conguration file where to apply the change
    object - Group to apply the change
    key    - parameter to change or struct ref to overwrite.
    value  - new value for the parameter or action for struct ref. The possible action values are: "update" to update only existing params , "new" to delete old params and set news ones or empty to add all new params. 
    action - This is a optional parameter. The possible values are: "add" to add
             a item to a list, or "del" to delete a item from a list, or "remove" to delete the key

Returns:

    Integer - Error code: 0 on success or other value on failure

=cut

sub setTinyObj ($path, $object = undef, $key = undef, $value = undef, $action = undef) {
    unless ($object) {
        &log_info("Object not defined trying to save it in file $path");
        return;
    }

    &log_debug2("Modify $object from $path");

    require Relianoid::Lock;
    require Config::Tiny;
    require Relianoid::File;

    my $lock_file = &getLockFile($path);
    my $lock_fd   = &openlock($lock_file, 'w');

    my $fileHandle;
    if (!-f "$path") {
        createFile($path);
        $fileHandle = Config::Tiny->new;
    }
    else {
        $fileHandle = Config::Tiny->read($path);
    }

    unless ($fileHandle) {
        &log_info("Could not open file $path: " . Config::Tiny::errstr());
        return -1;
    }

    # save all struct
    if (ref $key) {
        if ((defined $value) and ($value eq "new")) {
            $fileHandle->{$object} = {};
        }
        for my $param (keys %{$key}) {
            if (ref $key->{$param} eq 'ARRAY') {
                $key->{$param} = join(' ', @{ $key->{$param} });
            }
            next
              if (  (!exists $fileHandle->{$object}{$param})
                and ((defined $value) and ($value eq "update")));

            $fileHandle->{$object}{$param} = $key->{$param};
        }
    }

    # save a parameter
    else {
        if ($action and 'add' eq $action) {
            $fileHandle->{$object}{$key} .= " $value";
        }
        elsif ($action and 'del' eq $action) {
            $fileHandle->{$object}{$key} =~ s/(^| )$value( |$)/ /;
        }
        elsif ($action and 'remove' eq $action) {
            delete $fileHandle->{$object}{$key};
        }
        else {
            $fileHandle->{$object}{$key} = $value;
        }
    }

    my $success = $fileHandle->write($path);
    close $lock_fd;
    unlink $lock_file;

    return ($success) ? 0 : 1;
}

=pod

=head1 delTinyObj

It deletes a object of a tiny file. The tiny file is locked before than set the configuration

Parameters:

    object - Group name
    path   - Tiny file where the object will be deleted

Returns:

    Integer -  Error code: 0 on success or other value on failure

=cut

sub delTinyObj ($path, $object) {
    &log_debug2("Delete $object from $path");

    require Relianoid::Lock;

    my $lock_file = &getLockFile($path);
    my $lock_fd   = &openlock($lock_file, 'w');

    my $fileHandle = Config::Tiny->read($path);
    delete $fileHandle->{$object};
    my $error = $fileHandle->write($path);

    close $lock_fd;
    unlink $lock_file;

    return $error;
}

=pod

=head1 migrateConfigFiles

Apply all migrating scripts to relianoid

Parameters:

    none

Returns:

    none

=cut

sub migrateConfigFiles () {
    my $mig_dir = &getGlobalConfiguration('mig_dir');

    opendir(my $dh, $mig_dir);
    my @files = grep { -f "${mig_dir}/$_" } sort readdir($dh);
    closedir $dh;

    for my $file (@files) {
        my $errno = system("${mig_dir}/${file} >/dev/null");
        my $msg = "";

        if ($errno == 0) {
            $msg = "[ OK ]  ${file} ($errno)";
            log_info($msg);
        } else {
            $msg = "[ERROR] ${file} ($errno)";
            log_error($msg);
        }
    }

    return;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Core.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures state);

use Relianoid::Log;
use Relianoid::Config;
use Relianoid::Debug;

=pod

=head1 Module

Relianoid::Core

=cut

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Debug.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures state);

=pod

=head1 Module

Relianoid::Debug

=cut

=pod

=head1 debug

Get debugging level.

Parameters: None

Returns: integer - Debug level, a value from 0 to 5.

Bugs:

The debugging level should be stored as a variable.

=cut

sub debug () {
    state $debug;

    if (not defined $debug) {
        use Relianoid::Config;
        $debug = &getGlobalConfiguration('debug') // 0;
        $debug += 0;
    }

    return $debug;
}

=pod

=head1 getMemoryUsage

Get the resident memory usage of the current perl process.

Parameters: None

Returns: string - String with the memory usage.

=cut

sub getMemoryUsage () {
    my $mem_string;
    my $proc_pid_status_file = "/proc/$$/status";

    if (open(my $fh, "<", $proc_pid_status_file)) {
        my @lines = <$fh>;
        close $fh;

        ($mem_string) = grep { /RSS/ } @lines;
        chomp($mem_string);
        $mem_string =~ s/\s+/ /;
    }
    else {
        warn "Could not open file ${proc_pid_status_file}: $!";
    }

    return $mem_string;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/Action.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Config;

my $eload = eval { require Relianoid::ELoad };

my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::Action

=cut

=pod

=head1 _runFarmStart

Run a farm

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success, 2 if the ip:port is busy for another farm or another value on another failure

=cut

sub _runFarmStart ($farm_name, $writeconf = 0) {
    # The parameter expect "undef" to not write it
    $writeconf = 0 if ($writeconf eq 'false');

    require Relianoid::Farm::Base;
    require Relianoid::Farm::Config;

    my $status = -1;

    # finish the function if the farm is already up
    if (&getFarmStatus($farm_name) eq "up") {
        log_info("Farm $farm_name already up", "FARMS");
        return 0;
    }

    # check if the ip exists in any interface
    my $ip = &getFarmVip("vip", $farm_name);

    require Relianoid::Net::Interface;

    if (!&getIpAddressExists($ip)) {
        &log_info("The virtual interface $ip is not defined in any interface.");
        return $status;
    }

    require Relianoid::Net::Interface;

    my $farm_type = &getFarmType($farm_name);

    if ($farm_type ne "datalink") {
        my $port = &getFarmVip("vipp", $farm_name);
        if (!&validatePort($ip, $port, undef, $farm_name)) {
            &log_info("The networking '$ip:$port' is being used.");
            return 2;
        }
    }

    &log_info("Starting farm $farm_name with type $farm_type", "FARMS");

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Action;
        $status = &_runHTTPFarmStart($farm_name, $writeconf);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Action;
        $status = &startL4Farm($farm_name, $writeconf);
    }
    elsif ($farm_type eq "datalink") {
        $status = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Action',
            func   => '_runDatalinkFarmStart',
            args   => [ $farm_name, $writeconf ],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $status = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Action',
            func   => '_runGSLBFarmStart',
            args   => [ $farm_name, $writeconf ],
        );
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        $status = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Action',
            func   => '_runEproxyFarmStart',
            args   => [ { 'farm_name' => $farm_name, 'write' => $writeconf } ],
        );
    }

    &setFarmNoRestart($farm_name);

    return $status;
}

=pod

=head1 runFarmStart

Run a farm completely a farm. Run farm, its farmguardian, ipds rules and ssyncd

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success, 2 if the ip:port is busy for another farm or another value on another failure

NOTE:

    Generic function

=cut

sub runFarmStart ($farm_name, $writeconf = 0) {
    my $status = &_runFarmStart($farm_name, $writeconf);
    &log_info("Farm start status: $status");

    return $status if ($status != 0);

    require Relianoid::FarmGuardian;
    my $fg_status = &runFarmGuardianStart($farm_name, "");
    &log_info("Farm guardian start status: $fg_status");

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::IPDS::Base',
            func   => 'runIPDSStartByFarm',
            args   => [$farm_name],
        );

        require Relianoid::Farm::Config;
        if (&getPersistence($farm_name) == 0) {
            &eload(
                module => 'Relianoid::EE::Ssyncd',
                func   => 'setSsyncdFarmUp',
                args   => [$farm_name],
            );
        }
    }
    return $status;
}

=pod

=head1 runFarmStop

Stop a farm completely a farm. Stop the farm, its farmguardian, ipds rules and ssyncd

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success or different of 0 on failure

NOTE:

    Generic function

=cut

sub runFarmStop ($farm_name, $writeconf = 0) {
    if ($eload) {
        &eload(
            module => 'Relianoid::EE::IPDS::Base',
            func   => 'runIPDSStopByFarm',
            args   => [$farm_name],
        );
        &eload(
            module => 'Relianoid::EE::Ssyncd',
            func   => 'setSsyncdFarmDown',
            args   => [$farm_name],
        );
    }

    require Relianoid::FarmGuardian;
    &runFGFarmStop($farm_name);

    my $status = &_runFarmStop($farm_name, $writeconf);

    return $status;
}

=pod

=head1 _runFarmStop

Stop a farm

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success or different of 0 on failure

=cut

sub _runFarmStop ($farm_name, $writeconf = 0) {
    $writeconf = 0 if ($writeconf eq 'false');

    require Relianoid::Farm::Base;

    my $farm_filename = &getFarmFile($farm_name);
    if ($farm_filename eq '-1') {
        return -1;
    }

    my $farm_type = &getFarmType($farm_name);
    my $status    = $farm_type;

    &log_info("Stopping farm $farm_name with type $farm_type", "FARMS");

    if ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Action;
        $status = &_runHTTPFarmStop($farm_name, $writeconf);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Action;
        $status = &stopL4Farm($farm_name, $writeconf);
    }
    elsif ($farm_type eq "datalink") {
        $status = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Action',
            func   => '_runDatalinkFarmStop',
            args   => [ $farm_name, $writeconf ],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $status = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Action',
            func   => '_runGSLBFarmStop',
            args   => [ $farm_name, $writeconf ],
        );
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        $status = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Action',
            func   => '_runEproxyFarmStop',
            args   => [ { 'farm_name' => $farm_name, 'write' => $writeconf } ],
        );
    }

    &setFarmNoRestart($farm_name);

    return $status;
}

=pod

=head1 runFarmDelete

Delete a farm

Parameters:

    farmname - Farm name

Returns:

    String - farm name

NOTE:

    Generic function

=cut

sub runFarmDelete ($farm_name) {
    require Relianoid::Netfilter;

    my $configdir = &getGlobalConfiguration('configdir');

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::IPDS::Base',
            func   => 'runIPDSDeleteByFarm',
            args   => [$farm_name],
        );

        &eload(
            module => 'Relianoid::EE::RBAC::Group::Config',
            func   => 'delRBACResource',
            args   => [ $farm_name, 'farms' ],
        );
    }

    # stop and unlink farmguardian
    require Relianoid::FarmGuardian;
    &delFGFarm($farm_name);

    my $farm_type = &getFarmType($farm_name);
    my $status    = 1;

    &log_info("running 'Delete' for $farm_name", "FARMS");

    if ($farm_type eq "gslb") {
        require File::Path;
        File::Path->import('rmtree');

        $status = 0
          if rmtree(["$configdir/$farm_name\_gslb.cfg"]);
    }
    elsif ($farm_type eq "http" || $farm_type eq "https") {
        unlink glob("$configdir/$farm_name\_*\.html");

        # For HTTPS farms only
        my $dhfile = "$configdir\/$farm_name\_dh2048.pem";
        unlink("$dhfile") if -e "$dhfile";
        &delMarks($farm_name, "");

        # Check if local farm exists and delete it
        require Relianoid::Nft;
        my $output = &httpNlbRequest({
            method => "GET",
            uri    => "/farms/" . $farm_name,
            check  => 1,
        });

        if (!$output) {
            $output = &httpNlbRequest({
                farm   => $farm_name,
                method => "DELETE",
                uri    => "/farms/" . $farm_name,
            });
        }
    }
    elsif ($farm_type eq "datalink") {
        # delete cron task to check backends
        require Tie::File;
        tie my @filelines, 'Tie::File', "/etc/cron.d/relianoid";
        @filelines = grep { !/\# \_\_$farm_name\_\_/ } @filelines;
        untie @filelines;
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Factory;
        &runL4FarmDelete($farm_name);
    }

    if ($farm_type eq "eproxy" && $eload) {
        $status = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Factory',
            func   => 'runEproxyFarmDelete',
            args   => [{ farm_name => $farm_name }],
        );
    } else {
        unlink glob("$configdir/$farm_name\_*\.cfg");

        if (!-f "$configdir/$farm_name\_*\.cfg") {
            $status = 0;
        }
    }

    require Relianoid::RRD;

    &delGraph($farm_name, "farm");

    return $status;
}

=pod

=head1 runFarmReload

Reload a farm

Parameters:

    farm_name - Farm name

Returns:

    Integer - return 0 on success, another value on another failure

=cut

sub runFarmReload ($farm_name) {
    require Relianoid::Farm::Action;

    my $farm_type = &getFarmType($farm_name);
    my $status = 0;

    if ($farm_type eq "http" || $farm_type eq "https") {
        if (&getFarmRestartStatus($farm_name)) {
            &log_info("'Reload' on $farm_name is not executed. 'Restart' is needed.", "FARMS");
            return 2;
        }

        &log_info("running 'Reload' for $farm_name", "FARMS");

        $status = &_runFarmReload($farm_name);

        # Reload Farm status from its cfg file
        require Relianoid::Farm::HTTP::Backend;
        &setHTTPFarmBackendStatusFromFile($farm_name);
    }
    elsif ($farm_type eq "eproxy") {
        &log_info("running 'Reload' for $farm_name", "FARMS");
        $status = &_runFarmReload($farm_name);
    }

    return $status;
}

=pod

=head1 _runFarmReload

It reloads a farm to update the configuration.

Parameters:

    Farm - It is the farm name

Returns:

    Integer - It returns 0 on success or another value on failure.

=cut

sub _runFarmReload ($farm) {
    my $err = 0;

    require Relianoid::Farm::Base;
    return 0 if (&getFarmStatus($farm) ne 'up');

    my $farm_type = &getFarmType($farm);

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;
        my $poundctl = &getGlobalConfiguration('poundctl');
        my $socket    = &getHTTPFarmSocket($farm);

        $err = &logAndRun("$poundctl -c $socket -R 0");
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        $err = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Action',
            func   => 'runEproxyFarmReload',
            args   => [{ farm_name => $farm }],
        );
        require Relianoid::EE::Cluster;
        &runClusterRemoteManager('farm', 'reload', $farm);
    }

    return $err;
}

=pod

=head1 getFarmRestartFile

This function returns a file name that indicates that a farm is waiting to be restarted

Parameters:

    farmname - Farm name

Returns:

    sting - path to flag file

NOTE:

    Generic function

=cut

sub getFarmRestartFile ($farm_name) {
    return "/tmp/_farm_need_restart_$farm_name";
}

=pod

=head1 getFarmRestartStatus

This function responses if a farm has pending changes waiting for restarting

Parameters:

    farmname - Farm name

Returns:

    Integer - 1 if the farm has to be restarted or 0 if it is not

NOTE:

    Generic function

=cut

sub getFarmRestartStatus ($fname) {
    require Relianoid::Farm::Action;
    my $lfile = &getFarmRestartFile($fname);

    return 1 if (-e $lfile);
    return 0;
}

=pod

=head1 setFarmRestart

This function creates a file to tell that the farm needs to be restarted to apply changes

Parameters:

    farmname - Farm name

Returns:

    undef

NOTE:

    Generic function

=cut

sub setFarmRestart ($farm_name) {
    # do nothing if the farm is not running
    require Relianoid::Farm::Base;
    return if &getFarmStatus($farm_name) ne 'up';

    require Relianoid::Lock;
    my $lf = &getFarmRestartFile($farm_name);
    my $fh = &openlock($lf, 'w');
    close $fh;

    return;
}

=pod

=head1 setFarmNoRestart

This function deletes the file marking the farm to be restarted to apply changes

Parameters:

    farmname - Farm name

Returns:

    none

NOTE:

    Generic function

=cut

sub setFarmNoRestart ($farm_name) {
    my $lf = &getFarmRestartFile($farm_name);
    unlink($lf) if -e $lf;

    return;
}

=pod

=head1 setNewFarmName

Function that renames a farm. Before call this function, stop the farm.

Parameters:

    farmname    - Farm name
    newfarmname - New farm name

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub setNewFarmName ($farm_name, $new_farm_name) {
    my $collector_rrd_dir   = &getGlobalConfiguration('collector_rrd_dir');

    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    # farmguardian renaming
    require Relianoid::FarmGuardian;
    require File::Copy;

    &runFGFarmStop($farm_name);
    &setFGFarmRename($farm_name, $new_farm_name);

    # end of farmguardian renaming

    &log_info("setting 'NewFarmName $new_farm_name' for $farm_name farm $farm_type", "FARMS");

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Action;
        $output = &copyHTTPFarm($farm_name, $new_farm_name, 'del');
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Action;
        $output = &setL4NewFarmName($farm_name, $new_farm_name);
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Action',
            func   => 'copyDatalinkFarm',
            args   => [ $farm_name, $new_farm_name, 'del' ],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Action',
            func   => 'copyGSLBFarm',
            args   => [ $farm_name, $new_farm_name, 'del' ],
        );
    }

    # farmguardian renaming
    if ($output == 0) {
        &log_info("restarting farmguardian", 'FG') if &debug();
        &runFGFarmStart($farm_name);
    }

    # end of farmguardian renaming

    # rename rrd
    File::Copy::move("$collector_rrd_dir/$farm_name-farm.rrd", "$collector_rrd_dir/$new_farm_name-farm.rrd");

    # delete old graphs
    unlink("img/graphs/bar$farm_name.png");

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::IPDS::Base',
            func   => 'runIPDSRenameByFarm',
            args   => [ $farm_name, $new_farm_name ],
        );

        &eload(
            module => 'Relianoid::EE::RBAC::Group::Config',
            func   => 'setRBACRenameByFarm',
            args   => [ $farm_name, $new_farm_name ],
        );
    }

    # FIXME: logfiles
    return $output;
}

=pod

=head1 copyFarm

Function that copies the configuration file of a farm to create a new one.

Parameters:

    farmname - Farm name
    newfarmname - New farm name

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub copyFarm ($farm_name, $new_farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    &log_info("copying the farm '$farm_name' to '$new_farm_name'", "FARMS");

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Action;
        $output = &copyHTTPFarm($farm_name, $new_farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Action;
        $output = &copyL4Farm($farm_name, $new_farm_name);
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Action',
            func   => 'copyDatalinkFarm',
            args   => [ $farm_name, $new_farm_name ],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Action',
            func   => 'copyGSLBFarm',
            args   => [ $farm_name, $new_farm_name ],
        );
    }

    return $output;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/Backend.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use Relianoid::Farm::Backend::Maintenance;

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::Backend

=cut

=pod

=head1 getFarmServerIds

It returns a list with the backend servers for a farm and service.
The backends are read from the config file.
This function is to not use the getFarmservers that does stats checks.

Parameters:

    farm_name - Farm name
    service - service backends related (optional)

Returns:

    array ref - list of backends IDs

=cut

sub getFarmServerIds ($farm_name, $service) {
    my @servers   = ();
    my $farm_type = &getFarmType($farm_name);

    if ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Service;
        my $backendsvs = &getHTTPFarmVS($farm_name, $service, "backends");
        @servers = split("\n", $backendsvs);
        @servers = 0 .. $#servers if (@servers);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Backend;
        @servers = @{ &getL4FarmServers($farm_name) };
        @servers = 0 .. $#servers if (@servers);
    }
    elsif ($farm_type eq "datalink") {
        my $configdir     = &getGlobalConfiguration('configdir');
        my $farm_filename = &getFarmFile($farm_name);
        open my $fh, '<', "$configdir/$farm_filename";
        {
            while (my $line = <$fh>) {
                push @servers, $line if ($line =~ /^;server;/);
            }
            close $fh;
        }
        @servers = 0 .. $#servers if (@servers);
    }
    elsif ($farm_type eq "gslb" && $eload) {
        my $backendsvs = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Service',
            func   => 'getGSLBFarmVS',
            args   => [ $farm_name, $service, "backends" ],
        );
        my @be = split("\n", $backendsvs);
        my $id;
        for my $b (@be) {
            $b =~ s/^\s+//;
            next if ($b =~ /^$/);

            # ID and IP
            my @subbe = split(" => ", $b);
            $id = $subbe[0];
            $id =~ s/^primary$/1/;
            $id =~ s/^secondary$/2/;
            $id += 0;
            push @servers, $id;
        }
    }

    return \@servers;
}

=pod

=head1 getFarmServers

List all farm backends and theirs configuration

Parameters:

    farm_name - Farm name
    service - service backends related (optional)

Returns:

    array ref - list of backends

FIXME:

    changes output to hash format

=cut

sub getFarmServers ($farm_name, $service = undef) {
    my $farm_type = &getFarmType($farm_name);
    my $servers;

    if ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Backend;
        $servers = &getHTTPFarmBackends($farm_name, $service);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Backend;
        $servers = &getL4FarmServers($farm_name);
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $servers = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Backend',
            func   => 'getDatalinkFarmBackends',
            args   => [$farm_name],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $servers = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Backend',
            func   => 'getGSLBFarmBackends',
            args   => [ $farm_name, $service ],
        );
    }

    return $servers;
}

=pod

=head1 getFarmServer

Return the backend with the specified value on the specified parameter.

Parameters:

    backends_ref - Array ref of backends hashes.
    value - Parameter value to match
    param - Parameter to match. Default value "id"

Returns:

    hash ref - bachend hash reference or undef if there aren't backends

=cut

sub getFarmServer ($bcks_ref, $value, $param = "id") {
    for my $server (@{$bcks_ref}) {
        # preserve type param number
        if ($param eq "id") {
            return $server if ($server->{$param} == $value);
        }
        else {
            return $server if ($server->{$param} eq "$value");
        }
    }

    # Error, not found so return undef
    return;
}

=pod

=head1 setFarmServer

Add a new Backend

Parameters:

    farm_name -  Farm name
    service   -  Optional. service name. For HTTP farms
    ids       -  Backend id, if this id doesn't exist, it will create a new backend
    bk        -  hash with backend configuration. 
                 Depend on the type of farms, the backend can have the following keys:
                 ip, port, weight, priority, timeout, max_conns or interface

Returns:

    Scalar - Error code: undef on success or -1 on error

=cut

sub setFarmServer ($farm_name, $service, $ids, $bk) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    my $attrs_msg = sprintf(
        'Server %s ip:%s port:%u max:%u weight:%u prio:%u timeout:%u',
        $ids             // '', $bk->{ip},
        $bk->{port}      // 0,
        $bk->{max_conns} // 0,
        $bk->{weight}    // 0,
        $bk->{priority}  // 0,
        $bk->{timeout}   // 0
    );
    my $msg = sprintf("setting '$attrs_msg' for %s farm, %s service of type %s", $farm_name, $service // 'no', $farm_type);
    &log_info($msg, "FARMS");

    if ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Backend',
            func   => 'setDatalinkFarmServer',
            args   => [ $ids, $bk->{ip}, $bk->{interface}, $bk->{weight}, $bk->{priority}, $farm_name ],
        );
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Backend;
        $output = &setL4FarmServer(
            $farm_name, $ids, $bk->{ip},
            $bk->{port}      // "",
            $bk->{weight}    // 1,
            $bk->{priority}  // 1,
            $bk->{max_conns} // 0
        );
    }
    elsif ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Backend;
        $output = &setHTTPFarmServer(
            $ids,           $bk->{ip},  $bk->{port}, $bk->{weight},    #
            $bk->{timeout}, $farm_name, $service,    $bk->{priority}
        );
    }

    # FIXME: include setGSLBFarmNewBackend
    return $output;
}

=pod

=head1 runFarmServerDelete

Delete a Backend

Parameters:

    ids       - Backend id, if this id doesn't exist, it will create a new backend
    farm_name - Farm name
    service   - service name. For HTTP farms

Returns:

    Scalar - Error code: undef on success or -1 on error

=cut

sub runFarmServerDelete ($ids, $farm_name, $service = undef) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    &log_info("running 'ServerDelete $ids' for $farm_name farm $farm_type", "FARMS");

    if ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Backend;
        $output = &runL4FarmServerDelete($ids, $farm_name);
    }
    elsif ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Backend;
        $output = &runHTTPFarmServerDelete($ids, $farm_name, $service);
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Backend',
            func   => 'runDatalinkFarmServerDelete',
            args   => [ $ids, $farm_name ],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Backend',
            func   => 'runGSLBFarmServerDelete',
            args   => [ $ids, $farm_name, $service ],
        );
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Backend',
            func   => 'delEproxyFarmBackend',
            args   => [ { farm_name => $farm_name, service_name => $service, backend_id => $ids } ],
        );
    }

    return $output;
}

=pod

=head1 getFarmBackendAvailableID

Get next available backend ID

Parameters:

    farmname - farm name

Returns:

    integer

=cut

sub getFarmBackendAvailableID ($farmname) {
    my $nbackends;

    if (&getFarmType($farmname) eq 'l4xnat') {
        require Relianoid::Farm::L4xNAT::Backend;
        $nbackends = &getL4FarmBackendAvailableID($farmname);
    }
    else {
        my $backends = &getFarmServers($farmname);
        $nbackends = $#{$backends} + 1;
    }

    return $nbackends;
}

=pod

=head1 setBackendRule

Add or delete the route rule according to the backend mark.

Parameters:

    action    - "add" to create the mark or "del" to remove it.
    farm_ref  - farm reference.
    mark      - backend mark to apply in the rule.
    farm_type - type of farm (l4xnat, http, https).

Returns:

    integer - 0 if successful, otherwise error.

=cut

sub setBackendRule ($action, $farm_ref, $mark, $farm_type = undef) {
    $farm_type //= getFarmType($farm_ref->{name});

    unless ($action eq "add" or $action eq "del") {
        croak("Rule action must be 'add' or 'del'");
    }

    unless (defined $farm_ref) {
        croak("A farm configuration is required");
    }

    unless (length $mark and hex $mark) {
        croak("Invalid mark received");
    }

    require Relianoid::Net::Util;
    require Relianoid::Net::Route;

    my $vip_if_name = &getInterfaceOfIp($farm_ref->{vip});
    my $vip_if      = &getInterfaceConfig($vip_if_name);
    my $table_if =
      ($vip_if->{type} eq 'virtual') ? $vip_if->{parent} : $vip_if->{name};

    my $rule = {
        table  => "table_$table_if",
        type   => $farm_type,
        from   => 'all',
        fwmark => "$mark/0x7fffffff",
    };
    return &setRule($action, $rule);
}

=pod

=head1 getPriorityAlgorithmStatus

Calculates the Priroty algorithm status of the backend list

Parameters:

    $backends_ref - list of backend_ref
    $bk_index     - backend index if defined, only returns this index values. Optional. 

    $backend_ref->{status}   - Status of the backend. Possibles values:"up","down".
    $backend_ref->{priority} - Priority of the backend

Returns:

    $availability_ref - Hash of algorithm values.

Variable:

    $availability_ref->{priority} - algorithm priority.
    $availability_ref->{status}   - Array - list of backend availability.

    If defined parameter $backend_ref->{status}:
    - "true" if the backend is used.
    - "false" if is available to be used.

    If not defined parameter $backend_ref->{status}:
    - "true" if the backend is used or available to be used.
    - "false" if the backend will never be used.

=cut

sub getPriorityAlgorithmStatus ($backends_ref, $bk_index = undef) {
    my $alg_status_ref;
    my $sum_prio_ref;

    for my $bk (@{$backends_ref}) {
        #determine number of backends down for each level of priority
        if (not defined $bk->{status} or $bk->{status} eq "down") {
            $sum_prio_ref->{ $bk->{priority} }++;
        }
    }

    #determine the lowest priority level where backends are being used
    my $current_alg_prio = 1;
    my $alg_prio         = 1;

    while ($current_alg_prio <= $alg_prio) {
        #when the level of priority matches the number of down backends, loop stops
        #and $alg_prio indicates the lowest level of prio being used.
        #else, keep increasing the level of priority checked in the next iteration.
        if (defined $sum_prio_ref->{$current_alg_prio}) {
            $alg_prio += $sum_prio_ref->{$current_alg_prio};
        }
        last if $alg_prio == $current_alg_prio;
        $current_alg_prio++;
    }

    $alg_status_ref->{priority} = $alg_prio;
    $alg_status_ref->{status}   = [];

    if (defined $bk_index) {
        if (@{$backends_ref}[$bk_index]->{priority} <= $alg_prio) {
            push @{ $alg_status_ref->{status} }, "true";
        }
        else {
            push @{ $alg_status_ref->{status} }, "false";
        }
    }
    else {
        for my $bk (@{$backends_ref}) {
            if ($bk->{priority} <= $alg_prio) {
                push @{ $alg_status_ref->{status} }, "true";
            }
            else {
                push @{ $alg_status_ref->{status} }, "false";
            }
        }
    }

    return $alg_status_ref;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/Backend/Maintenance.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::Farm::Backend::Maintenance

=cut

=pod

=head1 setFarmBackendMaintenance

Function that enable the maintenance mode for backend

Parameters:

    farm_name -  Farm name
    backend   -  Backend id
    mode      -  Maintenance mode, the options are:
                 - drain: the backend continues working with the established connections
                 - cut:   the backend cuts all the established connections
    service   -  Service name, required for http only

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub setFarmBackendMaintenance ($farm_name, $backend, $mode, $service = undef) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Backend;
        $output = &setHTTPFarmBackendMaintenance($farm_name, $backend, $mode, $service);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Backend;
        $output = &setL4FarmBackendStatus($farm_name, $backend, 'maintenance', $mode);
    }

    return $output;
}

=pod

=head1 setFarmBackendNoMaintenance

Function that disable the maintenance mode for backend

Parameters:

    farm_name - Farm name
    backend   - Backend id
    service   - Service name

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub setFarmBackendNoMaintenance ($farm_name, $backend, $service = undef) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Backend;
        $output = &setHTTPFarmBackendNoMaintenance($farm_name, $backend, $service);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Backend;
        $output = &setL4FarmBackendStatus($farm_name, $backend, 'up', "");
    }

    return $output;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/Base.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Config;
use Relianoid::Farm::Core;

my $configdir = &getGlobalConfiguration('configdir');
my $eload     = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::Base

=cut

=pod

=head1 getFarmVip

Returns farm vip or farm port

Parameters:

    tag - requested parameter. The options are 
          - "vip" for virtual ip
          - "vipp" for virtual port

    farmname - Farm name

Returns:

    Scalar - return vip or port of farm or -1 on failure

See Also:

    setFarmVirtualConf

=cut

sub getFarmVip ($info, $farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;
        $output = &getHTTPFarmVip($info, $farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $output = &getL4FarmParam($info, $farm_name);
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Config',
            func   => 'getDatalinkFarmVip',
            args   => [ $info, $farm_name ],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Config',
            func   => 'getGSLBFarmVip',
            args   => [ $info, $farm_name ],
        );
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        my $farm = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Config',
            func   => 'getEproxyFarmStruct',
            args   => [{ farm_name => $farm_name }],
        );
        $output = $farm->{vip} if ($info eq "vip");
        $output = $farm->{vport} if ($info eq "vipp");
    }

    return $output;
}

=pod

=head1 getFarmStatus

Return farm status checking if pid file exists

Parameters:

    farmname - Farm name

Returns:

    String - "down", "up" or -1 on failure

NOTE:

    Generic function

=cut

sub getFarmStatus ($farm_name) {
    my $output = -1;
    return $output if !defined($farm_name);

    my $farm_type = &getFarmType($farm_name);

    if ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        return &getL4FarmStatus($farm_name);
    }
    elsif ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Config;
        return &getHTTPFarmStatus($farm_name);
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Config',
            func   => 'getDatalinkFarmStatus',
            args   => [$farm_name],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Config',
            func   => 'getGSLBFarmStatus',
            args   => [$farm_name],
        );
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Action',
            func   => 'getEproxyFarmStatus',
            args   => [{ farm_name => $farm_name }],
        );
    }

    return $output;
}

=pod

=head1 getFarmVipStatus

Return a vip status

Parameters:

    farmname - Farm name

Returns:

    String - "needed restart", "critical", "problem", "maintenance", "up", "down" or -1 on failure

    up

        The farm is up and all the backends are working success.

    down

        The farm is not running

    needed restart

        The farm is up but it is pending of a restart action

    critical

        The farm is up and all backends are unreachable or maintenance

    problem

        The farm is up and there are some backend unreachable, 
        but almost a backend is in up status

    maintenance

        The farm is up and there are backends in up status, 
        but almost a backend is in maintenance mode.

NOTE:

    Generic function

=cut

sub getFarmVipStatus ($farm_name) {
    my $output     = -1;
    my $farmStatus = &getFarmStatus($farm_name);
    return $output if !defined($farm_name);

    $output = "problem";

    require Relianoid::Farm::Action;

    if ($farmStatus eq "down") {
        return "down";
    }
    elsif (&getFarmRestartStatus($farm_name)) {
        return "needed restart";
    }
    elsif ($farmStatus ne "up") {
        return -1;
    }

    # types: "http", "https", "datalink", "l4xnat", "gslb", "eproxy" or 1
    my $type = &getFarmType($farm_name);

    my $backends;
    my $up_flag = 0;
    my $down_flag = 0;
    my $maintenance_flag = 0;

    require Relianoid::Farm::Backend;

    # HTTP, optimized for many services
    if ($type =~ /http/) {
        require Relianoid::Farm::HTTP::Backend;
        my $status = &getHTTPFarmBackendsStatusInfo($farm_name);

        for my $service (keys %{$status}) {
            next unless defined $status->{$service}{backends};

            for my $backend (@{ $status->{$service}{backends} }) {
                push @{$backends}, $backend;
            }
        }
    }

    elsif ($type eq "gslb" && $eload) {
        my $stats = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Stats',
            func   => 'getGSLBFarmBackendsStats',
            args   => [$farm_name],
        );
        $backends = $stats->{backends};
    }

    elsif ($type eq "eproxy" && $eload) {
        $backends = &eload(
           module => 'Relianoid::EE::Farm::Eproxy::Backend',
           func   => 'getEproxyFarmBackends',
           args   => [ { farm_name => $farm_name } ],
        );
    }

    else {
        $backends = &getFarmServers($farm_name);
    }

    # checking status
    for my $be (@{$backends}) {
        $up_flag          = 1 if grep { $be->{status} eq $_ } qw(up undefined);
        $maintenance_flag = 1 if grep { $be->{status} eq $_ } qw(maintenance);
        $down_flag        = 1 if grep { $be->{status} eq $_ } qw(down fgDOWN);

        # if there is a backend up and another down, the status is 'problem'
        last if ($down_flag and $up_flag);
    }

    # check if redirect exists when there are not backends
    if ($type =~ /http/) {
        require Relianoid::Farm::HTTP::Service;
        for my $srv (&getHTTPFarmServices($farm_name)) {
            if (&getHTTPFarmVS($farm_name, $srv, 'redirect')) {
                $up_flag = 1;
                last;
            }
        }
    }

    if (!$up_flag) {
        $output = "critical";
    }
    elsif ($down_flag) {
        $output = "problem";
    }
    elsif ($maintenance_flag) {
        $output = "maintenance";
    }
    else {
        $output = "up";
    }

    return $output;
}

=pod

=head1 getFarmPid

Returns farm PID

Parameters:

    farmname - Farm name

Returns:

    Integer - return a list of daemon pids. It can contains more than one value

=cut

sub getFarmPid ($farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my @output    = ();

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;

        @output = &getHTTPFarmPidPound($farm_name);
    }
    elsif ($farm_type eq "gslb" && $eload) {
        my $pid = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Config',
            func   => 'getGSLBFarmPid',
            args   => [$farm_name],
        );
        push(@output, $pid) if $pid;
    }

    return @output;
}

=pod

=head1 getFarmBootStatus

Return the farm status at boot relianoid

Parameters:

    farmname - Farm name

Returns:

    scalar - return "down" if the farm not run at boot or "up" if the farm run at boot

=cut

sub getFarmBootStatus ($farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = "down";

    if ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Config;
        $output = &getHTTPFarmBootStatus($farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $output = &getL4FarmParam('bootstatus', $farm_name);
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Config',
            func   => 'getDatalinkFarmBootStatus',
            args   => [$farm_name],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Config',
            func   => 'getGSLBFarmBootStatus',
            args   => [$farm_name],
        );
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Config',
            func   => 'getEproxyFarmBootStatus',
            args   => [{ farm_name => $farm_name }],
        );
    }

    return $output;
}

=pod

=head1 getFarmProto

Return basic transport protocol used by the farm protocol

Parameters:

    farmname - Farm name

Returns:

    String - "udp" or "tcp"

BUG:

    Gslb works with tcp protocol too

FIXME:

    Use getL4ProtocolTransportLayer to get l4xnat protocol

=cut

sub getFarmProto ($farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    if ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $output = &getL4FarmParam('proto', $farm_name);
    }
    elsif ($farm_type =~ /http/i) {
        $output = "tcp";
    }
    elsif ($farm_type eq "gslb") {
        $output = "all";
    }

    return $output;
}

=pod

=head1 getNumberOfFarmTypeRunning

    Counter how many farms exists in a farm profile.

Parameters:

    type - Farm profile: "http", "l4xnat", "gslb" or "datalink"

Returns:

    integer- Number of farms

=cut

sub getNumberOfFarmTypeRunning ($type) {
    my $counter = 0;

    for my $farm_name (&getFarmNameList()) {
        # count if requested farm type and running
        my $current_type = &getFarmType($farm_name);

        if ($current_type eq $type) {
            my $current_status = &getFarmStatus($farm_name);

            if ($current_status eq 'up') {
                $counter++;
            }
        }
    }

    return $counter;
}

=pod

=head1 getFarmListByVip

Returns a list of farms that have the same IP address.

Parameters:

    ip   - ip address
    port - virtual port. This parameter is optional

Returns:

    Array - List of farm names

=cut

sub getFarmListByVip ($ip, $port = undef) {
    require Relianoid::Net::Validate;

    my @out = ();

    for my $farm (&getFarmNameList()) {
        if (&getFarmVip('vip', $farm) eq $ip) {
            next if defined $port && !grep { $port eq $_ } @{ &getMultiporExpanded(&getFarmVip('vipp', $farm)) };
            push @out, $farm;
        }
    }

    return @out;
}

=pod

=head1 getFarmRunning

Returns the farms are currently running in the system.

Parameters:

    none

Returns:

    Array - List of farm names

=cut

sub getFarmRunning() {
    my @out = ();

    for my $farm (&getFarmNameList()) {
        if (&getFarmStatus($farm) eq 'up') {
            push @out, $farm;
        }
    }
    return @out;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/Config.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::Config

=cut

=pod

=head1 setFarmBlacklistTime

Configure check time for resurected back-end. It is a farm paramter.

Parameters:

    blacklist_time - time for resurrected checks
    farm_name - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setFarmBlacklistTime ($blacklist_time, $farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;
        $output = &setHTTPFarmBlacklistTime($blacklist_time, $farm_name);
    }

    return $output;
}

=pod

=head1 setFarmSessionType

Configure type of persistence

Parameters:

    session  - type of session: nothing, HEADER, URL, COOKIE, PARAM, BASIC or IP, for HTTP farms; none or ip, for l4xnat farms
    farm_name - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setFarmSessionType ($session, $farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;
        $output = &setHTTPFarmSessionType($session, $farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $output = &setL4FarmParam('persist', $session, $farm_name);
    }

    #if persistence is enabled
    require Relianoid::Farm::Config;
    if (&getPersistence($farm_name) == 0) {
        #register farm in ssyncd
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Ssyncd',
                func   => 'setSsyncdFarmUp',
                args   => [$farm_name],
            );
        }
    }
    else {
        #unregister farm in ssyncd
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Ssyncd',
                func   => 'setSsyncdFarmDown',
                args   => [$farm_name],
            );
        }
    }
    return $output;
}

=pod

=head1 setFarmTimeout

Asign a timeout value to a farm

Parameters:

    timeout  - Time out in seconds
    farm_name - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setFarmTimeout ($timeout, $farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    &log_info("setting 'Timeout $timeout' for $farm_name farm $farm_type", "LSLB");

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;
        $output = &setHTTPFarmTimeout($timeout, $farm_name);
    }

    return $output;
}

=pod

=head1 setFarmAlgorithm

Set the load balancing algorithm to a farm.

Supports farm types: TCP, Datalink, L4xNAT.

Parameters:

    algorithm - Type of balancing mode
    farm_name - Farm name

Returns:

    none

FIXME:

    set a return value, and do error control

=cut

sub setFarmAlgorithm ($algorithm, $farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    &log_info("setting 'Algorithm $algorithm' for $farm_name farm $farm_type", "FARMS");

    if ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Config',
            func   => 'setDatalinkFarmAlgorithm',
            args   => [ $algorithm, $farm_name ],
        );
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $output = &setL4FarmParam('alg', $algorithm, $farm_name);
    }

    return $output;
}

=pod

=head1 getFarmAlgorithm

Get type of balancing algorithm.

Supports farm types: Datalink, L4xNAT.

Parameters:

    farm_name - Farm name

Returns:

    scalar - return a string with type of balancing algorithm or -1 on failure

=cut

sub getFarmAlgorithm ($farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $algorithm = -1;

    if ($farm_type eq "datalink" && $eload) {
        $algorithm = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Config',
            func   => 'getDatalinkFarmAlgorithm',
            args   => [$farm_name],
        );
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $algorithm = &getL4FarmParam('alg', $farm_name);
    }

    return $algorithm;
}

=pod

=head1 setFarmMaxClientTime

Set the maximum time for a client

Parameters:

    maximumTO - Maximum client time
    farm_name - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setFarmMaxClientTime ($max_client_time, $track, $farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    &log_info("setting 'MaxClientTime $max_client_time $track' for $farm_name farm $farm_type", "LSLB");

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;
        $output = &setHTTPFarmMaxClientTime($track, $farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $output = &setL4FarmParam('persisttm', $track, $farm_name);
    }

    return $output;
}

=pod

=head1 setFarmVirtualConf

Set farm virtual IP and virtual PORT

Parameters:

    vip - virtual ip

    vip_port - virtual port (interface in datalink farms).
               If the port is not sent, the port will not be changed

    farm_name - Farm name

Returns:

    Integer - return 0 on success or other value on failure

See Also:

    To get values use getFarmVip.

=cut

sub setFarmVirtualConf ($vip, $vip_port, $farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $stat      = -1;
    $vip_port //= '';

    &log_info("setting 'VirtualConf $vip $vip_port' for $farm_name farm $farm_type", "FARMS");

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;
        $stat = &setHTTPFarmVirtualConf($vip, $vip_port, $farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $stat = 0;

        if ($vip ne "") {
            $stat = &setL4FarmParam('vip', $vip, $farm_name);
        }

        return $stat if $stat;

        if ($vip_port ne "") {
            $stat = &setL4FarmParam('vipp', $vip_port, $farm_name);
        }
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $stat = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Config',
            func   => 'setDatalinkFarmVirtualConf',
            args   => [ $vip, $vip_port, $farm_name ],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $stat = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Config',
            func   => 'setGSLBFarmVirtualConf',
            args   => [ $vip, $vip_port, $farm_name ],
        );
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        $stat = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Config',
            func   => 'setEproxyFarmStruct',
            args   => [ { 'farm_name' => $farm_name, 'vip' => $vip, 'vport' => $vip_port }],
        );
    }

    return $stat;
}

=pod

=head1 setAllFarmByVip

This function change the virtual interface for a set of farms. If some farm
is up, this function will restart it.

Parameters:

    IP        - New virtual interface for the farms
    farm list - List of farms to update. This list will send as reference

Returns:

    None

=cut

sub setAllFarmByVip ($vip, $farmList) {
    require Relianoid::Farm::Action;

    for my $farm (@{$farmList}) {
        # get status
        my $status = &getFarmStatus($farm);

        # stop farm
        if ($status eq 'up') { &runFarmStop($farm); }

        # change vip
        &setFarmVirtualConf($vip, undef, $farm);

        # start farm
        if ($status eq 'up') { &runFarmStart($farm); }
    }

    return;
}

=pod

=head1 getFarmVS

Return virtual server parameter

Parameters:

    farm_name - Farm name
    service  - Service name
    tag      - Indicate which field will be returned

Returns:

    Integer - The requested parameter value

=cut

sub getFarmVS ($farm_name, $service, $tag) {
    my $output = "";
    require Relianoid::Farm::Core;
    my $farm_type = &getFarmType($farm_name);

    if ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Service;
        $output = &getHTTPFarmVS($farm_name, $service, $tag);
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Service',
            func   => 'getGSLBFarmVS',
            args   => [ $farm_name, $service, $tag ],
        );
    }

    return $output;
}

=pod

=head1 setFarmVS

Set values for service parameters

Parameters:

    farm_name - Farm name
    service  - Service name
    tag      - Indicate which parameter modify
    string   - value for the field "tag"

Returns:

    Integer - Error code: 0 on success or -1 on failure

=cut

sub setFarmVS ($farm_name, $service, $tag, $string) {
    my $output    = "";
    my $farm_type = &getFarmType($farm_name);

    if ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Service;
        $output = &setHTTPFarmVS($farm_name, $service, $tag, $string);
    }
    elsif ($farm_type eq "gslb") {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Service',
            func   => 'setGSLBFarmVS',
            args   => [ $farm_name, $service, $tag, $string ],
        ) if $eload;
    }

    return $output;
}

=pod

=head1 getFarmStruct

    Generic subroutine for the struct retrieval

Parameters:

    farmname - Farm name

Returns:

    farm - reference of the farm hash

=cut

sub getFarmStruct ($farmName) {
    require Relianoid::Farm::Core;
    my $farm;    # declare output hash
    my $farmType = &getFarmType($farmName);
    return if ($farmType eq 1);

    if ($farmType =~ /http|https/) {
        require Relianoid::Farm::HTTP::Config;
        $farm = &getHTTPFarmStruct($farmName, $farmType);
    }
    elsif ($farmType =~ /l4xnat/) {
        require Relianoid::Farm::L4xNAT::Config;
        $farm = &getL4FarmStruct($farmName);
    }
    elsif ($farmType =~ /gslb/ && $eload) {
        $farm = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Config',
            func   => 'getGSLBFarmStruct',
            args   => [$farmName],
        );
    }
    elsif ($farmType =~ /eproxy/ && $eload) {
        $farm = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Config',
            func   => 'getEproxyFarmStruct',
            args   => [{ farm_name => $farmName}],
        );
    }

    # elsif ( $farmType =~ /datalink/ && $eload)
    # {
    #     $farm = &eload(
    #         module => 'Relianoid::EE::Farm::Datalink::Config',
    #         func   => 'getDatalinkFarmStruct',
    #         args   => [$farmName],
    #     );
    # }
    return $farm;    # return a hash reference
}

=pod

=head1 getFarmPlainInfo

Return the L4 farm text configuration

Parameters:

    farm_name - farm name to get the status

Returns:

    Scalar - Reference of the file content in plain text

=cut

sub getFarmPlainInfo ($farm_name, $file = undef) {
    my @content;

    my $configdir = &getGlobalConfiguration('configdir');

    my $farm_filename = &getFarmFile($farm_name);

    if ($farm_filename =~ /(?:gslb)\.cfg$/ && defined $file) {
        open my $fd, '<', "$configdir/$farm_filename/$file" or return;
        chomp(@content = <$fd>);
        close $fd;
    }
    else {
        open my $fd, '<', "$configdir/$farm_filename" or return;
        chomp(@content = <$fd>);
        close $fd;
    }

    return \@content;
}

=pod

=head1 reloadFarmsSourceAddress

Reload source address rules of farms

Parameters:

    none

Returns:

    none


FIXME:

    one source address per farm, not for backend

=cut

sub reloadFarmsSourceAddress () {
    require Relianoid::Farm::Core;

    for my $farm_name (&getFarmNameList()) {
        &reloadFarmsSourceAddressByFarm($farm_name);
    }

    return;
}

=pod

=head1 reloadL7FarmsSourceAddress

Reload source address rules of HTTP/HTTPS farms

Parameters:

    none

Returns:

    none

=cut

sub reloadL7FarmsSourceAddress () {
    require Relianoid::Farm::Core;

    my @farms = &getFarmsByType('http');
    push @farms, &getFarmsByType('https');

    for my $farm_name (@farms) {
        &reloadFarmsSourceAddressByFarm($farm_name);
    }

    return;
}

=pod

=head1 reloadFarmsSourceAddressbyFarm

Reload source address rules of a certain farm (l4 in NAT mode and HTTP)

HTTP:

    Add backend only if use a different sourceaddr

Parameters:

    farm_name - name of the farm to apply the source address

Returns:

    none

FIXME:

    one source address per farm, not per backend

=cut

sub reloadFarmsSourceAddressByFarm ($farm_name) {
    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    return if &getFarmStatus($farm_name) ne 'up';

    my $farm_type = &getFarmType($farm_name);

    if ($farm_type eq 'l4xnat') {
        my $farm_ref = &getL4FarmStruct($farm_name);

        return if $farm_ref->{nattype} ne 'nat';

        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Net::Floating',
                func   => 'setFloatingSourceAddr',
                args   => [ $farm_ref, undef ],
            );

            # reload the backend source address
            for my $bk (@{ $farm_ref->{servers} }) {
                &eload(
                    module => 'Relianoid::EE::Net::Floating',
                    func   => 'setFloatingSourceAddr',
                    args   => [ $farm_ref, $bk ],
                );
            }
        }
    }

    return;
}

=pod

=head1 checkLocalFarmSourceAddress

Check if an HTTP farm should exist as a local farm in nftlb in order to do snat in any of its backends.
The function will return 1 in case the farm's vip contains floating ip or any of the farm's backends 
are on a network with floating ip or is on an unknown network or custom routes.

Parameters:

    farm_name    - name of the farm to check
    floating_ref - Hash ref with floating system information

Returns:

    Scalar - Integer : 0 if the source address is not needed.

    1 - if farm must be configured for snat.
    2 - if some backend must be configured for snat.
    3 - if farm and some backend must be configured for snat.
    -1 - if there is an error.

=cut

sub checkLocalFarmSourceAddress ($farm_name, $floating_ref) {
    my $farm_srcaddr_ref;

    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    my $farm_type = &getFarmType($farm_name);

    if ($farm_type eq 'http' || $farm_type eq 'https') {
        my $floating = 0;

        if ($eload && &getGlobalConfiguration('floating_L7') eq 'true') {
            $floating = 1;
        }
        return $farm_srcaddr_ref if not $floating;

        # check system floating
        my $floating_config = &eload(
            module => 'Relianoid::EE::Net::Floating',
            func   => 'getFloatingConfig',
        );

        if (not $floating_config) {
            return $farm_srcaddr_ref;
        }

        # check farm vip has floating
        require Relianoid::Farm::HTTP::Config;
        my $farm_vip = &getHTTPFarmVip("vip", $farm_name);
        my $floating_system_ref;

        if ($floating_ref) {
            $floating_system_ref = $floating_ref;
        }
        else {
            $floating_system_ref = &eload(
                module => 'Relianoid::EE::Net::Floating',
                func   => 'get_floating_struct',
            );
        }

        require Relianoid::Net::Interface;
        my $if_system_status = &getInterfaceSystemStatusAll();

        my $farm_floating = &eload(
            module => 'Relianoid::EE::Net::Floating',
            func   => 'getFloatingSourceAddr',
            args   => [ $farm_vip, undef, $floating_system_ref, $if_system_status ]
        );

        # if iface with floating, needs snat
        if ($farm_floating->{out}{floating_ip}) {
            $farm_srcaddr_ref->{farm} = $farm_floating;
        }

        # check backends for every service
        require Relianoid::Farm::HTTP::Service;
        my @services = &getHTTPFarmServices($farm_name);

        require Relianoid::Farm::HTTP::Backend;
        my $ip_floating_ref;
        my $bk_floating;
        my $exists_floating_backend = 0;

        for my $serv_name (@services) {
            my $backends_ref = &getHTTPFarmBackends($farm_name, $serv_name, "false");

            for my $bk (@{$backends_ref}) {
                if (not $ip_floating_ref->{ $bk->{ip} }) {
                    # get sourceaddress
                    my $mark = sprintf("0x%x", $bk->{tag});
                    $bk_floating = &eload(
                        module => 'Relianoid::EE::Net::Floating',
                        func   => 'getFloatingSourceAddr',
                        args   => [ $bk->{ip}, $mark, $floating_system_ref, $if_system_status ]
                    );

                    $ip_floating_ref->{ $bk->{ip} } = $bk_floating;
                }
                else {
                    %{ $bk_floating->{in} }  = %{ $ip_floating_ref->{ $bk->{ip} }{in} };
                    %{ $bk_floating->{out} } = %{ $ip_floating_ref->{ $bk->{ip} }{out} };
                }

                $bk_floating->{in}{mark} = $bk->{tag};

                # check if backend uses floating
                if ($bk_floating->{out}{floating_ip}) {
                    $exists_floating_backend = 1;
                }

                push @{ $farm_srcaddr_ref->{backends} }, $bk_floating;
                $bk_floating = undef;
            }
        }

        if (not $exists_floating_backend) {
            delete $farm_srcaddr_ref->{backends};
        }
    }

    return $farm_srcaddr_ref;
}

=pod

=head1 reloadBackendsSourceAddressByIface

Reload source address rules of a certain farm (l4 in NAT mode and HTTP) by Iface

Parameters:

    iface_name - Interface which the the route is appplied in

Returns:

    none

=cut

sub reloadBackendsSourceAddressByIface ($iface_name) {
    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    for my $farm_name (&getFarmNameList()) {
        my $farm_type = &getFarmType($farm_name);

        next if &getFarmStatus($farm_name) ne 'up';

        if ($farm_type eq 'l4xnat') {
            my $farm_ref = &getL4FarmStruct($farm_name);
            next if $farm_ref->{nattype} ne 'nat';
            &reloadFarmsSourceAddressByFarm($farm_name);
        }
    }

    return;
}

=pod

=head1 getPersistence

Checks if persistence is enabled in the farm through config file

Parameters:

    farm_name - name of the farm where check persistence

Returns: integer

    0 - true
    1 - false

=cut

sub getPersistence ($farm_name) {
    my $farm_type  = &getFarmType($farm_name);
    my $nodestatus = "";

    return 1 if $farm_type !~ /l4xnat|http/;

    if ($eload) {
        $nodestatus = &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'getClusterNodeStatus',
            args   => [],
        );
    }

    if ($nodestatus ne "master") {
        return 1;
    }

    if ($farm_type eq 'l4xnat') {
        require Relianoid::Farm::L4xNAT::Config;

        my $persist = &getL4FarmParam('persist', $farm_name);

        if ($persist !~ /^$/) {
            &log_info("Persistence enabled to $persist for farm $farm_name", "farm");
            return 0;
        }
    }

    if ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Service;
        require Relianoid::Config;
        require Relianoid::Lock;

        my $farm_file = &getFarmFile($farm_name);
        my $pathconf  = &getGlobalConfiguration('configdir');
        my $lock_fh   = &openlock("$pathconf/$farm_file", 'r');

        while (<$lock_fh>) {
            if ($_ =~ /[^#]Session/) {
                &log_info("Persistence enabled for farm $farm_name", "farm");
                return 0;
            }
        }
        close $lock_fh;
    }

    return 1;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/Core.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Config;

my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::Core

=cut

=pod

=head1 getFarmType

Get the farm type for a farm

Parameters:

    farmname - Farm name

Returns:

    String - "http", "https", "datalink", "l4xnat", "gslb" or 1 on failure

FIXME: Return undefined, or "", or throw an exception on failure.

=cut

sub getFarmType ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);

    if ($farm_filename =~ /^$farm_name\_proxy.cfg/) {
        require Relianoid::File;

        if (grep { /ListenHTTPS/ } readFileAsArray("$configdir/$farm_filename")) {
            return "https";
        }
        else {
            return "http";
        }
    }
    elsif ($farm_filename =~ /^$farm_name\_datalink.cfg/) {
        return "datalink";
    }
    elsif ($farm_filename =~ /^$farm_name\_l4xnat.cfg/) {
        return "l4xnat";
    }
    elsif ($farm_filename =~ /^$farm_name\_gslb.cfg/) {
        return "gslb";
    }
    elsif ($farm_filename =~ /^$farm_name\_eproxy.yaml/) {
        return "eproxy";
    }

    return 1;
}

=pod

=head1 getFarmFile

Returns farm file name

Parameters:

    farmname - Farm name

Returns:

    String - file name or -1 on failure

=cut

sub getFarmFile ($farm_name) {
    opendir(my $dir, "$configdir") || return -1;

    my @farm_files =
      grep {
             /^$farm_name\_(?:gslb|proxy|datalink|l4xnat)\.cfg$|^$farm_name\_eproxy\.yaml$/
          && !/^$farm_name\_.*guardian\.conf$/
          && !/^$farm_name\_status.cfg$/
      } readdir($dir);

    closedir $dir;

    if (@farm_files) {
        return $farm_files[0];
    }
    else {
        return -1;
    }
}

=pod

=head1 getFarmName

Returns farms configuration filename list

Parameters:

    file - Farm file

Returns:

    String - farm name

=cut

sub getFarmName ($farm_filename) {
    my @filename_split = split("_", $farm_filename);
    return $filename_split[0];
}

=pod

=head1 getFarmList

Returns farms configuration filename list

Parameters: None

Returns:

    Array - List of configuration files

=cut

sub getFarmList() {
    opendir(my $directory, $configdir);
    my @cfgFiles = sort (grep { /\.cfg$|\.yaml$/ } readdir($directory));
    closedir($directory);

    my @files1 = grep { /_proxy\.cfg$/ } @cfgFiles;
    my @files2 = grep { /_datalink\.cfg$/ } @cfgFiles;
    my @files3 = grep { /_l4xnat\.cfg$/ } @cfgFiles;
    my @files4 = grep { /_gslb\.cfg$/ } @cfgFiles;
    my @files5 = grep { /_eproxy\.yaml$/ } @cfgFiles;
    my @files  = (@files1, @files2, @files3, @files4, @files5);

    return @files;
}

=pod

=head1 getFarmsByType

Get all farms of a type

Parameters:

    type - Farm type. The available options are "http", "https", "datalink", "l4xnat" or "gslb"

Returns:

    Array - List of farm name of a type

=cut

sub getFarmsByType ($farm_type) {
    my @farm_names = ();

    opendir(my $dir, "$configdir") || return -1;

    # gslb uses a directory, not a file
    # my @farm_files = grep { /^.*\_.*\.cfg/ && -f "$configdir/$_" } readdir ( $dir );
    my @farm_files = grep { /^.*\_.*\.cfg$/ } readdir($dir);
    closedir $dir;

    for my $farm_filename (@farm_files) {
        next if $farm_filename =~ /.*status.cfg/;
        next if $farm_filename =~ /.*sessions.cfg/;
        my $farm_name = &getFarmName($farm_filename);

        if (&getFarmType($farm_name) eq $farm_type) {
            push(@farm_names, $farm_name);
        }
    }

    return @farm_names;
}

=pod

=head1 getFarmNameList

Returns a list with the farm names.

Parameters: None

Returns:

    array - list of farm names.

=cut

sub getFarmNameList () {
    my @farm_names = ();

    for my $farm_filename (&getFarmList()) {
        push(@farm_names, &getFarmName($farm_filename));
    }

    return @farm_names;
}

=pod

=head1 getFarmExists

Check if a farm exists

Parameters:

    Farm - Farm name

Returns:

    Integer - 1 if the farm exists or 0 if it is not

=cut

sub getFarmExists ($farmname) {
    my $out = 0;
    $out = 1 if (grep { $farmname eq $_ } &getFarmNameList());
    return $out;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/Factory.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::Factory

=cut

=pod

=head1 runFarmCreate

Create a farm

Parameters:

    farm_type - Farm type. The available options are: "http", "https", "datalink", "l4xnat" or "gslb"
    vip       - Virtual IP where the virtual service is listening
    vip_port  - Virtual port where the virtual service is listening
    farm_name - Farm name
    fdev      - Inteface wich uses the VIP. This parameter is only used in datalink farms

Returns:

    Integer - return 0 on success or different of 0 on failure

FIXME:

    Use hash to pass the parameters

=cut

sub runFarmCreate ($farm_type, $vip, $vip_port, $farm_name, $fdev) {
    my $output        = -1;

    my $farm_filename = &getFarmFile($farm_name);

    if ($farm_filename != -1) {
        # the farm name already exists
        $output = -2;
        return $output;
    }

    my $status = 'up';
    if ($farm_type ne 'datalink') {
        require Relianoid::Net::Interface;

        if (!&validatePort($vip, $vip_port, $farm_type, $farm_name)) {
            $status = 'down';
        }
    }

    &log_info("running 'Create' for $farm_name farm $farm_type", "LSLB");

    if ($farm_type =~ /^HTTPS?$/i) {
        require Relianoid::Farm::HTTP::Factory;
        $output = &runHTTPFarmCreate($vip, $vip_port, $farm_name, $farm_type, $status);
    }
    elsif ($farm_type =~ /^eproxy$/) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Factory',
            func   => 'runEproxyFarmCreate',
            args   => [ {vip => $vip, vport => $vip_port, farm_name => $farm_name, farm_type => $farm_type, status => $status} ],
        );
    }
    elsif ($farm_type =~ /^L4xNAT$/i) {
        require Relianoid::Farm::L4xNAT::Factory;
        $output = &runL4FarmCreate($vip, $farm_name, $vip_port, $status);
    }
    elsif ($farm_type =~ /^DATALINK$/i && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Factory',
            func   => 'runDatalinkFarmCreate',
            args   => [ $farm_name, $vip, $fdev ],
        );
    }
    elsif ($farm_type =~ /^GSLB$/i && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Factory',
            func   => 'runGSLBFarmCreate',
            args   => [ $vip, $vip_port, $farm_name, $status ],
        );
    }

    &eload(
        module => 'Relianoid::EE::RBAC::Group::Config',
        func   => 'addRBACUserResource',
        args   => [ $farm_name, 'farms' ],
    ) if $eload;

    return $output;
}

=pod

=head1 runFarmCreateFrom

Function that does a copy of a farm and set the new virtual ip and virtual port.
Apply the same farguardians to the services and the same ipds rules.

Parameters:

    params - hash reference. The hash has to contain the following keys:

    profile:   is the type of profile is going to be copied
    farmname:  the name of the new farm
    copy_from: it is the name of the farm from is copying
    vip:       the new virtual ip for the new farm
    vport:     the new virtual port for the new farm. This parameters is skipped in datalink farms
    interface: it is the interface for the new farm. This parameter is for datalink farms

Returns:

    Integer - Error code: return 0 on success or another value on failure

=cut

sub runFarmCreateFrom ($params) {
    my $err = 0;

    require Relianoid::Lock;

    # lock farm
    my $lock_file = &getLockFile($params->{farmname});
    my $lock_fh   = &openlock($lock_file, 'w');

    # add ipds rules
    my $ipds;
    if ($eload) {
        $ipds = &eload(
            module => 'Relianoid::EE::IPDS::Core',
            func   => 'getIPDSfarmsRules',
            args   => [ $params->{copy_from} ],
        );

        # they doesn't have to be applied, they already are in the config file
        delete $ipds->{waf};
    }

    # create file
    require Relianoid::Farm::Action;
    $err = &copyFarm($params->{copy_from}, $params->{farmname});

    # add fg
    require Relianoid::FarmGuardian;
    if ($params->{profile} eq 'l4xnat') {
        if (my $fg = &getFGFarm($params->{copy_from})) {
            &linkFGFarm($fg, $params->{farmname});
        }
    }
    elsif ($params->{profile} ne 'datalink') {
        my $fg;
        require Relianoid::Farm::Service;
        for my $s (&getFarmServices($params->{farmname})) {
            if (my $fg = &getFGFarm($params->{copy_from}, $s)) {
                &linkFGFarm($fg, $params->{farmname}, $s);
            }
        }
    }

    # unlock farm
    close $lock_fh;

    # modify vport, vip, interface
    if ($params->{profile} ne 'datalink') {
        require Relianoid::Farm::Config;
        $err = &setFarmVirtualConf($params->{vip}, $params->{vport}, $params->{farmname});
    }
    else {
        $err = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Config',
            func   => 'setDatalinkFarmVirtualConf',
            args   => [ $params->{vip}, $params->{interface}, $params->{farmname} ],
        ) if $eload;
    }

    if ($eload and not $err) {
        $err = &eload(
            module => 'Relianoid::EE::IPDS::Core',
            func   => 'addIPDSFarms',
            args   => [ $params->{farmname}, $ipds ],
        );
    }

    if (($params->{profile} eq 'l4xnat') and (!$err)) {
        require Relianoid::Net::Interface;
        if (&validatePort($params->{vip}, $params->{vport}, 'l4xnat', $params->{farmname})) {
            $err = &startL4Farm($params->{farmname});
        }
    }

    return $err;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/HTTP/Action.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::HTTP::Action

=cut

=pod

=head1 _runHTTPFarmStart

Run a HTTP farm

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success or different of 0 on failure

=cut

sub _runHTTPFarmStart ($farm_name, $writeconf = undef) {
    require Relianoid::System;
    require Relianoid::Farm::HTTP::Backend;
    require Relianoid::Farm::Config;

    my $status        = -1;
    my $farm_filename = &getFarmFile($farm_name);
    my $pound         = &getGlobalConfiguration('pound');
    my $piddir        = &getGlobalConfiguration('piddir');

    require Relianoid::Lock;
    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    close $lock_fh;

    &log_info("Checking $farm_name farm configuration", "LSLB");
    return -1 if (&getHTTPFarmConfigIsOK($farm_name));

    my $args = '';
    if ($eload) {
        my $ssyncd_enabled = &getGlobalConfiguration('ssyncd_enabled');
        $args = '-s' if ($ssyncd_enabled eq 'true');
    }

    my $cmd = "$pound $args -f $configdir\/$farm_filename -p $piddir\/$farm_name\_proxy.pid";
    $status = &run_with_env("$cmd");

    if ($status) {
        &log_error("failed: $cmd", "LSLB");
        return $status;
    }

    # set backend at status before that the farm stopped
    &setHTTPFarmBackendStatusFromFile($farm_name);
    &setHTTPFarmBootStatus($farm_name, "up") if ($writeconf);

    return $status;
}

=pod

=head1 _runHTTPFarmStop

Stop a HTTP farm

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success or different of 0 on failure

=cut

sub _runHTTPFarmStop ($farm_name, $writeconf = undef) {
    require Relianoid::FarmGuardian;
    my $time = &getGlobalConfiguration("http_farm_stop_grace_time");

    &runFarmGuardianStop($farm_name, "");

    require Relianoid::Farm::HTTP::Config;
    &setHTTPFarmBootStatus($farm_name, "down") if ($writeconf);

    require Relianoid::Farm::HTTP::Config;
    return 0 if &getHTTPFarmStatus($farm_name) eq "down";

    my $piddir = &getGlobalConfiguration('piddir');

    if (&getHTTPFarmConfigIsOK($farm_name) == 0) {
        my @pids = &getFarmPid($farm_name);

        if (!@pids) {
            &log_warn("Not found pid", "LSLB");
        }
        else {
            my $pid = join(', ', @pids);
            &log_info("Stopping HTTP farm $farm_name with PID $pid", "LSLB");
            kill 9, @pids;
            sleep($time);
        }

        unlink("${piddir}/${farm_name}_proxy.pid") if -e "${piddir}/${farm_name}_proxy.pid";
        unlink("/tmp/${farm_name}_proxy.socket")   if -e "/tmp/${farm_name}_proxy.socket";

        require Relianoid::Lock;
        my $lf = &getLockFile($farm_name);
        unlink $lf if -e $lf;
    }
    else {
        &log_info("Farm $farm_name can't be stopped, check the logs and modify the configuration", "LSLB");
        return 1;
    }

    return 0;
}

=pod

=head1 copyHTTPFarm

Function that does a copy of a farm configuration.
If the flag has the value 'del', the old farm will be deleted.

Parameters:

    farm_name   - Farm name
    newfarmname - New farm name
    del         - It expects a 'del' string to delete the old farm.
                  It is used to copy or rename the farm.

Returns:

    Integer - Error code: return 0 on success or -1 on failure

=cut

sub copyHTTPFarm ($farm_name, $new_farm_name, $del = "") {
    use File::Copy qw(copy);
    require Relianoid::File;

    my $output           = 0;
    my @farm_configfiles = (
        "${configdir}/${farm_name}_status.cfg",  "${configdir}/${farm_name}_proxy.cfg",
        "${configdir}/${farm_name}_Err414.html", "${configdir}/${farm_name}_Err500.html",
        "${configdir}/${farm_name}_Err501.html", "${configdir}/${farm_name}_Err503.html",
        "${configdir}/${farm_name}_sessions.cfg",
    );
    my @new_farm_configfiles = (
        "${configdir}/${new_farm_name}_status.cfg",  "${configdir}/${new_farm_name}_proxy.cfg",
        "${configdir}/${new_farm_name}_Err414.html", "${configdir}/${new_farm_name}_Err500.html",
        "${configdir}/${new_farm_name}_Err501.html", "${configdir}/${new_farm_name}_Err503.html",
        "${configdir}/${new_farm_name}_sessions.cfg",
    );

    my $cfg = $configdir;
    my $oFN = $farm_name;        # old farm name
    my $nFN = $new_farm_name;    # new farm name

    for my $farm_file (@farm_configfiles) {
        my $new_farm_filename = shift @new_farm_configfiles;

        next unless (-e $farm_file);

        copy($farm_file, $new_farm_filename) or $output = -1;
        unlink($farm_file) if ($del eq 'del');

        next unless ($farm_file eq "${configdir}/${farm_name}_proxy.cfg");

        my @lines = readFileAsArray($new_farm_filename);

        # Lines to change:
        #Name		BasekitHTTP
        #Control 	"/tmp/BasekitHTTP_proxy.socket"
        #\tErr414 "/usr/local/relianoid/config/BasekitHTTP_Err414.html"
        #\tErr500 "/usr/local/relianoid/config/BasekitHTTP_Err500.html"
        #\tErr501 "/usr/local/relianoid/config/BasekitHTTP_Err501.html"
        #\tErr503 "/usr/local/relianoid/config/BasekitHTTP_Err503.html"
        #\t#Service "BasekitHTTP"
        #NfMarks (for each backend)

        for my $l (@lines) {
            $l =~ s/^(\s*Name\s+"?)${oFN}/$1${nFN}/;
            $l =~ s/\tErr414 "$cfg\/${oFN}_Err414.html"/\tErr414 "$cfg\/${nFN}_Err414.html"/;
            $l =~ s/\tErr500 "$cfg\/${oFN}_Err500.html"/\tErr500 "$cfg\/${nFN}_Err500.html"/;
            $l =~ s/\tErr501 "$cfg\/${oFN}_Err501.html"/\tErr501 "$cfg\/${nFN}_Err501.html"/;
            $l =~ s/\tErr503 "$cfg\/${oFN}_Err503.html"/\tErr503 "$cfg\/${nFN}_Err503.html"/;
            $l =~ s/\t#Service "${oFN}"/\t#Service "${nFN}"/;
        }

        my $match   = qq(Control \t"\/tmp\/${oFN}_proxy.socket");
        my $replace = qq(Control \t"\/tmp\/${nFN}_proxy.socket");

        for my $l (@lines) {
            $l =~ s/${match}/${replace}/;
        }

        writeFileFromArray($new_farm_filename, \@lines);

        &log_info("Configuration saved in $new_farm_filename file", "LSLB");
    }

    if (-e "\/tmp\/$farm_name\_pound.socket" and $del eq 'del') {
        unlink("\/tmp\/$farm_name\_pound.socket");
    }

    return $output;
}

=pod

=head1 checkFarmHTTPSystemStatus

Checks the process and PID file on the system and fixes the inconsistency.

Parameters:

    farm_name - farm that is going to be modified
    status    - Status to check. Only "down" status.
    fix       - True, do the necessary changes to get the inconsistency fixed. 

Returns:

    None

=cut

sub checkFarmHTTPSystemStatus ($farm_name, $status, $fix = undef) {
    if ($status eq "down") {
        my $pid_file = getHTTPFarmPidFile($farm_name);
        if (-e $pid_file) {
            unlink $pid_file if (defined $fix and $fix eq "true");
        }
        my $pgrep = &getGlobalConfiguration("pgrep");
        require Relianoid::Farm::Core;
        my $farm_file    = &getFarmFile($farm_name);
        my $config_dir   = &getGlobalConfiguration("configdir");
        my $pound        = &getGlobalConfiguration("pound");
        my @pids_running = @{ &logAndGet("$pgrep -f \"$pound (-s )?-f $config_dir/$farm_file -p $pid_file\"", "array") };

        if (@pids_running) {
            kill 9, @pids_running if (defined $fix and $fix eq "true");
        }
    }
    return;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/HTTP/Backend.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

require Relianoid::Netfilter;
require Relianoid::Farm::Config;

my $configdir = &getGlobalConfiguration('configdir');

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::HTTP::Backend

=cut

=pod

=head1 setHTTPFarmServer

Add a new backend to a HTTP service or modify if it exists

Parameters:

    ids       - integer - backend id
    rip       - string  - backend ip
    port      - integer - backend port
    weight    - integer - The weight of this backend (between 1 and 9). Higher weight backends will be used more often than lower weight ones.
    timeout   - integer - Override the global time out for this backend
    farm_name - string  - Farm name
    service   - string  - service name
    priority  - integer - Optional. The priority of this backend (greater than 1). Lower value indicates higher priority

Returns: integer - Error code - non-zero when there is an error.

=cut

sub setHTTPFarmServer ($ids, $rip, $port, $weight, $timeout, $farm_name, $service, $priority = 1) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    $priority = 1 if (not defined $priority) or $priority eq '';
    $priority = 1 unless ($priority == 1 || $priority == 2);

    require Relianoid::Lock;
    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @contents, 'Tie::File', "${configdir}/${farm_filename}";

    if ($ids ne "") {
        my $index_count = -1;
        my $i           = -1;
        my $sw          = 0;

        for my $line (@contents) {
            $i++;

            #search the service to modify
            if ($line =~ /^\s*Service "$service"/) {
                $sw = 1;
            }

            if ($line =~ /^\s*(BackEnd|Emergency)/ && $sw) {
                $index_count++;

                if ($index_count == $ids) {
                    #server for modify $ids;
                    #HTTPS
                    if ($line =~ /^\s*BackEnd/ && $priority == 2) {
                        $contents[$i] = "\t\tEmergency";
                    }
                    elsif ($line =~ /^\s*Emergency/ && $priority == 1) {
                        $contents[$i] = "\t\tBackEnd";
                    }

                    my $httpsbe = &getHTTPFarmVS($farm_name, $service, "httpsbackend");

                    if ($httpsbe eq "true") {
                        #add item
                        $i++;
                    }

                    $output             = 0;
                    $contents[ $i + 1 ] = "\t\t\tAddress $rip";
                    $contents[ $i + 2 ] = "\t\t\tPort $port";

                    my $p_m = 0;

                    if ($contents[ $i + 3 ] =~ /^\s*TimeOut/) {
                        $contents[ $i + 3 ] = "\t\t\tTimeOut $timeout";
                        &log_info("Modified current timeout", "LSLB");
                    }

                    if ($contents[ $i + 4 ] =~ /^\s*Priority/) {
                        $contents[ $i + 4 ] = "\t\t\tPriority $weight";
                        splice @contents, $i + 4, 1, if ($priority == 2);
                        &log_info("Modified current priority", "LSLB");
                        $p_m = 1;
                    }

                    if ($contents[ $i + 3 ] =~ /^\s*Priority/) {
                        $contents[ $i + 3 ] = "\t\t\tPriority $weight";
                        splice @contents, $i + 3, 1, if ($priority == 2);
                        $p_m = 1;
                    }

                    #delete item
                    if (!defined $timeout || $timeout =~ /^$/) {
                        if ($contents[ $i + 3 ] =~ /^\s*TimeOut/) {
                            splice @contents, $i + 3, 1,;
                        }
                    }

                    if (!defined $weight || $weight =~ /^$/) {
                        if ($contents[ $i + 3 ] =~ /^\s*Priority/) {
                            splice @contents, $i + 3, 1,;
                        }
                        if ($contents[ $i + 4 ] =~ /^\s*Priority/) {
                            splice @contents, $i + 4, 1,;
                        }
                    }

                    #new item
                    if (   defined $timeout
                        && $timeout !~ /^$/
                        && ($contents[ $i + 3 ] =~ /^\s*End/ || $contents[ $i + 3 ] =~ /^\s*Priority/))
                    {
                        splice @contents, $i + 3, 0, "\t\t\tTimeOut $timeout";
                    }

                    if (   defined $weight
                        && $p_m eq 0
                        && $weight !~ /^$/
                        && ($contents[ $i + 3 ] =~ /^\s*End/ || $contents[ $i + 4 ] =~ /^\s*End/))
                    {
                        if ($contents[ $i + 3 ] =~ /^\s*TimeOut/) {
                            splice @contents, $i + 4, 0, "\t\t\tPriority $weight" if ($priority == 1);
                        }
                        else {
                            splice @contents, $i + 3, 0, "\t\t\tPriority $weight" if ($priority == 1);
                        }
                    }
                }
            }
        }
    }
    else {
        #add new server
        my $nsflag     = "true";
        my $index      = -1;
        my $backend    = 0;
        my $be_section = -1;

        for my $line (@contents) {
            $index++;

            if ($be_section == 1 && $line =~ /^\s*Address/) {
                $backend++;
            }

            if ($line =~ /^\s*Service \"$service\"/ && $be_section == -1) {
                $be_section++;
            }

            if ($line =~ /^\s*#BackEnd/ && $be_section == 0) {
                $be_section++;
            }

            if ($be_section == 1 && $line =~ /^\s*#End/) {
                if ($priority == 1) {
                    splice @contents, $index, 0, "\t\tBackEnd";
                }
                else {
                    splice @contents, $index, 0, "\t\tEmergency";
                }

                $output = 0;
                $index++;

                splice @contents, $index, 0, "\t\t\tAddress $rip";
                my $httpsbe = &getHTTPFarmVS($farm_name, $service, "httpsbackend");

                if ($httpsbe eq "true") {
                    #add item
                    splice @contents, $index, 0, "\t\t\tHTTPS";
                    $index++;
                }

                $index++;
                splice @contents, $index, 0, "\t\t\tPort $port";
                $index++;

                #Timeout?
                if ($timeout) {
                    splice @contents, $index, 0, "\t\t\tTimeOut $timeout";
                    $index++;
                }

                #Priority?
                if ($weight && ($priority == 1)) {
                    splice @contents, $index, 0, "\t\t\tPriority $weight";
                    $index++;
                }

                splice @contents, $index, 0, "\t\tEnd";
                $be_section++;    # Backend Added
            }

            # if backend added then go out of form
        }

        if ($nsflag eq "true") {
            my $idservice = &getFarmVSI($farm_name, $service);

            if ($idservice ne "") {
                &setHTTPFarmBackendStatusFile($farm_name, $backend, "active", $idservice);
            }
        }
    }

    untie @contents;
    close $lock_fh;

    return $output;
}

=pod

=head1 runHTTPFarmServerDelete

Delete a backend in a HTTP service

Parameters:

    ids       - backend id to delete it
    farm_name - Farm name
    service   - service name where is the backend

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub runHTTPFarmServerDelete ($ids, $farm_name, $service) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;
    my $i             = -1;
    my $j             = -1;
    my $sw            = 0;
    my $dec_mark;
    my $farm_ref = getFarmStruct($farm_name);

    require Relianoid::Lock;
    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @contents, 'Tie::File', "$configdir\/$farm_filename";

    for my $line (@contents) {
        $i++;

        if ($line =~ /^\s*Service \"$service\"/) {
            $sw = 1;
        }

        if ($line =~ /^\s*(BackEnd|Emergency)/ && $sw) {
            $j++;

            if ($j == $ids) {
                splice @contents, $i, 1,;
                $output = 0;

                while ($contents[$i] !~ /^\s*End/) {
                    splice @contents, $i, 1,;
                }

                splice @contents, $i, 1,;
            }
        }
    }
    untie @contents;

    close $lock_fh;

    if ($output != -1) {
        &runRemoveHTTPBackendStatus($farm_name, $ids, $service);
    }

    return $output;
}

=pod

=head1 getHTTPFarmBackendStatusCtl

Get status of a HTTP farm and its backends, sessions can be not included

Parameters:

    farm_name - Farm name
    sessions  - "true" show sessions info. "false" sessions are not shown.

Returns:

    array - return the output of poundctl command for a farm

=cut

sub getHTTPFarmBackendStatusCtl ($farm_name, $sessions = undef) {
    my $poundctl = &getGlobalConfiguration('poundctl');

    my $sessions_option = "-C";
    if (defined $sessions and $sessions = "true") {
        $sessions_option = "";
    }
    return @{ &logAndGet("$poundctl $sessions_option -c /tmp/$farm_name\_proxy.socket", "array") };
}

=pod

=head1 getHTTPFarmBackends

Return a list with all backends in a service and theirs configuration

Parameters:

    farmname     - Farm name
    service      - Service name
    param_status - "true" or "false" to indicate to get backend status.

Returns:

    array ref - Each element in the array it is a hash ref to a backend.
                the array index is the backend id

=cut

sub getHTTPFarmBackends ($farmname, $service, $param_status = undef) {
    require Relianoid::Farm::HTTP::Service;

    my $backendsvs = &getHTTPFarmVS($farmname, $service, "backends");

    my @be = split("\n", $backendsvs);
    my @be_status;
    my @out_ba;
    my $backend_ref;

    if (not $param_status or $param_status eq "true") {
        @be_status = @{ &getHTTPFarmBackendsStatus($farmname, $service) };
    }

    for my $subl (@be) {
        my @subbe = split(' ', $subl);
        my $id    = $subbe[1] + 0;

        my $ip   = $subbe[3];
        my $port = $subbe[5] + 0;
        my $tout = $subbe[7];
        my $prio = $subbe[9];
        my $weig = $subbe[11];

        $tout = $tout eq '-' ? undef : $tout + 0;
        $prio = $prio eq '-' ? undef : $prio + 0;
        $weig = $weig eq '-' ? undef : $weig + 0;

        my $status = "undefined";
        if (not $param_status or $param_status eq "true") {
            $status = $be_status[$id] if $be_status[$id];
        }

        $backend_ref = {
            id       => $id,
            ip       => $ip,
            port     => $port + 0,
            timeout  => $tout,
            weight   => $prio,
            priority => $weig,
        };

        if (not $param_status or $param_status eq "true") {
            $backend_ref->{status} = $status;
        }

        push @out_ba, $backend_ref;
        $backend_ref = undef;
    }

    return \@out_ba;
}

=pod

=head1 getHTTPFarmBackendsStatus

Get the status of all backends in a service. The possible values are:

    up         - The farm is in up status and the backend is OK.
    down       - The farm is in up status and the backend is unreachable
    maintenace - The backend is in maintenance mode.
    undefined  - The farm is in down status and backend is not in maintenance mode.

Parameters:

    farm_name - Farm name
    service - Service name

Returns:

    Array ref - the index is backend index, the value is the backend status

=cut

#ecm possible bug here returns 2 values instead of 1 (1 backend only)
sub getHTTPFarmBackendsStatus ($farm_name, $service) {
    require Relianoid::Farm::Base;

    my @status;
    my $farmStatus = &getFarmStatus($farm_name);
    my $stats;

    if ($farmStatus eq "up") {
        require Relianoid::Farm::HTTP::Backend;
        $stats = &getHTTPFarmBackendsStatusInfo($farm_name);
    }

    require Relianoid::Farm::HTTP::Service;

    my $backendsvs = &getHTTPFarmVS($farm_name, $service, "backends");
    my @be         = split("\n", $backendsvs);
    my $id         = 0;

    # @be is used to get size of backend array
    for (@be) {
        my $backendstatus = &getHTTPBackendStatusFromFile($farm_name, $id, $service);
        if ($backendstatus ne "maintenance") {
            if ($farmStatus eq "up") {
                $backendstatus = $stats->{$service}{backends}[$id]->{status};
            }
            else {
                $backendstatus = "undefined";
            }
        }
        push @status, $backendstatus;
        $id = $id + 1;
    }

    return \@status;
}

=pod

=head1 setHTTPFarmBackendStatus

Set backend status for an http farm and stops traffic to that backend when needed.

Parameters:

    farm_name          - Farm name
    service            - Service name
    backend_index      - Backend index
    status             - Backend status. The possible values are: "up", "maintenance" or "fgDOWN".
    cutmode            - "cut" to remove sessions for such backend
    backends_info_ref  - array ref including status and prio of all backends of the service.

Returns:

    hash reference

    $error_ref->{code}

        0 on success
        1 on failure changing status,
        2 on failure removing sessions.

    $error_ref->{desc} - error message.

=cut

sub setHTTPFarmBackendStatus ($farm_name, $service, $backend_index, $status, $cutmode, $backends_info_ref = undef) {
    require Relianoid::Farm::HTTP::Service;
    require Relianoid::Farm::HTTP::Config;

    my $socket_file       = &getHTTPFarmSocket($farm_name);
    my $service_id        = &getFarmVSI($farm_name, $service);
    my $error_ref->{code} = -1;
    my $output;

    $cutmode = "" if &getHTTPFarmVS($farm_name, $service, "sesstype") eq "";

    my $poundctl = &getGlobalConfiguration('poundctl');
    if ($status eq 'maintenance' or $status eq 'fgDOWN') {
        $output = &logAndRun("$poundctl -c $socket_file -b 0 $service_id $backend_index");
        if ($output) {
            my $msg = "Backend '$backend_index' in service '$service' of farm '$farm_name' cannot be disabled";
            $error_ref->{code} = 1;
            $error_ref->{desc} = $msg;
            return $error_ref;
        }
        else {
            $error_ref->{code} = 0;
        }
        &setHTTPFarmBackendStatusFile($farm_name, $backend_index, $status, $service_id);
        if ($cutmode eq 'cut') {
            $output = &setHTTPFarmBackendsSessionsRemove($farm_name, $service, $backend_index);
            if ($output) {
                my $msg = "Sessions for backend '$backend_index' in service '$service' of farm '$farm_name' were not deleted.";
                &log_error($msg, "LSLB");
                $error_ref->{code} = 2;
                $error_ref->{desc} = $msg;
                return $error_ref;
            }
        }
    }
    elsif ($status eq 'up') {
        $output = &logAndRun("$poundctl -c $socket_file -B 0 $service_id $backend_index");
        if ($output) {
            my $msg = "Backend '$backend_index' in service '$service' of farm '$farm_name' cannot be enabled";
            $error_ref->{code} = 1;
            $error_ref->{desc} = $msg;
            return $error_ref;
        }
        else {
            $error_ref->{code} = 0;
        }
        &setHTTPFarmBackendStatusFile($farm_name, $backend_index, 'active', $service_id);
    }

    return $error_ref;
}

=pod

=head1 getHTTPBackendStatusFromFile

Function that return if a l7 proxy backend is active, down by farmguardian or it's in maintenance mode

Parameters:

    farm_name - Farm name
    backend  - backend id
    service  - service name

Returns:

    scalar - return backend status: "maintentance", "fgDOWN", "active" or -1 on failure

=cut

sub getHTTPBackendStatusFromFile ($farm_name, $backend, $service) {
    require Relianoid::Farm::HTTP::Service;

    my $index;
    my $stfile = "$configdir\/$farm_name\_status.cfg";

    # if the status file does not exist the backend is ok
    my $output = "active";

    if (!-e $stfile) {
        return $output;
    }

    $index = &getFarmVSI($farm_name, $service);

    if (open(my $fh, '<', $stfile)) {
        my @lines = <$fh>;
        close $fh;

        for my $line (@lines) {
            #service index
            if ($line =~ /\ 0\ ${index}\ ${backend}/) {
                if ($line =~ /maintenance/) {
                    $output = "maintenance";
                }
                elsif ($line =~ /fgDOWN/) {
                    $output = "fgDOWN";
                }
                else {
                    $output = "active";
                }
            }
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmBackendStatusFile

Function that save in a file the backend status (maintenance or not)

Parameters:

    farm_name   - Farm name
    backend     - Backend id
    status      - backend status to save in the status file
    idsv        - Service id

Returns: Nothing

FIXME:

    Not return anything, do error control

=cut

sub setHTTPFarmBackendStatusFile ($farm_name, $backend, $status, $idsv) {
    require Tie::File;

    my $statusfile = "${configdir}/${farm_name}_status.cfg";
    my $changed    = "false";

    unless (-e $statusfile) {
        my $poundctl = &getGlobalConfiguration('poundctl');
        my @run      = @{ &logAndGet("${poundctl} -C -c /tmp/${farm_name}_proxy.socket", "array") };
        my @sw;
        my @bw;
        my @statusfile_ln;

        for my $line (@run) {
            if ($line =~ /\.\ Service\ /) {
                @sw = split("\ ", $line);
                $sw[0] =~ s/\.//g;
                chomp $sw[0];
            }
            if ($line =~ /\.\ Backend\ /) {
                @bw = split("\ ", $line);
                $bw[0] =~ s/\.//g;
                chomp $bw[0];
                if ($bw[3] eq "active") {
                    #~ print FW "-B 0 $sw[0] $bw[0] active\n";
                }
                else {
                    push(@statusfile_ln, "-b 0 $sw[0] $bw[0] fgDOWN\n");
                }
            }
        }

        open my $fh, '>', $statusfile;
        print $fh join("\n", @statusfile_ln);
        close $fh;
    }

    tie my @filelines, 'Tie::File', "$statusfile";
    my $i = 0;

    for my $linea (@filelines) {
        if ($linea =~ / 0 ${idsv} ${backend}/) {
            if ($status =~ /maintenance/ || $status =~ /fgDOWN/) {
                $linea   = "-b 0 ${idsv} $backend $status";
                $changed = "true";
            }
            else {
                splice(@filelines, $i, 1);
                $changed = "true";
            }
        }
        $i++;
    }

    untie @filelines;

    if ($changed eq "false") {
        open(my $fh, '>>', $statusfile);

        if ($status =~ /maintenance/ || $status =~ /fgDOWN/) {
            print {$fh} "-b 0 ${idsv} $backend $status\n";
        }

        close $fh;
    }

    return;
}

=pod

=head1 setHTTPFarmBackendMaintenance

Function that enable the maintenance mode for backend

Parameters:

    farm_name - Farm name
    backend   - Backend id
    mode      - Maintenance mode, the options are:
                - drain, the backend continues working with the established connections
                - cut, the backend cuts all the established connections
    service   - Service name

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub setHTTPFarmBackendMaintenance ($farm_name, $backend, $mode, $service) {
    my $output = 0;

    &log_info("setting Maintenance mode for $farm_name service $service backend $backend", "LSLB");

    if (&getFarmStatus($farm_name) eq 'up') {
        $output = &setHTTPFarmBackendStatus($farm_name, $service, $backend, 'maintenance', $mode);
    }

    return $output;
}

=pod

=head1 setHTTPFarmBackendNoMaintenance

Function that disable the maintenance mode for backend

Parameters:

    farm_name - Farm name
    backend   - Backend id
    service   - Service name

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub setHTTPFarmBackendNoMaintenance ($farm_name, $backend, $service) {
    my $output = 0;

    &log_info("setting Disabled maintenance mode for $farm_name service $service backend $backend", "LSLB");

    if (&getFarmStatus($farm_name) eq 'up') {
        $output = &setHTTPFarmBackendStatus($farm_name, $service, $backend, 'up', 'cut');
    }

    return $output;
}

=pod

=head1 runRemoveHTTPBackendStatus

Function that removes a backend from the status file

Parameters:

    farm_name - Farm name
    backend   - Backend id
    service   - Service name

Returns:

    none

FIXME:

    This function returns nothing, do error control

=cut

sub runRemoveHTTPBackendStatus ($farm_name, $backend, $service) {
    require Tie::File;

    my $i          = -1;
    my $serv_index = &getFarmVSI($farm_name, $service);

    tie my @contents, 'Tie::File', "$configdir\/$farm_name\_status.cfg";

    for my $line (@contents) {
        $i++;
        if ($line =~ /0\ ${serv_index}\ ${backend}/) {
            splice @contents, $i, 1,;
            last;
        }
    }
    untie @contents;

    # decrease backend index in greater backend ids
    tie my @filelines, 'Tie::File', "$configdir\/$farm_name\_status.cfg";

    for my $line (@filelines) {
        if ($line =~ /0\ ${serv_index}\ (\d+) (\w+)/) {
            my $backend_index = $1;
            my $status        = $2;
            if ($backend_index > $backend) {
                $backend_index = $backend_index - 1;
                $line          = "-b 0 $serv_index $backend_index $status";
            }
        }
    }
    untie @filelines;

    return;
}

=pod

=head1 setHTTPFarmBackendStatusFromFile

For a HTTP farm, it gets each backend status from status file and set it in ly proxy daemon

Parameters:

    farmname - Farm name

Returns:

    none

FIXME:

    This function returns nothing, do error control

=cut

sub setHTTPFarmBackendStatusFromFile ($farm_name) {
    &log_info("Setting backends status in farm $farm_name", "LSLB");

    my $be_status_filename = "$configdir\/$farm_name\_status.cfg";
    my $poundctl           = &getGlobalConfiguration('poundctl');

    unless (-f $be_status_filename) {
        open my $fh, ">", $be_status_filename;
        close $fh;
        return;
    }

    if (open(my $fh, "<", $be_status_filename)) {
        my @lines = <$fh>;
        close $fh;

        for my $line_aux (@lines) {
            my @line = split("\ ", $line_aux);
            &logAndRun("$poundctl -c /tmp/$farm_name\_proxy.socket $line[0] $line[1] $line[2] $line[3]");
        }
    }
    else {
        my $msg = "Error opening $be_status_filename: $!. Aborting execution.";
        &log_error($msg, "LSLB");
        die $msg;
    }

    return;
}

=pod

=head1 setHTTPFarmBackendsSessionsRemove

Remove all the active sessions enabled to a backend in a given service
Used by farmguardian

Parameters:

    farm_name - Farm name
    service   - Service name
    backendid - Backend id

Returns:

    Integer - Error code: It returns 0 on success or another value if it fails deleting some sessions

=cut

sub setHTTPFarmBackendsSessionsRemove ($farm_name, $service, $backendid) {
    my $serviceid;
    my $err = 0;

    &log_info("Deleting established sessions to a backend $backendid from farm $farm_name in service $service",
        "LSLB");

    $serviceid = &getFarmVSI($farm_name, $service);

    my $poundctl = &getGlobalConfiguration('poundctl');
    my $cmd      = "$poundctl -c /tmp/$farm_name\_proxy.socket -f 0 $serviceid $backendid";
    $err = &logAndRun($cmd);

    return $err;
}

sub getHTTPFarmBackendAvailableID ($farmname, $service) {
    require Relianoid::Farm::HTTP::Service;

    # get an ID for the new backend
    my $backendsvs = &getHTTPFarmVS($farmname, $service, "backends");
    my @be         = split("\n", $backendsvs);
    my $id         = 0;

    for my $subl (@be) {
        my @subbe = split(' ', $subl);
        $id = $subbe[1] + 1;
    }

    if (defined $id && $id eq '') {
        $id = 0;
    }

    return $id;
}

=pod

=head1 getHTTPFarmBackendsStatusInfo

This function take data from proxy and it gives hash format

Parameters:

    farm_name - Farm name

Returns:

    hash ref - hash with backends farm status

    services => [
        "id" => $service_id,            # index in the service array
        "name" => $service_name,
        "backends" => [
            {
                "id" = $backend_id      # index in the backend array
                "ip" = $backend_ip
                "port" = $backend_port
                "status" = $backend_status
                "service" = $service_name
            }
        ]
    ]

=cut

sub getHTTPFarmBackendsStatusInfo ($farm_name) {
    require Relianoid::Farm::Base;
    require Relianoid::Farm::HTTP::Backend;
    require Relianoid::Validate;
    my $status = {};

    my $serviceName;
    my $service_re = &getValidFormat('service');

    # Get l7 proxy info
    #i.e. of poundctl:

    #Requests in queue: 0
    #0. http Listener 185.76.64.223:80 a
    #0. Service "HTTP" active (4)
    #0. Backend 172.16.110.13:80 active (1 0.780 sec) alive (61)
    #1. Backend 172.16.110.14:80 active (1 0.878 sec) alive (90)
    #2. Backend 172.16.110.11:80 active (1 0.852 sec) alive (99)
    #3. Backend 172.16.110.12:80 active (1 0.826 sec) alive (75)
    my @poundctl = &getHTTPFarmBackendStatusCtl($farm_name);

    # Parse l7 proxy info
    for my $line (@poundctl) {
        # i.e.
        #     0. Service "HTTP" active (10)
        if ($line =~ /(\d+)\. Service "($service_re)"/) {
            $serviceName = $2;
        }

        # Parse backend connections
        # i.e.
        #      0. Backend 192.168.100.254:80 active (5 0.000 sec) alive (0)
        if ($line =~ /(\d+)\. Backend (\d+\.\d+\.\d+\.\d+|[a-fA-F0-9:]+):(\d+) (\w+) .+ (\w+)(?: \((\d+)\))?/) {
            my $backendHash = {
                id     => $1 + 0,
                ip     => $2,
                port   => $3 + 0,
                status => $5,
            };

            # Getting real status
            my $backend_disabled = $4;
            if ($backend_disabled eq "DISABLED") {
                require Relianoid::Farm::HTTP::Backend;

                #Checkstatusfile
                $backendHash->{status} = &getHTTPBackendStatusFromFile($farm_name, $backendHash->{id}, $serviceName);

                # not show fgDOWN status
                $backendHash->{status} = "down" if ($backendHash->{status} ne "maintenance");
            }
            elsif ($backendHash->{status} eq "alive") {
                $backendHash->{status} = "up";
            }
            elsif ($backendHash->{status} eq "DEAD") {
                $backendHash->{status} = "down";
            }

            push(@{ $status->{$serviceName}{backends} }, $backendHash);
        }
    }

    return $status;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/HTTP/Config.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

require Relianoid::Config;
require Relianoid::Lock;

my $configdir = &getGlobalConfiguration('configdir');

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::HTTP::Config

=cut

=pod

=head1 setHTTPFarmClientTimeout

Configure the client time parameter for a HTTP farm.

Parameters:

    client   - It is the time in seconds for the client time parameter
    farmname - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmClientTimeout ($client, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";

    my $i_f         = -1;
    my $array_count = @filefarmhttp;
    my $found       = "false";

    while ($i_f <= $array_count && $found eq "false") {
        $i_f++;

        if ($filefarmhttp[$i_f] =~ /^Client/) {
            &log_info("setting 'ClientTimeout $client' for $farm_name farm http", "LSLB");
            $filefarmhttp[$i_f] = "Client\t\t $client";
            $output             = 0;
            $found              = "true";
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return $output;
}

=pod

=head1 getHTTPFarmClientTimeout

Return the client time parameter for a HTTP farm.

Parameters:

    farmname - Farm name

Returns:

    Integer - Return the seconds for client request timeout or -1 on failure.

=cut

sub getHTTPFarmClientTimeout ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;
    close $fh;

    for my $line (@file) {
        if ($line =~ /^Client\s+.*\d+/) {
            my @line_aux = split("\ ", $line);
            $output = $line_aux[1];
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmSessionType

Configure type of persistence

Parameters:

    session  - type of session: nothing, HEADER, URL, COOKIE, PARAM, BASIC or IP
    farmname - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmSessionType ($session, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    &log_info("Setting 'Session type $session' for $farm_name farm http", "LSLB");
    tie my @contents, 'Tie::File', "$configdir\/$farm_filename";

    my $i     = -1;
    my $found = "false";

    for my $line (@contents) {
        $i++;

        if ($session ne "nothing") {
            if ($line =~ "Session") {
                $contents[$i] = "\t\tSession";
                $found = "true";
            }

            if ($found eq "true" && $line =~ "End") {
                $contents[$i] = "\t\tEnd";
                $found = "false";
            }

            if ($line =~ "Type") {
                $contents[$i] = "\t\t\tType $session";
                $output = 0;
                $contents[ $i + 1 ] =~ s/#//g;

                if (   $session eq "URL"
                    || $session eq "COOKIE"
                    || $session eq "HEADER")
                {
                    $contents[ $i + 2 ] =~ s/#//g;
                }
                else {
                    if ($contents[ $i + 2 ] !~ /#/) {
                        $contents[ $i + 2 ] =~ s/^/#/;
                    }
                }
            }
        }

        if ($session eq "nothing") {
            if ($line =~ "Session") {
                $contents[$i] = "\t\t#Session $session";
                $found = "true";
            }

            if ($found eq "true" && $line =~ "End") {
                $contents[$i] = "\t\t#End";
                $found = "false";
            }

            if ($line =~ "TTL") {
                $contents[$i] = "#$contents[$i]";
            }

            if ($line =~ "Type") {
                $contents[$i] = "#$contents[$i]";
                $output = 0;
            }

            if ($line =~ "ID") {
                $contents[$i] = "#$contents[$i]";
            }
        }
    }

    untie @contents;
    close $lock_fh;

    return $output;
}

=pod

=head1 setHTTPFarmBlacklistTime

Configure check time for resurected back-end. It is a HTTP farm paramter.

Parameters:

    checktime - time for resurrected checks
    farmname  - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmBlacklistTime ($blacklist_time, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";

    my $i_f         = -1;
    my $array_count = @filefarmhttp;
    my $found       = "false";

    while ($i_f <= $array_count && $found eq "false") {
        $i_f++;

        if ($filefarmhttp[$i_f] =~ /^Alive/) {
            &log_info("Setting 'Blacklist time $blacklist_time' for $farm_name farm http", "LSLB");

            $filefarmhttp[$i_f] = "Alive\t\t $blacklist_time";
            $output             = 0;
            $found              = "true";
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return $output;
}

=pod

=head1 getHTTPFarmBlacklistTime

Return time for resurrected checks for a HTTP farm.

Parameters:

    farmname - Farm name

Returns:

    integer - seconds for check or -1 on failure.

=cut

sub getHTTPFarmBlacklistTime ($farm_name) {
    my $blacklist_time = -1;
    my $conf_file      = &getFarmFile($farm_name);
    my $conf_path      = "$configdir/$conf_file";

    open(my $fh, '<', $conf_path) or die "Could not open $conf_path: $!";
    while (my $line = <$fh>) {
        next unless $line =~ /^Alive/i;

        my @line_aux = split("\ ", $line);
        $blacklist_time = $line_aux[1];
        last;
    }
    close $fh;

    return $blacklist_time;
}

=pod

=head1 setHTTPFarmHttpVerb

Configure the accepted HTTP verb for a HTTP farm.

The accepted verb sets are:

    0. standardHTTP, for the verbs GET, POST, HEAD.
    1. extendedHTTP, add the verbs PUT, DELETE.
    2. standardWebDAV, add the verbs LOCK, UNLOCK, PROPFIND, PROPPATCH, SEARCH, MKCOL, MOVE, COPY, OPTIONS, TRACE, MKACTIVITY, CHECKOUT, MERGE, REPORT.
    3. MSextWebDAV, add the verbs SUBSCRIBE, UNSUBSCRIBE, NOTIFY, BPROPFIND, BPROPPATCH, POLL, BMOVE, BCOPY, BDELETE, CONNECT.
    4. MSRPCext, add the verbs RPC_IN_DATA, RPC_OUT_DATA.
    5. OptionsHTTP, add the verb OPTIONS to the set extendedHTTP.

Parameters:

    verb     - accepted verbs: 0, 1, 2, 3 or 4
    farmname - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmHttpVerb ($verb, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";

    my $i_f         = -1;
    my $array_count = @filefarmhttp;
    my $found       = "false";

    while ($i_f <= $array_count && $found eq "false") {
        $i_f++;

        if ($filefarmhttp[$i_f] =~ /xHTTP/) {
            &log_info("Setting 'Http verb $verb' for $farm_name farm http", "LSLB");

            $filefarmhttp[$i_f] = "\txHTTP $verb";
            $output             = 0;
            $found              = "true";
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return $output;
}

=pod

=head1 getHTTPFarmHttpVerb

Return the available verb set for a HTTP farm.

The possible verb sets are:

    0. standardHTTP, for the verbs GET, POST, HEAD.
    1. extendedHTTP, add the verbs PUT, DELETE.
    2. standardWebDAV, add the verbs LOCK, UNLOCK, PROPFIND, PROPPATCH, SEARCH, MKCOL, MOVE, COPY, OPTIONS, TRACE, MKACTIVITY, CHECKOUT, MERGE, REPORT.
    3. MSextWebDAV, add the verbs SUBSCRIBE, UNSUBSCRIBE, NOTIFY, BPROPFIND, BPROPPATCH, POLL, BMOVE, BCOPY, BDELETE, CONNECT.
    4. MSRPCext, add the verbs RPC_IN_DATA, RPC_OUT_DATA.
    5. OptionsHTTP, add the verb OPTIONS to the set extendedHTTP.

Parameters:

    farmname - Farm name

Returns:

    integer - return the verb set identier or -1 on failure.

=cut

sub getHTTPFarmHttpVerb ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;
    close $fh;

    for my $line (@file) {
        if ($line =~ /xHTTP/) {
            my @line_aux = split("\ ", $line);
            $output = $line_aux[1];
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmListen

Change a HTTP farm between HTTP and HTTPS listener

Parameters:

    farmname - Farm name
    listener - type of listener: http or https

Returns:

    none

FIXME

    not return nothing, use $found variable to return success or error

=cut

sub setHTTPFarmListen ($farm_name, $listener) {
    my $farm_filename = &getFarmFile($farm_name);
    my $i_f           = -1;

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";
    my $array_count = @filefarmhttp;

    while ($i_f <= $array_count) {
        $i_f++;
        if ($filefarmhttp[$i_f] =~ /^ListenHTTP/ && $listener eq "http") {
            $filefarmhttp[$i_f] = "ListenHTTP";
        }
        if ($filefarmhttp[$i_f] =~ /^ListenHTTP/ && $listener eq "https") {
            $filefarmhttp[$i_f] = "ListenHTTPS";
        }

        if ($filefarmhttp[$i_f] =~ /.*Cert\ \"/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/Cert\ \"/#Cert\ \"/;
        }
        if ($filefarmhttp[$i_f] =~ /.*Cert\ \"/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }

        if ($filefarmhttp[$i_f] =~ /.*Ciphers\ \"/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/Ciphers\ \"/#Ciphers\ \"/;
        }
        if ($filefarmhttp[$i_f] =~ /.*Ciphers\ \"/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }

        # Enable 'Disable TLSv1, TLSv1_1 or TLSv1_2'
        if ($filefarmhttp[$i_f] =~ /.*Disable TLSv1/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/Disable TLSv1/#Disable TLSv1/;
        }
        if ($filefarmhttp[$i_f] =~ /.*Disable TLSv1/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }
        elsif ($filefarmhttp[$i_f] =~ /.*DisableTLSv1\d$/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }

        # Enable 'Disable SSLv3 or SSLv2'
        if ($filefarmhttp[$i_f] =~ /.*Disable SSLv\d$/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/Disable SSLv/#Disable SSLv/;
        }
        if ($filefarmhttp[$i_f] =~ /.*Disable SSLv\d$/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }
        elsif ($filefarmhttp[$i_f] =~ /.*DisableSSLv\d$/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }

        # Enable SSLHonorCipherOrder
        if ($filefarmhttp[$i_f] =~ /.*SSLHonorCipherOrder/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/SSLHonorCipherOrder/#SSLHonorCipherOrder/;
        }
        if ($filefarmhttp[$i_f] =~ /.*SSLHonorCipherOrder/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }

        # Enable StrictTransportSecurity
        if ($filefarmhttp[$i_f] =~ /.*StrictTransportSecurity/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/StrictTransportSecurity/#StrictTransportSecurity/;
        }
        if ($filefarmhttp[$i_f] =~ /.*StrictTransportSecurity/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }

        # Check for ECDHCurve cyphers
        if ($filefarmhttp[$i_f] =~ /ECDHCurve/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/ECDHCurve/\#ECDHCurve/;
        }
        if ($filefarmhttp[$i_f] =~ /ECDHCurve/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#ECDHCurve/ECDHCurve/;
        }

        # Generate DH Keys if needed
        #my $dhfile = "$configdir\/$farm_name\_dh2048.pem";
        if ($filefarmhttp[$i_f] =~ /^\#*DHParams/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/.*DHParams/\#DHParams/;
        }
        if ($filefarmhttp[$i_f] =~ /^\#*DHParams/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/.*DHParams/DHParams/;
            #$filefarmhttp[$i_f] =~ s/.*DHParams.*/DHParams\t"$dhfile"/;
        }

        if ($filefarmhttp[$i_f] =~ /ZWACL-END/) {
            last;
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return;
}

=pod

=head1 setHTTPFarmRewriteL

Asign a RewriteLocation vaue to a farm HTTP or HTTPS

Parameters:

    farmname - Farm name

    rewritelocation - The options are: disabled, enabled or enabled-backends

Returns: Integer. Error code.

    0 - success
    1 - failure

=cut

sub setHTTPFarmRewriteL ($farm_name, $rewritelocation, $path = undef) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = 1;

    &log_info("setting 'Rewrite Location' for $farm_name to $rewritelocation", "LSLB");

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";
    my $i_f         = -1;
    my $array_count = @filefarmhttp;

    while ($i_f <= $array_count) {
        $i_f++;
        if ($filefarmhttp[$i_f] =~ /RewriteLocation\ .*/) {
            my $directive = "\tRewriteLocation $rewritelocation";
            $directive .= " path" if ($path);
            $filefarmhttp[$i_f] = $directive;
            $output = 0;
            last;
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return $output;
}

=pod

=head1 getHTTPFarmRewriteL

Return RewriteLocation Header configuration HTTP and HTTPS farms

Parameters:

    farmname - Farm name

Returns:

    string - The possible values are: 

    - disabled (default)
    - enabled
    - enabled-backends
    - enabled-path
    - enabled-backends-path

=cut

sub getHTTPFarmRewriteL ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = "disabled";

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;
    close $fh;

    for my $line (@file) {
        if ($line =~ /RewriteLocation\s+(\d)\s*(path)?/) {
            if    ($1 eq 0) { $output = "disabled"; last; }
            elsif ($1 eq 1) { $output = "enabled"; }
            elsif ($1 eq 2) { $output = "enabled-backends"; }

            if (defined $2 and $2 eq 'path') { $output .= "-path"; }
            last;
        }
    }
    return $output;
}

=pod

=head1 setHTTPFarmConnTO

Configure connection time out value to a farm HTTP or HTTPS

Parameters:

    connectionTO - Conection time out in seconds

    farmname - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmConnTO ($tout, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    &log_info("Setting 'ConnTo timeout $tout' for $farm_name farm http", "LSLB");

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";

    my $i_f         = -1;
    my $array_count = @filefarmhttp;
    my $found       = "false";

    while ($i_f <= $array_count && $found eq "false") {
        $i_f++;

        if ($filefarmhttp[$i_f] =~ /^ConnTO.*/) {
            $filefarmhttp[$i_f] = "ConnTO\t\t $tout";
            $output             = 0;
            $found              = "true";
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return $output;
}

=pod

=head1 getHTTPFarmConnTO

Return farm connecton time out value for http and https farms

Parameters:

    farmname - Farm name

Returns:

    integer - return the connection time out or -1 on failure

=cut

sub getHTTPFarmConnTO ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;
    close $fh;

    for my $line (@file) {
        if ($line =~ /^ConnTO/) {
            my @line_aux = split("\ ", $line);
            $output = $line_aux[1];
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmTimeout

Asign a timeout value to a farm

Parameters:

    timeout - Time out in seconds

    farmname - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmTimeout ($timeout, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";

    my $i_f         = -1;
    my $array_count = @filefarmhttp;
    my $found       = "false";

    while ($i_f <= $array_count && $found eq "false") {
        $i_f++;

        if ($filefarmhttp[$i_f] =~ /^Timeout/) {
            $filefarmhttp[$i_f] = "Timeout\t\t $timeout";
            $output             = 0;
            $found              = "true";
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return $output;
}

=pod

=head1 getHTTPFarmTimeout

Return the farm time out

Parameters:

    farmname - Farm name

Returns:

    Integer - Return time out, or -1 on failure.

=cut

sub getHTTPFarmTimeout ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;

    for my $line (@file) {
        if ($line =~ /^Timeout/) {
            my @line_aux = split("\ ", $line);
            $output = $line_aux[1];
        }
    }
    close $fh;

    return $output;
}

=pod

=head1 setHTTPFarmMaxClientTime

Set the maximum time for a client

Parameters:

    track     - Maximum client time
    farm_name - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmMaxClientTime ($track, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;
    my $i_f           = -1;
    my $found         = "false";

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";
    my $array_count = @filefarmhttp;

    while ($i_f <= $array_count && $found eq "false") {
        $i_f++;
        if ($filefarmhttp[$i_f] =~ /TTL/) {
            $filefarmhttp[$i_f] = "\t\t\tTTL $track";
            $output             = 0;
            $found              = "true";
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return $output;
}

=pod

=head1 getHTTPFarmGlobalStatus

Get the status of a farm, sessions and its backends through l7 proxy command.

Parameters:

    farmname - Farm name

Returns:

    array - Return poundctl output

=cut

sub getHTTPFarmGlobalStatus ($farm_name) {
    my $poundctl = &getGlobalConfiguration('poundctl');

    return @{ &logAndGet("$poundctl -c \"/tmp/$farm_name\_proxy.socket\"", "array") };
}

=pod

=head1 setHTTPFarmErr

Configure a error message for http error: WAF, 414, 500, 501 or 503

Parameters:

    farm_name - Farm name
    message   - Message body for the error
    error     - Number of error to set, the options are WAF, 414, 500, 501 or 503

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmErr ($farm_name, $content, $error) {
    my $output = -1;

    if (not $error) {
        log_error("Setting undefined HTTP Err");
        return $output;
    }

    &log_info("Setting 'Err$error' for $farm_name farm http", "LSLB");

    my $file_path = "${configdir}/${farm_name}_Err${error}.html";

    if (-e $file_path) {
        $output = 0;
        # FIXME
        # $content =~ s/\r\n/\n/;
        # my $fd  = &openlock($file_path, 'w');
        # print $fd "$line\n";
        # close $fd;
        my @err = split("\n", $content);
        my $fd  = &openlock($file_path, 'w');

        for my $line (@err) {
            $line =~ s/\r$//;
            print $fd "$line\n";
        }

        close $fd;
    }

    return $output;
}

=pod

=head1 getHTTPFarmErr

Return the error message for a http error: WAF, 414, 500, 501 or 503

Parameters:

    farmname - Farm name

    error_number - Number of error to set, the options are WAF, 414, 500, 501 or 503

Returns:

    string - Message body for the error

=cut

# Only http function
sub getHTTPFarmErr ($farm_name, $nerr) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output;

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;
    close $fh;

    for my $line (@file) {
        if ($line =~ /Err$nerr/) {
            my @line_aux = split("\ ", $line);
            my $err      = $line_aux[1];
            $err =~ s/"//g;

            if (-e $err) {
                open my $fh, '<', $err;
                while (<$fh>) {
                    $output .= $_;
                }
                close $fh;
                chomp($output);
            }
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmConfErrFile

Comment or uncomment an error config file line from the proxy config file.

Parameters:

    enabled

        - true to uncomment the line ( or to add if it doesn't exist)
        - false to comment the line.

    farmname - Farm name

    err - error file: WAF, 414, 500 ...

Returns:

    None

=cut

sub setHTTPFarmConfErrFile ($enabled, $farm_name, $err) {
    require Relianoid::Farm::Core;
    require Tie::File;

    my $farm_filename = &getFarmFile($farm_name);
    my $i             = -1;
    my $found         = 0;

    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";

    for my $line (@filefarmhttp) {
        $i++;
        if ($enabled eq "true") {
            if ($line =~ /^.*Err$err/) {
                $line =~ s/#//;
                splice @filefarmhttp, $i, 1, $line;
                $found = 1;
                last;
            }
        }
        else {
            if ($line =~ /^\s*Err$err/) {
                splice @filefarmhttp, $i, 1;
                last;
            }
        }
    }
    if (!$found && $enabled eq "true") {
        $i = -1;
        for my $line (@filefarmhttp) {
            $i++;
            if ($line =~ /^ListenHTTP/) {
                my $directive = "\tErr$err \"$configdir" . "/" . $farm_name . "_Err$err.html\"";
                splice @filefarmhttp, $i + 1, 0, $directive;
                last;
            }
        }
    }
    untie @filefarmhttp;

    return;
}

=pod

=head1 getHTTPFarmBootStatus

Return the farm status at boot relianoid

Parameters:

    farmname - Farm name

Returns:

    scalar - return "down" if the farm not run at boot or "up" if the farm run at boot

=cut

sub getHTTPFarmBootStatus ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = "down";
    my $lastline;

    open my $fh, '<', "${configdir}/${farm_filename}";

    while (my $line = <$fh>) {
        $lastline = $line;
    }
    close $fh;

    if ($lastline !~ /^#down/) {
        $output = "up";
    }

    return $output;
}

=pod

=head1 setHTTPFarmBootStatus

Set the farm status in the configuration file to boot relianoid process

Parameters:

    farm_name - Farm name
    value - Write the boot status "up" or "down"

Returns:

    scalar - return "down" if the farm not run at boot or "up" if the farm run at boot

=cut

sub setHTTPFarmBootStatus ($farm_name, $value) {
    my $farm_filename = &getFarmFile($farm_name);

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @configfile, 'Tie::File', "$configdir\/$farm_filename";
    @configfile = grep { !/^\#down/ } @configfile;

    push @configfile, '#down' if ($value eq "down");

    untie @configfile;
    close $lock_fh;

    return;
}

=pod

=head1 getHTTPFarmStatus

Return current farm process status

Parameters:

    farm_name - Farm name

Returns: string - Whether the process is running, with "up" or "down".

=cut

sub getHTTPFarmStatus ($farm_name) {
    my @pid         = &getHTTPFarmPid($farm_name);
    my $running_pid = @pid ? kill(0, @pid) : undef;

    return (@pid && $running_pid) ? "up" : "down";
}

=pod

=head1 getHTTPFarmSocket

Returns socket for HTTP farm.

This funcion is only used in farmguardian functions.

Parameters:

    farmname - Farm name

Returns:

    String - return socket file

=cut

sub getHTTPFarmSocket ($farm_name) {
    return "/tmp/" . $farm_name . "_proxy.socket";
}

=pod

=head1 getHTTPFarmPid

Returns farm PID

Parameters:

    farmname - Farm name

Returns:

    Integer - return a list with the PIDs of the farm

=cut

sub getHTTPFarmPid ($farm_name) {
    my $piddir  = &getGlobalConfiguration('piddir');
    my $pidfile = "$piddir\/$farm_name\_proxy.pid";

    my @pid = ();
    if (-e $pidfile) {
        open my $fh, '<', $pidfile;
        @pid = <$fh>;
        close $fh;
    }

    return @pid;
}

=pod

=head1 getHTTPFarmPidPound

This function returns all the pids of a process looking for in the ps table.

Parameters:

    farmname - Farm name

Returns:

    array - list of pids

=cut

sub getHTTPFarmPidPound ($farm_name) {
    my $ps        = &getGlobalConfiguration('ps');
    my $grep      = &getGlobalConfiguration('grep_bin');
    my @pid       = ();
    my $farm_file = "$configdir/" . &getFarmFile($farm_name);
    my $cmd       = "$ps aux | $grep '\\-f $farm_file' | $grep -v grep";

    my $out = &logAndGet($cmd, 'array');
    for my $l (@{$out}) {
        if ($l =~ /^\s*[^\s]+\s+([^\s]+)\s/) {
            push @pid, $1;
        }
    }

    return @pid;
}

=pod

=head1 getHTTPFarmPidFile

Returns farm PID File

Parameters:

    farmname - Farm name

Returns:

    String - Pid file path

=cut

sub getHTTPFarmPidFile ($farm_name) {
    my $piddir  = &getGlobalConfiguration('piddir');
    my $pidfile = "$piddir\/$farm_name\_proxy.pid";

    return $pidfile;
}

=pod

=head1 getHTTPFarmVip

Returns farm vip or farm port

Parameters:

    tag - requested parameter. The options are 
          - vip, for virtual ip
          - vipp, for virtual port

    farmname - Farm name

Returns:

    Scalar - return vip or port of farm or -1 on failure

=cut

sub getHTTPFarmVip ($info, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;
    my $i             = 0;
    my $lw            = 0;

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;
    close $fh;

    for my $line (@file) {
        if ($line =~ /^ListenHTTP/) {
            $lw = 1;
        }
        if ($lw) {
            if ($info eq "vip" && $line =~ /^\s+Address\s+(.*)/) {
                $output = $1;
            }

            if ($info eq "vipp" && $line =~ /^\s+Port\s+(.*)/) { $output = $1 }

            last if ($output ne '-1');
        }
        $i++;
    }

    return $output;
}

=pod

=head1 setHTTPFarmVirtualConf

Set farm virtual IP and virtual PORT

Parameters:

    vip - virtual ip
    vip_port - virtual port. If the port is not sent, the port will not be changed
    farm_name - Farm name

Returns:

    Integer - return 0 on success or different on failure

=cut

sub setHTTPFarmVirtualConf ($vip, $vip_port, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $stat          = 1;
    my $enter         = 2;
    $enter-- if !$vip_port;

    my $prev_config = getFarmStruct($farm_name);

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @array, 'Tie::File', "$configdir\/$farm_filename";
    my $size = @array;

    for (my $i = 0 ; $i < $size && $enter > 0 ; $i++) {
        if ($array[$i] =~ /Address/) {
            if ($array[$i] =~ s/.*Address\ .*/\tAddress\ $vip/) {
                $stat = 0;
            }
            $enter--;
        }
        if ($array[$i] =~ /Port/ and $vip_port) {
            if ($array[$i] =~ s/.*Port\ .*/\tPort\ $vip_port/) {
                $stat = 0;
            }
            $enter--;
        }
        last if (!$enter);
    }

    untie @array;
    close $lock_fh;

    return $stat;
}

=pod

=head1 getHTTPFarmConfigIsOK

Function that check if the config file is OK.

Parameters:

    farmname - Farm name

Returns:

    scalar - return 0 on success or different on failure

=cut

sub getHTTPFarmConfigIsOK ($farm_name) {
    my $pound         = &getGlobalConfiguration('pound');
    my $farm_filename = &getFarmFile($farm_name);
    my $farm_filepath = "${configdir}/${farm_filename}";
    my $proxy_command = "${pound} -f ${farm_filepath} -c";

    # do not use the function 'logAndGet' here is managing the error output and error code
    my $run = `$proxy_command 2>&1`;
    my $rc  = $?;

    if ($rc or &debug()) {
        if ($rc) {
            &log_error("failed: $proxy_command", "LSLB");
        }
        else {
            &log_debug("running: $proxy_command", "LSLB");
        }

        if ($run =~ / line (\d+)/) {
            my $line_number = $1;
            my $line        = `sed -n '$line_number p' ${farm_filepath}`;

            log_error("${farm_filepath} line $line_number: $line");
        }
    }

    return $rc;
}

=pod

=head1 getHTTPFarmConfigErrorMessage

This function return a message to know what parameter is not correct in a HTTP farm

Parameters:

    farm_name - Farm name

Returns:

    Scalar - If there is an error, it returns a message, else it returns a blank string

=cut

sub getHTTPFarmConfigErrorMessage ($farm_name) {
    my $pound         = &getGlobalConfiguration('pound');
    my $farm_filename = &getFarmFile($farm_name);
    my $farm_filepath = "${configdir}/${farm_filename}";
    my $proxy_command = "${pound} -f ${farm_filepath} -c";

    # do not use the function 'logAndGet' here is managing the error output and error code
    my @run = `$proxy_command 2>&1`;

    return "" if $? == 0;

    chomp @run;
    shift @run if ($run[0] =~ /starting\.\.\./);

    &log_error("Error checking ${farm_filepath}.", "LSLB");
    &log_error($run[0],                            "LSLB");

    $run[0] = $run[1] if ($run[0] =~ /waf/i);
    $run[0] =~ / line (\d+): /;
    my $error_line_number = $1;

    my $current_line_number = 1;
    my $line                = "";
    my $service             = "";

    if ($error_line_number && open my $fh, '<', $farm_filepath) {
        my @lines = <$fh>;
        close $fh;

        for my $current_line (@lines) {
            if ($line =~ /^\s+Service \"(.+)\"/) {
                $service = $1;
            }

            if ($current_line_number == $error_line_number) {
                $line = $current_line;
                last;
            }

            $current_line_number++;
        }
    }

    # examples of error msg
    #	AAAhttps, /usr/local/relianoid/config/AAAhttps_proxy.cfg line 36: unknown directive
    #	AAAhttps, /usr/local/relianoid/config/AAAhttps_proxy.cfg line 40: SSL_CTX_use_PrivateKey_file failed - aborted
    $line =~ /\s*([\w-]+)/;
    my $param = $1;
    my $msg   = "Error in the configuration file";

    # parse line
    if ($param eq "Cert") {
        # return pem name if the pem file is not correct
        $line =~ /([^\/]+)\"$/;
        $msg = "Error loading the certificate: $1" if $1;
    }
    elsif ($param eq "WafRules") {
        # return waf rule name  if the waf rule file is not correct
        $line =~ /([^\/]+)\"$/;
        $msg = "Error loading the WafRuleSet: $1" if $1;
    }
    elsif ($param) {
        $service = "in the service ${service}" if $service;
        $msg     = "Error in the parameter ${param} ${service}";
    }
    elsif (&debug()) {
        $msg = $run[0];
        log_error("${farm_filepath} line $error_line_number: $line");
    }

    &log_debug("Error checking config file: $msg");

    return $msg;
}

=pod

=head1 getHTTPFarmStruct

=cut

sub getHTTPFarmStruct ($farmname, $type = undef) {
    $type //= &getFarmType($farmname);

    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    # Output hash reference or undef if the farm does not exist.
    my $farm;

    return $farm unless $farmname;

    my $vip    = &getFarmVip("vip",  $farmname);
    my $vport  = &getFarmVip("vipp", $farmname) + 0;
    my $status = &getFarmVipStatus($farmname);

    my $connto              = 0 + &getHTTPFarmConnTO($farmname);
    my $alive               = 0 + &getHTTPFarmBlacklistTime($farmname);
    my $timeout             = 0 + &getHTTPFarmTimeout($farmname);
    my $client              = 0 + &getHTTPFarmClientTimeout($farmname);
    my $httpverb            = 0 + &getHTTPFarmHttpVerb($farmname);
    my $rewritelocation     = &getHTTPFarmRewriteL($farmname);
    my $logs                = &getHTTPFarmLogs($farmname);
    my $ignore_100_continue = &getHTTPFarm100Continue($farmname);

    # my $errWAF = &getHTTPFarmErr($farmname, "WAF");
    my $err414 = &getHTTPFarmErr($farmname, "414");
    my $err500 = &getHTTPFarmErr($farmname, "500");
    my $err501 = &getHTTPFarmErr($farmname, "501");
    my $err503 = &getHTTPFarmErr($farmname, "503");

    my @http_verbs = (
        "standardHTTP",      #0
        "extendedHTTP",      #1
        "standardWebDAV",    #2
        "MSextWebDAV",       #3
        "MSRPCext",          #4
        "optionsHTTP",       #5
    );

    $farm = {
        contimeout          => $connto,
        error414            => $err414,
        error500            => $err500,
        error501            => $err501,
        error503            => $err503,
        httpverb            => $http_verbs[$httpverb],
        ignore_100_continue => $ignore_100_continue,
        listener            => $type,
        logs                => $logs,
        name                => $farmname,
        reqtimeout          => $client,
        restimeout          => $timeout,
        resurrectime        => $alive,
        rewritelocation     => $rewritelocation,
        status              => $status,
        vip                 => $vip,
        vport               => $vport,
    };

    # HTTPS parameters
    if ($type eq "https") {
        require Relianoid::Farm::HTTP::HTTPS;

        ## Get farm certificate(s)
        my @cnames = ();

        if ($eload) {
            @cnames = &eload(
                module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext',
                func   => 'getFarmCertificatesSNI',
                args   => [$farmname],
            );
        }
        else {
            @cnames = (&getFarmCertificate($farmname));
        }

        # Make struct array
        my @cert_list;

        for (my $i = 0 ; $i < scalar @cnames ; $i++) {
            push @cert_list, { file => $cnames[$i], id => $i + 1 };
        }

        ## Get cipher set
        my $ciphers = &getFarmCipherSet($farmname);

        # adapt "ciphers" to required interface values
        if ($ciphers eq "cipherglobal") {
            $ciphers = "all";
        }
        elsif ($ciphers eq "cipherssloffloading") {
            $ciphers = "ssloffloading";
        }
        elsif ($ciphers eq "cipherpci") {
            $ciphers = "highsecurity";
        }
        else {
            $ciphers = "customsecurity";
        }

        ## All HTTPS parameters
        $farm->{certlist}        = \@cert_list;
        $farm->{ciphers}         = $ciphers;
        $farm->{cipherc}         = &getFarmCipherList($farmname);
        $farm->{disable_sslv2}   = (&getHTTPFarmDisableSSL($farmname, "SSLv2"))   ? "true" : "false";
        $farm->{disable_sslv3}   = (&getHTTPFarmDisableSSL($farmname, "SSLv3"))   ? "true" : "false";
        $farm->{disable_tlsv1}   = (&getHTTPFarmDisableSSL($farmname, "TLSv1"))   ? "true" : "false";
        $farm->{disable_tlsv1_1} = (&getHTTPFarmDisableSSL($farmname, "TLSv1_1")) ? "true" : "false";
        $farm->{disable_tlsv1_2} = (&getHTTPFarmDisableSSL($farmname, "TLSv1_2")) ? "true" : "false";
    }

    require Relianoid::Farm::Config;
    $farm = &getHTTPFarmHeadersStruct($farmname, $farm);

    return $farm;
}

=pod

=head1 getHTTPFarmVerbCode

=cut

sub getHTTPFarmVerbCode ($verbs_set) {
    # Default output value in case of missing verb set
    my $verb_code;

    my %http_verbs = (
        standardHTTP   => 0,
        extendedHTTP   => 1,
        standardWebDAV => 2,
        MSextWebDAV    => 3,
        MSRPCext       => 4,
        optionsHTTP    => 5,
    );

    if (exists $http_verbs{$verbs_set}) {
        $verb_code = $http_verbs{$verbs_set};
    }

    return $verb_code;
}

######### l7 proxy Config

# Writing

# add header

=pod

=head1 getHTTPAddReqHeader

Get a list with all the http headers are added by the farm

Parameters:

    farm_name - Farm name

Returns:

    Array ref - headers list

=cut

sub getHTTPAddReqHeader ($farm_name) {
    return &getHTTPFarmHeadersStruct($farm_name)->{addheader};
}

=pod

=head1 addHTTPAddheader

The HTTP farm will add the header to the http communication

Parameters:

    farm_name - Farm name
    header - Header to add

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub addHTTPAddheader ($farm_name, $header) {
    require Relianoid::Farm::Core;
    require Relianoid::Lock;

    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index        = 0;
    my $rewrite_flag = 0;    # it is used to add HeadRemove before than AddHeader

    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /[#\s]*RewriteLocation/) {
            $rewrite_flag = 1;
        }
        elsif ($rewrite_flag) {
            # put new headremove before than last one
            if (    $line !~ /^[#\s]*(?:AddHeader|HeadRemove|AddResponseHeader|RemoveResponseHead)\s+"/
                and $rewrite_flag)

            {
                # example: AddHeader "header: to add"
                splice @fileconf, $index, 0, "\tAddHeader \"$header\"";
                $errno = 0;
                last;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not add AddHeader") if $errno;

    return $errno;
}

=pod

=head1 modifyHTTPAddheader

Modify an AddHeader directive from the given farm

Parameters:

    farm_name   - Farm name
    header      - Header to add
    header_ind  - directive index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub modifyHTTPAddheader ($farm_name, $header, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*AddHeader\s+"/) {
            # put new headremove before than last one
            if ($header_ind == $ind) {
                splice @fileconf, $index, 1, "\tAddHeader \"$header\"";
                $errno = 0;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not modify AddHeader") if $errno;

    return $errno;
}

=pod

=head1 delHTTPAddheader

Delete a directive "AddHeader".

Parameters:

    farm_name  - Farm name
    header_ind - Header index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub delHTTPAddheader ($farm_name, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*AddHeader\s+"/) {
            if ($header_ind == $ind) {
                $errno = 0;
                splice @fileconf, $index, 1;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not remove HeadRemove") if $errno;

    return $errno;
}

# head remove

=pod

=head1 getHTTPRemReqHeader

Get a list with all the http headers are added by the farm

Parameters:

    farm_name - Farm name

Returns:

    Array ref - headers list

=cut

sub getHTTPRemReqHeader ($farm_name) {
    return &getHTTPFarmHeadersStruct($farm_name)->{headremove};
}

=pod

=head1 addHTTPHeadremove

Add a directive "HeadRemove". The HTTP farm will remove the header that match with the sentence

Parameters:

    farm_name - Farm name
    header   - Header to add

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub addHTTPHeadremove ($farm_name, $header) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index        = 0;
    my $rewrite_flag = 0;    # it is used to add HeadRemove before than AddHeader
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /[#\s]*RewriteLocation/) {
            $rewrite_flag = 1;
        }
        elsif ($rewrite_flag) {
            # put new headremove after than last one
            if (    $line !~ /^[#\s]*(?:AddHeader|HeadRemove|AddResponseHeader|RemoveResponseHead)\s+"/
                and $rewrite_flag)
            {
                # example: AddHeader "header: to add"
                splice @fileconf, $index, 0, "\tHeadRemove \"$header\"";
                $errno = 0;
                last;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not add HeadRemove") if $errno;

    return $errno;
}

=pod

=head1 modifyHTTPHeadremove

Modify an Headremove directive from the given farm

Parameters:

    farm_name    - Farm name
    header      - Header to add
    header_ind  - directive index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub modifyHTTPHeadremove ($farm_name, $header, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*HeadRemove\s+"/) {
            # put new headremove before than last one
            if ($header_ind == $ind) {
                splice @fileconf, $index, 1, "\tHeadRemove \"$header\"";
                $errno = 0;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not modify HeadRemove") if $errno;

    return $errno;
}

=pod

=head1 delHTTPHeadremove

Delete a directive "HeadRemove".

Parameters:

    farm_name - Farm name
    index    - Header index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub delHTTPHeadremove ($farm_name, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*HeadRemove\s+"/) {
            if ($header_ind == $ind) {
                $errno = 0;
                splice @fileconf, $index, 1;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not remove HeadRemove") if $errno;

    return $errno;
}

# add response header

=pod

=head1 getHTTPAddRespHeader

Get a list with all the http headers that load balancer will add to the backend repsonse

Parameters:

    farm_name - Farm name

Returns:

    Array ref - headers list

=cut

sub getHTTPAddRespHeader ($farm_name) {
    return &getHTTPFarmHeadersStruct($farm_name)->{addresponseheader};
}

=pod

=head1 addHTTPAddRespheader

The HTTP farm will add the header to the http response from the backend to the client

Parameters:

    farm_name - Farm name
    header   - Header to add

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub addHTTPAddRespheader ($farm_name, $header) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index        = 0;
    my $rewrite_flag = 0;    # it is used to add HeadRemove before than AddHeader
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /[#\s]*RewriteLocation/) {
            $rewrite_flag = 1;
        }
        elsif ($rewrite_flag) {
            # put new headremove before than last one
            if (    $line !~ /^[#\s]*(?:AddHeader|HeadRemove|AddResponseHeader|RemoveResponseHead)\s+"/
                and $rewrite_flag)
            {
                # example: AddHeader "header: to add"
                splice @fileconf, $index, 0, "\tAddResponseHeader \"$header\"";
                $errno = 0;
                last;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not add AddResponseHeader") if $errno;

    return $errno;
}

=pod

=head1 modifyHTTPAddRespheader

Modify an AddResponseHeader directive from the given farm

Parameters:

    farm_name   - Farm name
    header      - Header to add
    header_ind  - directive index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub modifyHTTPAddRespheader ($farm_name, $header, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*AddResponseHeader\s+"/) {
            # put new headremove before than last one
            if ($header_ind == $ind) {
                splice @fileconf, $index, 1, "\tAddResponseHeader \"$header\"";
                $errno = 0;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not modify AddResponseHeader") if $errno;

    return $errno;
}

=pod

=head1 delHTTPAddRespheader

Delete a directive "AddResponseHeader from the farm config file".

Parameters:

    farm_name  - Farm name
    header_ind - Header index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub delHTTPAddRespheader ($farm_name, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*AddResponseHeader\s+"/) {
            if ($header_ind == $ind) {
                $errno = 0;
                splice @fileconf, $index, 1;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not remove AddResponseHeader") if $errno;

    return $errno;
}

# remove response header

=pod

=head1 getHTTPRemRespHeader

Get a list with all the http headers that the load balancer will add to the response to the client

Parameters:

    farm_name - Farm name

Returns:

    Array ref - headers list

=cut

sub getHTTPRemRespHeader ($farm_name) {
    return &getHTTPFarmHeadersStruct($farm_name)->{removeresponseheader};
}

=pod

=head1 addHTTPRemRespHeader

Add a directive "HeadResponseRemove". The HTTP farm will remove a reponse
header from the backend that matches with this expression

Parameters:

    farm_name - Farm name
    header    - Header to add

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub addHTTPRemRespHeader ($farm_name, $header) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index        = 0;
    my $rewrite_flag = 0;    # it is used to add HeadRemove before than AddHeader
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /[#\s]*RewriteLocation/) {
            $rewrite_flag = 1;
        }
        elsif ($rewrite_flag) {
            # put new headremove after than last one
            if (    $line !~ /^[#\s]*(?:AddHeader|HeadRemove|AddResponseHeader|RemoveResponseHead)\s+"/
                and $rewrite_flag)
            {
                # example: AddHeader "header: to add"
                splice @fileconf, $index, 0, "\tRemoveResponseHead \"$header\"";
                $errno = 0;
                last;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not add RemoveResponseHead") if $errno;

    return $errno;
}

=pod

=head1 modifyHTTPRemRespHeader

Modify an RemoveResponseHead directive from the given farm

Parameters:

    farm_name     - Farm name
    header        - Header to add
    header_ind    - directive index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub modifyHTTPRemRespHeader ($farm_name, $header, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*RemoveResponseHead\s+"/) {
            # put new headremove before than last one
            if ($header_ind == $ind) {
                splice @fileconf, $index, 1, "\tRemoveResponseHead \"$header\"";
                $errno = 0;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not modify RemoveResponseHead") if $errno;

    return $errno;
}

=pod

=head1 delHTTPRemRespHeader

Delete a directive "HeadResponseRemove".

Parameters:

    farm_name  - Farm name
    header_ind - Header index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub delHTTPRemRespHeader ($farm_name, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*RemoveResponseHead\s+"/) {
            if ($header_ind == $ind) {
                $errno = 0;
                splice @fileconf, $index, 1;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not remove RemoveResponseHead") if $errno;

    return $errno;
}

=pod

=head1 getHTTPFarmHeadersStruct

It extends the farm struct with parameters exclusive to EE.
If no farm struct was passed to the function, the function will return
a new farm struct with the enterprise fields.

Parameters:

    farmname    - Farm name
    farm struct - Struct with the farm configuration parameters

Returns:

    Hash ref - Farm struct updated with EE parameters

=cut

sub getHTTPFarmHeadersStruct ($farmname, $farm_st = {}) {
    $farm_st->{addheader}            = [];
    $farm_st->{headremove}           = [];
    $farm_st->{addresponseheader}    = [];
    $farm_st->{removeresponseheader} = [];

    my $farm_filename = &getFarmFile($farmname);
    my @lines         = ();

    if (open my $fh, '<', "${configdir}/${farm_filename}") {
        @lines = <$fh>;
        close $fh;
    }

    my $add_req_header_index = 0;
    my $rem_req_header_index = 0;
    my $add_res_header_index = 0;
    my $rem_res_header_index = 0;

    for my $line (@lines) {
        if    ($line =~ /^[#\s]*Service \"/) { last; }
        elsif ($line =~ /^[#\s]*AddHeader\s+"(.+)"/) {
            push @{ $farm_st->{addheader} },
              {
                "id"     => $add_req_header_index++,
                "header" => $1
              };
        }
        elsif ($line =~ /^[#\s]*HeadRemove\s+"(.+)"/) {
            push @{ $farm_st->{headremove} },
              {
                "id"      => $rem_req_header_index++,
                "pattern" => $1
              };
        }
        elsif ($line =~ /^[#\s]*AddResponseHeader\s+"(.+)"/) {
            push @{ $farm_st->{addresponseheader} },
              {
                "id"     => $add_res_header_index++,
                "header" => $1
              };
        }
        elsif ($line =~ /^[#\s]*RemoveResponseHead\s+"(.+)"/) {
            push @{ $farm_st->{removeresponseheader} },
              {
                "id"      => $rem_res_header_index++,
                "pattern" => $1
              };
        }
        elsif ($line =~ /Ignore100Continue (\d).*/) {
            $farm_st->{ignore_100_continue} = ($1 eq '0') ? 'false' : 'true';
        }
        elsif ($line =~ /LogLevel\s+(\d).*/) {
            my $lvl = $1 + 0;
            $farm_st->{logs} = 'true' if ($lvl >= 5);
        }
    }

    return $farm_st;
}

=pod

=head1 moveHeader

Changes the position of a farm header directive.

NOTICE: This function is not currently being used.

Parameters:

    farmname - Farm name
    regex    - Regex to match the directive
    pos      - It is the required position for the rule.
    index    - It is index of the rule in the set

Returns:

    none

=cut

sub moveHeader ($farm_name, $regex, $pos, $index) {
    require Relianoid::Arrays;

    my $farm_filename = &getFarmFile($farm_name);

    require Tie::File;
    tie my @file, 'Tie::File', "$configdir/$farm_filename";

    my $file_index   = 0;
    my $header_index = 0;
    my @headers      = ();
    for my $l (@file) {
        if ($l =~ /^[#\s]*Service \"/) { last; }
        if ($l =~ /^$regex/) {
            $header_index = $file_index unless ($header_index != 0);
            push @headers, $l;
        }
        $file_index++;
    }

    &moveByIndex(\@headers, $index, $pos);

    my $size = scalar @headers;

    splice(@file, $header_index, $size, @headers);

    untie @file;

    return;
}

=pod

=head1 getHTTPFarmLogs

Return the log connection tracking status

Parameters:

    farm_name - Farm name

Returns:

    scalar - The possible values are: 0 on disabled, possitive value on enabled or -1 on failure

=cut

sub getHTTPFarmLogs ($farm_name) {
    my $output = 'false';

    my $farm_filename = &getFarmFile($farm_name);
    my @lines         = ();

    if (open my $fh, '<', "${configdir}/${farm_filename}") {
        @lines = <$fh>;
        close $fh;
    }

    for my $line (@lines) {
        if    ($line =~ /^[#\s]*Service \"/) { last; }
        elsif ($line =~ /LogLevel\s+(\d).*/) {
            my $lvl = $1 + 0;
            $output = 'true' if ($lvl >= 5);
            last;
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmLogs

Enable or disable the log connection tracking for a http farm

Parameters:

    farmname  - Farm name
    action    - The available actions are: "true" to enable or "false" to disable

Returns:

    scalar - The possible values are: 0 on success or -1 on failure

=cut

sub setHTTPFarmLogs ($farm_name, $action) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    my $loglvl;
    $loglvl = ($action eq "true") ? 5 : 0;

    require Relianoid::File;
    my @lines = readFileAsArray("$configdir/$farm_filename");

    my $match_found = 0;
    for my $line (@lines) {
        if ($line =~ s/^LogLevel\s+(\d).*$/LogLevel\t$loglvl/) {
            $match_found = 1;
            $output      = 0;
        }
    }

    if ($match_found) {
        writeFileFromArray("$configdir/$farm_filename", \@lines);
    }
    else {
        &log_error("Error modifying http logs", "LSLB");
    }

    return $output;
}

=pod

=head1 getHTTPFarm100Continue

Return 100 continue Header configuration HTTP and HTTPS farms

Parameters:

    farmname - Farm name

Returns:

    scalar - The possible values are: 0 on disabled, 1 on enabled

=cut

sub getHTTPFarm100Continue ($farm_name) {
    my $output = 'true';

    my $farm_filename = &getFarmFile($farm_name);
    my @lines;

    if (open my $fh, '<', "${configdir}/${farm_filename}") {
        @lines = <$fh>;
        close $fh;
    }

    for my $line (@lines) {
        if    ($line =~ /^[#\s]*Service \"/) { last; }
        elsif ($line =~ /Ignore100Continue (\d).*/) {
            $output = ($1 eq '0') ? 'false' : 'true';
            last;
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarm100Continue

Enable or disable the HTTP 100 continue header

Parameters:

    farm_name  - Farm name
    action    - The available actions are: 1 to enable or 0 to disable

Returns:

    scalar - The possible values are: 0 on success or -1 on failure

=cut

sub setHTTPFarm100Continue ($farm_name, $action) {
    my $farm_filename = &getFarmFile($farm_name);

    require Relianoid::File;
    my @lines = readFileAsArray("$configdir/$farm_filename");

    # check if 100 continue directive exists
    my $match_found = 0;
    for my $line (@lines) {
        if ($line =~ s/^Ignore100Continue\ .*/Ignore100Continue $action/) {
            $match_found = 1;
        }
    }

    if (not $match_found) {
        for my $line (@lines) {
            if ($line =~ /^Control\s/) {
                $line = "$line\nIgnore100Continue $action\n";
                last;
            }
        }
    }

    writeFileFromArray("$configdir/$farm_filename", \@lines);

    return 0;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/HTTP/Factory.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

require Relianoid::Core;

my $eload     = eval { require Relianoid::ELoad };
my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::HTTP::Factory

=cut

=pod

=head1 runHTTPFarmCreate

Create a HTTP farm

Parameters:

    vip - Virtual IP where the virtual service is listening
    vip_port - Virtual port where the virtual service is listening
    farm_name - Farm name
    farm_type - Specify if farm is HTTP or HTTPS
    status - Set the initial status of the farm. The possible values are: 'down' for creating the farm and do not run it or 'up' (default) for running the farm when it has been created

Returns:

    Integer - return 0 on success or different of 0 on failure

=cut

sub runHTTPFarmCreate ($vip, $vip_port, $farm_name, $farm_type, $status = 'up') {
    require Relianoid::Farm::HTTP::Config;
    require Tie::File;
    require File::Copy;
    File::Copy->import();

    my $output = -1;

    #copy template modyfing values
    my $poundtpl        = &getGlobalConfiguration('poundtpl');
    my $proxy_conf_file = "$configdir/${farm_name}_proxy.cfg";
    &log_info("Copying proxy template ($poundtpl) to $proxy_conf_file", "LSLB");
    copy($poundtpl, $proxy_conf_file);

    #modify strings with variables
    tie my @file, 'Tie::File', $proxy_conf_file;

    for my $line (@file) {
        $line =~ s/\[IP\]/$vip/;
        $line =~ s/\[PORT\]/$vip_port/;
        $line =~ s/\[DESC\]/$farm_name/;
        $line =~ s/\[CONFIGDIR\]/$configdir/;
        if ($farm_type eq "HTTPS") {
            $line =~ s/ListenHTTP/ListenHTTPS/;
            $line =~ s/#Cert/Cert/;
        }
    }
    untie @file;

    #create files with personalized errors
    my $f_err;

    open $f_err, '>', "${configdir}/${farm_name}_Err414.html";
    print $f_err "Request URI is too long.\n";
    close $f_err;

    open $f_err, '>', "${configdir}/${farm_name}_Err500.html";
    print $f_err "An internal server error occurred. Please try again later.\n";
    close $f_err;

    open $f_err, '>', "${configdir}/${farm_name}_Err501.html";
    print $f_err "This method may not be used.\n";
    close $f_err;

    open $f_err, '>', "${configdir}/${farm_name}_Err503.html";
    print $f_err "The service is not available. Please try again later.\n";
    close $f_err;

    #create session file
    open $f_err, '>', "${configdir}/${farm_name}_sessions.cfg";
    close $f_err;

    &setHTTPFarmLogs($farm_name, 'false');

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Farm::HTTP::Ext',
            func   => 'addHTTPFarmWafBodySize',
            args   => [$farm_name],
        );
    }

    $output = &getHTTPFarmConfigIsOK($farm_name);

    if ($output) {
        require Relianoid::Farm::Action;
        &runFarmDelete($farm_name);
        return 1;
    }

    #run farm
    require Relianoid::System;
    my $pound  = &getGlobalConfiguration('pound');
    my $piddir = &getGlobalConfiguration('piddir');

    if ($status eq 'up') {
        my $cmd = "${pound} -f ${configdir}/${farm_name}_proxy.cfg -p ${piddir}/${farm_name}_proxy.pid";
        &log_info("Running: ${cmd}", "LSLB");

        $output = &run_with_env($cmd);
    }
    else {
        $output = &setHTTPFarmBootStatus($farm_name, 'down');
    }

    return $output;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/HTTP/HTTPS.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload     = eval { require Relianoid::ELoad };
my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::HTTP::HTTPS

=cut

=pod

=head1 getFarmCertificate

Return the certificate applied to the farm

Parameters:

    farm_name - Farm name

Returns:

    scalar - Return the certificate file, or -1 on failure.

FIXME:

    If are there more than one certificate, only return the last one

=cut

sub getFarmCertificate ($farm_name) {
    my $output = -1;

    my $farm_filename = &getFarmFile($farm_name);
    open my $fh, '<', "${configdir}/${farm_filename}";
    my @content = <$fh>;
    close $fh;

    for my $line (@content) {
        if ($line =~ /Cert/ && $line !~ /\#.*Cert/) {
            my @partline = split('\"', $line);
            @partline = split("\/", $partline[1]);
            my $lfile = @partline;
            $output = $partline[ $lfile - 1 ];
        }
    }

    return $output;
}

=pod

=head1 setFarmCertificate

Configure a certificate for a HTTP farm

Parameters:

    cert_file - certificate file name
    farm_name - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

FIXME:

    There is other function for this action: setFarmCertificateSNI

=cut

sub setFarmCertificate ($cert_file, $farm_name) {
    require Tie::File;
    require Relianoid::Lock;
    require Relianoid::Farm::HTTP::Config;

    my $farm_filename = &getFarmFile($farm_name);
    my $lock_file     = &getLockFile($farm_name);
    my $lock_fh       = &openlock($lock_file, 'w');
    my $output        = -1;

    my $cert_dir  = &getGlobalConfiguration('certdir');
    my $cert_path = "${cert_dir}/${cert_file}";

    &log_info("Setting 'Certificate ${cert_file}' for ${farm_name} farm https", "LSLB");

    require Relianoid::Certificate;
    my $error = &checkCertPEMValid($cert_path);

    if ($error->{code}) {
        &log_error("'Certificate ${cert_file}' for ${farm_name} farm https is not valid", "LSLB");
        return $output;
    }

    tie my @array, 'Tie::File', "${configdir}/${farm_filename}";

    for my $line (@array) {
        if ($line =~ /Cert "/) {
            $line =~ s!.*Cert .*!\tCert "${cert_path}"!g;
            $output = 0;
        }
    }

    untie @array;
    close $lock_fh;

    return $output;
}

=pod

=head1 setFarmCipherList

Set Farm Ciphers value

Parameters:

    farmname - Farm name

    ciphers - The options are: cipherglobal, cipherpci, cipherssloffloading or ciphercustom

    cipherc - Cipher custom, this field is used when ciphers is ciphercustom

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub setFarmCipherList ($farm_name, $ciphers, $cipherc) {
    require Tie::File;
    require Relianoid::Lock;
    require Relianoid::Farm::HTTP::Config;

    my $farm_filename = &getFarmFile($farm_name);
    my $lock_file     = &getLockFile($farm_name);
    my $lock_fh       = &openlock($lock_file, 'w');
    my $output        = -1;

    tie my @array, 'Tie::File', "$configdir/$farm_filename";

    for my $line (@array) {
        # takes the first Ciphers line only
        next if ($line !~ /Ciphers/);

        if ($ciphers eq "cipherglobal") {
            $line =~ s/#//g;
            $line   = "\tCiphers \"ALL\"";
            $output = 0;
        }
        elsif ($ciphers eq "cipherpci") {
            my $cipher_pci = &getGlobalConfiguration('cipher_pci');
            $line =~ s/#//g;
            $line   = "\tCiphers \"$cipher_pci\"";
            $output = 0;
        }
        elsif ($ciphers eq "ciphercustom") {
            $cipherc = 'DEFAULT' if not defined $cipherc;
            $line =~ s/#//g;
            $line   = "\tCiphers \"$cipherc\"";
            $output = 0;
        }
        elsif ($ciphers eq "cipherssloffloading") {
            my $cipher = &getGlobalConfiguration('cipher_ssloffloading');
            $line   = "\tCiphers \"$cipher\"";
            $output = 0;
        }

        # default cipher
        else {
            $line =~ s/#//g;
            $line   = "\tCiphers \"ALL\"";
            $output = 0;
        }

        last;
    }

    untie @array;
    close $lock_fh;

    return $output;
}

=pod

=head1 getFarmCipherList

Get Cipher value defined in l7 proxy configuration file

Parameters:

    farmname - Farm name

Returns:

    scalar - return a string with cipher value or -1 on failure
=cut

sub getFarmCipherList ($farm_name) {
    my $output = -1;

    my $farm_filename = &getFarmFile($farm_name);

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @content = <$fh>;
    close $fh;

    for my $line (@content) {
        next if ($line !~ /Ciphers/);

        $output = (split('\"', $line))[1];

        last;
    }

    return $output;
}

=pod

=head1 getFarmCipherSet

Get Ciphers value defined in l7 proxy configuration file.

Parameters:

    farmname - Farm name

Returns:

    scalar - return a string with cipher set (ciphers) or -1 on failure

    Possible values are:

        cipherglobal
        cipherpci
        cipherssloffloading
        ciphercustom

=cut

sub getFarmCipherSet ($farm_name) {
    my $output = -1;

    my $cipher_list = &getFarmCipherList($farm_name);

    if ($cipher_list eq 'ALL') {
        $output = "cipherglobal";
    }
    elsif ($cipher_list eq &getGlobalConfiguration('cipher_pci')) {
        $output = "cipherpci";
    }
    elsif ($eload
        && $cipher_list eq &getGlobalConfiguration('cipher_ssloffloading'))
    {
        $output = "cipherssloffloading";
    }
    else {
        $output = "ciphercustom";
    }

    return $output;
}

=pod

=head1 getHTTPFarmDisableSSL

Get if a security protocol version is enabled or disabled in a HTTPS farm

Parameters:

    farm_name - Farm name
    protocol - SSL or TLS protocol get status (disabled or enabled)

Returns:

    Integer - 1 on disabled, 0 on enabled or -1 on failure

=cut

sub getHTTPFarmDisableSSL ($farm_name, $protocol) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    open my $fh, '<', "${configdir}/${farm_filename}" or return $output;
    $output = 0;    # if the directive is not in config file, it is disabled
    my @file = <$fh>;
    close $fh;

    for my $line (@file) {
        if ($line =~ /^\tDisable $protocol$/) {
            $output = 1;
            last;
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmDisableSSL

Enable or disable a security protocol for a HTTPS farm

Parameters:

    farm_name - Farm name
    protocol - SSL or TLS protocol to disable/enable: SSLv2|SSLv3|TLSv1|TLSv1_1|TLSv1_2
    action   - The available actions are: 1 to disable or 0 to enable

Returns:

    Integer - Error code: 0 on success or -1 on failure

=cut

sub setHTTPFarmDisableSSL ($farm_name, $protocol, $action) {
    require Tie::File;
    require Relianoid::Lock;
    require Relianoid::Farm::HTTP::Config;

    my $farm_filename = &getFarmFile($farm_name);
    my $lock_file     = &getLockFile($farm_name);
    my $lock_fh       = &openlock($lock_file, 'w');
    my $output        = -1;

    tie my @file, 'Tie::File', "$configdir/$farm_filename";

    if ($action == 1) {
        for my $line (@file) {
            if ($line =~ /Ciphers\ .*/) {
                $line = "$line\n\tDisable $protocol";
                last;
            }
        }
        $output = 0;
    }
    else {
        my $it = -1;
        for my $line (@file) {
            $it = $it + 1;
            last if ($line =~ /Disable $protocol$/);
        }

        # Remove line only if it is found (we haven't arrive at last line).
        splice(@file, $it, 1) if (($it + 1) != scalar @file);
        $output = 0;
    }

    untie @file;
    close $lock_fh;

    return $output;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/HTTP/Service.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload     = eval { require Relianoid::ELoad };
my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::HTTP::Service

=cut

=pod

=head1 setFarmHTTPNewService

Create a new Service in a HTTP farm

Parameters:

    farm_name - Farm name

    service - Service name

Returns:

    Integer - Error code: 0 on success, other value on failure

FIXME:

    This function returns nothing, do error control

=cut

sub setFarmHTTPNewService ($farm_name, $service) {
    require Tie::File;
    require Relianoid::Lock;
    require Relianoid::File;
    require Relianoid::Farm::Config;

    my $output = -1;

    #first check if service name exist
    if ($service =~ /(?=)/ && $service =~ /^$/) {
        #error 2 eq $service is empty
        $output = 2;
        return $output;
    }

    if (!grep { /^\s*Service "$service"/ } readFileAsArray("$configdir/$farm_name\_proxy.cfg")) {
        #create service
        my @newservice;
        my $sw       = 0;
        my $count    = 0;
        my $poundtpl = &getGlobalConfiguration('poundtpl');

        tie my @poundtpl, 'Tie::File', "$poundtpl";

        for my $line (@poundtpl) {
            if ($line =~ /Service \"\[DESC\]\"/) {
                $sw = 1;
            }

            if ($sw eq "1") {
                push(@newservice, $line);
            }

            if ($line =~ /End/) {
                $count++;
            }

            if ($count eq "4") {
                last;
            }
        }

        untie @poundtpl;

        $newservice[0]  =~ s/#//g;
        $newservice[-1] =~ s/#//g;

        my $lock_file = &getLockFile($farm_name);
        my $lock_fh   = &openlock($lock_file, 'w');

        my @fileconf;
        if (!grep { /^\s*Service "$service"/ } readFileAsArray("$configdir/$farm_name\_proxy.cfg")) {
            tie @fileconf, 'Tie::File', "$configdir/$farm_name\_proxy.cfg";

            my $i         = 0;
            my $farm_type = &getFarmType($farm_name) // "";

            for my $line (@fileconf) {
                if ($line =~ /#ZWACL-END/) {
                    $output = 0;

                    for my $lline (@newservice) {
                        if ($lline =~ /\[DESC\]/) {
                            $lline =~ s/\[DESC\]/$service/;
                        }

                        if ($lline =~ /StrictTransportSecurity/ && $farm_type eq "https") {
                            $lline =~ s/#//;
                        }

                        splice @fileconf, $i, 0, "$lline";
                        $i++;
                    }
                    last;
                }
                $i++;
            }
        }

        untie @fileconf;
        close $lock_fh;
    }
    else {
        $output = 1;
    }

    return $output;
}

=pod

=head1 setFarmHTTPNewServiceFirst

Create a new Service in a HTTP farm on first position

Parameters:

    farm_name - Farm name

    service - Service name

Returns:

    Integer - Error code: 0 on success, other value on failure

=cut

sub setFarmHTTPNewServiceFirst ($farm_name, $service) {
    require Tie::File;
    require Relianoid::Lock;
    require Relianoid::File;
    require Relianoid::Farm::Config;

    my $output = -1;

    #first check if service name exist
    if ($service =~ /(?=)/ && $service =~ /^$/) {
        #error 2 eq $service is empty
        $output = 2;
        return $output;
    }

    if (!grep { /^\s*Service "$service"/ } readFileAsArray("$configdir/$farm_name\_proxy.cfg")) {
        #create service
        my @newservice;
        my $sw       = 0;
        my $count    = 0;
        my $poundtpl = &getGlobalConfiguration('poundtpl');

        tie my @poundtpl, 'Tie::File', "$poundtpl";

        for my $line (@poundtpl) {
            if ($line =~ /Service \"\[DESC\]\"/) {
                $sw = 1;
            }

            if ($sw eq "1") {
                push(@newservice, $line);
            }

            if ($line =~ /End/) {
                $count++;
            }

            if ($count eq "4") {
                last;
            }
        }

        untie @poundtpl;

        $newservice[0]  =~ s/#//g;
        $newservice[-1] =~ s/#//g;

        my $lock_file = &getLockFile($farm_name);
        my $lock_fh   = &openlock($lock_file, 'w');
        my @fileconf;

        if (!grep { /^\s*Service "$service"/ } readFileAsArray("${configdir}/${farm_name}_proxy.cfg")) {
            tie @fileconf, 'Tie::File', "$configdir/$farm_name\_proxy.cfg";

            my $i         = 0;
            my $farm_type = "";
            $farm_type = &getFarmType($farm_name);

            for my $line (@fileconf) {
                if ($line =~ /#ZWACL-INI/) {
                    $output = 0;

                    for my $lline (@newservice) {
                        if ($lline =~ /\[DESC\]/) {
                            $lline =~ s/\[DESC\]/$service/;
                        }

                        if ($lline =~ /StrictTransportSecurity/ && $farm_type eq "https") {
                            $lline =~ s/#//;
                        }

                        $i++;
                        splice @fileconf, $i, 0, "$lline";
                    }

                    last;
                }

                $i++;
            }
        }

        untie @fileconf;
        close $lock_fh;
    }
    else {
        $output = 1;
    }

    return $output;
}

=pod

=head1 delHTTPFarmService

Delete a service in a Farm

Parameters:

    farm_name - Farm name
    service - Service name

Returns:

    Integer - Error code: 0 on success, -1 on failure

=cut

sub delHTTPFarmService ($farm_name, $service) {
    require Tie::File;
    require Relianoid::Lock;
    require Relianoid::FarmGuardian;
    require Relianoid::Farm::HTTP::Service;
    require Relianoid::Farm::Config;

    my $farm_filename = &getFarmFile($farm_name);
    my $sw            = 0;
    my $output        = -1;
    my $farm_ref      = getFarmStruct($farm_name);

    # Counter the Service's backends
    my $sindex     = &getFarmVSI($farm_name, $service);
    my $backendsvs = &getHTTPFarmVS($farm_name, $service, "backends");
    my @be         = split("\n", $backendsvs);
    my $counter    = @be;

    # Stop FG service
    &delFGFarm($farm_name, $service);

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    tie my @fileconf, 'Tie::File', "$configdir/$farm_filename";

    my $i = 0;
    for ($i = 0 ; $i < $#fileconf ; $i++) {
        my $line = $fileconf[$i];
        if ($sw eq "1" && ($line =~ /ZWACL-END/ || $line =~ /Service/)) {
            $output = 0;
            last;
        }

        if ($sw) {
            splice @fileconf, $i, 1,;
            $i--;
        }

        if ($line =~ /Service "$service"/) {
            $sw = 1;
            splice @fileconf, $i, 1,;
            $i--;
        }
    }

    if ($eload) {
        if (&getGlobalConfiguration('floating_L7') eq 'true') {
            &reloadFarmsSourceAddressByFarm($farm_name);
        }
    }

    untie @fileconf;
    close $lock_fh;

    # delete service's backends  in status file
    if ($counter > -1) {
        while ($counter > -1) {
            require Relianoid::Farm::HTTP::Backend;
            &runRemoveHTTPBackendStatus($farm_name, $counter, $service);
            $counter--;
        }
    }

    # change the ID value of services with an ID higher than the service deleted (value - 1)
    tie my @contents, 'Tie::File', "$configdir\/$farm_name\_status.cfg";
    for my $line (@contents) {
        my @params = split(" ", $line);
        my $newval = $params[2] - 1;

        if ($params[2] > $sindex) {
            my $old = join " ", @params;
            $params[2] = $newval;
            my $new = join " ", @params;
            $line =~ s/$old/$new/g;
        }
    }
    untie @contents;

    return $output;
}

=pod

=head1 getHTTPFarmServices

Get an array containing all service name configured in an HTTP farm.

If Service name is sent, get an array containing the service name foundand index.

Parameters:

    farm_name - Farm name
    service_name - Service name

Returns:

    Array - service names if service name param does not exist. 
    Hash ref  - Hash ref $service_ref if service name param exists.

Variable: $service_ref

    $service_ref->{ $service_name } - Service index

FIXME:

    &getHTTPFarmVS(farmname) does same but in a string

=cut

sub getHTTPFarmServices ($farm_name, $service_name = undef) {
    require Relianoid::Farm::Core;

    my $farm_filename = &getFarmFile($farm_name);
    my @output        = ();

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;
    close $fh;

    my $index = 0;
    for my $line (@file) {
        if ($line =~ /^\s*Service\s+\"(.*)\"\s*$/) {
            my $service = $1;
            if ($service_name) {
                if ($service_name eq $service) {
                    return { $service => $index };
                }
                $index++;
            }
            else {
                push(@output, $service);
            }
        }
    }

    return @output;
}

=pod

=head1 getHTTPServiceStruct

Get a struct with all parameters of a HTTP service

Parameters:

    farm_name - Farm name
    service_name  - Service name

Returns:

    hash ref - hash with service configuration

    Example output:

    {
        "backends" : [
            {
                "id" : 0,
                "ip" : "48.5.25.5",
                "port" : 70,
                "status" : "up",
                "timeout" : null,
                "weight" : null
            }
        ],
        "fgenabled" : "false",
        "fglog" : "false",
        "fgscript" : "",
        "fgtimecheck" : 5,
        "httpsb" : "false",
        "id" : "srv3",
        "leastresp" : "false",
        "persistence" : "",
        "redirect" : "",
        "redirecttype" : "",
        "sessionid" : "",
        "ttl" : 0,
        "urlp" : "",
        "vhost" : ""
    };

    Enterprise Edition also includes:

    {
        ...
        "cookiedomain" : "",
        "cookieinsert" : "false",
        "cookiename" : "",
        "cookiepath" : "",
        "cookiettl" : 0,
        ...
    };

Notes:

    Similar to the function get_http_service_struct

=cut

sub getHTTPServiceStruct ($farm_name, $service_name) {
    require Relianoid::FarmGuardian;
    require Relianoid::Farm::HTTP::Backend;

    # http services
    my $services_str = &getHTTPFarmVS($farm_name, "", "");
    my @services     = split(' ', $services_str);

    # return error if service is not found
    return unless grep ({ $service_name eq $_ } @services);

    my $service = {
        id           => $service_name,
        vhost        => &getHTTPFarmVS($farm_name, $service_name, "vs"),
        urlp         => &getHTTPFarmVS($farm_name, $service_name, "urlp"),
        redirect     => &getHTTPFarmVS($farm_name, $service_name, "redirect"),
        redirecttype => &getHTTPFarmVS($farm_name, $service_name, "redirecttype"),
        persistence  => &getHTTPFarmVS($farm_name, $service_name, "sesstype"),
        ttl          => &getHTTPFarmVS($farm_name, $service_name, "ttl"),
        sessionid    => &getHTTPFarmVS($farm_name, $service_name, "sessionid"),
        leastresp    => &getHTTPFarmVS($farm_name, $service_name, "dynscale")     || "false",
        httpsb       => &getHTTPFarmVS($farm_name, $service_name, "httpsbackend") || "false",
        backends     => &getHTTPFarmBackends($farm_name, $service_name),
        farmguardian => &getFGFarm($farm_name, $service_name),
    };
    # Remove backend status 'undefined', it is for news api versions
    for my $be (@{ $service->{backends} }) {
        $be->{status} = 'up' if $be->{status} eq 'undefined';
    }

    if ($eload) {
        $service->{backends} = &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'addAliasBackendsStruct',
            args   => [ $service->{backends} ],
        );

        $service = &eload(
            module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
            func   => 'add_service_cookie_insertion',
            args   => [ $farm_name, $service ],
        );

        $service->{redirect_code} = &eload(
            module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
            func   => 'getHTTPServiceRedirectCode',
            args   => [ $farm_name, $service_name ],
        );
        $service->{sts_status} = &eload(
            module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
            func   => 'getHTTPServiceSTSStatus',
            args   => [ $farm_name, $service_name ],
        );

        $service->{sts_timeout} = &eload(
            module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
            func   => 'getHTTPServiceSTSTimeout',
            args   => [ $farm_name, $service_name ],
        );
    }

    return $service;
}

=pod

=head1 getHTTPServiceId

Returns the service id

Parameters:

    farmname - Farm name
    service_name - Service name

Returns:

    integer - id of service

    undefined - if the service was not found

=cut

sub getHTTPServiceId ($farmname, $service_name) {
    my $id       = undef;
    my @services = getHTTPFarmServices($farmname);
    my $index    = 0;
    my $exist    = 0;

    for my $service (@services) {
        if ($service eq $service_name) {
            $id    = $index;
            $exist = 1;
            last;
        }
        $index++;
    }
    return unless ($exist);
    return $id;
}

=pod

=head1 getHTTPFarmVS

Return virtual server parameter

Parameters:

    farm_name - Farm name
    service - Service name
    tag - Indicate which field will be returned. The options are: vs, urlp, redirect, redirecttype, dynscale, sesstype, ttl, sessionid, httpsbackend or backends

Returns:

    scalar - if service and tag is blank, return all services in a string: "service0 service1 ..." else return the parameter value

FIXME:

    return a hash with all parameters

=cut

sub getHTTPFarmVS ($farm_name, $service = "", $tag = "") {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = "";

    my $directive_index = 0;
    my @lines           = ();

    if (open my $fh, '<', "${configdir}/${farm_filename}") {
        @lines = <$fh>;
        close $fh;
    }

    my $sw         = 0;
    my $be_section = 0;
    my $se_section = 0;
    my $be_emerg   = 0;
    my $be         = -1;
    my $sw_ti      = 0;
    my $output_ti  = "";
    my $sw_pr      = 0;
    my $output_pr  = "";
    my $sw_w       = 0;
    my $output_w   = "";
    my $outputa;
    my $outputp;
    my @return;

    for my $line (@lines) {
        if ($line =~ /^\s*Service \"$service\"/) { $sw         = 1; }
        if ($line =~ /^\s*Session/ && $sw)       { $se_section = 1; }
        if ($line =~ /^\s*End\s*$/) {
            if    ($se_section)                { $se_section = 0; }
            elsif (!$be_section && !$be_emerg) { $sw         = 0; }
        }

        # returns all services for this farm
        if ($tag eq "" && $service eq "") {
            if ($line =~ /^\s*Service\ \"/) {
                @return = split("\ ", $line);
                $return[1] =~ s/\"//g;
                $return[1] =~ s/^\s+//;
                $return[1] =~ s/\s+$//;
                $output = "$output $return[1]";
            }
        }

        #vs tag
        if ($tag eq "vs") {
            if ($line =~ /^\s*HeadRequire/ && $sw) {
                @return = split("Host:", $line);
                $return[1] =~ s/\"//g;
                $return[1] =~ s/^\s+//;
                $return[1] =~ s/\s+$//;
                $output = $return[1];
                last;
            }
        }

        #url pattern
        if ($tag eq "urlp") {
            if ($line =~ /^\s*Url \"/ && $sw) {
                @return = split("Url", $line);
                $return[1] =~ s/\"//g;
                $return[1] =~ s/^\s+//;
                $return[1] =~ s/\s+$//;
                $output = $return[1];
                last;
            }
        }

        #redirect
        if ($tag eq "redirect") {
            # Redirect types: 301, 302 or 307.
            if ($line =~ /^\s*Redirect(?:Append)?\s/ && $sw) {
                @return = split(" ", $line);

                my $url = $return[-1];
                $url =~ s/\"//g;
                $url =~ s/^\s+//;
                $url =~ s/\s+$//;
                $output = $url;
                last;
            }
        }

        if ($tag eq "redirecttype") {
            if ($line =~ /^\s*Redirect(?:Append)?\s/ && $sw) {
                if    ($line =~ /Redirect /)       { $output = "default"; }
                elsif ($line =~ /RedirectAppend /) { $output = "append"; }
                last;
            }
        }

        # leastresp
        if ($tag eq "dynscale") {
            if ($line =~ /^\s*DynScale\ / && $sw) {
                $output = "true";
                last;
            }
        }

        #######################
        # Session has 3 fields:
        # - Type
        # - TTL
        # - ID

        # session type
        # only get the session type when it's not commented
        if ($tag eq "sesstype") {
            if ($line =~ /^\s*Type/ && $sw) {
                @return = split(" ", $line);
                $return[1] =~ s/\"//g;
                $return[1] =~ s/^\s+//;
                $return[1] =~ s/\s+$//;
                $output = $return[1];
                last;
            }
        }

        # session ttl
        # Get ttl value whether the line is commented or not
        if ($tag eq "ttl") {
            if ($line =~ /^[\s#]*TTL/ && $sw) {
                @return = split(" ", $line);
                $return[1] =~ s/\"//g;
                $return[1] =~ s/^\s+//;
                $return[1] =~ s/\s+$//;
                $output = $return[1] + 0;
                last;
            }
        }

        # session id
        # only get the session name when it's not commented
        # Format: sessionid "sessionname"
        if ($tag eq "sessionid") {
            if ($line =~ /^\s*ID/ && $sw) {
                @return = split(" ", $line);
                $return[1] =~ s/\"//g;
                $return[1] =~ s/^\s+//;
                $return[1] =~ s/\s+$//;
                $output = $return[1];
                last;
            }
        }

        # End of session section
        ########################

        #HTTPS tag
        if ($tag eq "httpsbackend") {
            if ($line =~ "##True##HTTPS-backend##" && $sw) {
                $output = "true";
                last;
            }
        }

        #backends
        if ($tag eq "backends") {
            if ($line =~ /^\s*BackEnd|^\s*Emergency/ && $sw) {
                $be_section = 1;
            }
            if ($line =~ /^\s*Emergency/ && $sw) {
                $be_emerg = 1;
            }
            if ($be_section) {
                if ($line =~ /^\s*End/ && $sw) {
                    if ($sw_ti == 0) {
                        $output_ti = "TimeOut -";
                    }
                    if ($sw_pr == 0) {
                        $output_pr = "Priority -";
                    }
                    if ($sw_w == 0) {
                        $output_w = "Weight 1";
                        $output_w = "Weight 2" if ($be_emerg == 1);
                        $be_emerg = 0;
                    }

                    my @line_parts = ($output, $outputa, $outputp, $output_ti, $output_pr, $output_w);
                    $output    = join(" ", @line_parts) . "\n";
                    $output_ti = "";
                    $output_pr = "";
                    $sw_ti     = 0;
                    $sw_pr     = 0;
                    $sw_w      = 0;
                }
                elsif ($line =~ /^\s*Address/) {
                    $be++;
                    chomp($line);
                    $outputa = "Server $be $line";
                }
                elsif ($line =~ /^\s*Port/) {
                    chomp($line);
                    $outputp = "$line";
                }
                elsif ($line =~ /^\s*TimeOut/) {
                    chomp($line);

                    #$output = $output . "$line";
                    $output_ti = $line;
                    $sw_ti     = 1;
                }
                elsif ($line =~ /^\s*Priority/) {
                    chomp($line);

                    #$output = $output . "$line";
                    $output_pr = $line;
                    $sw_pr     = 1;
                }
                elsif ($line =~ /^\s*Weight/) {
                    chomp($line);

                    #$output = $output . "$line";
                    $output_w = $line;
                    $sw_w     = 1;
                }
            }
            if ($sw && $be_section && $line =~ /#End/) {
                last;
            }
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmVS

Set values for service parameters. The parameters are: vs, urlp, redirect, redirectappend, dynscale, sesstype, ttl, sessionid, httpsbackend or backends

An empty string/value will comment the tag/attribute/field in config file.

Examples of service section:

	Service "newservice"
		##False##HTTPS-backend##
		#DynScale 1
		#BackendCookie "NOIDSESSIONID" "" "/" 3600
		#HeadRequire "Host: "
		#Url ""
		#Redirect ""
		#StrictTransportSecurity 21600000
		#Session
			#Type nothing
			#TTL 120
			#ID "sessionname"
		#End
		#BackEnd

		#End
	End

	Service "newservice"
		##False##HTTPS-backend##
		DynScale 1
		BackendCookie "TESTING" "domaintesting.com" "/a" 17
		HeadRequire "Host: www.mywebserver.com"
		Url "^/myapp1$"
		Redirect 302 "http://www.mysite.com"
		#StrictTransportSecurity 21600000
		Session
			Type URL
			TTL 120
			ID "sessionname"
		End
		#BackEnd

		#End
	End

Parameters:

    farm_name - Farm name
    service   - Service name
    tag       - Indicate which parameter modify
    string    - value for the field "tag"

Returns:

    Integer - Error code: 0 on success or -1 on failure

=cut

sub setHTTPFarmVS ($farm_name, $service, $tag, $string = '') {
    my $farm_filename  = &getFarmFile($farm_name);
    my $output         = 0;
    my $in_service     = 0;                          # Found service block
    my $be_section     = 0;
    my $se_section     = 0;
    my $clean_sessions = 0;
    my $line_index     = -1;

    $string =~ s/^\s+//;
    $string =~ s/\s+$//;

    require Relianoid::Lock;
    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @fileconf, 'Tie::File', "$configdir/$farm_filename";

    for my $line (@fileconf) {
        $line_index++;
        if ($line =~ /^\s*Service "$service"/)                 { $in_service = 1; next; }
        if ($line =~ /^\s*Session/ && $in_service)             { $se_section = 1; }
        if ($line =~ /^\s*(BackEnd|Emergency)/ && $in_service) { $be_section = 1; }

        if ($line =~ /^\s*End\s*$/ && $in_service && !$se_section && !$be_section) { last; }
        if ($in_service && $line =~ /\s*Service "/ && $line !~ /\s*Service "$service"/) { last; }

        next if not $in_service;

        # vhost or vs tag
        if ($tag eq "vs") {
            if ($line =~ /^[\s#]*HeadRequire / && $string ne "") {
                $line = "\t\tHeadRequire \"Host: $string\"";
                last;
            }
            if ($line =~ /^[\s#]*HeadRequire / && $string eq "") {
                $line = "\t\t#HeadRequire \"Host:\"\n";
                last;
            }
        }

        # urlp or url pattern
        if ($tag eq "urlp") {
            if ($line =~ /^[\s#]*Url / && $string ne "") {
                $line = "\t\tUrl \"$string\"";
                last;
            }
            if ($line =~ /^[\s#]*Url / && $string eq "") {
                $line = "\t\t#Url \"\"";
                last;
            }
        }

        # leastresp or dynscale tag
        if ($tag eq "dynscale") {
            if ($line =~ /^[\s#]*DynScale / && $string ne "") {
                $line = "\t\tDynScale 1";
                last;
            }
            if ($line =~ /^[\s#]*DynScale / && $string eq "") {
                $line = "\t\t#DynScale 1";
                last;
            }
        }

        # client redirect default
        if ($tag eq "redirect") {
            if ($line =~ /^[\s#]*(Redirect(?:Append)?) (30[127] )?.*/) {
                my $policy        = $string ? $1 : "Redirect";
                my $redirect_code = $2 // '';
                my $comment       = $string ? '' : '#';
                $line = qq(\t\t${comment}${policy} ${redirect_code}"${string}");
                last;
            }
        }

        # redirecttype
        if ($tag eq "redirecttype") {
            if ($line =~ /^[\s#]*Redirect(?:Append)? (.*)/) {
                my $rest    = $1;
                my $policy  = $string eq 'append' ? 'RedirectAppend' : 'Redirect';
                my $comment = $string             ? ''               : '#';
                $line = "\t\t${comment}${policy} $rest";
                last;
            }
        }

        # ttl
        if ($tag eq "ttl") {
            if ($line =~ /^[\s#]*TTL / && $string ne "") {
                $line = "\t\t\tTTL $string";
                last;
            }
            if ($line =~ /^[\s#]*TTL / && $string eq "") {
                $line = "\t\t\t#TTL 120";
                last;
            }
        }

        # session id
        if ($tag eq "sessionid") {
            if ($line =~ /^[\s#]*ID / && $string ne "") {
                $line = "\t\t\tID \"$string\"";
                last;
            }
            if ($line =~ /^[\s#]*ID / && $string eq "") {
                $line = "\t\t\t#ID \"$string\"";
                last;
            }
        }

        # httpsb or HTTPS Backends tag
        if ($tag eq "httpsbackend") {
            if ($line =~ "##HTTPS-backend##" && $string ne "") {
                #turn on
                $line = "\t\t##True##HTTPS-backend##";
            }
            elsif ($line =~ "##HTTPS-backend##" && $string eq "") {
                #turn off
                $line = "\t\t##False##HTTPS-backend##";
            }

            #Delete HTTPS tag in a BackEnd
            if ($line =~ /^\s*HTTPS$/ && $string eq "") {
                #Delete HTTPS tag
                splice @fileconf, $line_index, 1,;
            }

            #Add HTTPS tag
            if ($line =~ /^\s*(BackEnd|Emergency)$/ && $string ne "") {
                $line .= "\n\t\t\tHTTPS";
            }
        }

        # session type
        if ($tag eq "session") {
            # Session section enabled
            if ($string ne "nothing") {
                if ($line =~ /^[\s#]*Session/) {
                    $line = "\t\tSession";
                }
                elsif ($line =~ /^[\s#]*End/) {
                    $line = "\t\tEnd";
                    last;
                }
                elsif ($line =~ /^[\s#]*Type\s+(.*)\s*/) {
                    $line           = "\t\t\tType $string";
                    $clean_sessions = 1 if $1 ne $string;
                }
                elsif ($line =~ /^[\s#]*TTL /) {
                    $line =~ s/#//g;
                }
                elsif ($line =~ /^[\s#]*ID /) {
                    if (grep { $string eq $_ } ("URL", "COOKIE", "HEADER")) {
                        $line =~ s/#//g;
                    }
                    else {
                        $line = "#$line";
                    }
                }
            }
            # Session section disabled
            else {
                if ($line =~ /^[\s#]*Session/) {
                    $line = "\t\t#Session";
                }
                elsif ($line =~ /^[\s#]*End/) {
                    $line = "\t\t#End";
                    last;
                }
                elsif ($line =~ /^[\s#]*TTL /) {
                    $line = "\t\t\t#TTL 120";
                }
                elsif ($line =~ /^[\s#]*Type /) {
                    $line           = "\t\t\t#Type nothing";
                    $clean_sessions = 1;
                }
                elsif ($line =~ /^[\s#]*ID /) {
                    $line = "\t\t\t#ID \"sessionname\"";
                }
            }
        }
    }

    untie @fileconf;
    close $lock_fh;

    return $output;
}

=pod

=head1 getFarmVSI

Get the index of a service in a http farm

Parameters:

    farmname - Farm name
    service - Service name

Returns:

    integer - Service index, it returns -1 if the service does not exist

FIXME:

    Rename with intuitive name, something like getHTTPFarmServiceIndex

=cut

sub getFarmVSI ($farm_name, $target_service) {
    my @services = &getHTTPFarmServices($farm_name);
    my $index    = 0;

    for my $service (@services) {
        if ($service eq $target_service) {
            return $index;
        }
        $index++;
    }

    return -1;
}

=pod

=head1 get_http_service_struct

FIXME:

    This function is only used in API 3.2. getHTTPServiceStruct should be used.

=cut

sub get_http_service_struct ($farmname, $service_name) {
    require Relianoid::FarmGuardian;
    require Relianoid::Farm::HTTP::Backend;

    my $service_ref = &getHTTPServiceStruct($farmname, $service_name);

    # Backends
    my $backends = &getHTTPFarmBackends($farmname, $service_name);

    # Remove backend status 'undefined', it is for news api versions
    for my $be (@{$backends}) {
        $be->{status} = 'up' if $be->{status} eq 'undefined';
    }

    # Add FarmGuardian
    $service_ref->{farmguardian} = &getFGFarm($farmname, $service_name);

    # Add STS
    if ($eload) {
        $service_ref->{sts_status} = &eload(
            module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
            func   => 'getHTTPServiceSTSStatus',
            args   => [ $farmname, $service_name ],
        );

        $service_ref->{sts_timeout} = &eload(
            module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
            func   => 'getHTTPServiceSTSTimeout',
            args   => [ $farmname, $service_name ],
        );
    }

    return $service_ref;
}

=pod

=head1 get_http_all_services_summary_struct

=cut

sub get_http_all_services_summary_struct ($farmname) {
    # Output
    my @services_list = ();

    for my $service (&getHTTPFarmServices($farmname)) {
        push @services_list, { 'id' => $service };
    }

    return \@services_list;
}

=pod

=head1 getHTTPFarmPriorities

Get the list of the backends priorities of the service in a http farm

Parameters:

    farmname - Farm name

    service - Service name

Returns:

    Array Ref - it returns an array ref of priority values

=cut

sub getHTTPFarmPriorities ($farmname, $service_name) {
    my @priorities;
    my $backends = &getHTTPFarmBackends($farmname, $service_name);

    for my $backend (@{$backends}) {
        if (defined $backend->{priority} and $backend->{priority} > 1) {
            push @priorities, $backend;
        }
    }

    return \@priorities;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/HTTP/Stats.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::HTTP::Stats

=cut

=pod

=head1 getHTTPFarmEstConns

Get all ESTABLISHED connections for a farm

Parameters:

    farm_name - Farm name

Returns:

    array - Return all ESTABLISHED conntrack lines for a farm

=cut

sub getHTTPFarmEstConns ($farm_name) {
    my $count = 0;

    my $vip      = &getFarmVip("vip",  $farm_name);
    my $vip_port = &getFarmVip("vipp", $farm_name);

    my $filter = {
        proto         => 'tcp',
        orig_dst      => $vip,
        orig_port_dst => $vip_port,
        state         => 'ESTABLISHED',
    };

    my $ct_params = &getConntrackParams($filter);
    $count = &getConntrackCount($ct_params);

    #~ &log_info( "getHTTPFarmEstConns: $farm_name farm -> $count connections." );

    return $count + 0;
}

=pod

=head1 getHTTPFarmSYNConns

Get all SYN connections for a farm

Parameters:

    farm_name - Farm name

Returns:

    array - Return all SYN conntrack lines for a farm

=cut

sub getHTTPFarmSYNConns ($farm_name) {
    my $vip      = &getFarmVip("vip",  $farm_name);
    my $vip_port = &getFarmVip("vipp", $farm_name);

    my $filter = {
        proto         => 'tcp',
        orig_dst      => $vip,
        orig_port_dst => $vip_port,
        state         => 'SYN_SENT',
    };

    my $ct_params = &getConntrackParams($filter);
    my $count     = &getConntrackCount($ct_params);

    $filter->{state} = 'SYN_RECV';

    $ct_params = &getConntrackParams($filter);
    $count += &getConntrackCount($ct_params);

    #~ &log_info( "getHTTPFarmSYNConns: $farm_name farm -> $count connections." );

    return $count + 0;
}

=pod

=head1 getHTTPBackendEstConns

Get all ESTABLISHED connections for a backend

Parameters:

    farm_name    - Farm name
    backend_ip   - IP backend
    backend_port - backend port
    mark

Returns:

    array - Return all ESTABLISHED conntrack lines for the backend

BUG:

    If a backend is used on more than one farm, here it appears all them

=cut

sub getHTTPBackendEstConns ($farm_name, $backend_ip, $backend_port, $mark = undef) {
    my $filter = {
        proto         => 'tcp',
        orig_dst      => $backend_ip,
        orig_port_dst => $backend_port,
        state         => 'ESTABLISHED',
    };

    if ($mark) {
        $filter->{mark} = $mark;
    }

    require Relianoid::Net::ConnStats;
    my $ct_params = &getConntrackParams($filter);
    my $count     = &getConntrackCount($ct_params);

    return $count + 0;
}

=pod

=head1 getHTTPBackendSYNConns

Get all SYN connections for a backend

Parameters:

    farm_name    - Farm name
    backend_ip   - IP backend
    backend_port - backend port
    mark

Returns:

    unsigned integer - connections count

BUG:

    If a backend is used on more than one farm, here it appears all them.

=cut

sub getHTTPBackendSYNConns ($farm_name, $backend_ip, $backend_port, $mark = undef) {
    my $filter = {
        proto         => 'tcp',
        orig_dst      => $backend_ip,
        orig_port_dst => $backend_port,
        state         => 'SYN_SENT',
    };

    if ($mark) {
        $filter->{mark} = $mark;
    }

    my $ct_params = &getConntrackParams($filter);
    my $count     = &getConntrackCount($ct_params);

    $filter->{state} = 'SYN_RECV';

    $ct_params = &getConntrackParams($filter);
    $count += &getConntrackCount($ct_params);

    return $count + 0;
}

=pod

=head1 getHTTPFarmBackendsStats

This function take data from pounctl and it gives hash format

Parameters:

    farm_name    - Farm name
    service_name - Service name

Returns:

    hash ref - hash with backend farm stats

    backends => [
        {
            "id" = $backend_id      # it is the index in the backend array too
            "ip" = $backend_ip
            "port" = $backend_port
            "status" = $backend_status
            "established" = $established_connections
        }
    ]

    sessions => [
        {
            "client"       = $client_id         # it is the index in the session array too
            "id"           = $session_id        # id associated to a backend, it can change depend of session type
            "backend_ip"   = $backend ip        # it is the backend ip
            "backend_port" = $backend port      # it is the backend port
            "service"      = $service name
            "session"      = $session identifier    # it depends on the persistence mode
        }
    ]

FIXME:

    Put output format same format than "GET /stats/farms/BasekitHTTP"

=cut

sub getHTTPFarmBackendsStats ($farm_name, $service_name = undef) {
    require Relianoid::Farm::Base;
    require Relianoid::Farm::HTTP::Config;
    require Relianoid::Validate;

    my $serviceName;
    my $service_re = &getValidFormat('service');
    my $stats      = {
        sessions => [],
        backends => []
    };

    unless ($eload) {
        require Relianoid::Net::ConnStats;
    }

    # Get L7 proxy info
    #i.e. of poundctl:

    #Requests in queue: 0
    #0. http Listener 185.76.64.223:80 a
    #0. Service "HTTP" active (4)
    #0. Backend 172.16.110.13:80 active (1 0.780 sec) alive (61)
    #1. Backend 172.16.110.14:80 active (1 0.878 sec) alive (90)
    #2. Backend 172.16.110.11:80 active (1 0.852 sec) alive (99)
    #3. Backend 172.16.110.12:80 active (1 0.826 sec) alive (75)
    my @poundctl = &getHTTPFarmGlobalStatus($farm_name);

    my $alias;
    $alias = &eload(
        module => 'Relianoid::EE::Alias',
        func   => 'getAlias',
        args   => ['backend']
    ) if $eload;

    my $backend_info;

    # Parse L7 proxy info
    for my $line (@poundctl) {
        # i.e.
        #     0. Service "HTTP" active (10)
        if ($line =~ /(\d+)\. Service "($service_re)"/) {
            $serviceName  = $2;
            $backend_info = undef;
        }

        next if (defined $service_name && $service_name ne $serviceName);

        # Parse backend connections
        # i.e.
        #      0. Backend 192.168.100.254:80 active (5 0.000 sec) alive (0)
        if ($line =~ /(\d+)\. Backend (\d+\.\d+\.\d+\.\d+|[a-fA-F0-9:]+):(\d+) (\w+) .+ (\w+)(?: \((\d+)\))?/) {
            my $backendHash = {
                id      => $1 + 0,
                ip      => $2,
                port    => $3 + 0,
                status  => $5,
                pending => 0,
                service => $serviceName,
            };

            $backendHash->{alias}                       = $alias->{$2} if $eload;
            $backend_info->{ $backendHash->{id} }{ip}   = $backendHash->{ip};
            $backend_info->{ $backendHash->{id} }{port} = $backendHash->{port};

            # The established connections should be always defined with >= 0
            # If there is any case where it is not defined, we can use the IP based filtering in conntrack
            # $backendHash->{established} = &getHTTPBackendEstConns($farm_name, $backendHash->{ip}, $backendHash->{port});
            $backendHash->{established} = $6 + 0;

            # Getting real status
            my $backend_disabled = $4;

            if ($backend_disabled eq "DISABLED") {
                require Relianoid::Farm::HTTP::Backend;

                #Checkstatusfile
                $backendHash->{status} =
                  &getHTTPBackendStatusFromFile($farm_name, $backendHash->{id}, $serviceName);

                # not show fgDOWN status
                $backendHash->{status} = "down"
                  if ($backendHash->{status} ne "maintenance");
            }
            elsif ($backendHash->{status} eq "alive") {
                $backendHash->{status} = "up";
            }
            elsif ($backendHash->{status} eq "DEAD") {
                $backendHash->{status} = "down";
            }

            # Getting pending connections
            require Relianoid::Net::ConnStats;
            require Relianoid::Farm::Stats;

            # The port passed to getBackendSYNConns will be converted to string,
            # port + 0 will pass a copy of the port, so the original port will not be converted
            $backendHash->{pending} = &getBackendSYNConns($farm_name, $backendHash->{ip}, $backendHash->{port} + 0);

            # Workaround: getBackendSYNConns changes the port to string
            $backendHash->{port} += 0;

            push(@{ $stats->{backends} }, $backendHash);
        }

        # Parse sessions
        # i.e.
        #      1. Session 107.178.194.117 -> 1
        if ($line =~ /(\d+)\. Session (.+) \-\> (\d+)/) {
            push @{ $stats->{sessions} },
              {
                client       => $1 + 0,
                session      => $2,
                id           => $3 + 0,
                backend_ip   => $backend_info->{$3}{ip},
                backend_port => $backend_info->{$3}{port},
                service      => $serviceName,
              };
        }
    }

    return $stats;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/L4xNAT.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::L4xNAT::Config;
use Relianoid::Farm::L4xNAT::Action;
use Relianoid::Farm::L4xNAT::Stats;
use Relianoid::Farm::L4xNAT::Factory;
use Relianoid::Farm::L4xNAT::Backend;
use Relianoid::Farm::L4xNAT::Service;

1;

=pod

=head1 Module

Relianoid::Farm::L4xNAT

=cut

=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/L4xNAT/Action.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Config;
use Relianoid::Nft;

my $eload     = eval { require Relianoid::ELoad };
my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::L4xNAT::Action

=cut

=pod

=head1 startL4Farm

Run a l4xnat farm

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success or different of 0 on failure

=cut

sub startL4Farm ($farm_name, $writeconf = 0) {
    require Relianoid::Farm::L4xNAT::Config;

    &log_info("Starting L4xNAT farm $farm_name") if &debug();

    my $status = 0;
    my $farm   = &getL4FarmStruct($farm_name);

    &loadL4Modules($$farm{vproto});

    $status = &startL4FarmNlb($farm_name, $writeconf);
    if ($status != 0) {
        return $status;
    }

    &doL4FarmRules("start", $farm_name);

    &reloadFarmsSourceAddressByFarm($farm_name);

    # Enable IP forwarding
    require Relianoid::Net::Util;
    &setIpForward('true');

    if ($farm->{lbalg} eq 'leastconn') {
        require Relianoid::Farm::L4xNAT::L4sd;
        &sendL4sdSignal();
    }

    return $status;
}

=pod

=head1 stopL4Farm

Stop a l4xnat farm

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success or other value on failure

=cut

sub stopL4Farm ($farm_name, $writeconf) {
    my $pidfile = &getL4FarmPidFile($farm_name);

    require Relianoid::Farm::Core;
    require Relianoid::Farm::L4xNAT::Config;

    &log_info("Stopping L4xNAT farm $farm_name") if &debug();

    my $farm = &getL4FarmStruct($farm_name);

    &doL4FarmRules("stop", $farm_name);

    my $pid = &getNlbPid();
    if ($pid <= 0) {
        return 0;
    }

    my $status = &stopL4FarmNlb($farm_name, $writeconf);

    # Flush conntrack
    &resetL4FarmConntrack($farm_name) unless ($status);

    unlink "$pidfile" if (-e "$pidfile");

    &unloadL4Modules($$farm{vproto});

    if ($farm->{lbalg} eq 'leastconn') {
        require Relianoid::Farm::L4xNAT::L4sd;
        &sendL4sdSignal();
    }

    return $status;
}

=pod

=head1 setL4NewFarmName

Function that renames a farm

Parameters:

    farmname - Farm name
    newfarmname - New farm name

Returns:

    Integer - return 0 on success or <> 0 on failure

=cut

sub setL4NewFarmName ($farm_name, $new_farm_name) {
    my $err = &setL4FarmParam('name', "$new_farm_name", $farm_name);

    unlink "$configdir\/${farm_name}_l4xnat.cfg";

    if (!$err) {
        $err = &setL4FarmParam('log-prefix', undef, $new_farm_name);
    }

    return $err;
}

=pod

=head1 copyL4Farm

Function that copies a l4xnat farm.
If the flag has the value 'del', the old farm will be deleted.

Parameters:

    farmname - Farm name

    newfarmname - New farm name

    flag - It expets a 'del' string to delete the old farm. It is used to copy or rename the farm.

Returns:

    Integer - return 0 on success or <> 0 on failure

=cut

sub copyL4Farm ($farm_name, $new_farm_name, $del = '') {
    my $output = 0;

    use File::Copy qw(copy);

    my $file_ori = "$configdir/" . &getFarmFile($farm_name);
    my $file_new = "$configdir/${new_farm_name}_l4xnat.cfg";

    copy($file_ori, $file_new);

    # replace the farm directive
    my @lines;
    &ztielock(\@lines, $file_new);
    require Relianoid::Netfilter;
    my $backend_block = 0;

    for my $line (@lines) {
        if ($line =~ /(^\s+"name": )"$farm_name(.*)",/) {
            $line = $1 . "\"$new_farm_name" . $2 . "\",";
        }
        if ((!$backend_block) and ($line =~ /^(\s+"state": )"\w+",/)) {
            $line = $1 . "\"down\",";
        }
        if ($line =~ /^\s+"backends": \[/) {
            $backend_block = 1;
        }
        if (($backend_block) and ($line =~ /(^\s+"mark": )"0x\w+",/)) {
            my $new_mark = &getNewMark($new_farm_name);
            $line = $1 . "\"$new_mark\",";
        }
        if ($line =~ /(^\s+"log-prefix":)(.*)$farm_name ",/) {
            $line = $1 . $2 . "$new_farm_name \",";
        }
    }

    untie @lines;

    unlink $file_ori if ($del eq 'del');

    return $output;
}

=pod

=head1 loadL4NlbFarm

Load farm configuration in nftlb

Parameters:

    farm_name - farm name configuration to be loaded

Returns:

    Integer - 0 on success or -1 on failure

=cut

sub loadL4FarmNlb ($farm_name) {
    require Relianoid::Farm::Core;

    my $farmfile = &getFarmFile($farm_name);

    return 0 if ($farmfile eq "-1" or (!-e "$configdir/$farmfile"));

    return &httpNlbRequest({
        farm   => $farm_name,
        method => "POST",
        uri    => "/farms",
        body   => qq(\@$configdir/$farmfile)
    });
}

=pod

=head1 startL4FarmNlb

Start a new farm in nftlb

Parameters:

    farm_name - farm name to be started
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - 0 on success or -1 on failure

=cut

sub startL4FarmNlb ($farm_name, $writeconf) {
    require Relianoid::Farm::L4xNAT::Config;

    my $output = &setL4FarmParam(($writeconf) ? 'bootstatus' : 'status', "up", $farm_name);

    my $pidfile = &getL4FarmPidFile($farm_name);

    if (!-e $pidfile) {
        open my $fh, '>', $pidfile;
        close $fh;
    }

    return $output;
}

=pod

=head1 stopL4FarmNlb

Stop an existing farm in nftlb

Parameters:

    farm_name - farm name to be started
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - 0 on success or -1 on failure

=cut

sub stopL4FarmNlb ($farm_name, $writeconf) {
    require Relianoid::Farm::Core;

    my $out = &setL4FarmParam(($writeconf) ? 'bootstatus' : 'status', "down", $farm_name);

    return $out;
}

=pod

=head1 getL4FarmPidFile

Return the farm pid file

Parameters:

    farm_name - Name of the given farm

Returns:

    String - Pid file path or -1 on failure

=cut

sub getL4FarmPidFile ($farm_name) {
    my $piddir  = &getGlobalConfiguration('piddir');
    my $pidfile = "$piddir/$farm_name\_l4xnat.pid";

    return $pidfile;
}

=pod

=head1 sendL4NlbCmd

Send the param to Nlb for a L4 Farm

Parameters:

    self - hash that includes hash_keys:

    farm        - it is the farm that is going to be modified
    farm_new_name - this field is defined when the farm name is going to be modified.
    backend     - backend id to modify
    file        - file where the HTTP body response of the nftlb is saved
    method      - HTTP verb for nftlb request
    body        - body to use in POST and PUT requests

Returns:

    Integer - return code of the request command

=cut

sub sendL4NlbCmd ($self) {
    my $cfgfile = "";
    my $output  = -1;

    # load the configuration file first if the farm is down
    my $status = &getL4FarmStatus($self->{farm});
    if ($status ne "up") {
        my $out = &loadL4FarmNlb($self->{farm});
        return $out if ($out != 0);
    }

    # avoid farm configuration file destruction by asking nftlb only for modifications
    # or deletion of attributes of the farm
    if ($self->{method} =~ /PUT/
        || ($self->{method} =~ /DELETE/ && defined $self->{uri} && $self->{uri} =~ /farms\/.*\/.*/))
    {
        my $file  = "/tmp/get_farm_$$";
        my $match = 0;

        $output = &httpNlbRequest({
            method => "GET",
            uri    => "/farms/" . $self->{farm},
            file   => $file,
        });

        if (-e $file) {
            open my $fh, "<", $file;
            while (my $line = <$fh>) {
                if ($line =~ /\"name\"\: \"$$self{farm}\"/) {
                    $match = 1;
                    last;
                }
            }
            close $fh;
            unlink $file;
        }

        if (!$match) {
            &log_error("The farms was not loaded properly, trying it again");
            &loadL4FarmNlb($self->{farm});
        }
    }

    if ($self->{method} =~ /PUT|DELETE/) {
        $cfgfile = $self->{file};
        $self->{file} = "";
    }

    if (defined $self->{backend} && $self->{backend} ne "") {
        $self->{uri} = "/farms/$self->{farm}/backends/$self->{backend}";
    }
    elsif (!defined $self->{uri}) {
        $self->{uri} = "/farms";
        $self->{uri} = "/farms/$self->{farm}" if $self->{method} eq "DELETE";
    }

    # use the new name
    $self->{farm} = $self->{farm_new_name} if exists $self->{farm_new_name};

    $output = &httpNlbRequest($self);

    if ($self->{method} eq "GET" or not defined $self->{file}) {
        return $output;
    }

    # end if the farm was deleted
    if ($self->{method} eq "DELETE" and not exists $self->{backend}) {
        return $output;
    }

    # save the conf
    if ($self->{method} =~ /PUT|DELETE/) {
        $self->{file} = $cfgfile;
    }

    $self->{method} = "GET";
    $self->{uri}    = "/farms/" . $self->{farm};
    $self->{body}   = "";

    $output = &httpNlbRequest($self);

    return $output;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/L4xNAT/Backend.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Config;
use Relianoid::Nft;

my $configdir = &getGlobalConfiguration('configdir');
my $eload     = eval { require Relianoid::ELoad; };

=pod

=head1 Module

Relianoid::Farm::L4xNAT::Backend

=cut

=pod

=head1 setL4FarmServer

Edit a backend or add a new one if the id is not found

Parameters:

    farm_name - Farm name
    ids - Backend id
    ip - Backend IP
    port - Backend port
    weight - Backend weight. The backend with more weight will manage more connections
    priority - The priority of this backend (between 1 and 9). Higher priority backends will be used more often than lower priority ones
    max_conns - Maximum connections for the given backend

Returns:

    Integer - return 0 on success, -1 on NFTLB failure or -2 on IP duplicated.

Returns:

    Scalar - 0 on success or other value on failure
    FIXME: Stop returning -2 when IP duplicated, nftlb should do this

=cut

sub setL4FarmServer ($farm_name, $ids, $ip, $port = undef, $weight = undef, $priority = undef, $max_conns = undef) {
    require Relianoid::Farm::L4xNAT::Config;
    require Relianoid::Farm::L4xNAT::Action;
    require Relianoid::Farm::Backend;
    require Relianoid::Netfilter;

    my $farm_filename = &getFarmFile($farm_name);
    my $output        = 0;
    my $json          = qq();
    my $msg           = "setL4FarmServer << farm_name:$farm_name ids:$ids ";

    # load the configuration file first if the farm is down
    my $f_ref = &getL4FarmStruct($farm_name);
    if ($f_ref->{status} ne "up") {
        my $out = &loadL4FarmNlb($farm_name);
        return $out if ($out != 0);
    }

    my $exists = &getFarmServer($f_ref->{servers}, $ids);

    my $rip  = $ip;
    my $mark = "0x0";

    if (defined $port && $port ne "") {
        if (&ipversion($ip) == 4) {
            $rip = "$ip\:$port";
        }
        elsif (&ipversion($ip) == 6) {
            $rip = "[$ip]\:$port";
        }

        if (!defined $exists || (defined $exists && $exists->{port} ne $port)) {
            $json .= qq(, "port" : "$port");
            $msg  .= "port:$port ";
        }
    }
    elsif (defined $port && $port eq "") {
        $json .= qq(, "port" : "$port");
        $msg  .= "port:$port ";
    }

    if (   defined $ip
        && $ip ne ""
        && (!defined $exists || (defined $exists && $exists->{rip} ne $rip)))
    {
        my $existrip = &getFarmServer($f_ref->{servers}, $rip, "rip");
        return -2 if (defined $existrip && ($existrip->{id} ne $ids));
        $json = qq(, "ip-addr" : "$ip") . $json;
        $msg .= "ip:$ip ";

        if (!defined $exists) {
            $mark = &getNewMark($farm_name);
            return -1 if (!defined $mark || $mark eq "");
            $json .= qq(, "mark" : "$mark");
            $msg  .= "mark:$mark ";
        }
        else {
            $mark = $exists->{tag};
        }

        &setBackendRule("add", $f_ref, $mark) if ($f_ref->{status} eq "up");
    }

    if (
           defined $weight
        && $weight ne ""
        && (!defined $exists
            || (defined $exists && $exists->{weight} ne $weight))
      )
    {
        $weight = 1 if ($weight == 0);
        $json .= qq(, "weight" : "$weight");
        $msg  .= "weight:$weight ";
    }

    if (
           defined $priority
        && $priority ne ""
        && (!defined $exists
            || (defined $exists && $exists->{priority} ne $priority))
      )
    {
        $priority = 1 if ($priority == 0);
        $json .= qq(, "priority" : "$priority");
        $msg  .= "priority:$priority ";
    }

    if (
           defined $max_conns
        && $max_conns ne ""
        && (!defined $exists
            || (defined $exists && $exists->{max_conns} ne $max_conns))
      )
    {
        $max_conns = 0 if ($max_conns < 0);
        $json .= qq(, "est-connlimit" : "$max_conns");
        $msg  .= "maxconns:$max_conns ";
    }

    if (!defined $exists) {
        $json .= qq(, "state" : "up");
        $msg  .= "state:up ";
    }

    &log_info("$msg") if &debug();

    $output = &sendL4NlbCmd({
        farm   => $farm_name,
        file   => "$configdir/$farm_filename",
        method => "PUT",
        body   => qq({"farms" : [ { "name" : "$farm_name", "backends" : [ { "name" : "bck$ids"$json } ] } ] })
    });

    # take care of floating interfaces without masquerading
    if ($json =~ /ip-addr/ && $eload) {
        my $farm_ref = &getL4FarmStruct($farm_name);
        &eload(
            module => 'Relianoid::EE::Net::Floating',
            func   => 'setFloatingSourceAddr',
            args   => [ $farm_ref, { ip => $ip, id => $ids, tag => $mark } ],
        );
    }

    return $output;
}

=pod

=head1 runL4FarmServerDelete

Delete a backend from a l4 farm

Parameters:

    ids - Backend id
    farm_name - Farm name

Returns:

    Scalar - 0 on success or other value on failure

=cut

sub runL4FarmServerDelete ($ids, $farm_name) {
    require Relianoid::Farm::L4xNAT::Config;
    require Relianoid::Farm::L4xNAT::Action;
    require Relianoid::Netfilter;

    my $farm_filename = &getFarmFile($farm_name);
    my $output        = 0;
    my $mark          = "0x0";

    # load the configuration file first if the farm is down
    my $f_ref = &getL4FarmStruct($farm_name);

    $output = &sendL4NlbCmd({
        farm    => $farm_name,
        backend => "bck" . $ids,
        file    => "$configdir/$farm_filename",
        method  => "DELETE",
    });

    my $backend;
    for my $server (@{ $f_ref->{servers} }) {
        if ($server->{id} eq $ids) {
            $mark    = $server->{tag};
            $backend = $server;
            last;
        }
    }

    ### Flush conntrack
    &resetL4FarmBackendConntrackMark($backend);

    &setBackendRule("del", $f_ref, $mark);
    &delMarks("", $mark);

    return $output;
}

=pod

=head1 setL4FarmBackendsSessionsRemove

Remove all the active sessions enabled to a backend

Parameters:

    farm_name - Farm name
    backend_ref - Hash ref of Backend 
    farm_mode - Farm Mode

Returns:

    Integer - 0 on success , 1 on failure

=cut

sub setL4FarmBackendsSessionsRemove ($farm_name, $backend_ref = undef, $farm_mode = undef) {
    my $output = -1;
    if (not defined $backend_ref) {
        &log_warn("Warning removing sessions for backend id farm '$farm_name': Backend id not found", "lslb");
        return $output;
    }

    my $table;
    my $value_check;
    my $value_regex;
    if (defined $farm_mode and $farm_mode eq "dsr") {
        $table = "netdev";
        my $ip_bin    = &getGlobalConfiguration('ip_bin');
        my $mac       = &logAndRun("$ip_bin neigh show $backend_ref->{ip}");
        my @mac_split = split(' ', $mac);
        $value_check = $mac_split[4];
        $value_regex = qr/([a-fA-F0-9:]{1,})/;
    }
    else {
        $table = "ip";
        require Relianoid::Net::Validate;
        if (&ipversion($backend_ref->{ip}) == 6) {
            $table .= "6";
        }
        ($value_check = $backend_ref->{tag}) =~ s/0x//g;
        $value_regex = qr/0x0*(\d+)/;
    }

    my $nft_bin    = &getGlobalConfiguration('nft_bin');
    my $map_name   = "persist-$farm_name";
    my @persistmap = @{ &logAndGet("$nft_bin list map $table nftlb $map_name", "array") };
    my $data       = 0;

    my $sessions;
    my $n_sessions_deleted;
    for my $line (@persistmap) {
        $data = 1 if ($line =~ /elements = /);
        next      if (!$data);

        my ($key, $value) = ($line =~ /,?\s+([\w\.\s\:]+) expires \w+ : $value_regex[\s,]/);
        if ($value eq $value_check) {
            $sessions .= " $key,";
            $n_sessions_deleted++;
        }

        last if ($data and $line =~ /\}/);
    }

    if (defined $sessions) {
        chop $sessions;
        my $error = &logAndRun("$nft_bin delete element $table nftlb $map_name { $sessions }");
        if ($error) {
            &log_error("Error removing '$n_sessions_deleted' sessions for backend id '$backend_ref->{id}' in farm '$farm_name'",
                "lslb");
            $output = 1;
        }
        else {
            &log_info("Removing '$n_sessions_deleted' sessions for backend id '$backend_ref->{id}' in farm '$farm_name'", "lslb");
            $output = 0;
        }
    }
    else {
        # no sessions found
        $output = 0;
    }

    return $output;
}

=pod

=head1 setL4FarmBackendStatus

Set backend status for an l4 farm and stops traffic to that backend when needed.

Parameters:

    farm_name - Farm name
    backend - Backend id
    status - Backend status. The possible values are: "up", "down", "maintenance" or "fgDOWN".
    cutmode - "cut" to force the traffic stop for such backend

Returns:

    hash reference 

    $error_ref->{code}

        - 0 on success
        - 1 on failure changing status,
        - 2 on failure removing sessions
        - 3 on failure removing connections,
        - 4 on failure removing sessions and connections.

    $error_ref->{desc} - error message.

=cut

sub setL4FarmBackendStatus ($farm_name, $backend, $status, $cutmode = undef) {
    require Relianoid::Farm::L4xNAT::Config;
    require Relianoid::Farm::L4xNAT::Action;

    my $error_ref->{code} = -1;
    my $farm              = &getL4FarmStruct($farm_name);
    my $farm_filename     = $farm->{filename};
    my @backends;
    my @bks_prio_status;
    my @bks_updated_prio_status;
    my $output;
    my $msg;
    $status = 'off'  if ($status eq "maintenance");
    $status = 'down' if ($status eq "fgDOWN");

    #the following actions are only needed if a high priority backend turns up after being down/off and
    #a lower priority backend(s) turned active during the time the other backends was down/off
    if ($status eq 'up' and @{ $$farm{servers} } > 1) {
        my $i = 0;
        my $bk_index;
        for my $server (@{ $$farm{servers} }) {
            my $bk;
            $bk_index = $i if $backend == $server->{id};
            if ($server->{status} ne "up") {
                $bk->{status} = "down";
            }
            else {
                $bk->{status} = $server->{status};
            }
            $bk->{priority} = $server->{priority};
            push(@backends, $bk);
            $i++;
        }
        require Relianoid::Farm::Backend;
        @bks_prio_status =
          @{ &getPriorityAlgorithmStatus(\@backends)->{status} };
        $backends[$bk_index]->{status} = $status;
        @bks_updated_prio_status =
          @{ &getPriorityAlgorithmStatus(\@backends)->{status} };
    }

    $output = &sendL4NlbCmd({
        farm   => $farm_name,
        file   => "$configdir/$farm_filename",
        method => "PUT",
        body   =>
          qq({"farms" : [ { "name" : "$farm_name", "backends" : [ { "name" : "bck$backend", "state" : "$status" } ] } ] })
    });

    if ($output) {
        $msg = "Status of backend $backend in farm '$farm_name' was not changed to $status";
        &log_error($msg, "LSLB");
        $error_ref->{code} = 1;
        $error_ref->{desc} = $msg;
        return $error_ref;
    }
    else {
        $msg = "Status of backend $backend in farm '$farm_name' was changed to $status";
        &log_info($msg, "LSLB");
        $error_ref->{code} = 0;
        $error_ref->{desc} = $msg;
    }

    #compare priority status of all backends and delete sessions and connections of backends
    #that have had their priority status changed from true to false.
    my $i = 0;
    for my $bk (@bks_updated_prio_status) {
        if ($bk ne $bks_prio_status[$i]) {
            if (@{ $farm->{servers} }[$i]->{status} eq 'up') {
                if ($farm->{persist} ne '') {
                    # delete backend session
                    $output = &setL4FarmBackendsSessionsRemove($farm_name, @{ $farm->{servers} }[$i], $farm->{mode});
                    if ($output) {
                        $error_ref->{code} = 2;
                    }
                }

                # remove conntrack
                $output =
                  &resetL4FarmBackendConntrackMark(@{ $farm->{servers} }[$i]);
                if ($output) {
                    $msg               = "Connections for unused backends in farm '$farm_name' were not deleted";
                    $error_ref->{code} = 3;
                    $error_ref->{desc} = $msg;
                }

                if ($farm->{persist} ne '') {
                    # delete backend session again in case new connections are created
                    $output = &setL4FarmBackendsSessionsRemove($farm_name, @{ $farm->{servers} }[$i], $farm->{mode});
                    if ($output) {
                        if ($error_ref->{code} == 3) {
                            $msg               = "Connections and sessions of unused backends in farm '$farm_name' were not deleted";
                            $error_ref->{code} = 4;
                            $error_ref->{desc} = $msg;
                        }
                        else {
                            $msg               = "Sessions for unused backends in farm '$farm_name' were not deleted";
                            $error_ref->{code} = 2;
                            $error_ref->{desc} = $msg;
                        }
                    }
                    else {
                        $error_ref->{code} = 0 if $error_ref->{code} == 2;
                    }
                }
            }
        }
        $i++;
    }
    if ($status ne "up" and $cutmode eq "cut") {
        my $server;

        # get backend with id $backend
        for my $srv (@{ $$farm{servers} }) {
            if ($srv->{id} == $backend) {
                $server = $srv;
                last;
            }
        }

        if ($farm->{persist} ne '') {
            #delete backend session
            $output = &setL4FarmBackendsSessionsRemove($farm_name, $server, $farm->{mode});
            if ($output) {
                $error_ref->{code} = 2;
            }
        }

        # remove conntrack
        $output = &resetL4FarmBackendConntrackMark($server);
        if ($output) {
            $msg               = "Connections for backend $server->{ip}:$server->{port} in farm '$farm_name' were not deleted";
            $error_ref->{code} = 3;
            $error_ref->{desc} = $msg;
        }

        if ($farm->{persist} ne '') {
            # delete backend session again in case new connections are created
            $output = &setL4FarmBackendsSessionsRemove($farm_name, $server, $farm->{mode});
            if ($output) {
                if ($error_ref->{code} == 3) {
                    $msg = "Error deleting connections and sessions on backend $server->{ip}:$server->{port} in farm '$farm_name'";
                    $error_ref->{code} = 4;
                    $error_ref->{desc} = $msg;
                }
                else {
                    $msg               = "Sessions for backend $server->{ip}:$server->{port} in farm '$farm_name' were not deleted";
                    $error_ref->{code} = 2;
                    $error_ref->{desc} = $msg;
                }
            }
            else {
                $error_ref->{code} = 0 if $error_ref->{code} == 2;
            }
        }
    }
    if ($farm->{lbalg} eq 'leastconn') {
        require Relianoid::Farm::L4xNAT::L4sd;
        &sendL4sdSignal();
    }

    #~ TODO
    #~ my $stopping_fg = ( $caller =~ /runFarmGuardianStop/ );
    #~ if ( $fg_enabled eq 'true' && !$stopping_fg )
    #~ {
    #~ if ( $0 !~ /farmguardian/ && $fg_pid > 0 )
    #~ {
    #~ kill 'CONT' => $fg_pid;
    #~ }
    #~ }

    return $error_ref;
}

=pod

=head1 getL4FarmServers

Get all backends and their configuration

Parameters:

    farmname - Farm name

Returns:

    Array - array of hash refs of backend struct

=cut

sub getL4FarmServers ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);

    open my $fh, '<', "${configdir}/${farm_filename}";
    chomp(my @content = <$fh>);
    close $fh;

    return &_getL4FarmParseServers(\@content);
}

=pod

=head1 _getL4FarmParseServers

Return the list of backends with all data about a backend in a l4 farm

Parameters:

    config - plain text server list

Returns:

    array reference - reference to a list of backend hashes

    [
        {
            $id, 
            $alias, 
            $family, 
            $ip, 
            $port, 
            $tag, 
            $weight, 
            $priority, 
            $status, 
            $rip = $ip, 
            $max_conns
        },
        ...
    ]

=cut

sub _getL4FarmParseServers ($config) {
    my $stage = 0;
    my $server;
    my @servers;

    require Relianoid::Farm::L4xNAT::Config;
    my $fproto = &_getL4ParseFarmConfig('proto', undef, $config);

    for my $line (@{$config}) {
        if ($line =~ /\"farms\"/) {
            $stage = 1;
        }

        # do not go to the next level if empty
        if ($line =~ /\"backends\"/ && $line !~ /\[\],/) {
            $stage = 2;
        }

        if ($stage == 2 && $line =~ /\{/) {
            $stage = 3;
            undef $server;
        }

        if ($stage == 3 && $line =~ /\}/) {
            $stage = 2;
            push(@servers, $server);
        }

        if ($stage == 2 && $line =~ /\]/) {
            last;
        }

        if ($stage == 3 && $line =~ /\"name\"/) {
            my @l     = split(/"/, $line);
            my $index = $l[3];
            $index =~ s/bck//;
            $server->{id}        = $index + 0;
            $server->{port}      = undef;
            $server->{tag}       = "0x0";
            $server->{max_conns} = 0;
        }

        if ($stage == 3 && $line =~ /\"ip-addr\"/) {
            my @l = split(/"/, $line);
            $server->{ip}  = $l[3];
            $server->{rip} = $l[3];
        }

        if ($stage == 3 && $line =~ /\"source-addr\"/) {
            my @l = split(/"/, $line);
            $server->{sourceip} = $l[3];
        }

        if ($stage == 3 && $line =~ /\"port\"/) {
            my @l = split(/"/, $line);
            $server->{port} = $l[3];

            require Relianoid::Net::Validate;
            if ($server->{port} ne '' && $fproto ne 'all') {
                if (&ipversion($server->{rip}) == 4) {
                    $server->{rip} = "$server->{ip}\:$server->{port}";
                }
                elsif (&ipversion($server->{rip}) == 6) {
                    $server->{rip} = "[$server->{ip}]\:$server->{port}";
                }
            }

            # Convert to number after being used as string.
            if (defined $server->{port} and length $server->{port}) {
                $server->{port} += 0;
            }
        }

        if ($stage == 3 && $line =~ /\"weight\"/) {
            my @l = split(/"/, $line);
            $server->{weight} = $l[3] + 0;
        }

        if ($stage == 3 && $line =~ /\"priority\"/) {
            my @l = split(/"/, $line);
            $server->{priority} = $l[3] + 0;
        }

        if ($stage == 3 && $line =~ /\"mark\"/) {
            my @l = split(/"/, $line);
            $server->{tag} = $l[3];
        }

        if ($stage == 3 && $line =~ /\"est-connlimit\"/) {
            my @l = split(/"/, $line);
            $server->{max_conns} = $l[3] + 0;
        }

        if ($stage == 3 && $line =~ /\"state\"/) {
            my @l = split(/"/, $line);
            $server->{status} = $l[3];
            $server->{status} = "undefined"
              if ($server->{status} eq "config_error");
            $server->{status} = "maintenance" if ($server->{status} eq "off");
            $server->{status} = "fgDOWN"      if ($server->{status} eq "down");
            $server->{status} = "up"          if ($server->{status} eq "available");
        }
    }

    return \@servers;
}

=pod

=head1 getL4BackendsWeightProbability

Get probability for every backend

Parameters:

    farm - Farm hash ref. It is a hash with all information about the farm

Returns:

    none

=cut

sub getL4BackendsWeightProbability ($farm) {
    my $weight_sum = 0;

    &doL4FarmProbability($farm);

    for my $server (@{ $$farm{servers} }) {
        # only calculate probability for the servers running
        if ($$server{status} eq 'up') {
            $weight_sum += $$server{weight};
            $$server{prob} = $weight_sum / $$farm{prob};
        }
        else {
            $$server{prob} = 0;
        }
    }

    return;
}

=pod

=head1 resetL4FarmBackendConntrackMark

Reset Connection tracking for a given backend

Parameters:

    server - Backend hash reference. It uses the backend unique mark in order to deletes the conntrack entries.

Returns:

    scalar - 0 if deleted, 1 if not deleted

=cut

sub resetL4FarmBackendConntrackMark ($server) {
    my $conntrack = &getGlobalConfiguration('conntrack');
    my $cmd       = "$conntrack -D -m $server->{tag}/0x7fffffff";

    &log_info("running: $cmd") if &debug();

    # return_code = 0 -> deleted
    # return_code = 1 -> not found/deleted
    my $return_code = &logAndRunCheck("$cmd");

    #check if error in return_code is because connections were not found
    if ($return_code) {
        require Relianoid::Net::ConnStats;
        my $params = {
            proto => 'tcp sctp',
            mark  => "$server->{tag}/0x7fffffff",
            state => "ESTABLISHED"
        };
        my $conntrack_params = &getConntrackParams($params);
        my $conns            = &getConntrackCount($conntrack_params);

        #if connections are not found, no error
        $return_code = 0 if $conns == 0;
    }

    if (&debug()) {
        if ($return_code) {
            &log_info("Connection tracking for " . $server->{ip} . " not removed.");
        }
        else {
            &log_info("Connection tracking for " . $server->{ip} . " removed.");
        }
    }

    return $return_code;
}

=pod

=head1 getL4FarmBackendAvailableID

Get next available backend ID

Parameters:

    farmname - farm name

Returns:

    integer - backend ID available

=cut

sub getL4FarmBackendAvailableID ($farmname) {
    require Relianoid::Farm::Backend;

    my $backends  = &getL4FarmServers($farmname);
    my $nbackends = $#{$backends} + 1;

    for (my $id = 0 ; $id < $nbackends ; $id++) {
        my $exists = &getFarmServer($backends, $id);
        return $id if (!$exists);
    }

    return $nbackends;
}

=pod

=head1 getL4FarmPriorities

Get the list of the backends priorities in a L4 farm

Parameters:

    farmname - Farm name

Returns:

    Array Ref - it returns an array ref of priority values

=cut

sub getL4FarmPriorities ($farmname) {
    my @priorities;
    my $backends = &getL4FarmServers($farmname);

    for my $backend (@{$backends}) {
        if (defined $backend->{priority}) {
            push @priorities, $backend->{priority};
        }
        else {
            push @priorities, 1;
        }
    }

    return \@priorities;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/L4xNAT/Config.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Config;
use Relianoid::Nft;

my $eload     = eval { require Relianoid::ELoad };
my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::L4xNAT::Config

=cut

=pod

=head1 getL4FarmParam

Returns farm parameter

Parameters:

    param - requested parameter. The options are:

        "vip":          get the virtual IP
        "vipp":         get the virtual port
        "bootstatus":   get boot status
        "status":       get the current status
        "mode":         get the topology (or nat type)
        "alg":          get the algorithm
        "proto":        get the protocol
        "persist":      get persistence
        "persisttm":    get client persistence timeout
        "limitrst":     limit RST request per second
        "limitrstbrst": limit RST request per second burst
        "limitsec":     connection limit per second
        "limitsecbrst": Connection limit per second burst
        "limitconns":   total connections limit per source IP
        "bogustcpflags": check bogus TCP flags
        "nfqueue":      queue to verdict the packets
        "sourceaddr":   get the source address

    farm_name - Farm name

Returns:

    Scalar - return the parameter as a string or -1 on failure

=cut

sub getL4FarmParam ($param, $farm_name) {
    require Relianoid::Farm::Core;

    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    if ($param eq "status") {
        return &getL4FarmStatus($farm_name);
    }

    if ($param eq "alg") {
        require Relianoid::Farm::L4xNAT::L4sd;
        my $l4sched = &getL4sdType($farm_name);
        return $l4sched if ($l4sched ne "");
    }

    open my $fh, '<', "${configdir}/${farm_filename}";
    chomp(my @content = <$fh>);
    close $fh;

    $output = &_getL4ParseFarmConfig($param, undef, \@content);

    return $output;
}

=pod

=head1 setL4FarmParam

    Writes a farm parameter

Parameters:

    param - requested parameter. The options are:

        "name":         new farm name
        "family":       write ipv4 or ipv6
        "vip":          write the virtual IP
        "vipp":         write the virtual port
        "status" or "bootstatus":
                        write the status and boot status
        "mode":         write the topology (or nat type)
        "alg":          write the algorithm
        "proto":        write the protocol
        "persist":      write persistence
        "persisttm":    write client persistence timeout
        "limitrst":     limit RST request per second
        "limitrstbrst": limit RST request per second burst
        "limitsec":     connection limit per second
        "limitsecbrst": Connection limit per second burst
        "limitconns":   total connections limit per source IP
        "bogustcpflags": check bogus TCP flags
        "nfqueue":      queue to verdict the packets
        "policy":       policy list to be applied
        "sourceaddr":   set the source address

    value - the new value of the given parameter of a certain farm

    farm_name - Farm name

Returns:

    Scalar - return the parameter as a string or -1 on failure

=cut

sub setL4FarmParam ($param, $value, $farm_name) {
    require Relianoid::Farm::Core;

    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;
    my $srvparam      = "";
    my $addition      = "";
    my $prev_config   = "";
    my $farm_req      = $farm_name;
    my $parameters    = "";

    if ($param eq "name") {
        $farm_filename = "${value}_l4xnat.cfg";
        $farm_req      = $value;
        $parameters    = qq(, "newname" : "$value" );
    }
    elsif ($param eq "family") {
        $parameters = qq(, "family" : "$value" );
    }
    elsif ($param eq "mode") {
        $value      = "snat"     if ($value eq "nat");
        $value      = "stlsdnat" if ($value eq "stateless_dnat");
        $parameters = qq(, "mode" : "$value" );

        # deactivate leastconn and persistence for ingress modes
        if ($value eq "dsr" || $value eq "stateless_dnat") {
            require Relianoid::Farm::L4xNAT::L4sd;
            &setL4sdType($farm_name, "none");

            if ($eload) {
                # unassign DoS & RBL
                &eload(
                    module => 'Relianoid::EE::IPDS::Base',
                    func   => 'runIPDSStopByFarm',
                    args   => [ $farm_name, "dos" ],
                );
                &eload(
                    module => 'Relianoid::EE::IPDS::Base',
                    func   => 'runIPDSStopByFarm',
                    args   => [ $farm_name, "rbl" ],
                );
            }
        }

        # take care of floating interfaces without masquerading
        if ($value eq "snat" && $eload) {
            my $farm_ref = &getL4FarmStruct($farm_name);
            &eload(
                module => 'Relianoid::EE::Net::Floating',
                func   => 'setFloatingSourceAddr',
                args   => [ $farm_ref, undef ],
            );
        }
    }
    elsif ($param eq "vip") {
        $prev_config = &getFarmStruct($farm_name);
        require Relianoid::Net::Validate;
        my $vip_family = "ipv" . &ipversion($value);
        $parameters = qq(, "virtual-addr" : "$value", "family" : "$vip_family" );
    }
    elsif ($param eq "vipp" or $param eq "vport") {
        $value =~ s/\:/\-/g;
        if ($value eq "*") {
            $parameters = qq(, "virtual-ports" : "" );
        }
        else {
            $parameters = qq(, "virtual-ports" : "$value" );
        }
    }
    elsif ($param eq "alg") {
        $value = "rr" if ($value eq "roundrobin");

        if ($value eq "hash_srcip_srcport") {
            $value    = "hash";
            $addition = $addition . qq( , "sched-param" : "srcip srcport" );
        }

        if ($value eq "hash_srcip") {
            $value    = "hash";
            $addition = $addition . qq( , "sched-param" : "srcip" );
        }

        require Relianoid::Farm::L4xNAT::L4sd;
        if ($value eq "leastconn") {
            &setL4sdType($farm_name, $value);
            $value = "weight";
        }
        else {
            &setL4sdType($farm_name, "none");
        }

        $parameters = qq(, "scheduler" : "$value" ) . $addition;
    }
    elsif ($param eq "proto") {
        $srvparam = "protocol";

        &loadL4Modules($value);

        if ($value =~ /^ftp|irc|pptp|sane/) {
            $addition = $addition . qq( , "helper" : "$value" );
            $value    = "tcp";
        }
        elsif ($value =~ /tftp|snmp|amanda|netbios-ns/) {
            $addition = $addition . qq( , "helper" : "$value" );
            $value    = "udp";
        }
        elsif ($value =~ /all/) {
            $addition = $addition . qq( , "helper" : "none" );
            $addition = $addition . qq( , "virtual-ports" : "" );
        }
        elsif ($value =~ /sip|h323/) {
            $addition = $addition . qq( , "helper" : "$value" );
            $value    = "all";
        }
        else {
            $addition = $addition . qq( , "helper" : "none" );
        }

        $parameters = qq(, "protocol" : "$value" ) . $addition;
    }
    elsif ($param eq "status" || $param eq "bootstatus") {
        $parameters = qq(, "state" : "$value" );
    }
    elsif ($param eq "persist") {
        $value      = "srcip" if ($value eq "ip");
        $value      = "none"  if ($value eq "");
        $parameters = qq(, "persistence" : "$value" );
    }
    elsif ($param eq "persisttm") {
        $parameters = qq(, "persist-ttl" : "$value" );
    }
    elsif ($param eq "limitrst") {
        $parameters = qq(, "rst-rtlimit" : "$value" );
    }
    elsif ($param eq "limitrstbrst") {
        $parameters = qq(, "rst-rtlimit-burst" : "$value" );
    }
    elsif ($param eq "limitrst-logprefix") {
        $parameters = qq(, "rst-rtlimit-log-prefix" : "$value" );
    }
    elsif ($param eq "limitsec") {
        $parameters = qq(, "new-rtlimit" : "$value" );
    }
    elsif ($param eq "limitsecbrst") {
        $parameters = qq(, "new-rtlimit-burst" : "$value" );
    }
    elsif ($param eq "limitsec-logprefix") {
        $parameters = qq(, "new-rtlimit-log-prefix" : "$value" );
    }
    elsif ($param eq "limitconns") {
        $parameters = qq(, "est-connlimit" : "$value" );
    }
    elsif ($param eq "limitconns-logprefix") {
        $parameters = qq(, "est-connlimit-log-prefix" : "$value" );
    }
    elsif ($param eq "bogustcpflags") {
        $parameters = qq(, "tcp-strict" : "$value" );
    }
    elsif ($param eq "bogustcpflags-logprefix") {
        $parameters = qq(, "tcp-strict-log-prefix" : "$value" );
    }
    elsif ($param eq "nfqueue") {
        $parameters = qq(, "queue" : "$value" );
    }
    elsif ($param eq "sourceaddr") {
        $parameters = qq(, "source-addr" : "$value" );
    }
    elsif ($param eq 'policy') {
        $parameters = qq(, "policies" : [ { "name" : "$value" } ] );
    }
    elsif ($param eq "logs") {
        $srvparam   = "log";
        $value      = "forward" if ($value eq "true");
        $value      = "none"    if ($value eq "false");
        $parameters = qq(, "$srvparam" : "$value");
    }
    elsif ($param eq "log-prefix") {
        $srvparam   = "log-prefix";
        $value      = "l4:$farm_name ";
        $parameters = qq(, "$srvparam" : "$value");

        # TODO: put a warning msg when farm name is longer than nftables reserved log size
    }
    else {
        return -1;
    }

    require Relianoid::Farm::L4xNAT::Action;

    $output = &sendL4NlbCmd({
        farm          => $farm_name,
        farm_new_name => $farm_req,
        file          => ($param ne 'status') ? "$configdir/$farm_filename" : undef,
        method        => "PUT",
        body          => qq({"farms" : [ { "name" : "$farm_name"$parameters } ] })
    });

    # Finally, reload rules
    if ($param eq "vip") {
        &doL4FarmRules("reload", $farm_name, $prev_config)
          if ($prev_config->{status} eq "up");

        # reload source address maquerade
        require Relianoid::Farm::Config;
        &reloadFarmsSourceAddressByFarm($farm_name);
    }

    return $output;
}

=pod

=head1 _getL4ParseFarmConfig

Parse the farm file configuration and read/write a certain parameter

Parameters:

    param - requested parameter. The options are 
            "family", 
            "vip", 
            "vipp", 
            "status", 
            "mode", 
            "alg", 
            "proto", 
            "persist", 
            "presisttm", 
            "limitsec", 
            "limitsecbrst", 
            "limitconns", 
            "limitrst", 
            "limitrstbrst", 
            "bogustcpflags", 
            "nfqueue", 
            "sourceaddr"

    value - value to be changed in case of write operation, undef for read only cases

    config - reference of an array with the full configuration file

Returns:

    Scalar - return the parameter value on read or the changed value in case of write as a string or -1 in other case

=cut

sub _getL4ParseFarmConfig ($param, $value, $config) {
    my $output = -1;
    my $exit   = 1;

    for my $line (@{$config}) {
        if ($line =~ /\"family\"/ && $param eq 'family') {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"virtual-addr\"/ && $param eq 'vip') {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"virtual-ports\"/ && $param eq 'vipp') {
            my @l = split /"/, $line;
            $output = $l[3];
            $output = "*" if ($output eq '1-65535' || $output eq '');
            $output =~ s/-/:/g;
        }

        if ($line =~ /\"source-addr\"/ && $param eq 'sourceaddr') {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"mode\"/ && $param eq 'mode') {
            my @l = split /"/, $line;
            $output = $l[3];
            $output = "nat"            if ($output eq "snat");
            $output = "stateless_dnat" if ($output eq "stlsdnat");
        }

        if ($line =~ /\"protocol\"/ && $param eq 'proto') {
            my @l = split /"/, $line;
            $output = $l[3];
            $exit   = 0;
        }

        if ($line =~ /\"persistence\"/ && $param eq 'persist') {
            my @l   = split /"/, $line;
            my $out = $l[3];
            if ($out =~ /none/) {
                $output = "";
            }
            elsif ($out =~ /srcip/) {
                $output = "ip";
                $output = "srcip_srcport" if ($out =~ /srcport/);
                $output = "srcip_dstport" if ($out =~ /dstport/);
            }
            elsif ($out =~ /srcport/) {
                $output = "srcport";
            }
            elsif ($out =~ /srcmac/) {
                $output = "srcmac";
            }
            $exit = 0;
        }

        if ($line =~ /\"persist-ttl\"/ && $param eq 'persisttm') {
            my @l = split /"/, $line;
            $output = $l[3] + 0;
            $exit   = 0;
        }

        if ($line =~ /\"helper\"/ && $param eq 'proto') {
            my @l   = split /"/, $line;
            my $out = $l[3];

            $output = $out if ($out ne "none");
            $exit   = 1;
        }

        if ($line =~ /\"scheduler\"/ && $param eq 'alg') {
            my @l = split /"/, $line;
            $output = $l[3];

            $exit   = 0            if ($output =~ /hash/);
            $output = "roundrobin" if ($output eq "rr");
        }

        if ($line =~ /\"sched-param\"/ && $param eq 'alg') {
            my @l   = split /"/, $line;
            my $out = $l[3];

            if ($output eq "hash") {
                if ($out =~ /srcip/) {
                    $output = "hash_srcip";
                    $output = "hash_srcip_srcport" if ($out =~ /srcport/);
                }
            }
            $exit = 1;
        }

        if ($line =~ /\"log\"/ && $param eq 'logs') {
            my @l = split /"/, $line;
            $output = "false";
            $output = "true" if ($l[3] ne "none");
        }

        if ($line =~ /\"state\"/ && $param =~ /status/) {
            my @l = split /"/, $line;
            if ($l[3] ne "up") {
                $output = "down";
            }
            else {
                $output = "up";
            }
        }

        if ($line =~ /\"rst-rtlimit\"/ && $param eq "limitrst") {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"rst-rtlimit-burst\"/ && $param eq "limitrstbrst") {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"new-rtlimit\"/ && $param eq "limitsec") {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"new-rtlimit-burst\"/ && $param eq "limitsecbrst") {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"est-connlimit\"/ && $param eq "limitconns") {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"tcp-strict\"/ && $param eq "bogustcpflags") {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"queue\"/ && $param eq "nfqueue") {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($output ne "-1") {
            $line =~ s/$output/$value/g if defined $value;
            return $output              if ($exit);
        }
    }

    return $output;
}

=pod

=head1 modifyLogsParam

It enables or disables the logs for a l4xnat farm

Parameters:

    farmname - Farm name

    log value - The possible values are: 'true' to enable the logs or 'false' to disable them

Returns:

    String - return an error message on error or undef on success

=cut

sub modifyLogsParam ($farmname, $logsValue) {
    my $msg;
    my $err = 0;

    if ($logsValue =~ /(?:true|false)/) {
        $err = &setL4FarmParam('logs',       $logsValue, $farmname);
        $err = &setL4FarmParam('log-prefix', undef,      $farmname)
          if (not $err and $logsValue eq 'true');
    }
    else {
        $msg = "Invalid value for logs parameter.";
    }

    if ($err) {
        $msg = "Error modifying the parameter logs.";
    }
    return $msg;
}

=pod

=head1 getL4FarmStatus

Return current farm status

Parameters:

    farm_name - Farm name

Returns:

    String - "up" or "down"

=cut

sub getL4FarmStatus ($farm_name) {
    require Relianoid::Farm::L4xNAT::Action;

    my $pidfile = &getL4FarmPidFile($farm_name);
    my $output  = "down";

    my $nlbpid = &getNlbPid();
    if ($nlbpid eq "-1") {
        return $output;
    }

    $output = "up" if (-e "$pidfile");

    return $output;
}

=pod

=head1 getL4FarmStruct

Return a hash with all data about a l4 farm

Parameters:

    farmname - Farm name

Returns:

    hash ref - hash with farm values

    # %farm = 
    {
        $name,
        $filename,
        $nattype,
        $lbalg, 
        $vip, 
        $vport, 
        $vproto, 
        $sourceip, 
        $persist, 
        $ttl, 
        $proto, 
        $status, 
        \@servers
    }

    \@servers = [ \%backend1, \%backend2, ... ]

=cut

sub getL4FarmStruct ($farmname) {
    my %farm;

    $farm{name} = $farmname;

    require Relianoid::Farm::L4xNAT::Backend;

    $farm{filename} = &getFarmFile($farm{name});
    require Relianoid::Farm::Config;
    my $config = &getFarmPlainInfo($farm{name});

    $farm{nattype} = &_getL4ParseFarmConfig('mode', undef, $config);
    $farm{mode}    = $farm{nattype};

    require Relianoid::Farm::L4xNAT::L4sd;
    my $l4sched = &getL4sdType($farm{name});
    if ($l4sched ne "") {
        $farm{lbalg} = $l4sched;
    }
    else {
        $farm{lbalg} = &_getL4ParseFarmConfig('alg', undef, $config);
    }

    $farm{vip}      = &_getL4ParseFarmConfig('vip',   undef, $config);
    $farm{vport}    = &_getL4ParseFarmConfig('vipp',  undef, $config);
    $farm{vproto}   = &_getL4ParseFarmConfig('proto', undef, $config);
    $farm{sourceip} = "";
    $farm{sourceip} = &_getL4ParseFarmConfig('sourceaddr', undef, $config);

    my $persist = &_getL4ParseFarmConfig('persist', undef, $config);
    $farm{persist} = ($persist eq "-1") ? '' : $persist;
    my $ttl = &_getL4ParseFarmConfig('persisttm', undef, $config);
    $farm{ttl} = ($ttl == -1) ? 0 : $ttl;

    $farm{proto}      = &getL4ProtocolTransportLayer($farm{vproto});
    $farm{bootstatus} = &_getL4ParseFarmConfig('bootstatus', undef, $config);
    $farm{status}     = &getL4FarmStatus($farm{name});
    $farm{logs}       = &_getL4ParseFarmConfig('logs', undef, $config) if ($eload);
    $farm{servers}    = &_getL4FarmParseServers($config);

    if ($farm{lbalg} eq 'weight') {
        &getL4BackendsWeightProbability(\%farm);
    }

    return \%farm;
}

=pod

=head1 loadL4Modules

Load sip, ftp or tftp conntrack module for l4 farms

Parameters:

    protocol - protocol module to load

Returns:

    Integer - 0 if success, otherwise error

=cut

sub loadL4Modules ($protocol) {
    require Relianoid::Netfilter;

    my $status = 0;

    if ($protocol =~ /sip|tftp|ftp|amanda|h323|irc|netbios-ns|pptp|sane|snmp/) {
        my $params = "";
        $params = &getGlobalConfiguration("l4xnat_sip_params")
          if ($protocol eq "sip");
        $status = &loadNfModule("nf_conntrack_$protocol", $params);
        $status = $status || &loadNfModule("nf_nat_$protocol", "");
    }

    return $status;
}

=pod

=head1 unloadL4Modules

Unload conntrack helpers modules for l4 farms

Parameters:

    protocol - protocol module to load

Returns:

    Integer - 0 if success, otherwise error

=cut

sub unloadL4Modules ($protocol) {
    my $status = 0;

    require Relianoid::Netfilter;

    if ($protocol =~ /sip|tftp|ftp|amanda|h323|irc|netbios-ns|pptp|sane|snmp/) {
        my $n_farms = 0;
        require Relianoid::Farm::Core;
        for my $farm (&getFarmsByType("l4xnat")) {
            if (&getL4FarmParam('proto', $farm) eq $protocol) {
                $n_farms++ if (&getL4FarmStatus($farm) ne "down");
            }
        }
        if (not $n_farms) {
            $status = &removeNfModule("nf_nat_$protocol");
            $status = $status || &removeNfModule("nf_conntrack_$protocol");
        }
    }

    return $status;
}

=pod

=head1 getFarmPortList

If port is multiport, it removes range port and it passes it to a port list

Parameters:

    fvipp - Port string

Returns:

    array - return a list of ports

=cut

sub getFarmPortList ($fvipp) {
    my @portlist    = split(',', $fvipp);
    my @retportlist = ();

    if (!grep { /\*/ } @portlist) {
        for my $port (@portlist) {
            if ($port =~ /:/) {
                my @intlimits = split(':', $port);

                for (my $i = $intlimits[0] ; $i <= $intlimits[1] ; $i++) {
                    push(@retportlist, $i);
                }
            }
            else {
                push(@retportlist, $port);
            }
        }
    }
    else {
        $retportlist[0] = '*';
    }

    return @retportlist;
}

=pod

=head1 getL4ProtocolTransportLayer

Return basic transport protocol used by l4 farm protocol

Parameters:

    protocol - L4xnat farm protocol

Returns:

    String - "udp" or "tcp"

=cut

sub getL4ProtocolTransportLayer ($vproto) {
    return
        ($vproto =~ /sip|tftp/) ? 'udp'
      : ($vproto eq 'ftp')      ? 'tcp'
      :                           $vproto;
}

=pod

=head1 doL4FarmProbability

Create in the passed hash a new key called "prob". In this key is saved total weight of all backends

Parameters:

    farm - farm hash ref. It is a hash with all information about the farm

Returns:

    none

=cut

sub doL4FarmProbability ($farm) {
    $$farm{prob} = 0;

    for my $server_ref (@{ $$farm{servers} }) {
        if ($$server_ref{status} eq 'up') {
            $$farm{prob} += $$server_ref{weight};
        }
    }

    return;
}

=pod

=head1 doL4FarmRules

Created to operate with setBackendRule in order to start, stop or reload ip rules

Parameters:

    action - stop (delete all ip rules), start (create ip rules) or reload (delete old one stored in prev_farm_ref and create new)

    farm_name - farm hash ref. It is a hash with all information about the farm

    prev_farm_ref - farm reference of the old configuration. Optional.

Returns:

    none

=cut

sub doL4FarmRules ($action, $farm_name, $prev_farm_ref = undef) {
    my $farm_ref = &getL4FarmStruct($farm_name);

    require Relianoid::Farm::Backend;

    for my $server (@{ $farm_ref->{servers} }) {
        if ($action eq "stop") {
            &setBackendRule("del", $farm_ref, $server->{tag});
        }
        elsif ($action eq "reload") {
            &setBackendRule("del", $prev_farm_ref, $server->{tag});
            &setBackendRule("add", $farm_ref,      $server->{tag});
        }
        elsif ($action eq "start") {
            &setBackendRule("add", $farm_ref, $server->{tag});
        }
    }

    return;
}

=pod

=head1 writeL4NlbConfigFile

Write the L4 config file from a curl Nlb request, by filtering IPDS parameters.

Parameters:

    nftfile - temporary file captured from the nftlb farm configuration

    cfgfile - definitive file where the definitive nftlb farm configuration will be stored

Returns:

    Integer - 0 if success, other if error.

=cut

sub writeL4NlbConfigFile ($nftfile, $cfgfile) {
    require Relianoid::Lock;

    if (!-e "$nftfile") {
        return 1;
    }

    &log_debug("Saving farm conf '$cfgfile'");

    my $fo = &openlock($cfgfile, 'w');

    my @lines = ();
    if (open(my $fh, '<', $nftfile)) {
        @lines = <$fh>;
        close $fh;
    }

    my $line  = shift @lines;
    my $write = 1;
    my $next_line;

    while (defined $line) {
        $next_line = shift @lines;
        $write     = 0 if ($line =~ /\"policies\"\:/);

        if (   defined($next_line)
            && $next_line =~ /\"policies\"\:/
            && $line      =~ /\]/)
        {
            $line =~ s/,$//g;
            $line =~ s/\n//g;
        }
        print $fo $line
          if ( $line !~ /new-rtlimit|rst-rtlimit|tcp-strict|queue|^[\s]{24}.est-connlimit/
            && $write == 1);

        if ($write == 0 && $line =~ /\]/) {
            $write = 1;
            if ($next_line =~ /\"sessions\"\:/) {
                print $fo ",\n";
            }
            else {
                print $fo "\n";
            }
        }

        $line = $next_line;
    }

    close $fo;
    unlink $nftfile;

    return 0;
}

=pod

=head1 resetL4FarmConntrack

Reset Connection tracking for a given farm

Parameters:

    farm_name

Returns:

    error: 1 in case of error and 0 otherwise

=cut

sub resetL4FarmConntrack ($farm_name) {
    my $error = 0;

    my $servers = &getL4FarmServers($farm_name);
    for my $server (@{$servers}) {
        &resetL4FarmBackendConntrackMark($server);
    }

    # Check there are not connections
    require Relianoid::Farm::L4xNAT::Stats;
    require Relianoid::Net::ConnStats;
    my $vip     = &getL4FarmParam("vip", $farm_name);
    my $netstat = &getConntrack('', $vip, '', '', '');
    my $conns   = &getL4FarmEstConns($farm_name, $netstat);
    $conns += &getL4FarmSYNConns($farm_name, $netstat);

    if ($conns > 0) {
        &log_error("Error flushing conntrack for $farm_name");
        $error = 1;
    }

    return $error;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/L4xNAT/Factory.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Core;
use Relianoid::Farm::L4xNAT::Action;

my $configdir = &getGlobalConfiguration('configdir');

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::L4xNAT::Factory

=cut

=pod

=head1 runL4FarmCreate

Create a l4xnat farm

Parameters:

    vip - Virtual IP
    farm_name - Farm name
    vip_port - Virtual port. In l4xnat it ls possible to define multiport
               using ',' to add ports and ':' for ranges
    status - Set the initial status of the farm. The possible values are:
             - 'down' for creating the farm and do not run it
             - 'up' (default) for running the farm when it has been created

Returns:

    Integer - return 0 on success or other value on failure

=cut

sub runL4FarmCreate ($vip, $farm_name, $vip_port, $status = 'up') {
    my $output        = -1;
    my $farm_type     = 'l4xnat';
    my $farm_filename = "$configdir/$farm_name\_$farm_type.cfg";

    require Relianoid::Farm::L4xNAT::Action;
    require Relianoid::Farm::L4xNAT::Config;

    my $proto = ($vip_port eq "*") ? 'all' : 'tcp';
    $vip_port = "80" if not defined $vip_port;
    $vip_port = ""   if ($vip_port eq "*");
    $vip_port =~ s/\:/\-/g;

    require Relianoid::Net::Validate;
    my $vip_family;
    if (&ipversion($vip) == 6) {
        $vip_family = "ipv6";
    }
    else {
        $vip_family = "ipv4";
    }

    $output = &sendL4NlbCmd({
        farm   => $farm_name,
        file   => "$farm_filename",
        method => "POST",
        body   =>
          qq({"farms" : [ { "name" : "$farm_name", "virtual-addr" : "$vip", "virtual-ports" : "$vip_port", "protocol" : "$proto", "mode" : "snat", "scheduler" : "weight", "state" : "$status", "family" : "$vip_family" } ] })
    });

    if ($output) {
        require Relianoid::Farm::Action;
        &runFarmDelete($farm_name);
        return 1;
    }

    if ($status eq 'up') {
        $output = &startL4Farm($farm_name);
    }

    return $output;
}

=pod

=head1 runL4FarmDelete

Delete a l4xnat farm

Parameters:

    farm_name - Farm name

Returns:

    Integer - return 0 on success or other value on failure

=cut

sub runL4FarmDelete ($farm_name) {
    my $output = -1;

    require Relianoid::Farm::L4xNAT::Action;
    require Relianoid::Farm::L4xNAT::Config;
    require Relianoid::Farm::Core;
    require Relianoid::Netfilter;

    my $farmfile = &getFarmFile($farm_name);

    $output = &sendL4NlbCmd({ farm => $farm_name, method => "DELETE" });

    unlink("$configdir/$farmfile") if (-f "$configdir/$farmfile");

    &delMarks($farm_name, "");

    return $output;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/L4xNAT/L4sd.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::Farm::L4xNAT::L4sd

=cut

=pod

=head1 runL4sdDaemon

Launch the l4sd daemon if it's not already launched

Parameters:

    none

Returns:

    Integer - Error code: 0 on success or other value on failure
=cut

sub runL4sdDaemon () {
    my $l4sdbin = &getGlobalConfiguration('l4sd');
    my $pidfile = &getGlobalConfiguration('l4sdpid');

    if (!-f "$pidfile") {
        return &logAndRunBG($l4sdbin);
    }

    return -1;
}

=pod

=head1 sendL4sdSignal

Send a USR1 signal to L4sd

Parameters:

    none

Returns:

    Integer - Error code: 0 on success or other value on failure
=cut

sub sendL4sdSignal () {
    my $output  = -1;
    my $pidfile = &getGlobalConfiguration('l4sdpid');

    &runL4sdDaemon();

    # read pid number
    open my $fh, "<", $pidfile or return -1;
    my $pid = <$fh>;
    close $fh;

    my $success = kill USR1 => $pid;
    $output = 0 if $success;

    return $output;
}

=pod

=head1 getL4sdType

Obtain if a given farm has l4sd and its type

Parameters:

    farm_name - Name of the farm to search for l4sd configuration

Returns:

    String - Returns a string with the type of dynamic scheduler, empty if none.
=cut

sub getL4sdType ($farm_name) {
    my $output   = "";
    my $l4sdfile = &getGlobalConfiguration('l4sdcfg');

    if (!-f "$l4sdfile") {
        return $output;
    }

    require Config::Tiny;
    my $config = Config::Tiny->read($l4sdfile);
    if (defined $config->{$farm_name} && exists $config->{$farm_name}) {
        $output = $config->{$farm_name}{type};
    }

    return $output;
}

=pod

=head1 setL4sdType

Obtain if a given farm has l4sd and its type

Parameters:

    farm_name - Name of the farm to search for l4sd configuration

    type - Type of dynamic scheduler (ex: leastconn, none )

Returns:

    String - Returns a string with the type of dynamic scheduler, empty if none.

=cut

sub setL4sdType ($farm_name, $type) {
    my $l4sdfile = &getGlobalConfiguration('l4sdcfg');

    if (!-f "$l4sdfile") {
        if(open my $fh, '>', $l4sdfile) {
            close $fh;
        }
        else {
            &log_error("Could not create file $l4sdfile: $!", "L4SD");
            return -1;
        }
    }

    require Config::Tiny;
    my $config = Config::Tiny->read($l4sdfile);

    if ($type eq "none") {
        delete $config->{$farm_name};
    }
    elsif ($type eq "leastconn") {
        $config->{$farm_name}{type} = $type;
    }
    $config->write($l4sdfile);

    &sendL4sdSignal();

    return 0;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/L4xNAT/Service.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::L4xNAT::Service

=cut

=pod

=head1 loadL4FarmModules

Load L4farm system modules and conntrack

Parameters:

    none

Returns:

    Integer - 0 on success or any other value on failure

=cut

sub loadL4FarmModules () {
    my $modprobe_bin = &getGlobalConfiguration("modprobe");
    my $error        = 0;
    if ($eload) {
        my $cmd = "$modprobe_bin nf_conntrack enable_hooks=1";
        $error += &logAndRun("$cmd");
    }
    else {
        $error += &logAndRun("$modprobe_bin nf_conntrack");

        # Initialize conntrack
        my $nftbin = &getGlobalConfiguration("nft_bin");

        # Flush nft tables
        &logAndRun("$nftbin flush table ip dummyTable");

        my $nftCmd =
          "$nftbin add table ip dummyTable; $nftbin add chain ip dummyTable dummyChain { type nat hook input priority 0 \\; }; $nftbin add rule ip dummyTable dummyChain ct state established accept";

        $error += &logAndRun("$nftCmd")
          if (&logAndRunCheck("$nftbin list table dummyTable"));
    }

    return $error;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/L4xNAT/Sessions.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::L4xNAT::Config;

=pod

=head1 Module

Relianoid::Farm::L4xNAT::Sessions

=cut

=pod

=head1 parseL4FarmSessions

It transform the session output of nftlb output in a Relianoid session struct

Parameters:

    session ref - It is the session hash returned for nftlb. Example:

    session = {
        'expiration' => '1h25m31s364ms',
        'backend' => 'bck0',
        'client' => '192.168.10.162'
    }

Returns:

    Hash ref - It is a hash with the following keys:

    'session' 

        Returns the session token.

    'id'

        Returns the backen linked with the session token.
        If any session was found the function will return 'undef'.

    'type'

        Will have the value:

        - 'static' if the session is preloaded by the user.
        - 'dynamic' if the session is created automatically by the system when the connection arrives.

    'ttl'

        Is the time out of the session.
        This field will be 'undef' when the session is static.

        {
            "id" : 3,
            "session" : "192.168.1.186"
            "type" : "dynamic"
            "ttl" : "1h25m31s364ms"
        }

=cut

sub parseL4FarmSessions ($s) {
    # translate session
    my $session = $s->{client};
    $session =~ s/ \. /_/;

    my $obj = {
        'session' => $session,
        'type'    => (exists $s->{expiration}) ? 'dynamic'        : 'static',
        'ttl'     => (exists $s->{expiration}) ? $s->{expiration} : undef,
    };

    if ($s->{backend} =~ /bck(\d+)/) {
        $obj->{id} = $1;
    }

    return $obj;
}

=pod

=head1 listL4FarmSessions

Get a list of the static and dynamic l4 sessions in a farm. Using nftlb

Parameters:

    farmname - Farm name

Returns:

    array ref - Returns a list of hash references with the following parameters:

    "client" 

        is the client position entry in the session table

    "id"

        is the backend id assigned to session

    "session"

        is the key that identifies the session

    "type"

        is the key that identifies the session

    [
        {
            "client" : 0,
            "id" : 3,
            "session" : "192.168.1.186",
            "type" : "dynamic",
            "ttl" : "54m5s",
        }
    ]

=cut

sub listL4FarmSessions ($farmname) {
    require Relianoid::Lock;
    require Relianoid::JSON;
    require Relianoid::Nft;

    my $farm     = &getL4FarmStruct($farmname);
    my @sessions = ();
    my $it;

    return [] if ($farm->{persist} eq "");

    my $session_tmp = "/tmp/session_$farmname.data";
    my $lock_f      = &getLockFile($session_tmp);
    my $lock_fd     = &openlock($lock_f, 'w');
    my $err         = &sendL4NlbCmd({
        method => "GET",
        uri    => "/farms/" . $farmname . '/sessions',
        farm   => $farmname,
        file   => $session_tmp,
    });

    my $nftlb_resp;
    if (!$err) {
        $nftlb_resp = &decodeJSONFile($session_tmp);
    }

    close $lock_fd;

    if ($err or not defined $nftlb_resp) {
        return [];
    }

    my $client_id = 0;
    my $backend_info;
    for my $bck (@{ $farm->{servers} }) {
        $backend_info->{ $bck->{id} }{ip}   = $bck->{ip};
        $backend_info->{ $bck->{id} }{port} = $bck->{port};
    }

    for my $s (@{ $nftlb_resp->{sessions} }) {
        $it                 = &parseL4FarmSessions($s);
        $it->{client}       = $client_id++;
        $it->{backend_ip}   = $backend_info->{ $it->{id} }{ip};
        $it->{backend_port} = $backend_info->{ $it->{id} }{port};
        push @sessions, $it;
    }

    return \@sessions;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/L4xNAT/Stats.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::Farm::L4xNAT::Stats

=cut

=pod

=head1 getL4BackendEstConns

Get all ESTABLISHED connections for a backend

Parameters:

    farm_name - Farm name
    be_ip - IP backend
    be_port - Backend port
    netstat - reference to array with Conntrack -L output

Returns:

    array - Return all ESTABLISHED conntrack lines for the backend

FIXME:

    dnat and nat regexp is duplicated

=cut

sub getL4BackendEstConns ($farm_name, $be_ip, $be_port, $netstat) {
    my $farm = &getL4FarmStruct($farm_name);

    my @fportlist   = &getFarmPortList($farm->{vport});
    my $regexp      = "";
    my $connections = 0;
    my $add_search  = "";

    #if there is a backend port then must be included in the filter
    if ($be_port > 0) {
        $add_search = "sport=$be_port";
    }

    if ($fportlist[0] !~ /\*/) {
        $regexp = "\(" . join('|', @fportlist) . "\)";
    }
    else {
        $regexp = "\.*";
    }

    if ($farm->{mode} eq "dnat") {
        if (   $farm->{proto} eq "sip"
            || $farm->{proto} eq "all"
            || $farm->{proto} eq "tcp")
        {
            # i.e.
            # tcp      6 431998 ESTABLISHED src=192.168.0.168 dst=192.168.100.241 sport=40130 dport=81 src=192.168.100.254 dst=192.168.100.241 sport=80 dport=40130 [ASSURED] mark=523 use=1
            #protocol				 status		      client                         vip                                                           vport          backend_ip                   (vip, but can change)    backend_port
            $connections += scalar @{
                &getNetstatFilter("tcp", "",
                    "\.* ESTABLISHED src=\.* dst=$farm->{vip} \.* dport=$regexp \.*src=$be_ip \.*$add_search",
                    "", $netstat)
            };
        }
        if (   $farm->{proto} eq "sip"
            || $farm->{proto} eq "all"
            || $farm->{proto} eq "udp")
        {
            $connections += scalar @{
                &getNetstatFilter("udp", "", "\.* src=\.* dst=$farm->{vip} \.* dport=$regexp .*src=$be_ip \.*$add_search",
                    "", $netstat)
            };
        }
    }
    else {
        if (   $farm->{proto} eq "sip"
            || $farm->{proto} eq "all"
            || $farm->{proto} eq "tcp")
        {
            $connections += scalar @{
                &getNetstatFilter("tcp", "",
                    "\.*ESTABLISHED src=\.* dst=$farm->{vip} sport=\.* dport=$regexp \.*src=$be_ip \.*$add_search",
                    "", $netstat)
            };
        }
        if (   $farm->{proto} eq "sip"
            || $farm->{proto} eq "all"
            || $farm->{proto} eq "udp")
        {
            $connections += scalar @{
                &getNetstatFilter("udp", "", "\.* src=\.* dst=$farm->{vip} \.* dport=$regexp .*src=$be_ip \.*$add_search",
                    "", $netstat)
            };
        }
    }

    return $connections;
}

=pod

=head1 getL4FarmEstConns

Get all ESTABLISHED connections for a farm

Parameters:

    farm_name - Farm name
    netstat - reference to array with Conntrack -L output

Returns:

    array - Return all ESTABLISHED conntrack lines for a farm

FIXME:

    dnat and nat regexp is duplicated

=cut

sub getL4FarmEstConns ($farm_name, $netstat) {
    require Relianoid::Net::ConnStats;

    my $farm = &getL4FarmStruct($farm_name);

    # states : NONE | SYN_SENT | SYN_RECV | ESTABLISHED | FIN_WAIT | CLOSE_WAIT | LAST_ACK | TIME_WAIT | CLOSE | LISTEN
    my $established_filter = '(?:SYN_RECV|ESTABLISHED|FIN_WAIT|CLOSE_WAIT|LAST_ACK)';

    my @fportlist   = &getFarmPortList($farm->{vport});
    my $regexp      = "";
    my $connections = 0;

    if ($fportlist[0] !~ /\*/) {
        $regexp = "\(" . join('|', @fportlist) . "\)";
    }
    else {
        $regexp = "\.*";
    }

    my $backends = &getL4FarmServers($farm_name);

    for my $backend (@{$backends}) {
        if ($backend->{status} eq "up") {
            if ($farm->{mode} eq "dnat") {
                if (   $farm->{proto} eq "sip"
                    || $farm->{proto} eq "all"
                    || $farm->{proto} eq "tcp")
                {
                    $connections += scalar @{
                        &getNetstatFilter("tcp", "",
                            "\.* $established_filter src=\.* dst=$farm->{vip} \.* dport=$regexp .*src=$backend->{ip} \.*",
                            "", $netstat)
                    };
                }

                if (   $farm->{proto} eq "sip"
                    || $farm->{proto} eq "all"
                    || $farm->{proto} eq "udp")
                {
                    $connections += scalar @{
                        &getNetstatFilter("udp", "", "\.* src=\.* dst=$farm->{vip} \.* dport=$regexp .*src=$backend->{ip} \.*",
                            "", $netstat)
                    };
                }
            }
            else {
                if (   $farm->{proto} eq "sip"
                    || $farm->{proto} eq "all"
                    || $farm->{proto} eq "tcp")
                {
                    $connections += scalar @{
                        &getNetstatFilter("tcp", "",
                            "\.* $established_filter src=\.* dst=$farm->{vip} \.* dport=$regexp .*src=$backend->{ip} \.*",
                            "", $netstat)
                    };
                }

                if (   $farm->{proto} eq "sip"
                    || $farm->{proto} eq "all"
                    || $farm->{proto} eq "udp")
                {
                    $connections += scalar @{ &getNetstatFilter("udp", "",
                            "\.* src=\.* dst=$farm->{vip} \.* dport=$regexp .*src=$backend->{ip}", "", $netstat) };
                }
            }
        }
    }

    return $connections;
}

=pod

=head1 getL4BackendSYNConns

Get all SYN connections for a backend. This connection are called "pending".

UDP protocol doesn't have pending concept

Parameters:

    farmname - Farm name
    be_ip - IP backend
    be_port - Backend port
    netstat - reference to array with Conntrack -L output

Returns:

    array - Return all SYN conntrack lines for a backend of a farm

FIXME:

    dnat and nat regexp is duplicated

=cut

sub getL4BackendSYNConns ($farm_name, $be_ip, $be_port, $netstat) {
    my $farm = &getL4FarmStruct($farm_name);

    my @fportlist   = &getFarmPortList($farm->{vport});
    my $regexp      = "";
    my $connections = 0;
    my $add_search  = "";

    #if there is a backend port then must be included in the filter
    if ($be_port > 0) {
        $add_search = "sport=$be_port";
    }

    if ($fportlist[0] !~ /\*/) {
        $regexp = "\(" . join('|', @fportlist) . "\)";
    }
    else {
        $regexp = "\.*";
    }

    if ($farm->{mode} eq "dnat") {
        if (   $farm->{proto} eq "sip"
            || $farm->{proto} eq "all"
            || $farm->{proto} eq "tcp")
        {
            $connections += scalar @{
                &getNetstatFilter("tcp", "", "\.* SYN\.* src=\.* dst=$farm->{vip} \.* dport=$regexp \.* src=$be_ip \.*$add_search",
                    "", $netstat)
            };
        }

        # udp doesn't have pending connections
    }
    else {
        if (   $farm->{proto} eq "sip"
            || $farm->{proto} eq "all"
            || $farm->{proto} eq "tcp")
        {
            $connections += scalar @{
                &getNetstatFilter("tcp", "", "\.* SYN\.* src=\.* dst=$farm->{vip} \.* dport=$regexp \.* src=$be_ip \.*$add_search",
                    "", $netstat)
            };
        }

        # udp doesn't have pending connections
    }

    return $connections;
}

=pod

=head1 getL4FarmSYNConns

Get all SYN connections for a farm. This connection are called "pending". 

UDP protocol doesn't have pending concept

Parameters:

    farm_name - Farm name
    netstat - reference to array with Conntrack -L output

Returns:

    array - Return all SYN conntrack lines for a farm

FIXME:

    dnat and nat regexp is duplicated

=cut

sub getL4FarmSYNConns ($farm_name, $netstat) {
    my $farm = &getL4FarmStruct($farm_name);

    my @fportlist   = &getFarmPortList($farm->{vport});
    my $regexp      = "";
    my $connections = 0;

    if ($fportlist[0] !~ /\*/) {
        $regexp = "\(" . join('|', @fportlist) . "\)";
    }
    else {
        $regexp = ".*";
    }

    my $backends = &getL4FarmServers($farm_name);

    # tcp      6 299 ESTABLISHED src=192.168.0.186 dst=192.168.100.241 sport=56668 dport=80 src=192.168.0.186 dst=192.168.100.241 sport=80 dport=56668 [ASSURED] mark=517 use=2
    for my $backend (@{$backends}) {
        if ($backend->{status} eq "up") {
            if ($farm->{mode} eq "dnat") {
                if (   $farm->{proto} eq "sip"
                    || $farm->{proto} eq "all"
                    || $farm->{proto} eq "tcp")
                {
                    $connections += scalar @{
                        &getNetstatFilter("tcp", "", "\.* SYN\.* src=\.* dst=$farm->{vip} \.* dport=$regexp \.* src=$backend->{ip} \.*",
                            "", $netstat)
                    };
                }

                # udp doesn't have pending connections
            }
            else {
                if (   $farm->{proto} eq "sip"
                    || $farm->{proto} eq "all"
                    || $farm->{proto} eq "tcp")
                {
                    $connections += scalar @{
                        &getNetstatFilter("tcp", "", "\.* SYN\.* src=\.* dst=$farm->{vip} \.* dport=$regexp \.* src=$backend->{ip} \.*",
                            "", $netstat)
                    };
                }

                # udp doesn't have pending connections
            }
        }
    }

    return $connections;
}

=pod

=head1 getL4FarmBackendsStats

Parameters:

    farmname - Farm name

Returns:

    array ref

=cut

sub getL4FarmBackendsStats ($farmname) {
    require Relianoid::Net::ConnStats;
    require Relianoid::Farm::L4xNAT::Config;

    # Get list of backend hashes and add stats
    my $farm_st  = &getL4FarmStruct($farmname);
    my $backends = $farm_st->{servers};

    for my $be (@{$backends}) {
        # Copy port value, to keep getL4BackendEstConns and
        # getL4BackendSYNConns from converting it to string.
        my $port    = $be->{port};
        my $netstat = &getConntrack("", $farm_st->{vip}, $be->{ip}, "", "");

        # Established
        $be->{established} =
          &getL4BackendEstConns($farmname, $be->{ip}, $port, $netstat);

        # Pending
        $be->{pending} = 0;

        if ($farm_st->{proto} ne "udp") {
            $be->{pending} =
              &getL4BackendSYNConns($farmname, $be->{ip}, $port, $netstat);
        }
    }

    return $backends;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/Service.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::Service

=cut

=pod

=head1 getFarmServices

Get a list of services name for a farm

Parameters:

    farm_name - Farm name

Returns:

    Array - list of service names 

=cut

sub getFarmServices ($farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my @output    = ();

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Service;
        @output = &getHTTPFarmServices($farm_name);
    }
    elsif ($farm_type eq "gslb" && $eload) {
        @output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Service',
            func   => 'getGSLBFarmServices',
            args   => [$farm_name],
        ) if $eload;
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        @output = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Service',
            func   => 'getEproxyFarmServices',
            args   => [{ farm_name => $farm_name }],
        ) if $eload;
    }

    return @output;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/Stats.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::Stats

=cut

=pod

=head1 getFarmEstConns

Get all ESTABLISHED connections for a farm

Parameters:

    farm_name - Farm name
    netstat   - reference to array with Conntrack -L output

Returns:

    unsigned integer - Return number of ESTABLISHED conntrack lines for a farm

=cut

sub getFarmEstConns ($farm_name, $netstat) {
    my $farm_type   = &getFarmType($farm_name);
    my $connections = 0;

    if ($farm_type eq "http" || $farm_type eq "https") {
        my @pid = &getFarmPid($farm_name);
        return $connections if (!@pid);
        require Relianoid::Farm::HTTP::Stats;
        $connections = &getHTTPFarmEstConns($farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Stats;
        $connections = &getL4FarmEstConns($farm_name, $netstat);
    }
    elsif ($farm_type eq "gslb") {
        my @pid = &getFarmPid($farm_name);
        return $connections if (!@pid);
        $connections = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Stats',
            func   => 'getGSLBFarmEstConns',
            args   => [ $farm_name, $netstat ],
        ) if $eload;
    }

    return $connections;
}

=pod

=head1 getBackendSYNConns

Get all SYN connections for a backend

Parameters:

    farm_name    - Farm name
    ip_backend   - IP backend
    port_backend - backend port
    netstat      - reference to array with Conntrack -L output

Returns:

    integer - Return number of SYN conntrack lines for a backend of a farm or -1 if error

=cut

sub getBackendSYNConns ($farm_name, $ip_backend, $port_backend, $netstat = undef) {
    my $farm_type   = &getFarmType($farm_name);
    my $connections = 0;

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Stats;
        $connections = &getHTTPBackendSYNConns($farm_name, $ip_backend, $port_backend);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Stats;
        $connections = &getL4BackendSYNConns($farm_name, $ip_backend, $port_backend, $netstat);
    }

    return $connections;
}

=pod

=head1 getFarmSYNConns

Get all SYN connections for a farm

Parameters:

    farm_name - Farm name
    netstat   - reference to array with Conntrack -L output

Returns:

    unsigned integer - Return number of SYN conntrack lines for a farm

=cut

sub getFarmSYNConns ($farm_name, $netstat = undef) {
    my $farm_type   = &getFarmType($farm_name);
    my $connections = 0;

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Stats;
        $connections = &getHTTPFarmSYNConns($farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Stats;
        $connections = &getL4FarmSYNConns($farm_name, $netstat);
    }

    return $connections;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Farm/Validate.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2020-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::Farm::Validate

=cut

=pod

=head1 priorityAlgorithmIsOK

This funcion receives a list of priority values and it checks if all backends will be started according to priority Algorithm

Parameters:

    Priorities - Array reference to priorities to check

Returns:

    Integer - Return 0 if valid priority settings, unsuitable priority value if not.

=cut

sub priorityAlgorithmIsOK ($priority_ref) {
    use List::Util qw( min max );
    my @backends = sort @{$priority_ref};
    my @backendstmp;

    my $prio_last = 0;
    for my $prio_cur (@backends) {
        if ($prio_cur != $prio_last) {
            my $n_backendstmp = @backendstmp;
            return $prio_cur if ($prio_cur > ($n_backendstmp + 1));
            push @backendstmp, $prio_cur;
            $prio_last = $prio_cur;
        }
        else {
            push @backendstmp, $prio_cur;
        }
    }
    return 0;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/FarmGuardian.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use Relianoid::Log;
use Config::Tiny;

my $configdir   = &getGlobalConfiguration("configdir");
my $fg_conf     = "$configdir/farmguardian.conf";
my $fg_template = &getGlobalConfiguration("templatedir") . "/farmguardian.template";

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::FarmGuardian

=cut

=pod

=head1 getFGStatusFile

The function returns the path of the file that is used to save the backend status for a farm.

Parameters:

    fname - Farm name

Returns:

    String - file path

=cut

sub getFGStatusFile ($farm) {
    return "$configdir\/$farm\_status.cfg";
}

=pod

=head1 getFGStruct

It returns a default struct with all farmguardian parameters

Parameters:

    none

Returns:

    Hash ref - hash with the available parameters of fg

    example:

    hash => {
        'description' => "",       # Tiny description about the check
        'command'     => "",       # Command to check. The check must return 0 on sucess
        'farms'       => [],       # farm list where the farm guardian is applied
        'log'         => "false",  # logg farm guardian
        'interval'    => "10",     # Time between checks
        'cut_conns' => "false",    # cut the connections with the backend is marked as down
        'template'  => "false",    # it is a template. The fg cannot be deleted, only reset its configuration
        'backend_alias'     => "false",    # Use the backend alias to do the farmguardian check. The load balancer must resolve the alias
    };

=cut

sub getFGStruct() {
    return {
        'description'   => "",         # Tiny description about the check
        'command'       => "",         # Command to check. The check must return 0 on sucess
        'farms'         => [],         # farm list where the farm guardian is applied
        'log'           => "false",    # logg farm guardian
        'interval'      => "10",       # Time between checks
        'cut_conns'     => "false",    # cut the connections with the backend is marked as down
        'template'      => "false",
        'backend_alias' => "false",
    };
}

=pod

=head1 getFGExistsConfig

It checks out if the fg already exists in the configuration file.

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Integer - 1 if the fg already exists or 0 if it is not

=cut

sub getFGExistsConfig ($fg_name) {
    if (!-f "$fg_conf") {
        return 0;
    }
    my $fh = Config::Tiny->read($fg_conf);
    return (exists $fh->{$fg_name}) ? 1 : 0;
}

=pod

=head1 getFGExistsTemplate

It checks out if a template farmguardian exists with this name.

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Integer - 1 if the fg exists or 0 if it is not

=cut

sub getFGExistsTemplate ($fg_name) {
    if (!-f "$fg_template") {
        return 0;
    }
    my $fh = Config::Tiny->read($fg_template);
    return (exists $fh->{$fg_name}) ? 1 : 0;
}

=pod

=head1 getFGExists

It checks out if the fg exists, in the template file or in the configuraton file

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Integer - 1 if the fg already exists or 0 if it is not

=cut

sub getFGExists ($fg_name) {
    return (&getFGExistsTemplate($fg_name) or &getFGExistsConfig($fg_name));
}

=pod

=head1 getFGConfigList

It returns a list of farmguardian names of the configuration file

Parameters:

    None

Returns:

    Array - List of fg names

=cut

sub getFGConfigList() {
    if (!-f "$fg_conf") {
        return ();
    }

    my $fg_file = Config::Tiny->read($fg_conf);
    return keys %{$fg_file};
}

=pod

=head1 getFGTemplateList

It returns a list of farmguardian names of the template file

Parameters:

    None

Returns:

    Array - List of fg names

=cut

sub getFGTemplateList() {
    if (!-f "$fg_template") {
        return ();
    }
    my $fg_file = Config::Tiny->read($fg_template);
    return keys %{$fg_file};
}

=pod

=head1 getFGList

It is a list with all fg, templates and created by the user

Parameters:

    None

Returns:

    Array - List of fg names

=cut

sub getFGList() {
    my @list = &getFGConfigList();

    # get from template file
    for my $fg (&getFGTemplateList()) {
        next if grep { $fg eq $_ } @list;
        push @list, $fg;
    }

    return @list;
}

=pod

=head1 getFGObject

Get the configuration of a farmguardian

Parameters:

    Farmguardian - Farmguardian name
    template - If this parameter has the value "template", the function returns the object from the template file

Returns:

    Hash ref - It returns a hash with the configuration of the farmguardian

    example:

    hash => {
        'description' => "",       # Tiny description about the check
        'command'     => "",       # Command to check. The check must return 0 on sucess
        'farms'       => [],       # farm list where the farm guardian is applied
        'log'         => "false",  # log farm guardian
        'interval'    => "10",     # Time between checks
        'cut_conns' => "false",    # cut the connections with the backend is marked as down
        'template'  => "false",    # it is a template. The fg cannot be deleted, only reset its configuration
        'backend_alias'     => "false",    # Use the backend alias to do the farmguardian check. The load balancer must resolve the alias
    };

=cut

sub getFGObject ($fg_name, $use_template = '') {
    unless ($fg_name) {
        croak("Farmguardian name required");
    }

    my $file = "";

    # using template file if this parameter is sent
    if ($use_template eq 'template') {
        $file = $fg_template;
    }

    # using farmguardian config file by default
    elsif (grep { $fg_name eq $_ } &getFGConfigList()) {
        $file = $fg_conf;
    }

    # using template file if farmguardian is not defined in config file
    else { $file = $fg_template; }

    my $obj;
    if (!-f "$file") {
        require Relianoid::File;
        createFile($file);
        $obj = Config::Tiny->new;
        return $obj;
    }

    $obj = Config::Tiny->read($file);

    if (!defined $fg_name || $fg_name =~ /^$/) {
        return $obj;
    }

    if (exists $obj->{$fg_name}) {
        $obj = $obj->{$fg_name};
        $obj = &setConfigStr2Arr($obj, ['farms']);
        return $obj;
    }

    return;
}

=pod

=head1 getFGFarm

Get the farmguardian name that a farm is using

Parameters:

    farm    - string - Farm name
    service - string - Optional. Service of the farm. This parameter is mandatory for HTTP and GSLB farms

Returns: string|undef - Farmguardian name if found or undef if not found.

=cut

sub getFGFarm ($farm, $service = undef) {
    my $farmguardian = undef;
    my $farm_tag     = $service ? "${farm}_${service}" : $farm;

    if (!-f $fg_conf) {
        return $farmguardian;
    }

    my $fg_list = Config::Tiny->read($fg_conf);

    for my $fg_name (keys %{$fg_list}) {
        next if not exists $fg_list->{$fg_name}{farms};

        if (grep { /(^| )$farm_tag( |$)/ } $fg_list->{$fg_name}{farms}) {
            $farmguardian = $fg_name;
            last;
        }
    }

    return $farmguardian;
}

=pod

=head1 createFGBlank

Create a fg without configuration

Parameters:

    Name - Farmguardian name

Returns:

    none

=cut

sub createFGBlank ($name) {
    my $values = &getFGStruct();
    &setFGObject($name, $values);

    return;
}

=pod

=head1 createFGTemplate

Create a fg from a template

Parameters:

    Farmguardian - Farmguardian name
    template - If this parameter has the value "template", the function returns the object from the template file

Returns:

    None

=cut

sub createFGTemplate ($name, $template) {
    my $values = &getFGObject($template, 'template');
    return if (!defined $values);
    $values->{template} = "false";

    &setFGObject($name, $values);

    return;
}

=pod

=head1 createFGConfig

Create a farm guardian from another farm guardian

Parameters:

    Farmguardian - Farmguardian name
    template - Farmguardian name of the fg used as template

Returns:

    None

=cut

sub createFGConfig ($name, $fg_config) {
    my $values = &getFGObject($fg_config);
    $values->{farms} = [];
    &setFGObject($name, $values);

    return;
}

=pod

=head1 delFGObject

Remove a farmguardianfrom the configuration file. First, it stops it.
This function will restart the fg process.

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Integer - 0 on success or another value on failure

=cut

sub delFGObject ($fg_name) {
    my $out = &runFGStop($fg_name);
    $out = &delTinyObj($fg_conf, $fg_name);

    return $out;
}

=pod

=head1 setFGObject

Set a configuration for fg.
This function has 2 behaviour:

    * passing to the function a hash with several parameters
    * passing to the function 2 parameters, key and value. So, only is updated one parater.

If the farmguardian name is not found in the configuration file, the configuraton will be got
from the template file and save it in the configuration file.

This function will restart the fg process

Parameters:

    Farmguardian - Farmguardian name
    object / key - object: hash reference with a set of parameters, or key: parameter name to set
    value        - value for the "key"

Returns:

    Integer - 0 on success or another value on failure

=cut

sub setFGObject ($fg_name, $key = undef, $value = undef) {
    my $restart = 0;
    my $out     = 0;

    # not restart if only is changed the parameter description
    if (&getFGExistsConfig($fg_name)) {
        if (@{ &getFGRunningFarms($fg_name) }) {
            if (ref $key and grep { !/^description$/ } keys %{$key}) {
                $restart = 1;
            }
            elsif ($key ne 'description') { $restart = 1; }
        }
    }

    # if the fg does not exist in config file, take it from template file
    unless (&getFGExistsConfig($fg_name)) {
        my $template = &getFGObject($fg_name, 'template');

        if (defined $template) {
            $out = &setTinyObj($fg_conf, $fg_name, $template);
        }
    }

    $out = &runFGStop($fg_name) if $restart;
    $out = &setTinyObj($fg_conf, $fg_name, $key, $value);
    $out = &runFGStart($fg_name) if $restart;

    if ($eload) {
        $out += &eload(
            module => 'Relianoid::EE::Farm::GSLB::FarmGuardian',
            func   => 'updateGSLBFg',
            args   => [$fg_name],
        );
    }

    return $out;
}

=pod

=head1 setFGFarmRename

Re-asign farmguardian to a farm that has been renamed

Parameters:

    old name - Old farm name
    new name - New farm name

Returns:

    Integer - 0 on success or another value on failure

=cut

sub setFGFarmRename ($farm, $new_farm) {
    my $fh;
    my $srv;
    my $farm_tag;
    my $new_farm_tag;
    my $out;

    if (!-f $fg_conf) {
        return 1;
    }
    $fh = Config::Tiny->read($fg_conf);

    # foreach farm check, remove and add farm
    for my $fg (keys %{$fh}) {
        if ($fh->{$fg}{farms} =~ /(?:^| )${farm}_?([\w-]+)?(?:$| )/) {
            $srv          = $1;
            $farm_tag     = ($srv) ? "${farm}_$srv"     : $farm;
            $new_farm_tag = ($srv) ? "${new_farm}_$srv" : $new_farm;

            $out = &setTinyObj($fg_conf, $fg, 'farms', $farm_tag,     'del');
            $out = &setTinyObj($fg_conf, $fg, 'farms', $new_farm_tag, 'add');

            my $status_file     = &getFGStatusFile($farm);
            my $new_status_file = &getFGStatusFile($new_farm);
            &log_info("renaming $status_file =>> $new_status_file") if &debug();
            rename $status_file, $new_status_file;
        }
    }

    return $out;
}

=pod

=head1 linkFGFarm

Assign a farmguardian to a farm (or service of a farm).
Farmguardian will run if the farm is up.

Parameters:

    Farmguardian - Farmguardian name
    Farm         - Farm name
    Service      - Service name. It is used for GSLB and HTTP farms

Returns:

    Integer - 0 on success or another value on failure

=cut

sub linkFGFarm ($fg_name, $farm, $srv = undef) {
    croak("Farmguardian name required") unless ($fg_name);
    croak("Farm name required")         unless ($farm);

    my $out;

    require Relianoid::Farm::Base;
    my $farm_tag = ($srv) ? "${farm}_$srv" : "$farm";

    # if the fg does not exist in config file, take it from template file
    unless (&getFGExistsConfig($fg_name)) {
        my $template = &getFGObject($fg_name, 'template');
        if (defined $template) {
            $out = &setTinyObj($fg_conf, $fg_name, $template);
            return $out if $out;
        }
    }

    $out = &setTinyObj($fg_conf, $fg_name, 'farms', $farm_tag, 'add');
    return $out if $out;

    if (&getFarmType($farm) eq 'gslb' and $eload) {
        $out = &eload(
            module => 'Relianoid::EE::Farm::GSLB::FarmGuardian',
            func   => 'linkGSLBFg',
            args   => [ $fg_name, $farm, $srv ],
        );
    }
    elsif (&getFarmStatus($farm) eq 'up') {
        $out = &runFGFarmStart($farm, $srv);
    }

    return $out;
}

=pod

=head1 unlinkFGFarm

Remove a farmguardian from a farm (or service of a farm).
Farmguardian will be stopped if it is running.

Parameters:

    Farmguardian - Farmguardian name
    Farm         - Farm name
    Service      - Service name. It is used for GSLB and HTTP farms

Returns:

    Integer - 0 on success or another value on failure

=cut

sub unlinkFGFarm ($fg_name, $farm, $srv = undef) {
    my $type = &getFarmType($farm);

    require Relianoid::Log;

    my $farm_tag = ($srv) ? "${farm}_$srv" : "$farm";
    my $out;

    $out = &setTinyObj($fg_conf, $fg_name, 'farms', $farm_tag, 'del');
    return $out if $out;

    if (($type eq 'gslb') and $eload) {
        $out = &eload(
            module => 'Relianoid::EE::Farm::GSLB::FarmGuardian',
            func   => 'unlinkGSLBFg',
            args   => [ $farm, $srv ],
        );
    }
    else {
        $out = &runFGFarmStop($farm, $srv);
    }

    return $out;
}

=pod

=head1 delFGFarm

Function used if a farm is deleted. All farmguardian assigned to it will be unliked.

Parameters:

    Farm    - Farm name
    Service - Service name. It is used for GSLB and HTTP farms

Returns:

    None

=cut

sub delFGFarm ($farm, $service = undef) {
    require Relianoid::Farm::Service;

    my $err  = &runFGFarmStop($farm, $service);
    my $type = &getFarmType($farm);

    # NOT MATCH qw(http https gslb eproxy)
    if (!grep { $type eq $_ } qw(http https gslb eproxy)) {
        if (my $fg = &getFGFarm($farm)) {
            $err |= &setTinyObj($fg_conf, $fg, 'farms', $farm, 'del');
        }

        return;
    }

    # MATCH qw(http https gslb eproxy)
    my @services = $service? ($service): &getFarmServices($farm);

    for my $service (@services) {
        if (my $fg = &getFGFarm($farm, $service)) {
            $err |= &setTinyObj($fg_conf, $fg, 'farms', "${farm}_${service}", 'del');
        }
    }

    return;
}

############# run process

=pod

=head1 getFGPidFile

Get the path of the file where the pid of the farmguardian is saved.

Parameters:

    Farm - Farm name
    Service - Service name. It is used for GSLB and HTTP farms. It expects 'undef' for l4 farms

Returns:

    String - Pid file path.

=cut

sub getFGPidFile ($fname, $svice = undef) {
    my $piddir = &getGlobalConfiguration('piddir');
    my $file;

    if (defined $svice and length $svice) {
        # return a regexp for a farm the request service
        $file = "$piddir/${fname}_${svice}_guardian.pid";
    }
    else {
        # return a regexp for a farm and all its services
        $file = "$piddir/${fname}_guardian.pid";
    }

    return $file;
}

=pod

=head1 getFGPidFarm

It returns the farmguardian PID assigned to a farm (and service)

Parameters:

    Farm - Farm name
    Service - Service name. It is used for GSLB and HTTP farms

Returns:

    Integer - 0 on failure, or a natural number for PID

=cut

sub getFGPidFarm ($farm, $service = undef) {
    my $pid     = 0;
    my $pidFile = &getFGPidFile($farm, $service);

    if (!-f "$pidFile") {
        return $pid;
    }

    open my $fh, '<', $pidFile or return 0;
    $pid = <$fh>;
    close $fh;

    my $run;

    # check if the pid exists
    if ($pid > 0) {
        $run = kill 0, $pid;
    }

    # if it does not exist, remove the pid file
    if (!$run) {
        $pid = 0;
        unlink $pidFile;
    }

    # return status
    return $pid;
}

=pod

=head1 runFGStop

It stops all farmguardian process are using the passed fg name

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Integer - 0 on failure, or another value on success

=cut

sub runFGStop ($fgname) {
    &log_debug("Stopping farmguardian $fgname", "FG");

    my $out;
    my $obj = &getFGObject($fgname);

    for my $farm (@{ $obj->{farms} }) {
        my $srv;
        if ($farm =~ /([^_]+)_(.+)/) {
            $farm = $1;
            $srv  = $2;
        }

        $out |= &runFGFarmStop($farm, $srv);
    }

    return $out;
}

=pod

=head1 runFGStart

It runs fg for each farm is using it and it is running

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Integer - 0 on failure, or another value on success

=cut

sub runFGStart ($fgname) {
    &log_debug("Starting farmguardian $fgname", "FG");

    my $out;
    my $obj = &getFGObject($fgname);

    for my $farm (@{ $obj->{farms} }) {
        my $srv;
        if ($farm =~ /([^_]+)_(.+)/) {
            $farm = $1;
            $srv  = $2;
        }

        $out |= &runFGFarmStart($farm, $srv);
    }

    return $out;
}

=pod

=head1 runFGRestart

It restarts all farmguardian process for each farm is using the passed fg

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Integer - 0 on failure, or another value on success

=cut

sub runFGRestart ($fgname) {
    my $out = &runFGStop($fgname);
    $out |= &runFGStart($fgname);

    return $out;
}

=pod

=head1 runFGFarmStop

It stops farmguardian process used by the farm. If the farm is GSLB or HTTP
and is not passed the service name, all farmguardians will be stoped.

Parameters:

    Farm - Farm name
    Service - Service name. This parameter is for HTTP and GSLB farms. If the farm has not services, this parameter expect 'undef'

Returns:

    Integer - 0 on failure, or another value on success

=cut

sub runFGFarmStop ($farm, $service = undef) {
    # optional, if the farm is http and the service is not sent to
    # the function, all services will be restarted
    $service = undef if (defined $service and not length $service);

    my $out = 0;

    require Relianoid::Farm::Core;
    my $type = &getFarmType($farm);

    # Stop Farmguardian for every service
    if ($type =~ /http|eproxy/ and not defined $service) {
        require Relianoid::Farm::Service;
        for my $srv (&getFarmServices($farm)) {
            $out |= &runFGFarmStop($farm, $srv);
        }
        return $out;
    }

    my $fgpid = &getFGPidFarm($farm, $service);

    if ($fgpid && $fgpid > 0) {
        my $service_str = $service // '';
        &log_debug("running 'kill 9, $fgpid' stopping FarmGuardian $farm $service_str", "FG");

        # kill returns the number of process affected
        $out = kill 9, $fgpid;
        $out = (not $out);
        if ($out) {
            &log_error("running 'kill 9, $fgpid' stopping FarmGuardian $farm $service_str", "FG");
        }

        # delete pid files
        unlink &getFGPidFile($farm, $service);

        # put backend up
        if ($type eq "http" || $type eq "https") {
            my $status_file = &getFGStatusFile($farm);

            if (-e $status_file && -s $status_file) {
                require Relianoid::Farm::HTTP::Service;
                require Tie::File;

                my $idsv = &getFarmVSI($farm, $service);

                tie my @filelines, 'Tie::File', $status_file;

                my @fileAux = @filelines;
                my $lines   = scalar @fileAux;

                while ($lines > 0) {
                    $lines--;

                    my $matched = $fileAux[$lines] =~ /0 $idsv (\d+) fgDOWN/;
                    my $index   = $1;

                    next if not $matched;

                    splice(@fileAux, $lines, 1,);

                    require Relianoid::Farm::HTTP::Backend;
                    my $error_ref = &setHTTPFarmBackendStatus($farm, $service, $index, 'up', 'cut');

                    if ($error_ref->{code} != 1 and $error_ref->{code} != -1) {
                        $error_ref->{code} = 0;
                    }

                    $out |= $error_ref->{code};
                }
                @filelines = @fileAux;
                untie @filelines;
            }
        }

        elsif ($type eq "l4xnat") {
            require Relianoid::Farm::Backend;

            my $be = &getFarmServers($farm);

            for my $l_serv (@{$be}) {
                unless ($l_serv->{status} eq "fgDOWN") {
                    next;
                }

                my $error_ref = &setL4FarmBackendStatus($farm, $l_serv->{id}, "up");
                if ($error_ref->{code} != 1 and $error_ref->{code} != -1) {
                    $error_ref->{code} = 0;
                }
                $out |= $error_ref->{code};
            }
        }

        elsif ($type eq "eproxy") {
            # TODO LGL
        }
    }
    my $srvtag = defined $service ? "${service}_" : '';
    unlink "$configdir/${farm}_${srvtag}status.cfg";

    return $out;
}

=pod

=head1 runFGFarmStart

It starts the farmguardian process used by the farm. If the farm is GSLB or HTTP
and is not passed the service name, all farmguardians will be run.
The pid file is created by the farmguardian process.

Parameters:

    Farm - Farm name
    Service - Service name. This parameter is for HTTP and GSLB farms.

Returns:

    Integer - 0 on failure, or another value on success

=cut

sub runFGFarmStart ($farm, $svice = undef) {
    my $status = 0;
    my $log    = "";
    my $sv     = "";

    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    my $ftype = &getFarmType($farm);

    # check if the farm is up
    return 0 if (&getFarmStatus($farm) ne 'up');

    # if the farmguardian is running...
    if (&getFGPidFarm($farm, $svice)) {
        return 0;
    }

    # check if the node is master
    if ($eload) {
        my $node = "";
        $node = &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'getClusterNodeStatus',
            args   => [],
        );
        return 0 unless (not $node or $node eq 'master');
    }

    $svice = '' if not defined $svice;
    &log_debug("Start fg for farm $farm, $svice", "FG");

    if ($ftype =~ /http|eproxy/ && $svice eq "") {
        require Relianoid::Farm::Service;

        for my $service (&getFarmServices($farm)) {
            $status |= &runFGFarmStart($farm, $service);
        }
    }
    elsif ($ftype =~ /http|l4xnat|eproxy/) {
        my $fgname = &getFGFarm($farm, $svice);

        return 0 if not $fgname;

        &log_debug("Starting fg $fgname, farm $farm, $svice", "FG");
        my $fg = &getFGObject($fgname);

        if ($fg->{log} eq 'true') {
            $log = "-l";
        }

        if ($svice ne "") {
            $sv = "-s $svice";
        }

        my $farmguardian = &getGlobalConfiguration('farmguardian');
        my $fg_cmd       = "$farmguardian $farm $sv $log";

        require Relianoid::Log;
        $status = &logAndRunBG("$fg_cmd");

        # necessary for waiting that fg process write its process
        use Time::HiRes qw(usleep);
        $status = 1;
        my $pid_file = &getFGPidFile($farm, $svice);

        # wait for 2 seconds
        for (my $it = 0 ; $it < 4000 ; $it += 1) {
            if (-f $pid_file) {
                $status = 0;
                last;
            }

            # 500 microseconds == 0.5 milliseconds
            usleep(500);
        }

        if ($status) {
            my $msg = "The farmguardian for the farm '$farm'";
            $msg .= " and the service '$svice'" if ($svice);
            $msg .= " could not start properly";
            &log_error($msg, "fg");
        }
    }
    elsif ($ftype ne 'gslb') {
        # WARNING: farm types not supported by farmguardian return 0.
        $status = 1;
    }

    return $status;
}

=pod

=head1 runFGFarmRestart

It restarts the farmguardian process used by the farm. If the farm is GSLB or HTTP
and is not passed the service name, all farmguardians will be restarted.

Parameters:

    Farm    - Farm name
    Service - Service name. This parameter is for HTTP and GSLB farms.

Returns:

    Integer - 0 on failure, or another value on success

=cut

sub runFGFarmRestart ($farm, $service = undef) {
    my $out = &runFGFarmStop($farm, $service);
    $out |= &runFGFarmStart($farm, $service);

    return $out;
}

=pod

=head1 getFGRunningFarms

Get a list with all running farms where the farmguardian is applied.

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Array ref - list of farm names

=cut

sub getFGRunningFarms ($fg) {
    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    my @runfarm;
    for my $farm (@{ &getFGObject($fg)->{farms} }) {
        my $srv;
        if ($farm =~ /([^_]+)_(.+)/) {
            $farm = $1;
            $srv  = $2;
        }

        if (&getFarmStatus($farm) eq 'up') {
            push @runfarm, $farm;
        }
    }
    return \@runfarm;
}

=pod

=head1 getFGMigrateFile

This function returns a standard name used to migrate the old farmguardians.

Parameters:

    Farm - Farm name
    Service - Service name. This parameter is for HTTP and GSLB farms.

Returns:

    String - Farmguardian name

=cut

sub getFGMigrateFile ($farm, $srv = undef) {
    return ($srv) ? "_default_${farm}_$srv" : "_default_$farm";
}

=pod

=head1 setOldFarmguardian

Create a struct of the new fg using the parameters of the old fg

Parameters:

    Configuration - Hash with the configuration of the old FG

Returns:

    None

=cut

sub setOldFarmguardian ($obj) {
    my $srv  = $obj->{service} // "";
    my $farm = $obj->{farm};
    my $name = &getFGMigrateFile($obj->{farm}, $srv);
    my $type = &getFarmType($farm);
    my $set;

    &log_debug2("setOldFarmguardian: $farm, $srv", "FG");

    # default object
    my $def = {
        'description' => "This farmguardian was created automatically to migrate to Relianoid 5.2 version or higher",
        'command'     => $obj->{command},
        'log'         => $obj->{log},
        'interval'    => $obj->{interval},
        'cut_conns'   => ($type =~ /http/) ? "true" : "false",
        'template'    => "false",
        'farms'       => [],
    };

    &runFGFarmStop($farm, $srv);

    # if exists, update it
    if (&getFGExistsConfig($name)) {
        $set             = &getFGObject($name);
        $set->{command}  = $obj->{command}  if exists $obj->{command};
        $set->{log}      = $obj->{log}      if exists $obj->{log};
        $set->{interval} = $obj->{interval} if exists $obj->{interval};
    }

    # else create it
    else {
        $set = $def;
    }

    &setFGObject($name, $set);
    my $farm_tag = ($srv) ? "${farm}_$srv" : $farm;

    if ($obj->{enable} eq 'true') {
        &setTinyObj($fg_conf, $name, 'farms', $farm_tag, 'add');
    }

    return;
}

####################################################################
######## ######## 	OLD FUNCTIONS 	######## ########
# Those functions are for compatibility with the APIs 3.0 and 3.1
####################################################################

=pod

=head1 runFarmGuardianStart

Start FarmGuardian rutine

Parameters:

    fname - Farm name.
    svice - Service name. Only apply if the farm profile has services. Leave undefined for farms without services.

Returns: integer

- -1 - If farmguardian file was not found or if farmguardian is not running.
- 0  - If farm profile is not supported by farmguardian, or farmguardian was executed.

=cut

sub runFarmGuardianStart ($fname, $svice) {
    return &runFGFarmStart($fname, $svice);
}

=pod

=head1 runFarmGuardianStop

Stop FarmGuardian rutine

Parameters:

    fname - Farm name.
    svice - Service name. Only apply if the farm profile has services. Leave undefined for farms without services.

Returns:

    Integer - 0 on success, or greater than 0 on failure.

=cut

sub runFarmGuardianStop ($fname, $svice) {
    return &runFGFarmStop($fname, $svice);
}

=pod

=head1 runFarmGuardianCreate

Create or update farmguardian config file

ttcheck and script must be defined and non-empty to enable farmguardian.

Parameters:

    fname - Farm name.
    ttcheck - Time between command executions for all the backends.
    script - Command to run.
    usefg - 'true' to enable farmguardian, or 'false' to disable it.
    fglog - 'true' to enable farmguardian verbosity in logs, or 'false' to disable it.
    svice - Service name.

Returns: integer

- -1 - If ttcheck or script is not defined or empty and farmguardian is enabled.
-  0 - If farmguardian configuration was created.

=cut

sub runFarmGuardianCreate ($fname, $ttcheck, $script, $usefg, $fglog, $svice) {
    &log_debug("runFarmGuardianCreate( farm: $fname, interval: $ttcheck, cmd: $script, log: $fglog, enabled: $usefg )",
        "FG");

    my $output = -1;

    # get default name and check not exist
    my $obj = {
        'service'  => $svice,
        'farm'     => $fname,
        'command'  => $script,
        'log'      => $fglog,
        'interval' => $ttcheck,
        'enable'   => $usefg,
    };

    $output = &setOldFarmguardian($obj);

    # start
    $output |= &runFGFarmStart($fname, $svice);

    return $output;
}

=pod

=head1 runFarmGuardianRemove

Remove farmguardian down status on backends.

When farmguardian is stopped or disabled any backend marked as down by farmgardian must reset it's status.

Parameters:

    fname - Farm name.
    svice - Service name. Only apply if the farm profile has services. Leave undefined for farms without services.

Returns:

    none - Nothing is returned explicitly.

=cut

sub runFarmGuardianRemove ($fname, $svice) {
    my $fg = &getFGFarm($fname, $svice);

    return if (not $fg);

    # "unlink" stops the fg
    my $out = &unlinkFGFarm($fg, $fname, $svice);

    if ($fg eq &getFGMigrateFile($fname, $svice) and not @{ &getFGObject($fg)->{farms} }) {
        $out |= &delFGObject($fg);
    }

    return;
}

=pod

=head1 getFarmGuardianPid

Read farmgardian pid from pid file. Check if the pid is running and return it,
else it removes the pid file.

Parameters:

    fname   - Farm name.
    service - Service name. Only apply if the farm profile has services. Leave undefined for farms without services.

Returns:

    -1      - If farmguardian PID file was not found (farmguardian not running).
    integer - PID number (unsigned integer) if farmguardian is running.

Bugs:

    Regex with .* should be fixed.

See Also:

    relianoid

=cut

sub getFarmGuardianPid ($fname, $service = undef) {
    my $pid = &getFGPidFarm($fname, $service);

    return $pid;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/File.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;

=pod

=head1 Module

Relianoid::File

=cut

=pod

=head1 getFile

Returns the content of a file as a string. Binary compatible.

Parameters:

    file_name - string with the location of the file

Returns:

    string - Content of the file.

=cut

sub getFile ($file_name) {
    unless (-f $file_name) {
        &log_info("Could not find file '$file_name'");
        return;
    }

    my $content;
    if (open(my $fh, '<', $file_name)) {
        binmode $fh;

        local $/ = undef;
        $content = <$fh>;

        close $fh;
    }
    else {
        &log_info("Could not open file '$file_name': $!");
        return;
    }

    return $content;
}

=pod

=head1 setFile

Writes a file with the content received. Binary compatible.

Parameters:

    path - string with the location of the file

    content - content to write to the files

Returns:

    integer

    1 - success
    0 - failure

=cut

sub setFile ($path, $content) {
    unless (defined $content) {
        &log_info("Trying to save undefined content");
        return 0;
    }

    if (open(my $fh, '>', $path)) {
        binmode $fh;
        print $fh $content;
        close $fh;
    }
    else {
        &log_info("Could not open file '$path': $!");
        return 0;
    }

    return 1;
}

=pod

=head1 insertFileWithPattern

Insert an array in a file before or after a pattern

=cut

sub insertFileWithPattern ($file, $array, $pattern, $opt = 'after') {
    my $err = 0;

    my $index = 0;
    my $found = 0;
    tie my @fileconf, 'Tie::File', $file;

    for my $line (@fileconf) {
        if ($line =~ /$pattern/) {
            $found = 1;
            last;
        }
        $index++;
    }

    return 1 if (!$found);

    $index++ if ($opt eq 'after');

    splice @fileconf, $index, 0, @{$array};
    untie @fileconf;

    return $err;
}

=pod

=head1 createFile

Create an empty file

Parameters:

    filename

Returns:

    integer

    0 - success
    1 - file already exists
    2 - error creating file

=cut

sub createFile ($filename) {
    if (-f $filename) {
        &log_error("The file $filename already exists", "System");
        return 1;
    }

    if (open(my $fh, '>', $filename)) {
        close $fh;
    }
    else {
        &log_error("The file $filename could not be created: $!", "System");
        return 2;
    }

    return 0;
}

=pod

=head1 deleteFile

=cut

sub deleteFile ($file) {
    if (!-f $file) {
        &log_error("The file $file doesn't exist", "System");
        return 1;
    }
    unlink $file;
    return 0;
}

=pod

=head1 getFileDateGmt

It gets the date of last modification of a file and it returns it in GMT format

Parameters:

    file path - File path

Returns:

    String - Date in GMT format

=cut

sub getFileDateGmt ($filepath) {
    use File::stat;
    my @eject = split(/ /, gmtime(stat($filepath)->mtime));
    splice(@eject, 0, 1);
    push(@eject, "GMT");

    my $date = join(' ', @eject);
    chomp $date;

    return $date;
}

=pod

=head1 getFileChecksumMD5

Returns the checksum MD5 of the file or directory including subdirs.

Parameters:

    file path - File path or Directory path

Returns:

    Hash ref - Hash ref with filepath as key and checksummd5 as value.

=cut

sub getFileChecksumMD5 ($filepath) {
    my $md5 = {};

    if (-d $filepath) {
        opendir(my $directory, $filepath);
        my @files = readdir($directory);
        closedir($directory);

        for my $file (@files) {
            next if ($file eq "." or $file eq "..");
            $md5 = { %{$md5}, %{ &getFileChecksumMD5($filepath . "/" . $file) } };
        }
    }
    elsif (-f $filepath) {
        if (open(my $fh, '<', $filepath)) {
            binmode($fh);
            use Digest::MD5;
            $md5->{$filepath} = Digest::MD5->new->addfile($fh)->hexdigest;
            close $fh;
        }
    }
    return $md5;
}

=pod

=head1 getFileChecksumAction

Compare two Hashes of checksum filepaths and returns the actions to take.

Parameters:

    checksum_filepath1 - Hash ref checksumMD5 file path1
    checksum_filepath2 - Hash ref checksumMD5 file path2

Returns:

    Hash ref - Hash ref with filepath as key and action as value

=cut

sub getFileChecksumAction ($checksum_filepath1, $checksum_filepath2) {
    my $files_changed;

    for my $file (keys %{$checksum_filepath1}) {
        if (!defined $checksum_filepath2->{$file}) {
            $files_changed->{$file} = "del";
        }
        elsif ($checksum_filepath1->{$file} ne $checksum_filepath2->{$file}) {
            $files_changed->{$file} = "modify";
            delete $checksum_filepath2->{$file};
        }
        else {
            delete $checksum_filepath2->{$file};
        }
    }
    for my $file (keys %{$checksum_filepath2}) {
        $files_changed->{$file} = "add";
    }
    return $files_changed;
}

=pod

=head1 readFileAsArray

Get the content of a file as an array of lines

Parameters:

    file_name - string. path to file

Returns:

    list - list of lines in the file

=cut

sub readFileAsArray ($file_name) {
    unless (-f $file_name) {
        my $msg = "Could not find file '$file_name'";
        &log_error($msg);
        croak($msg);
    }

    my @lines;
    if (open(my $fh, '<', $file_name)) {
        @lines = <$fh>;
        close $fh;
    }
    else {
        my $msg = "Could not open file '$file_name': $!";
        &log_error($msg);
        croak($msg);
    }

    return @lines;
}

=pod

=head1 writeFileFromArray

Write an array to a file

Parameters:

    file_name - string. path and file name

    array_ref - reference to the array to be written

Returns:

    list - list of files in the directory

=cut

sub writeFileFromArray ($file_name, $array_ref) {
    unless (defined $file_name and length $file_name) {
        my $msg = "The file name is not a valid string";
        &log_error($msg);
        croak($msg);
    }
    unless (ref $array_ref eq 'ARRAY') {
        my $msg = "Did not receive an array reference";
        &log_error($msg);
        croak($msg);
    }

    if (open(my $fh, '>', $file_name)) {
        print $fh join("", @{$array_ref});
        close $fh;
    }
    else {
        my $msg = "Could not open file '$file_name': $!";
        &log_error($msg);
        croak($msg);
    }

    return 1;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

=pod

=head1 Module

Relianoid::HTTP

=cut

use strict;
use warnings;
use feature qw(signatures);

use Carp;

use Relianoid::API;

my $LOG_TAG = "";
$LOG_TAG = "API"    if get_http_api_key();
$LOG_TAG = "WEBGUI" if (exists $ENV{HTTP_COOKIE});

my $eload = eval { require Relianoid::ELoad };

my %http_status_codes = (
    # 2xx Success codes
    200 => 'OK',
    201 => 'Created',
    204 => 'No Content',

    # 4xx Client Error codes
    400 => 'Bad Request',
    401 => 'Unauthorized',
    402 => 'Certificate not valid',
    403 => 'Forbidden',
    404 => 'Not Found',
    406 => 'Not Acceptable',
    415 => 'Unsupported Media Type',
    410 => 'Gone',
    422 => 'Unprocessable Entity',
);

# Examples of path regexes:
# - Non-capturing: (?^:^/interfaces/nic$)
# - Capturing:     (?^:^/farms/([a-zA-Z0-9\-]+)$)
my $CAPTURING_REGEX = qr{\/.+\(};

sub GET ($path, $code, $mod = undef) {
    return
      unless $ENV{REQUEST_METHOD} eq 'GET'
      or $ENV{REQUEST_METHOD} eq 'HEAD';

    my @captures = ($ENV{PATH_INFO} =~ $path);

    # if @capture is false, there was no match
    return unless @captures;

    # When there is nothing to be captured: @captures = (1)
    # Only attempt to save captured text when there are parenthesis on the url regex '('
    if ($path !~ $CAPTURING_REGEX) {
        @captures = ();
    }

    if (ref $code eq 'CODE') {
        $code->(@captures);
    }
    else {
        &eload(module => $mod, func => $code, args => \@captures) if $eload;
    }
    return;
}

sub POST ($path, $code, $mod = undef) {
    return unless $ENV{REQUEST_METHOD} eq 'POST';

    my @captures = ($ENV{PATH_INFO} =~ $path);

    # if @capture is false, there was no match
    return unless @captures;

    # When there is nothing to be captured: @captures = (1)
    # Only attempt to save captured text when there are parenthesis on the url regex '('
    if ($path !~ $CAPTURING_REGEX) {
        @captures = ();
    }

    require Relianoid::CGI;
    my $data = &getCgiParam('POSTDATA');
    my $input_ref;

    if (exists $ENV{CONTENT_TYPE} && $ENV{CONTENT_TYPE} eq 'application/json' && $data) {
        require JSON;

        $input_ref = eval { JSON::decode_json($data) };

        if (&debug()) {
            &log_debug("json: ${data}", $LOG_TAG);
        }

        if (!$input_ref) {
            my $body = {
                message => 'The body does not look a valid JSON',
                error   => 'true'
            };
            return &httpResponse({ code => 400, body => $body });
        }
    }
    elsif (exists $ENV{CONTENT_TYPE} && $ENV{CONTENT_TYPE} eq 'text/plain') {
        $input_ref = $data;
    }
    elsif (exists $ENV{CONTENT_TYPE}
        && $ENV{CONTENT_TYPE} eq 'application/x-pem-file')
    {
        $input_ref = $data;
    }
    elsif (exists $ENV{CONTENT_TYPE}
        && $ENV{CONTENT_TYPE} eq 'application/gzip')
    {
        $input_ref = $data;
    }
    elsif ($ENV{PATH_INFO} eq '/session' && !exists $ENV{CONTENT_TYPE} && !$data) {
        # Exception for /session. Allow no content, so content type too.
    }
    else {
        &log_error("Content-Type not supported: $ENV{CONTENT_TYPE}", $LOG_TAG);
        my $body = { message => 'Content-Type not supported', error => 'true' };

        return &httpResponse({ code => 415, body => $body });
    }

    my @args = ($input_ref, @captures);

    # stubborn web gui needs to send no body for POST /session
    if ($ENV{PATH_INFO} eq '/session') {
        @args = ();
    }

    if (ref $code eq 'CODE') {
        $code->(@args);
    }
    else {
        &eload(module => $mod, func => $code, args => \@args) if $eload;
    }

    return;
}

sub PUT ($path, $code, $mod = undef) {
    return unless $ENV{REQUEST_METHOD} eq 'PUT';

    my @captures = ($ENV{PATH_INFO} =~ $path);

    # if @capture is false, there was no match
    return unless @captures;

    # When there is nothing to be captured: @captures = (1)
    # Only attempt to save captured text when there are parenthesis on the url regex '('
    if ($path !~ $CAPTURING_REGEX) {
        @captures = ();
    }

    require Relianoid::CGI;
    my $data = &getCgiParam('PUTDATA');
    my $input_ref;

    if (exists $ENV{CONTENT_TYPE} && $ENV{CONTENT_TYPE} eq 'application/json' && $data) {
        require JSON;

        $input_ref = eval { JSON::decode_json($data) };

        if (&debug()) {
            &log_debug("json: ${data}", $LOG_TAG);
        }

        if (!$input_ref) {
            my $body = {
                message => 'The body does not look a valid JSON',
                error   => 'true'
            };

            return &httpResponse({ code => 400, body => $body });
        }
    }
    elsif (exists $ENV{CONTENT_TYPE} && $ENV{CONTENT_TYPE} eq 'text/plain') {
        $input_ref = $data;
    }
    elsif (exists $ENV{CONTENT_TYPE} && $ENV{CONTENT_TYPE} eq 'application/x-pem-file') {
        $input_ref = $data;
    }
    elsif (exists $ENV{CONTENT_TYPE} && $ENV{CONTENT_TYPE} eq 'application/gzip') {
        $input_ref = $data;
    }
    else {
        &log_error("Content-Type not supported: $ENV{CONTENT_TYPE}", $LOG_TAG);
        my $body = { message => 'Content-Type not supported', error => 'true' };

        return &httpResponse({ code => 415, body => $body });
    }

    my @args = ($input_ref, @captures);

    if (ref $code eq 'CODE') {
        $code->(@args);
    }
    else {
        &eload(module => $mod, func => $code, args => \@args) if $eload;
    }

    return;
}

sub DELETE ($path, $code, $mod = undef) {
    return unless $ENV{REQUEST_METHOD} eq 'DELETE';

    my @captures = ($ENV{PATH_INFO} =~ $path);

    # if @capture is false, there was no match
    return unless @captures;

    # When there is nothing to be captured: @captures = (1)
    # Only attempt to save captured text when there are parenthesis on the url regex '('
    if ($path !~ $CAPTURING_REGEX) {
        @captures = ();
    }

    if (ref $code eq 'CODE') {
        $code->(@captures);
    }
    else {
        &eload(module => $mod, func => $code, args => \@captures) if $eload;
    }

    return;
}

sub OPTIONS ($path, $code) {
    return unless $ENV{REQUEST_METHOD} eq 'OPTIONS';

    my @captures = ($ENV{PATH_INFO} =~ $path);

    # if @capture is false, there was no match
    return unless @captures;

    # When there is nothing to be captured: @captures = (1)
    # Only attempt to save captured text when there are parenthesis on the url regex '('
    if ($path !~ $CAPTURING_REGEX) {
        @captures = ();
    }

    &log_debug("OPTIONS captures( @captures )", $LOG_TAG) if &debug();

    $code->(@captures);

    return;
}

=pod

=head1 httpResponse

Serialize and send to STDOUT API response from data input.

Parameters: hash reference

    code    - HTTP status code digit
    headers - Optional. Hash reference of extra http headers to be included
    body    - Optional. Hash reference with data to be sent as JSON
    type    - Optional. HTTP Content-type header. Example: 'text/plain'

Returns: Nothing

=cut

sub httpResponse ($response) {
    return $response unless exists $ENV{GATEWAY_INTERFACE};

    if (not defined $response or ref $response ne 'HASH') {
        die 'httpResponse: Bad input';
    }

    if (not defined $response->{code} or not exists $http_status_codes{ $response->{code} }) {
        die 'httpResponse: Bad http status code';
    }

    require Relianoid::CGI;

    my $q      = &getCGI();
    my $origin = '*';

    if (not get_http_api_key()) {
        my $cors_devel_mode = &getGlobalConfiguration('cors_devel_mode') eq "true";
        $origin = $cors_devel_mode ? $ENV{HTTP_ORIGIN} : "https://$ENV{HTTP_HOST}";
    }

    # Headers included in all the responses, any method, any URI, sucess or error
    my %headers = (
        'Access-Control-Allow-Origin'      => $origin,
        'Access-Control-Allow-Credentials' => 'true',
        'Cache-Control'                    => 'no-cache',
        'Expires'                          => '-1',
        'Pragma'                           => 'no-cache',
    );

    # no session info received
    if ($ENV{REQUEST_METHOD} eq 'OPTIONS') {
        $headers{'Access-Control-Allow-Methods'} = 'GET, POST, PUT, DELETE, OPTIONS';
        $headers{'Access-Control-Allow-Headers'} =
          'API_KEY, ZAPI_KEY, Authorization, Set-cookie, Content-Type, X-Requested-With';
    }

    if (exists $ENV{HTTP_COOKIE} && $ENV{HTTP_COOKIE} =~ /CGISESSID/) {
        require Relianoid::HTTP::Auth;

        if (&validCGISession()) {
            my $session        = CGI::Session->load($q);
            my $session_cookie = $q->cookie(CGISESSID => $session->id);

            $headers{'Set-Cookie'}                    = "${session_cookie}; SameSite=None; Secure; HttpOnly";
            $headers{'Access-Control-Expose-Headers'} = "Set-Cookie, Content-Disposition";
        }
    }

    if ($q->path_info =~ '/session') {
        $headers{'Access-Control-Expose-Headers'} = "Set-Cookie";
    }

    if (exists $response->{headers} && ref $response->{headers} eq 'HASH') {
        %headers = (%headers, %{ $response->{headers} });
    }

    if ($response->{body}) {
        my $json_type = 'application/json';

        use Data::Dumper;
        log_debug("Response Headers: " . Dumper \%headers);

        if (not $headers{-type}) {
            $headers{-type} = $response->{type} || $json_type;
        }

        if ($headers{-type} eq $json_type) {
            $headers{-charset} = 'utf-8';
        }
    }

    print $q->header(
        -status => "$response->{code} $http_status_codes{$response->{code}}",
        %headers,
    );

    if ($response->{body}) {
        if (ref $response->{body} eq 'HASH') {
            require JSON;
            require Relianoid::Debug;

            my $canonical = debug();
            my $pretty    = debug();
            my $json      = JSON->new->utf8->pretty($pretty)->canonical([$canonical]);

            print $json->encode($response->{body});
        }
        elsif (ref $response->{body} eq 'GLOB') {
            my $fh = $response->{body};
            binmode $fh;

            local $/ = \4096;
            print while <$fh>;
            close $fh;
        }
        else {
            print $response->{body};
        }
    }

    # avoid logging frequent requests
    my @path_exceptions = ('/stats/system/connections', '/system/cluster/nodes', '/system/cluster/nodes/localhost');
    my $is_exception    = $ENV{REQUEST_METHOD} eq 'GET' && grep { $ENV{PATH_INFO} eq $_ } @path_exceptions;

    if (not $is_exception) {
        # log request if debug is enabled
        my $req_msg = "STATUS: $response->{code} REQUEST: $ENV{REQUEST_METHOD} $ENV{SCRIPT_URL}";

        # include memory usage if debug is 2 or higher
        $req_msg = sprintf("%s %s", $req_msg, &getMemoryUsage()) if &debug();
        &log_info($req_msg, $LOG_TAG);

        # log error message on error.
        if (ref $response->{body} eq 'HASH' and exists $response->{body}{message}) {
            &log_info($response->{body}{message}, $LOG_TAG);
        }
    }

    exit;
}

sub httpErrorResponse ($args) {
    unless (ref($args) eq 'HASH') {
        my $message = "httpErrorResponse: Argument is not a hash reference.";
        &log_info($message);
        carp($message);
    }

    # check required arguments: code, desc and msg
    unless ($args->{code} && $args->{desc} && $args->{msg}) {
        my $message = "httpErrorResponse: Missing required argument";
        &log_info($message);
        carp($message);
    }

    # check the status code is in a valid range
    unless ($args->{code} =~ /^4[0-9][0-9]$/) {
        my $message = "httpErrorResponse: Non-supported HTTP status code: $args->{code}";
        &log_info($message);
        carp($message);
    }

    my $body = {
        description => $args->{desc},
        error       => "true",
        message     => $args->{msg},
    };

    my $doc_url = &getGlobalConfiguration('doc_v4_0');
    $body->{documentation} = $doc_url if $doc_url;

    &log_error("$args->{desc}: $args->{msg}", $LOG_TAG);
    &log_info($args->{log_msg}, $LOG_TAG) if exists $args->{log_msg};

    my $response = { code => $args->{code}, body => $body };

    if ($0 =~ m!bin/enterprise\.bin$!) {
        return $response;
    }

    return &httpResponse($response);
}

sub httpSuccessResponse ($args) {
    unless (ref($args) eq 'HASH') {
        my $message = "httpSuccessResponse: Argument is not a hash reference";
        &log_info($message);
        carp($message);
    }

    unless ($args->{code} && $args->{desc} && $args->{msg}) {
        my $message = "httpSuccessResponse: Missing required argument";
        &log_info($message);
        carp($message);
    }

    unless ($args->{code} =~ /^2[0-9][0-9]$/) {
        my $message = "httpSuccessResponse: Non-supported HTTP status code: $args->{code}";
        &log_info($message);
        carp($message);
    }

    my $body = {
        description => $args->{desc},
        success     => "true",
        message     => $args->{msg},
    };

    &log_info($args->{log_msg}, $LOG_TAG) if exists $args->{log_msg};

    return &httpResponse({ code => $args->{code}, body => $body });
}

=pod

=head1 httpDownloadResponse

Arguments: array | hash

Receives a hash, or an array with hash parameters.

Hash keys:

    desc - string - Description of the API response
    dir  - string - Location of the file
    file - string - File name

Returns: Nothing

=cut

sub httpDownloadResponse (@args) {
    my $args;

    eval { $args = @args == 1 ? shift @args : {@args}; };

    # check errors loading the hash reference
    if ($@) {
        my $message = "httpDownloadResponse: Wrong argument received";
        &log_info($message);
        carp($message);
    }

    unless (ref($args) eq 'HASH') {
        my $message = "httpDownloadResponse: Argument is not a hash reference";
        &log_info($message);
        carp($message);
    }

    unless ($args->{desc} && $args->{dir} && $args->{file}) {
        my $message = "httpDownloadResponse: Missing required argument";
        &log_info($message);
        carp($message);
    }

    unless (-d $args->{dir}) {
        my $msg = "Invalid directory '$args->{dir}'";
        return &httpErrorResponse({ code => 400, desc => $args->{desc}, msg => $msg });
    }

    my $path = "$args->{dir}/$args->{file}";
    unless (-f $path) {
        my $msg = "The requested file $path could not be found.";
        return &httpErrorResponse({ code => 400, desc => $args->{desc}, msg => $msg });
    }

    my $fh;

    unless (open($fh, "<", $path)) { ## no critic (InputOutput::RequireBriefOpen)
        my $msg = "Could not open file $path: $!";
        return &httpErrorResponse({ code => 400, desc => $args->{desc}, msg => $msg });
    }

    my $type    = 'application/x-download';
    my $headers = {
        -type            => $type,
        -attachment      => $args->{file},
        'Content-length' => -s $path,
    };

    &log_info("[Download] $args->{desc}: $path", $LOG_TAG);

    return &httpResponse({ code => 200, headers => $headers, body => $fh, type => $type });
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Adapters/Backend.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Adapters::Backend

=cut

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 getBackendsResponse

Function to standarizate the backend structure on the API.

Parameters:

    out_b    - hash reference  - Required. Input and output
    type     - string          - Required. Farm type
    api_keys - array reference - Optional. Keys in API response. Only used in `get_farm_stats_controller`

Returns: nothing - It modifies the hash referenced by `out_b`.

=cut

sub getBackendsResponse ($backend_ref, $type, $api_keys = []) {
    die "Waiting a hash input" if not ref $backend_ref;

    if ($type eq 'l4xnat') {
        push @{$api_keys}, qw(id weight port ip priority status max_conns);
    }
    elsif ($type eq 'datalink') {
        push @{$api_keys}, qw(id weight ip priority status interface);
    }
    elsif ($type =~ /http/) {
        push @{$api_keys}, qw(id ip port weight status timeout);
    }
    elsif ($type eq 'gslb') {
        push @{$api_keys}, qw(id ip);
    }

    my $translate->{status} = { "fgdown" => "down", "undefined" => "up" };

    if (ref $backend_ref eq "ARRAY") {
        for my $backend (@{$backend_ref}) {
            _buildBackendAPIParams($backend, $api_keys, $translate);
        }
    }
    elsif (ref $backend_ref eq "HASH") {
        _buildBackendAPIParams($backend_ref, $api_keys, $translate);
    }

    if ($eload) {
        $backend_ref = &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'addAliasBackendsStruct',
            args   => [$backend_ref],
        );
    }

    return;
}

sub _buildBackendAPIParams ($backend, $api_keys, $translate) {
    my @bk_keys = keys(%{$backend});

    for my $param (keys %{$translate}) {
        for my $opt (keys %{ $translate->{$param} }) {
            if ($opt) {
                # This is a workaround to avoid regex substitution on undefined $out_b->{$param}
                if (defined $backend->{$param}) {
                    if (lc($backend->{$param}) eq $opt) {
                        $backend->{$param} = $translate->{$param}{$opt};
                    }
                    # else {
                    #     $out_b->{$param} =~ s/$opt/$translate->{$param}{$opt}/i;
                    # }
                }
                else {
                    if (not exists $backend->{$param}) {
                        $backend->{$param} = undef;
                    }

                    # if ($opt eq 'undefined') {
                    #     $backend->{$param} = $translate->{$param}{$opt};
                    # }
                }
            }
        }
    }

    for my $param (@bk_keys) {
        if (!grep { $param eq $_ } @{$api_keys}) {
            delete $backend->{$param};
        }
    }

    if (&debug()) {
        for my $param (@{$api_keys}) {
            if (!grep { $param eq $_ } @bk_keys) {
                &log_error("API parameter $param is missing", 'API');
            }
        }
    }

    return;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Auth.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::HTTP::Auth

=cut

sub validCGISession() {
    require Relianoid::CGI;
    require CGI::Session;

    my $q            = &getCGI();
    my $validSession = 0;

    my $session = CGI::Session->load($q);

    if ($session && $session->param('is_logged_in') && !$session->is_expired) {
        # ignore cluster nodes status to reset session expiration date
        unless ($q->path_info eq '/system/cluster/nodes') {
            my $session_timeout = &getGlobalConfiguration('session_timeout') // 30;
            $session->expire('is_logged_in', '+' . $session_timeout . 'm');
        }

        $validSession = 1;
        require Relianoid::User;
        &setUser($session->param('username'));
    }

    return $validSession;
}

sub getAuthorizationCredentials() {
    my $base64_digest;
    my $username;
    my $password;

    if (exists $ENV{HTTP_AUTHORIZATION}) {
        # Expected header example: 'Authorization': 'Basic aHR0cHdhdGNoOmY='
        $ENV{HTTP_AUTHORIZATION} =~ /^Basic (.+)$/;
        $base64_digest = $1;
    }

    if ($base64_digest) {
        # $decoded_digest format: "username:password"
        require MIME::Base64;
        chomp(my $decoded_digest = MIME::Base64::decode_base64($base64_digest));

        ($username, $password) = split /:/, $decoded_digest, 2;
    }

    &log_error("User not found",     "api") if not length $username;
    &log_error("Password not found", "api") if not length $password;

    return if not length $username or not length $password;

    require Relianoid::User;
    &setUser($username);

    return ($username, $password);
}

sub authenticateCredentials ($user, $pass) {
    return if not defined $user or not defined $pass;

    my $valid_credentials = 0;    # output

    if ($user eq 'root') {
        require Authen::Simple::Passwd;
        Authen::Simple::Passwd->import;

        my $passfile = "/etc/shadow";
        my $simple   = Authen::Simple::Passwd->new(path => "$passfile");

        if ($simple->authenticate($user, $pass)) {
            &log_debug("The user '$user' login locally", "auth");
            $valid_credentials = 1;
        }
    }
    elsif ($eload) {
        $valid_credentials = &eload(
            module => 'Relianoid::EE::RBAC::Runtime',
            func   => 'runRBACAuthUser',
            args   => [ $user, $pass ]
        );
    }

    return $valid_credentials;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Certificate.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Certificate

=cut

my $eload = eval { require Relianoid::ELoad };

my $CSR_KEY_SIZE = 2048;

# GET /certificates
sub list_certificates_controller () {
    require Relianoid::Certificate;

    my $desc         = "List certificates";
    my @certificates = &getCertFiles();
    my $configdir    = &getGlobalConfiguration('certdir');
    my @out;

    for my $cert (sort @certificates) {
        push @out, &getCertInfo("$configdir/$cert");
    }

    my $body = {
        description => $desc,
        params      => \@out,
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /certificates/CERTIFICATE/info
sub get_certificate_info_controller ($cert_filename) {
    require Relianoid::Certificate;

    my $desc     = "Show certificate details";
    my $cert_dir = &getGlobalConfiguration('certdir');

    # check is the certificate file exists
    if (!-f "$cert_dir\/$cert_filename") {
        my $msg = "Certificate file not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (not &getValidFormat('certificate', $cert_filename)) {
        my $msg = "Could not get such certificate information";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $cert = &getCertData("$cert_dir\/$cert_filename", "true");
    return &httpResponse({ code => 200, body => $cert, type => 'text/plain' });
}

# GET /certificates/CERTIFICATE
sub download_certificate_controller ($cert_filename) {
    my $desc      = "Download certificate";
    my $cert_dir  = &getGlobalConfiguration('certdir');
    my $cert_path = "$cert_dir/$cert_filename";

    unless ($cert_filename =~ /\.(pem|csr)$/ && -f $cert_path) {
        my $msg = "Could not find such certificate";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    return &httpDownloadResponse(desc => $desc, dir => $cert_dir, file => $cert_filename);
}

# DELETE /certificates/CERTIFICATE
sub delete_certificate_controller ($cert_filename) {
    require Relianoid::Certificate;
    require Relianoid::Letsencrypt;

    my $desc     = "Delete certificate";
    my $cert_dir = &getGlobalConfiguration('certdir');

    # check is the certificate file exists
    if (!-f "$cert_dir\/$cert_filename") {
        my $msg = "Certificate file not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $status = &getFarmCertUsed($cert_filename);

    # check is the certificate is being used
    if ($status == 0) {
        my $msg = "File can't be deleted because it's in use by a farm.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($eload) {
        $status = &eload(
            module => 'Relianoid::EE::System::HTTP',
            func   => 'getHttpsCertUsed',
            args   => [$cert_filename]
        );

        if ($status == 0) {
            my $msg = "File can't be deleted because it's in use by HTTPS server";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # check if it is a LE certificate
    my $le_cert_name = $cert_filename;
    $le_cert_name =~ s/.pem//g;
    $le_cert_name =~ s/\_/\./g;
    my $error;
    if (@{ &getLetsencryptCertificates($le_cert_name) }) {
        $error = &runLetsencryptDestroy($le_cert_name);
    }

    if ($eload) {
        my $wildcard = &eload(
            module => 'Relianoid::EE::Letsencrypt::Wildcard',
            func   => 'getLetsencryptWildcardCertificates',
            args   => [$le_cert_name]
        );

        if (@{$wildcard}) {
            $error = &eload(
                module => 'Relianoid::EE::Letsencrypt::Wildcard',
                func   => 'runLetsencryptWildcardDestroy',
                args   => [$le_cert_name]
            );
        }
    }

    if ($error) {
        my $msg = "LE Certificate can not be removed";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &delCert($cert_filename);

    # check if the certificate exists
    if (-f "$cert_dir\/$cert_filename") {
        my $msg = "Error deleting certificate $cert_filename.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no errors found, make a succesful response
    my $msg  = "The Certificate $cert_filename has been deleted.";
    my $body = {
        description => $desc,
        success     => "true",
        message     => $msg,
    };

    return &httpResponse({ code => 200, body => $body });
}

# POST /certificates (Create CSR)
sub create_csr_controller ($json_obj) {
    require Relianoid::Certificate;

    my $desc      = 'Create CSR';
    my $configdir = &getGlobalConfiguration('certdir');

    if (-f "$configdir/$json_obj->{name}.csr") {
        my $msg = "$json_obj->{name} already exists.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("certificate_csr-create.json");
    $params->{fqdn}{function} = \&checkFQDN;

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my $error = &createCSR(
        $json_obj->{name},     $json_obj->{fqdn},         $json_obj->{country},  $json_obj->{state},
        $json_obj->{locality}, $json_obj->{organization}, $json_obj->{division}, $json_obj->{mail},
        $CSR_KEY_SIZE,         ""
    );

    if ($error) {
        my $msg = "Error, creating certificate $json_obj->{name}.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $message = "Certificate $json_obj->{name} created";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
    };

    return &httpResponse({ code => 200, body => $body });
}

# POST /certificates/CERTIFICATE (Upload PEM)
sub upload_certificate_controller ($upload_data, $filename) {
    require Relianoid::File;
    require Relianoid::Certificate;

    my $desc      = "Upload PEM certificate";
    my $configdir = &getGlobalConfiguration('certdir');

    # add extension if it does not exist
    $filename .= ".pem" if $filename !~ /\.pem$/;

    # check if the certificate filename already exists
    $filename =~ s/[\(\)\@ ]//g;
    if (-f "$configdir/$filename") {
        my $msg = "Certificate file name already exists";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    unless (&setFile("$configdir/$filename", $upload_data)) {
        my $msg = "Could not save the certificate file";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if (&checkCertPEMKeyEncrypted("$configdir/$filename") == 1) {
        &delCert("$filename");
        my $msg = "SSL certificates with passphrase are not supported";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no errors found, return sucessful response
    my $message = "Certificate uploaded";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /ciphers
sub get_ciphers_controller () {
    my $desc = "Get the ciphers available";

    my @out = (
        { 'ciphers' => "all",            "description" => "All" },
        { 'ciphers' => "highsecurity",   "description" => "High security" },
        { 'ciphers' => "customsecurity", "description" => "Custom security" }
    );

    if ($eload) {
        push(@out, &eload(module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext', func => 'getExtraCipherProfiles',));
    }

    my $body = {
        description => $desc,
        params      => \@out,
    };

    return &httpResponse({ code => 200, body => $body });
}

# POST /farms/FARM/certificates (Add certificate to farm)
sub add_farm_certificate_controller ($json_obj, $farmname) {
    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;
    unless ($eload) { require Relianoid::Farm::HTTP::HTTPS; }

    my $desc = "Add certificate to farm '$farmname'";

    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "Farm not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Check if the farm exists
    my $farm_type = &getFarmType($farmname);
    if ($farm_type !~ /https|eproxy/) {
        my $msg = "This feature is only available for 'https' or 'eproxy' farms";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_certificate-add.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my $configdir = &getGlobalConfiguration('certdir');

    # validate certificate filename and format
    unless (-f $configdir . "/" . $json_obj->{file}) {
        my $msg = "The certificate does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    require Relianoid::Certificate;
    my $error = &checkCertPEMValid($configdir . "/" . $json_obj->{file});
    if ($error->{code}) {
        &log_error("'Certificate $json_obj->{file}' for farm $farmname is not valid", "LSLB");
        my $msg = "The certificate $json_obj->{file} is not valid.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $cert_in_use;
    if ($eload) {
        if ($farm_type eq 'https') {
            $cert_in_use = grep { $json_obj->{file} eq $_ } &eload(
                module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext',
                func   => 'getFarmCertificatesSNI',
                args   => [$farmname]
            );
        } elsif ($farm_type eq 'eproxy') {
            $cert_in_use = grep { $json_obj->{file} eq $_ } &eload(
                module => 'Relianoid::EE::Farm::Eproxy::SSL',
                func   => 'getEproxyFarmCertificates',
                args   => [{ farm_name => $farmname }]
            );
        }
    }
    else {
        $cert_in_use = &getFarmCertificate($farmname) eq $json_obj->{file};
    }

    if ($cert_in_use) {
        my $msg = "The certificate already exists in the farm.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $status;
    if ($eload) {
        if ($farm_type eq 'https') {
            $status = &eload(
                module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext',
                func   => 'setFarmCertificateSNI',
                args   => [ $json_obj->{file}, $farmname ],
            );
        } elsif ($farm_type eq 'eproxy') {
            $status = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::SSL',
                func   => 'setEproxyFarmCertificate',
                args   => [ { farm_name => $farmname, ssl_cert_filename => $json_obj->{file} } ],
            );
        }
    }
    else {
        $status = &setFarmCertificate($json_obj->{file}, $farmname);
    }

    if ($status) {
        my $msg = "It's not possible to add the certificate with name $json_obj->{file} for the $farmname farm";

        &log_error("It's not possible to add the certificate.", "LSLB");
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no errors found, return succesful response
    &log_info("Success trying to add a certificate to the farm.", "LSLB");

    my $message =
      "The certificate $json_obj->{file} has been added to the farm $farmname, you need restart the farm to apply";

    my $body = {
        description => $desc,
        success     => "true",
        message     => $message,
    };

    if (&getFarmStatus($farmname) ne 'down') {
        if ($farm_type eq 'https') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }
        elsif ($farm_type eq 'eproxy' && $eload) {
            $body->{status} = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Action',
                func   => 'runEproxyFarmReload',
                args   => [ { farm_name => $farmname } ],
            );
            require Relianoid::EE::Cluster;
            &runClusterRemoteManager('farm', 'reload', $farmname);
        }
    }

    return &httpResponse({ code => 200, body => $body });
}

# DELETE /farms/FARM/certificates/CERTIFICATE
sub delete_farm_certificate_controller ($farmname, $certfilename) {
    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    my $desc = "Delete farm certificate";

    unless ($eload) {
        my $msg = "HTTPS farm without certificate is not allowed.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate certificate
    unless ($certfilename && &getValidFormat('cert_pem', $certfilename)) {
        my $msg = "Invalid certificate id, please insert a valid value.";
        &log_error("Invalid certificate id.", "LSLB");
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my @certSNI = &eload(
        module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext',
        func   => 'getFarmCertificatesSNI',
        args   => [$farmname],
    );

    my $number = scalar grep ({ $_ eq $certfilename } @certSNI);
    if (!$number) {
        my $msg = "Certificate is not used by the farm.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if (@certSNI == 1 or ($number == @certSNI)) {
        my $msg = "The certificate '$certfilename' could not be deleted, the farm needs one certificate at least.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $status;

    # This is a BUGFIX: delete the certificate all times that it appears in config file
    for (my $it = 0 ; $it < $number ; $it++) {
        $status = &eload(
            module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext',
            func   => 'setFarmDeleteCertNameSNI',
            args   => [ $certfilename, $farmname ],
        );
        last if ($status == -1);
    }

    # check if the certificate could not be removed
    if ($status == -1) {
        &log_error("It's not possible to delete the certificate.", "LSLB");

        my $msg = "It isn't possible to delete the selected certificate $certfilename from the SNI list";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if removing the certificate would leave the SNI list empty, not supported
    if ($status == 1) {
        &log_error("It's not possible to delete all certificates, at least one is required for HTTPS.", "LSLB");

        my $msg = "It isn't possible to delete all certificates, at least one is required for HTTPS profiles";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no errors found, return succesful response
    my $msg  = "The Certificate $certfilename has been deleted";
    my $body = {
        description => $desc,
        success     => "true",
        message     => $msg
    };

    if (&getFarmStatus($farmname) ne 'down') {
        require Relianoid::Farm::Action;
        &setFarmRestart($farmname);
        $body->{status} = 'needed restart';
    }

    &log_info("Success trying to delete a certificate to the SNI list.", "LSLB");

    return &httpResponse({ code => 200, body => $body });
}

# POST /certificates/pem (Create PEM)
sub create_certificate_controller ($json_obj) {
    my $desc = "Create certificate";

    my $configdir = &getGlobalConfiguration('certdir');

    if (-f "$configdir/$json_obj->{name}.pem") {
        my $msg = "$json_obj->{name} already exists.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("certificate_pem-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    require Relianoid::Certificate;
    my $error = &createPEM($json_obj->{name}, $json_obj->{key}, $json_obj->{ca}, $json_obj->{intermediates});

    if ($error->{code}) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error->{desc} });
    }

    # no errors found, return sucessful response
    my $message = "Certificate $json_obj->{name} created";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
    };

    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Action.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::Core;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Action

=cut

my $eload = eval { require Relianoid::ELoad };

# PUT /farms/<farmname>/actions Set an action in a Farm
sub actions_farm_controller ($json_obj, $farmname) {
    require Relianoid::Farm::Action;
    require Relianoid::Farm::Base;

    my $desc = "Farm actions";

    # validate FARM NAME
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) =~ /http/) {
        require Relianoid::Farm::HTTP::Config;
        my $err_msg = &getHTTPFarmConfigErrorMessage($farmname);

        if ($err_msg) {
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $err_msg });
        }
    }

    my $params = &getAPIModel("farm-action.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    if ($json_obj->{action} eq "stop") {
        my $status = &runFarmStop($farmname, "true");

        if ($status != 0) {
            my $msg = "Error trying to set the action stop in farm $farmname.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    elsif ($json_obj->{action} eq "start") {
        require Relianoid::Net::Interface;

        # check if the ip exists in any interface
        my $ip = &getFarmVip("vip", $farmname);

        if (!&getIpAddressExists($ip)) {
            my $msg = "The virtual ip $ip is not defined in any interface.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        require Relianoid::Farm::Base;
        require Relianoid::Farm::Action;
        if (&getFarmRestartStatus($farmname)) {
            my $msg = "The farm has changes pending of applying, it has to be restarted.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        require Relianoid::Farm::Core;
        my $farm_type = &getFarmType($farmname);
        if ($farm_type ne "datalink") {
            my $if_name = &getInterfaceByIp($ip);
            my $if_ref  = &getInterfaceConfig($if_name);
            if (&getInterfaceSystemStatus($if_ref) ne "up") {
                my $msg = "The virtual IP '$ip' is not UP";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
            if ($farm_type eq "http" or $farm_type eq "https") {
                require Relianoid::Farm::HTTP::Action;
                &checkFarmHTTPSystemStatus($farmname, "down", "true");
            }

            my $port = &getFarmVip("vipp", $farmname);
            if (!&validatePort($ip, $port, undef, $farmname)) {
                my $msg = "There is another farm using the ip '$ip' and the port '$port'";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        my $status = &runFarmStart($farmname, "true");

        if ($status) {
            my $msg = "Error trying to set the action start in farm $farmname.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    elsif ($json_obj->{action} eq "restart") {
        my $status = &runFarmStop($farmname, "true");

        if ($status) {
            my $msg = "Error trying to stop the farm in the action restart in farm $farmname.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        require Relianoid::Net::Interface;

        # check if the ip exists in any interface
        my $ip = &getFarmVip("vip", $farmname);

        if (!&getIpAddressExists($ip)) {
            my $msg = "The virtual ip $ip is not defined in any interface.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        require Relianoid::Farm::Core;
        my $farm_type = &getFarmType($farmname);

        if ($farm_type ne "datalink") {
            my $if_name = &getInterfaceByIp($ip);
            my $if_ref  = &getInterfaceConfig($if_name);

            if (&getInterfaceSystemStatus($if_ref) ne "up") {
                my $msg = "The virtual IP '$ip' is not UP";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            my $port = &getFarmVip("vipp", $farmname);
            if (!&validatePort($ip, $port, undef, $farmname)) {
                my $msg = "There is another farm using the ip '$ip' and the port '$port'";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        $status = &runFarmStart($farmname, "true");

        if ($status) {
            my $msg = "API error, trying to start the farm in the action restart in farm $farmname.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my $msg = "The action $json_obj->{action} has been performed in farm $farmname.";

    &log_info("Success, $msg", "FARMS");

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', $json_obj->{action}, $farmname ],
    ) if ($eload);

    my $body = {
        description => "Set a new action in $farmname",
        params      => {
            "action" => $json_obj->{action},
            "status" => &getFarmVipStatus($farmname),
        },
        message => $msg
    };

    return &httpResponse({ code => 200, body => $body });
}

# Set an action in a backend of http|https farm
# PUT /farms/<farmname>/services/<service>/backends/<backend>/maintenance
sub set_service_backend_maintenance_controller ($json_obj, $farmname, $service, $backend_id) {
    require Relianoid::Farm::Base;
    require Relianoid::Farm::HTTP::Config;
    require Relianoid::Farm::HTTP::Service;
    require Relianoid::Farm::HTTP::Backend;

    my $desc = "Set service backend status";

    # validate FARM NAME
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate FARM TYPE
    if (&getFarmType($farmname) !~ /^https?$/) {
        my $msg = "Only HTTP farm profile supports this feature.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # validate SERVICE
    my @services = &getHTTPFarmServices($farmname);
    my $found_service;

    for my $service_name (@services) {
        if ($service eq $service_name) {
            $found_service = 1;
            last;
        }
    }

    if (!$found_service) {
        my $msg = "Could not find the requested service.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate BACKEND
    my $be_aref = &getHTTPFarmBackends($farmname, $service);
    my $be      = $be_aref->[ $backend_id - 1 ];

    if (!$be) {
        my $msg = "Could not find a service backend with such id.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_service_backend-maintenance.json");
    if ($json_obj->{action} ne 'maintenance') {
        delete $params->{mode};
    }

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # Do not allow to modify the maintenance status if the farm needs to be restarted
    require Relianoid::Farm::Action;
    if (&getFarmRestartStatus($farmname)) {
        my $msg = "The farm needs to be restarted before to apply this action.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # validate STATUS
    my $status;
    if ($json_obj->{action} eq "maintenance") {
        my $maintenance_mode = $json_obj->{mode} // "drain";    # default

        $status = &setHTTPFarmBackendMaintenance($farmname, $backend_id, $maintenance_mode, $service);
    }
    elsif ($json_obj->{action} eq "up") {
        $status = &setHTTPFarmBackendNoMaintenance($farmname, $backend_id, $service);
    }

    if ($status->{code} == 1 or $status->{code} == -1) {
        my $msg = "Errors found trying to change status backend to $json_obj->{action}";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $msg = "The action $json_obj->{action} has been performed in farm '$farmname'.";
    my $warning;
    if ($status->{code} != 0) {
        $warning = $status->{desc};
    }

    my $body = {
        description => $desc,
        params      => {
            action => $json_obj->{action},
            farm   => {
                status => &getFarmVipStatus($farmname),
            },
            message => $msg
        },
    };
    $body->{warning} = $warning if $warning;

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', 'restart', $farmname ],
    ) if ($eload && &getFarmStatus($farmname) eq 'up');

    return &httpResponse({ code => 200, body => $body });
}

# PUT backend in maintenance
# PUT /farms/<farmname>/backends/<backend>/maintenance
sub set_backend_maintenance_controller ($json_obj, $farmname, $backend_id) {
    require Relianoid::Farm::Backend::Maintenance;
    require Relianoid::Farm::Backend;
    require Relianoid::Farm::Base;

    my $desc = "Set backend status";

    # validate FARM NAME
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate FARM TYPE
    unless (&getFarmType($farmname) eq 'l4xnat') {
        my $msg = "Only L4xNAT farm profile supports this feature.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate BACKEND
    require Relianoid::Farm::L4xNAT::Backend;

    my $backends = &getL4FarmServers($farmname);
    my $exists   = &getFarmServer($backends, $backend_id);

    if (!$exists) {
        my $msg = "Could not find a backend with such id.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_l4xnat_service_backend-maintenance.json");

    if ($json_obj->{action} ne 'maintenance') {
        delete $params->{mode};
    }

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # validate STATUS
    my $status;
    if ($json_obj->{action} eq "maintenance") {
        my $maintenance_mode = $json_obj->{mode} // "drain";    # default

        $status = &setFarmBackendMaintenance($farmname, $backend_id, $maintenance_mode);
    }
    elsif ($json_obj->{action} eq "up") {
        $status = &setFarmBackendNoMaintenance($farmname, $backend_id);
    }

    if ($status->{code} == 1 or $status->{code} == -1) {
        my $msg = "Errors found trying to change status backend to $json_obj->{action}";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $msg = "The action $json_obj->{action} has been performed in farm '$farmname'.";
    my $warning;
    if ($status->{code} != 0) {
        $warning = $status->{desc};
    }

    # no error found, send successful response
    my $body = {
        description => $desc,
        params      => {
            action => $json_obj->{action},
            farm   => {
                status => &getFarmVipStatus($farmname),
            },
            message => $msg
        },
    };
    $body->{warning} = $warning if $warning;

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', 'restart', $farmname ],
    ) if ($eload && &getFarmStatus($farmname) eq 'up');

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Backend.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::HTTP;
use Relianoid::Farm::Core;
use Relianoid::Farm::Base;
use Relianoid::Net::Validate;
use Relianoid::HTTP::Controllers::API::Farm::Get;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Backend

=cut

my $eload = eval { require Relianoid::ELoad };

# POST

sub add_farm_backend_controller ($json_obj, $farmname) {
    require Relianoid::Farm::Backend;

    # Initial parameters
    my $desc = "New farm backend";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);
    if ($type ne 'datalink' and $type ne 'l4xnat') {
        my $msg = "The $type farm profile has backends only in services.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $params =
      ($type eq 'l4xnat')
      ? &getAPIModel("farm_l4xnat_service_backend-add.json")
      : &getAPIModel("farm_datalink_service_backend-add.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my $id = &getFarmBackendAvailableID($farmname);

    my $info_msg;

    # check of interface for datalink
    if ($type eq 'datalink') {
        my $msg = &_validate_datalink_backend_interface($json_obj);
        if ($msg) {
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # check of ip version
    if ($type eq 'l4xnat') {
        require Relianoid::Farm::L4xNAT::Config;
        my $farm_vip = &getL4FarmParam("vip", $farmname);

        if (&ipversion($json_obj->{ip}) ne &ipversion($farm_vip)) {
            my $msg = "The IP version of backend IP '$json_obj->{ip}' does not match with farm VIP '$farm_vip'";

            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Create backend
    my $status = &setFarmServer($farmname, undef, $id, $json_obj);

    if ($status && $status == -1) {
        my $msg = "It was not possible to create the backend";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    elsif ($status && $status == -2) {
        my $msg = "The IP $json_obj->{ip} is already set in farm $farmname";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &log_info("New backend created in farm $farmname with IP $json_obj->{ip}.", "FARMS");

    # check priority for l4xnat
    if ($type eq 'l4xnat') {
        require Relianoid::Farm::L4xNAT::Backend;
        require Relianoid::Farm::Validate;

        my $priorities = &getL4FarmPriorities($farmname);

        if (my $prio = &priorityAlgorithmIsOK($priorities)) {
            $info_msg = "Backends with high priority value ($prio) will not be used.";
            &log_warn("Warning, backend with high priority value ($prio) in farm $farmname.", "FARMS");
        }
    }

    # Backend retrieval
    my $serversArray = &getFarmServers($farmname);
    my $backend      = &getFarmServer($serversArray, $id);

    if (!$backend) {
        my $msg = "Error when retrieving the backend created";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::HTTP::Adapters::Backend;
    &getBackendsResponse($backend, $type);

    my $message = "Backend added.";
    my $body    = {
        description => $desc,
        params      => $backend,
        message     => $message,
        status      => &getFarmVipStatus($farmname),
    };

    $body->{warning} = $info_msg if defined $info_msg;

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', 'restart', $farmname ],
    ) if ($eload);

    return &httpResponse({ code => 201, body => $body });
}

sub add_service_backend_controller ($json_obj, $farmname, $service) {
    # Initial parameters
    my $desc = "New service backend";
    my $type = &getFarmType($farmname);

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate FARM TYPE

    if ($type eq "gslb" && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::GSLB',
            func   => 'new_gslb_service_backend',
            args   => [ $json_obj, $farmname, $service ]
        );
    }
    elsif ($type eq "eproxy" && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::Eproxy',
            func   => 'new_eproxy_service_backend',
            args   => [ $json_obj, $farmname, $service ]
        );
    }
    elsif ($type !~ /^https?$/) {
        my $msg = "The $type farm profile does not support services.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # HTTP
    require Relianoid::Farm::Config;
    require Relianoid::Farm::Backend;
    require Relianoid::Farm::Validate;
    require Relianoid::Farm::HTTP::Backend;
    require Relianoid::Farm::HTTP::Service;

    # validate SERVICE
    my @services = &getHTTPFarmServices($farmname);

    # Check if the provided service is configured in the farm
    unless (grep { $service eq $_ } @services) {
        my $msg = "Invalid service name, please insert a valid value.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the service has configured a redirect
    if (&getHTTPFarmVS($farmname, $service, 'redirect')) {
        my $msg = "It is not possible to create a backend when the service has a redirect configured.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_service_backend-add.json");
    undef $params->{connection_limit};

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # get an ID for the new backend
    my $id = &getHTTPFarmBackendAvailableID($farmname, $service);

    my $prio = 1;
    if (defined $json_obj->{priority} && $json_obj->{priority} !~ /^$/) {
        $prio = $json_obj->{priority} + 0;
    }

    if ($type =~ /http/ && $prio > 1) {
        my $priorities = &getHTTPFarmPriorities($farmname, $service);

        if (scalar(@{$priorities}) >= 1) {
            my $msg = "Only one backend as second priority is allowed.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # First param ($id) is an empty string to let function autogenerate the id for the new backend
    my $error = &setHTTPFarmServer(
        "",                   $json_obj->{ip}, $json_obj->{port}, $json_obj->{weight},    #
        $json_obj->{timeout}, $farmname,       $service,          $json_obj->{priority}
    );

    # check if there was an error adding a new backend
    if ($error) {
        my $msg =
            "It's not possible to create the backend with ip $json_obj->{ip}"
          . " and port $json_obj->{port} for the $farmname farm";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no error found, return successful response
    &log_info("Success, a new backend has been created in farm $farmname in service $service with IP $json_obj->{ip}.",
        "FARMS");

    my $message = "Added backend to service successfully.";
    my $backend = &getFarmServers($farmname, $service)->[$id];

    require Relianoid::HTTP::Adapters::Backend;
    &getBackendsResponse($backend, $type);

    my $body = {
        description => $desc,
        params      => $backend,
        message     => $message,
        status      => &getFarmVipStatus($farmname),
    };

    if (&getFarmStatus($farmname) eq 'up') {
        if ($type eq "eproxy" && $eload) {
            $body->{status} = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Action',
                func   => 'runEproxyFarmReload',
                args   => [ { farm_name => $farmname } ],
            );
            require Relianoid::EE::Cluster;
            &runClusterRemoteManager('farm', 'reload', $farmname);
        }
        else {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }
    }

    return &httpResponse({ code => 201, body => $body });
}

# GET

#GET /farms/<name>/backends
sub list_farm_backends_controller ($farmname) {
    require Relianoid::Farm::Backend;

    my $desc = "List backends";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);

    if ($type ne 'l4xnat' and $type ne 'datalink') {
        my $msg = "The farm $farmname with profile $type does not support this request.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::HTTP::Adapters::Backend;

    my $backends = &getFarmServers($farmname);
    &getBackendsResponse($backends, $type);

    my $body = {
        description => $desc,
        params      => $backends,
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET /farms/<name>/services/<service>/backends
sub list_service_backends_controller ($farmname, $service) {
    my $desc = "List service backends";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);
    my $service_ref;

    if ($type eq 'gslb' && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::GSLB',
            func   => 'list_gslb_service_backends',
            args   => [ $farmname, $service ]
        );
    }
    elsif ($type eq 'eproxy' && $eload) {
        $service_ref->{backends} = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Backend',
            func   => 'getEproxyFarmBackends',
            args   => [ { farm_name => $farmname, service_name => $service } ]
        );
    }
    elsif ($type =~ /^https?$/) {
        require Relianoid::Farm::HTTP::Service;
        $service_ref = &getHTTPServiceStruct($farmname, $service);
        # check if the requested service exists
        if ($service_ref == -1) {
            my $msg = "The service $service does not exist.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }
    else {
        my $msg = "The farm profile $type does not support this request.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $body = {
        description => $desc,
        params      => $service_ref->{backends},
    };

    return &httpResponse({ code => 200, body => $body });
}

# PUT

sub modify_farm_backend_controller ($json_obj, $farmname, $id_server) {
    my $desc = "Modify backend";

    require Relianoid::Farm::Backend;
    require Relianoid::Net::Validate;

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);
    if ($type ne 'datalink' and $type ne 'l4xnat') {
        my $msg = "The $type farm profile has backends only in services.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # get backends
    my $serversArray = &getFarmServers($farmname);

    my $backend = &getFarmServer($serversArray, $id_server);

    if (!$backend || ref($backend) ne "HASH") {
        my $msg = "Could not find a backend with such id.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $params =
      ($type eq 'l4xnat')
      ? &getAPIModel("farm_l4xnat_service_backend-modify.json")
      : &getAPIModel("farm_datalink_service_backend-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # check of ip version
    if ($type eq 'l4xnat' && exists $json_obj->{ip}) {
        require Relianoid::Farm::L4xNAT::Config;
        my $farm_vip = &getL4FarmParam("vip", $farmname);

        if (&ipversion($json_obj->{ip}) ne &ipversion($farm_vip)) {
            my $msg = "The IP version of backend IP '$json_obj->{ip}' does not match with farm VIP '$farm_vip'";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    $backend->{ip}        = $json_obj->{ip}        if exists $json_obj->{ip};
    $backend->{port}      = $json_obj->{port}      if exists $json_obj->{port};         # l4xnat
    $backend->{weight}    = $json_obj->{weight}    if exists $json_obj->{weight};
    $backend->{priority}  = $json_obj->{priority}  if exists $json_obj->{priority};
    $backend->{max_conns} = $json_obj->{max_conns} if exists $json_obj->{max_conns};    # l4xnat
    $backend->{interface} = $json_obj->{interface} if exists $json_obj->{interface};    # datalink

    if ($type eq 'datalink') {
        if (my $msg = &_validate_datalink_backend_interface($backend)) {
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my $error = &setFarmServer($farmname, undef, $id_server, $backend);
    if ($error && $error == -2) {
        my $msg = "The IP $json_obj->{ip} is already set in farm $farmname";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    if ($error) {
        my $msg = "Error trying to modify the backend $id_server.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $info_msg;
    if (($type ne 'datalink') and (exists $json_obj->{priority})) {
        require Relianoid::Farm::L4xNAT::Backend;
        require Relianoid::Farm::Validate;
        if (my $prio = &priorityAlgorithmIsOK(&getL4FarmPriorities($farmname))) {
            $info_msg = "Backends with high priority value ($prio) will not be used.";
            &log_warn("Warning, backend with high priority value ($prio) in farm $farmname.", "FARMS");
        }
    }

    &log_info("Success, some parameters have been changed in the backend $id_server in farm $farmname.", "FARMS");

    my $message = "Backend modified.";
    my $body    = {
        description => $desc,
        params      => $json_obj,
        message     => $message,
        status      => &getFarmVipStatus($farmname),
    };
    $body->{warning} = $info_msg if defined $info_msg;

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', 'restart', $farmname ],
    ) if ($eload && &getFarmStatus($farmname) eq 'up');

    return &httpResponse({ code => 200, body => $body });
}

sub modify_service_backends_controller ($json_obj, $farmname, $service, $id_server) {
    my $desc = "Modify service backend";

    my $type = &getFarmType($farmname);

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if ($type eq "gslb" && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::GSLB',
            func   => 'modify_gslb_service_backends',
            args   => [ $json_obj, $farmname, $service, $id_server ]
        );
    }
    if ($type eq "eproxy" && $eload) {
        my $status = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Backend',
            func   => 'modifyEproxyFarmBackend',
            args   => [ {
                farm_name => $farmname,
                service_name => $service,
                backend_id => $id_server,
                backend_ip => $json_obj->{ip},
                backend_port => $json_obj->{port},
                backend_weight => $json_obj->{weight},
                backend_priority => $json_obj->{priority}
            } ]
        );
        if ($status) {
            my $msg = "It's not possible to modify the backend with IP $json_obj->{ip} in service $service.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    elsif ($type =~ /^https?$/) {
        # HTTP
        require Relianoid::Farm::Action;
        require Relianoid::Farm::HTTP::Config;
        require Relianoid::Farm::HTTP::Backend;
        require Relianoid::Farm::HTTP::Service;

        # validate SERVICE
        my @services      = &getHTTPFarmServices($farmname);
        my $found_service = grep { $service eq $_ } @services;

        # check if the service exists
        if (!$found_service) {
            my $msg = "Could not find the requested service.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        # validate BACKEND
        my $be;
        {
            my @be_list = @{ &getHTTPFarmBackends($farmname, $service) };
            $be = $be_list[$id_server];
        }

        # check if the backend was found
        if (!$be) {
            my $msg = "Could not find a service backend with such id.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        my $params = &getAPIModel("farm_http_service_backend-modify.json");
        undef $params->{connection_limit};

        # Check allowed parameters
        if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
        }

        # apply BACKEND change

        $be->{ip}               = $json_obj->{ip}               // $be->{ip};
        $be->{port}             = $json_obj->{port}             // $be->{port};
        $be->{weight}           = $json_obj->{weight}           // $be->{weight};
        $be->{priority}         = $json_obj->{priority}         // $be->{priority};
        $be->{timeout}          = $json_obj->{timeout}          // $be->{timeout};
        $be->{connection_limit} = $json_obj->{connection_limit} // $be->{connection_limit};

        my $prio = 1;
        if (defined $be->{priority} && $be->{priority} !~ /^$/) {
            $prio = $be->{priority} + 0;
        }

        if ($type =~ /http/ && $prio > 1) {
            my $priorities = &getHTTPFarmPriorities($farmname, $service);
            if (scalar(@{$priorities}) >= 1 && !grep { $_->{id} == $id_server } @{$priorities}) {
                my $msg = "Only one backend as second priority is allowed.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        my $status = &setHTTPFarmServer(
            $id_server,     $be->{ip}, $be->{port}, $be->{weight},    #
            $be->{timeout}, $farmname, $service,    $be->{priority}
        );

        # check if there was an error modifying the backend
        if ($status == -1) {
            my $msg = "It's not possible to modify the backend with IP $json_obj->{ip} in service $service.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    else {
        my $msg = "The $type farm profile does not support services.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $msg  = "Backend modified.";
    my $body = {
        description => $desc,
        params      => $json_obj,
        message     => $msg,
        status      => &getFarmVipStatus($farmname),
    };

    if (&getFarmStatus($farmname) eq "up") {
        if ($type eq "eproxy" && $eload) {
            $body->{status} = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Action',
                func   => 'runEproxyFarmReload',
                args   => [ { farm_name => $farmname } ],
            );
            require Relianoid::EE::Cluster;
            &runClusterRemoteManager('farm', 'reload', $farmname);
        }
        else {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }
    }

    return &httpResponse({ code => 200, body => $body });
}

# DELETE

# DELETE /farms/<farmname>/backends/<backendid> Delete a backend of a Farm
sub delete_farm_backend_controller ($farmname, $id_server) {
    require Relianoid::Farm::Backend;

    my $desc = "Delete backend";

    # validate FARM NAME
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate FARM TYPE
    my $type = &getFarmType($farmname);
    unless ($type eq 'l4xnat' || $type eq 'datalink') {
        my $msg = "The $type farm profile has backends only in services.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $backends = &getFarmServers($farmname);
    my $exists   = &getFarmServer($backends, $id_server);

    if (!$exists) {
        my $msg = "Could not find a backend with such id.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $status = &runFarmServerDelete($id_server, $farmname);

    if ($status == -1) {
        my $msg = "It's not possible to delete the backend with ID $id_server of the $farmname farm.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $info_msg;
    if ($type eq 'l4xnat') {
        require Relianoid::Farm::Validate;
        if (my $prio = &priorityAlgorithmIsOK(&getL4FarmPriorities($farmname))) {
            $info_msg = "Backends with high priority value ($prio) will not be used.";
            &log_warn("Warning, backend with high priority value ($prio) in farm $farmname.", "FARMS");
        }
    }

    &log_info("Success, the backend $id_server in farm $farmname has been deleted.", "FARMS");

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', 'delete', $farmname, 'backend', $id_server ],
    ) if ($eload && $type eq 'l4xnat');

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', 'restart', $farmname ],
    ) if ($eload && $type eq 'datalink');

    my $message = "Backend removed";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
        status      => &getFarmVipStatus($farmname),
    };
    $body->{warning} = $info_msg if defined $info_msg;

    return &httpResponse({ code => 200, body => $body });
}

#  DELETE /farms/<farmname>/services/<servicename>/backends/<backendid> Delete a backend of a Service
sub delete_service_backend_controller ($farmname, $service, $id_server) {
    my $desc = "Delete service backend";

    # validate FARM NAME
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate FARM TYPE
    my $type = &getFarmType($farmname);

    if ($type eq 'gslb' && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::GSLB',
            func   => 'delete_gslb_service_backend',
            args   => [ $farmname, $service, $id_server ]
        );
    }
    elsif ($type eq 'eproxy' && $eload) {
        my $status = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Backend',
            func   => 'delEproxyFarmBackend',
            args   => [ { farm_name => $farmname, service_name => $service, backend_id => $id_server } ]
        );
        if ($status) {
            my $msg = "It hasn't been possible to delete the backend ID $id_server in the service $service from the eproxy farm $farmname";
            &log_info($msg, "LSLB");
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }
    elsif ($type =~ /^https?$/) {
        require Relianoid::Farm::Action;
        require Relianoid::Farm::HTTP::Config;
        require Relianoid::Farm::HTTP::Backend;
        require Relianoid::Farm::HTTP::Service;

        # validate SERVICE
        my @services = &getHTTPFarmServices($farmname);

        # check if the SERVICE exists
        unless (grep { $service eq $_ } @services) {
            my $msg = "Could not find the requested service.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        # check if the backend id is available
        my $be_found;
        {
            my $be = &getHTTPFarmBackends($farmname, $service);
            $be_found = defined @{$be}[$id_server];
        }

        unless ($be_found) {
            my $msg = "Could not find the requested backend.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        my $status = &runHTTPFarmServerDelete($id_server, $farmname, $service);

        # check if there was an error deleting the backend
        if ($status == -1) {
            &log_info("It's not possible to delete the backend.", "FARMS");

            my $msg = "Could not find the backend with ID $id_server of the $farmname farm.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }
    else {
        my $msg = "The $type farm profile does not support services.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no error found, return successful response
    &log_info("Success, the backend $id_server in service $service in farm $farmname has been deleted.", "FARMS");

    my $message = "Backend removed";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
        status      => &getFarmVipStatus($farmname),
    };

    if (&getFarmStatus($farmname) eq 'up') {
        if ($type eq "eproxy" && $eload) {
            $body->{status} = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Action',
                func   => 'runEproxyFarmReload',
                args   => [ { farm_name => $farmname } ],
            );
            require Relianoid::EE::Cluster;
            &runClusterRemoteManager('farm', 'reload', $farmname);
        }
        else {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }
    }

    return &httpResponse({ code => 200, body => $body });
}

sub _validate_datalink_backend_interface ($backend) {
    require Relianoid::Net::Interface;

    my $msg;
    my $iface_ref = &getInterfaceConfig($backend->{interface});

    if (not defined $iface_ref) {
        $msg = "$backend->{interface} has not been found";
    }
    elsif ($iface_ref->{vini}) {
        $msg = "It is not possible to configure vlan interface for datalink backends";
    }
    elsif (!&validateGateway($iface_ref->{addr}, $iface_ref->{mask}, $backend->{ip})) {
        $msg = "The $backend->{ip} IP must be in the same network than the $iface_ref->{addr} interface.";
    }

    return $msg;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Delete.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::Core;
use Relianoid::Farm::Base;
use Relianoid::Farm::Action;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Delete

=cut

my $eload = eval { require Relianoid::ELoad };

# DELETE /farms/FARMNAME
sub delete_farm_controller ($farmname) {
    my $desc = "Delete farm $farmname";

    if (!&getFarmExists($farmname)) {
        my $msg = "The farm $farmname doesn't exist, try another name.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmStatus($farmname) eq 'up') {
        if (&runFarmStop($farmname, "true")) {
            my $msg = "The farm $farmname could not be stopped.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'farm', 'stop', $farmname ],
        ) if ($eload);
    }

    my $error = &runFarmDelete($farmname);

    if ($error) {
        my $msg = "The Farm $farmname hasn't been deleted";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &log_info("Success, the farm $farmname has been deleted.", "FARMS");

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', 'delete', $farmname ],
    ) if ($eload);

    my $msg  = "The Farm $farmname has been deleted.";
    my $body = {
        description => $desc,
        success     => "true",
        message     => $msg
    };

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Get.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Config;
use Relianoid::Farm::Core;
use Relianoid::Farm::Base;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Get

=cut

my $eload = eval { require Relianoid::ELoad };

#GET /farms
sub list_farms_controller () {
    require Relianoid::Farm::Base;

    my @out;
    my @files = &getFarmList();

    for my $file (@files) {
        my $name   = &getFarmName($file);
        my $type   = &getFarmType($name);
        my $status = &getFarmVipStatus($name);
        my $vip    = &getFarmVip('vip',  $name);
        my $port   = &getFarmVip('vipp', $name);

        push @out,
          {
            farmname => $name,
            profile  => $type,
            status   => $status,
            vip      => $vip,
            vport    => $port
          };
    }

    if ($eload) {
        @out = @{
            &eload(
                module => 'Relianoid::EE::RBAC::Group::Core',
                func   => 'getRBACUserSet',
                args   => [ 'farms', \@out ],
            )
        };
    }

    my $body = {
        description => "List farms",
        params      => \@out,
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /farms/modules/lslb
sub list_lslb_controller () {
    require Relianoid::Farm::Base;

    my @out;
    my @files = &getFarmList();

    for my $file (@files) {
        my $name = &getFarmName($file);
        my $type = &getFarmType($name);
        next unless $type =~ /^(?:https?|l4xnat|eproxy)$/;
        my $status = &getFarmVipStatus($name);
        my $vip    = &getFarmVip('vip',  $name);
        my $port   = &getFarmVip('vipp', $name);

        push @out,
          {
            farmname => $name,
            profile  => $type,
            status   => $status,
            vip      => $vip,
            vport    => $port
          };
    }

    if ($eload) {
        @out = @{
            &eload(
                module => 'Relianoid::EE::RBAC::Group::Core',
                func   => 'getRBACUserSet',
                args   => [ 'farms', \@out ],
            )
        };
    }

    my $body = {
        description => "List LSLB farms",
        params      => \@out,
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /farms/modules/dslb
sub list_dslb_controller () {
    require Relianoid::Farm::Base;

    my @out;
    my @files = &getFarmList();

    for my $file (@files) {
        my $name = &getFarmName($file);
        my $type = &getFarmType($name);
        next unless $type eq 'datalink';
        my $status = &getFarmVipStatus($name);
        my $vip    = &getFarmVip('vip',  $name);
        my $iface  = &getFarmVip('vipp', $name);

        push @out,
          {
            farmname  => $name,
            status    => $status,
            vip       => $vip,
            interface => $iface
          };
    }

    if ($eload) {
        @out = @{
            &eload(
                module => 'Relianoid::EE::RBAC::Group::Core',
                func   => 'getRBACUserSet',
                args   => [ 'farms', \@out ],
            )
        };
    }

    my $body = {
        description => "List DSLB farms",
        params      => \@out,
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET /farms/<name>/summary
sub get_farm_summary_controller ($farmname) {
    my $desc = "Show farm $farmname";
    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "Farm not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);
    if ($type =~ /https?/) {
        require Relianoid::HTTP::Controllers::API::Farm::Get::HTTP;
        &farms_name_http_summary($farmname);
    }
    else {
        &get_farm_controller($farmname);
    }

    return;
}

#GET /farms/<name>
sub get_farm_controller ($farmname) {
    my $desc = "Show farm $farmname";

    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "Farm not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);

    if ($type =~ /https?/) {
        require Relianoid::HTTP::Controllers::API::Farm::Get::HTTP;
        &farms_name_http($farmname);
    }
    elsif ($type eq 'l4xnat') {
        require Relianoid::HTTP::Controllers::API::Farm::Get::L4xNAT;
        &farms_name_l4($farmname);
    }
    elsif ($type eq 'datalink') {
        require Relianoid::EE::HTTP::Controllers::API::Farm::Get::Datalink;
        &farms_name_datalink($farmname);
    }
    elsif ($type eq 'gslb' && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::Get::GSLB',
            func   => 'farms_name_gslb',
            args   => [$farmname],
        );
    }
    elsif ($type eq 'eproxy' && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::Get::Eproxy',
            func   => 'farms_name_eproxy',
            args   => [$farmname],
        );
    }

    return;
}

#GET /farms/<name>/status
sub get_farm_status_controller ($farmname) {
    my $desc = "Show farm $farmname status";

    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "Farm not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $status = &getFarmVipStatus($farmname);

    # Output
    my $body = {
        description => $desc,
        params      => { status => $status },
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /farms/modules/summary
sub get_farm_modules_controller () {
    require Relianoid::Farm::Service;
    my $out = { lslb => [], gslb => [], dslb => [], };

    for my $farm_name (&getFarmNameList()) {
        my $type = &getFarmType($farm_name);
        $type =~ s/https/http/;
        my $it = {
            name    => $farm_name,
            profile => $type,
        };

        if ($type eq 'gslb' or $type eq 'http') {
            my @srv = &getFarmServices($farm_name);
            $it->{services} = \@srv;
        }

        if    ($type eq 'datalink') { push @{ $out->{dslb} }, $it; }
        elsif ($type eq 'gslb')     { push @{ $out->{gslb} }, $it; }
        else                        { push @{ $out->{lslb} }, $it; }
    }

    my $body = {
        description => "Farm Modules summary",
        params      => $out,
    };

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Get/HTTP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::HTTP::Config;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Get::HTTP

=cut

my $eload = eval { require Relianoid::ELoad };

# GET /farms/<farmname> Request info of a http|https Farm
sub farms_name_http ($farmname) {
    # Get farm reference
    require Relianoid::HTTP::Controllers::API::Farm::Output::HTTP;
    my $farm_ref = &getHTTPOutFarm($farmname);

    # Get farm services reference
    require Relianoid::Farm::HTTP::Service;
    my $services_ref = &getHTTPOutService($farmname);

    # Output
    my $body = {
        description => "List farm $farmname",
        params      => $farm_ref,
        services    => $services_ref,
    };

    if ($eload) {
        $body->{ipds} = &eload(
            module => 'Relianoid::EE::IPDS::Core',
            func   => 'getIPDSfarmsRules',
            args   => [$farmname],
        );
    }

    return &httpResponse({ code => 200, body => $body });
}

# GET /farms/<farmname>/summary
sub farms_name_http_summary ($farmname) {
    # Get farm reference
    require Relianoid::HTTP::Controllers::API::Farm::Output::HTTP;
    my $farm_ref = &getHTTPOutFarm($farmname);

    # Services
    require Relianoid::Farm::HTTP::Service;

    my $services_ref = &get_http_all_services_summary_struct($farmname);

    my $body = {
        description => "List farm $farmname",
        params      => $farm_ref,
        services    => $services_ref,
    };

    if ($eload) {
        $body->{ipds} = &eload(
            module => 'Relianoid::EE::IPDS::Core',
            func   => 'getIPDSfarmsRules',
            args   => [$farmname],
        );
    }

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Get/L4xNAT.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::FarmGuardian;
use Relianoid::Farm::Config;
use Relianoid::Farm::Backend;
use Relianoid::Farm::L4xNAT::Config;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Get::L4xNAT

=cut

my $eload = eval { require Relianoid::ELoad };

# GET /farms/<farmname> Request info of a l4xnat Farm
sub farms_name_l4 ($farmname) {
    require Relianoid::Farm::L4xNAT::Sessions;

    my $farm   = &getL4FarmStruct($farmname);
    my $status = &getFarmVipStatus($farmname);
    my $fields = {
        status      => $status,
        vip         => $farm->{vip},
        vport       => $farm->{vport},
        algorithm   => $farm->{lbalg},
        nattype     => $farm->{nattype},
        persistence => $farm->{persist},
        ttl         => $farm->{ttl} + 0,
        protocol    => $farm->{vproto},

        farmguardian => &getFGFarm($farmname),
        listener     => 'l4xnat',
        sessions     => &listL4FarmSessions($farmname)
    };

    require Relianoid::HTTP::Adapters::Backend;

    my $backends = &getL4FarmServers($farmname);
    &getBackendsResponse($backends, 'l4xnat');

    my $body = {
        description => "List farm $farmname",
        params      => $fields,
        backends    => $backends,
    };

    if ($eload) {
        $fields->{logs} = $farm->{logs};

        $body->{ipds} = &eload(
            module => 'Relianoid::EE::IPDS::Core',
            func   => 'getIPDSfarmsRules',
            args   => [$farmname],
        );
    }

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Guardian.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::FarmGuardian;
use Relianoid::Farm::Core;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Guardian

=cut

my $eload = eval { require Relianoid::ELoad };

sub get_farmguardian_response ($fg_name) {
    my $fg  = &getFGObject($fg_name);
    my $out = {
        'name'          => $fg_name,
        'backend_alias' => $fg->{backend_alias} // 'false',
        'description'   => $fg->{description},
        'command'       => $fg->{command},
        'farms'         => $fg->{farms},
        'log'           => $fg->{log} // 'false',
        'interval'      => $fg->{interval} + 0,
        'cut_conns'     => $fg->{cut_conns},
        'template'      => $fg->{template},
        'timeout'       => ($fg->{timeout} // $fg->{interval}) + 0,
    };

    return $out;
}

sub list_farmguardian_response () {
    my @out;
    my @list = &getFGList();

    for my $fg_name (@list) {
        my $fg = &get_farmguardian_response($fg_name);
        push @out, $fg;
    }

    return \@out;
}

# first, it checks is exists and later look for in both lists, template and config
#  GET /monitoring/fg/<fg_name>
sub get_farmguardian_controller ($fg_name) {
    my $desc = "Retrive the farm guardian '$fg_name'";

    unless (&getFGExists($fg_name)) {
        my $msg = "The farm guardian '$fg_name' has not been found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $out  = &get_farmguardian_response($fg_name);
    my $body = { description => $desc, params => $out };

    return &httpResponse({ code => 200, body => $body });
}

#  GET /monitoring/fg
sub list_farmguardian_controller () {
    my $fg   = &list_farmguardian_response();
    my $desc = "List farm guardian checks and templates";

    return &httpResponse({ code => 200, body => { description => $desc, params => $fg } });
}

#  POST /monitoring/fg
sub create_farmguardian_controller ($json_obj) {
    my $fg_name = $json_obj->{name};
    my $desc    = "Create a farm guardian '$fg_name'";

    if (&getFGExistsConfig($fg_name)) {
        my $msg = "The farm guardian '$fg_name' already exists.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if (&getFGExistsTemplate($fg_name)) {
        my $msg = "The farm guardian '$fg_name' is a template, select another name, please";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farmguardian-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    if (exists $json_obj->{copy_from}
        and not &getFGExists($json_obj->{copy_from}))
    {
        my $msg = "The parent farm guardian '$json_obj->{copy_from}' does not exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if    (not exists $json_obj->{copy_from}) { &createFGBlank($fg_name); }
    elsif (&getFGExistsTemplate($json_obj->{copy_from})) {
        &createFGTemplate($fg_name, $json_obj->{copy_from});
    }
    else { &createFGConfig($fg_name, $json_obj->{copy_from}); }

    my $out = &get_farmguardian_response($fg_name);
    if ($out) {
        my $msg  = "The farm guardian '$fg_name' has been created successfully.";
        my $body = {
            description => $desc,
            params      => $out,
            message     => $msg,
        };
        return &httpResponse({ code => 200, body => $body });
    }
    else {
        my $msg = "The farm guardian '$fg_name' could not be created";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
}

#  PUT /monitoring/fg/<fg_name>
sub modify_farmguardian_controller ($json_obj, $fgname) {
    my $desc = "Modify farm guardian '$fgname'";

    unless (&getFGExists($fgname)) {
        my $msg = "The farm guardian '$fgname' does not exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farmguardian-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my @run_farms = @{ &getFGRunningFarms($fgname) };
    my $run_farms;
    $run_farms = join(', ', @run_farms) if @run_farms;

    # avoid modifying some parameters of a template
    if (&getFGExistsTemplate($fgname)) {
        if (exists $json_obj->{description} or exists $json_obj->{command}) {
            my $msg = "It is not allow to modify the parameters 'description' or 'command' in a template.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # check if farm guardian is running
    if (    $run_farms
        and not exists $json_obj->{force}
        and $json_obj->{force} ne 'true')
    {
        if (exists $json_obj->{command} or exists $json_obj->{backend_alias}) {
            my $error_msg = "Farm guardian '$fgname' is running in: '$run_farms'. To apply, send parameter 'force'";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
        }
    }

    delete $json_obj->{force};

    if (my $error = &setFGObject($fgname, $json_obj)) {
        my $msg  = "Modifying farm guardian '$fgname'.";
        my $body = { description => $desc, message => $msg, };
        return &httpResponse({ code => 400, body => $body });
    }

    # sync with cluster
    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'fg', 'restart', $fgname ],
        );
    }

    # no error found, return successful response
    my $msg  = "Success, some parameters have been changed in farm guardian '$fgname'.";
    my $out  = &get_farmguardian_response($fgname);
    my $body = { description => $desc, params => $out, message => $msg, };

    return &httpResponse({ code => 200, body => $body });
}

#  DELETE /monitoring/fg/<fg_name>
sub delete_farmguardian_controller ($fg_name) {
    my $desc = "Delete the farm guardian '$fg_name'";

    unless (&getFGExists($fg_name)) {
        my $msg = "The farm guardian $fg_name does not exist";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my @running_farms = @{ &getFGRunningFarms($fg_name) };
    if (@running_farms) {
        my $farm_str = join(', ', @running_farms);
        my $msg      = "It is not possible delete farm guardian '$fg_name' because it is running in: '$farm_str'";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &delFGObject($fg_name);

    if (!&getFGExists($fg_name)) {
        # sync with cluster
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'fg', 'stop', $fg_name ],
            );
        }

        my $msg  = "$fg_name has been deleted successfully.";
        my $body = {
            description => $desc,
            success     => "true",
            message     => $msg,
        };
        return &httpResponse({ code => 200, body => $body });
    }
    else {
        my $msg = "Deleting the farm guardian '$fg_name'.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
}

#  POST /farms/<farm>(/services/<service>)?/fg
sub add_fg_to_farm_controller ($json_obj, $farm, $srv = undef) {
    my $srv_message = ($srv) ? "service '$srv' in the farm '$farm'" : "farm '$farm'";

    my $desc = "Add the farm guardian '$json_obj->{name}' to the '$srv_message'";

    require Relianoid::Farm::Service;

    # Check if it exists
    if (!&getFarmExists($farm)) {
        my $msg = "The farm '$farm' does not exist";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farmguardian_to_farm-add.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # Check if it exists
    if (!&getFGExists($json_obj->{name})) {
        my $msg = "The farmguardian '$json_obj->{name}' does not exist";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Check if it exists
    if ($srv and not grep { $srv eq $_ } &getFarmServices($farm)) {
        my $msg = "The service '$srv' does not exist";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # check if another fg is applied to the farm
    my $fg_old = &getFGFarm($farm, $srv);
    if ($fg_old) {
        my $msg = "The '$srv_message' has already linked a farm guardian";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # link the check with the farm_service
    my $farm_tag = $farm;
    $farm_tag = "${farm}_$srv" if $srv;

    # check if the farm guardian is already applied to the farm
    my $fg_obj = &getFGObject($json_obj->{name});
    if (grep { $farm_tag eq $_ } @{ $fg_obj->{farms} }) {
        my $msg = "'$json_obj->{name}' is already applied in the '$srv_message'";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check farm type
    my $type = &getFarmType($farm);
    if ($type =~ /http|gslb|eproxy/ and not $srv) {
        my $msg = "The farm guardian expects a service";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $output = &linkFGFarm($json_obj->{name}, $farm, $srv);

    # check result and return success or failure
    if (!$output) {
        # sync with cluster
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'fg_farm', 'start', $farm, $srv ],
            );
        }

        my $msg  = "Success, The farm guardian '$json_obj->{name}' was added to the '$srv_message'";
        my $body = {
            description => $desc,
            message     => $msg,
            status      => &getFarmVipStatus($farm),
        };
        return &httpResponse({ code => 200, body => $body });
    }
    else {
        my $msg = "There was an error trying to add '$json_obj->{name}' to the '$srv_message'";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
}

#  DELETE /farms/<farm>(/services/<service>)?/fg/<fg_name>
sub delete_fg_from_farm_controller ($farm, $srv, $fgname = undef) {
    unless (defined $fgname) {
        $fgname = $srv;
        $srv    = undef;
    }

    my $srv_message = ($srv) ? "service '$srv' in the farm '$farm'" : "farm '$farm'";
    my $desc        = "Remove the farm guardian '$fgname' from the '$srv_message'";

    require Relianoid::Farm::Service;

    # Check if it exists
    if (!&getFarmExists($farm)) {
        my $msg = "The farm '$farm' does not exist";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Check if it exists
    if (!&getFGExists($fgname)) {
        my $msg = "The farmguardian '$fgname' does not exist";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Check if it exists
    if ($srv and not grep { $srv eq $_ } &getFarmServices($farm)) {
        my $msg = "The service '$srv' does not exist";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # link the check with the farm_service
    my $farm_tag = $farm;
    $farm_tag = "${farm}_$srv" if $srv;

    # check if the farm guardian is already applied to the farm
    my $fg_obj = &getFGObject($fgname);
    if (not grep { $farm_tag eq $_ } @{ $fg_obj->{farms} }) {
        my $msg = "The farm guardian '$fgname' is not applied to the '$srv_message'";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &unlinkFGFarm($fgname, $farm, $srv);

    # check output
    $fg_obj = &getFGObject($fgname);
    if (grep { $farm_tag eq $_ } @{ $fg_obj->{farms} } or &getFGPidFarm($farm)) {
        my $msg = "Error removing '$fgname' from the '$srv_message'";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    else {
        require Relianoid::Farm::Base;

        # sync with cluster
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'fg_farm', 'stop', $farm, $srv ],
            );
        }

        my $msg  = "Success, '$fgname' was removed from the '$srv_message'";
        my $body = {
            description => $desc,
            message     => $msg,
            status      => &getFarmVipStatus($farm),
        };
        return &httpResponse({ code => 200, body => $body });
    }
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/HTTP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

use Relianoid::HTTP;
use Relianoid::Farm::Base;
use Relianoid::Farm::HTTP::Config;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::HTTP

=cut

# POST	/farms/<>/addheader
sub add_addheader_controller ($json_obj, $farmname) {
    my $desc = "Add addheader directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_request_add-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # check if the header is already added
    for my $header (@{ &getHTTPAddReqHeader($farmname) }) {
        if ($header->{header} eq $json_obj->{header}) {
            my $msg = "The header is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&addHTTPAddheader($farmname, $json_obj->{header})) {
        # success
        my $message = "Added a new item to the addheader list";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error adding a new addheader";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

# PUT	/farms/<>/addheader/<id>
sub modify_addheader_controller ($json_obj, $farmname, $index) {
    my $desc = "Modify an addheader directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_request_add-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my @directives = @{ &getHTTPAddReqHeader($farmname) };

    # check if the header exists
    if ((scalar @directives) < $index + 1) {
        my $msg = "The header with index $index not found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the header is already added
    for my $header (@directives) {
        if ($header->{header} eq $json_obj->{header}) {
            my $msg = "The header is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&modifyHTTPAddheader($farmname, $json_obj->{header}, $index)) {
        # success
        my $message = "Modified an item from the addheader list";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error modifying an addheader";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

#  DELETE	/farms/<>/addheader/<>
sub del_addheader_controller ($farmname, $index) {
    my $desc = "Delete addheader directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the header is already added
    if ((scalar @{ &getHTTPAddReqHeader($farmname) }) < $index + 1) {
        my $msg = "The index has not been found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    unless (&delHTTPAddheader($farmname, $index)) {
        # success
        my $message = "The addheader $index was deleted successfully";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error deleting the addheader $index";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

# POST	/farms/<>/headremove
sub add_headremove_controller ($json_obj, $farmname) {
    my $desc = "Add headremove directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_request_remove-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # check if the header is already added
    for my $header (@{ &getHTTPRemReqHeader($farmname) }) {
        if ($header->{pattern} eq $json_obj->{pattern}) {
            my $msg = "The pattern is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&addHTTPHeadremove($farmname, $json_obj->{pattern})) {
        # success
        my $message = "Added a new item to the headremove list";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error adding a new headremove";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

# PUT	/farms/<>/headremove/<id>
sub modify_headremove_controller ($json_obj, $farmname, $index) {
    my $desc = "Modify an headremove directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_request_remove-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my @directives = @{ &getHTTPRemReqHeader($farmname) };

    # check if the header exists
    if ((scalar @directives) < $index + 1) {
        my $msg = "The header with index $index not found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the new pattern is already added
    for my $header (@directives) {
        if ($header->{pattern} eq $json_obj->{pattern}) {
            my $msg = "The pattern is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&modifyHTTPHeadremove($farmname, $json_obj->{pattern}, $index)) {
        # success
        my $message = "Modified an item from the headremove list";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error modifying an headremove";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

#  DELETE	/farms/<>/addheader/<>
sub del_headremove_controller ($farmname, $index) {
    my $desc = "Delete headremove directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the headremove is already added
    if ((scalar @{ &getHTTPRemReqHeader($farmname) }) < $index + 1) {
        my $msg = "The index has not been found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    unless (&delHTTPHeadremove($farmname, $index)) {
        # success
        my $message = "The headremove $index was deleted successfully";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error deleting the headremove $index";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

# POST	/farms/<>/addheader
sub add_addResHeader_controller ($json_obj, $farmname) {
    my $desc = "Add a header to the backend repsonse.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_response_add-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # check if the header is already added
    for my $header (@{ &getHTTPAddRespHeader($farmname) }) {
        if ($header->{header} eq $json_obj->{header}) {
            my $msg = "The header is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&addHTTPAddRespheader($farmname, $json_obj->{header})) {
        # success
        my $message = "Added a new header to the backend response";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error adding a new response header";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

# PUT	/farms/<>/addresponseheader/<id>
sub modify_addResHeader_controller ($json_obj, $farmname, $index) {
    my $desc = "Modify an addresponseheader directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_response_add-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my @directives = @{ &getHTTPAddRespHeader($farmname) };

    # check if the header exists
    if ((scalar @directives) < $index + 1) {
        my $msg = "The header with index $index not found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the header is already added
    for my $header (@directives) {
        if ($header->{header} eq $json_obj->{header}) {
            my $msg = "The header is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&modifyHTTPAddRespheader($farmname, $json_obj->{header}, $index)) {
        # success
        my $message = "Modified an item from the addresponseheader list";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error modifying an addresponseheader";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

#  DELETE	/farms/<>/addresponseheader/<>
sub del_addResHeader_controller ($farmname, $index) {
    my $desc = "Delete a header previously added to the backend response.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the header is already added
    if ((scalar @{ &getHTTPAddRespHeader($farmname) }) < $index + 1) {
        my $msg = "The index has not been found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    unless (&delHTTPAddRespheader($farmname, $index)) {
        # success
        my $message = "The header $index was deleted successfully";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error deleting the response header $index";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

# POST	/farms/<>/removeresponseheader
sub add_delResHeader_controller ($json_obj, $farmname) {
    my $desc = "Remove a header from the backend response.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_response_remove-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # check if the header is already added
    for my $header (@{ &getHTTPRemRespHeader($farmname) }) {
        if ($header->{pattern} eq $json_obj->{pattern}) {
            my $msg = "The pattern is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&addHTTPRemRespHeader($farmname, $json_obj->{pattern})) {
        # success
        my $message = "Added a patter to remove reponse headers";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error adding the remove pattern";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

# PUT	/farms/<>/removeresponseheader/<id>
sub modify_delResHeader_controller ($json_obj, $farmname, $index) {
    my $desc = "Modify a remove response header directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_response_remove-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my @directices = @{ &getHTTPRemRespHeader($farmname) };

    # check if the header exists
    if ((scalar @directices) < $index + 1) {
        my $msg = "The header with index $index not found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the header is already added
    for my $header (@directices) {
        if ($header->{pattern} eq $json_obj->{pattern}) {
            my $msg = "The pattern is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&modifyHTTPRemRespHeader($farmname, $json_obj->{header}, $index)) {
        # success
        my $message = "Modified an item from the removeresponseheader list";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error modifying an removeresponseheader";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

#  DELETE	/farms/<>/addheader/<>
sub del_delResHeader_controller ($farmname, $index) {
    my $desc = "Delete a pattern to remove response headers.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the headremove is already added
    if ((scalar @{ &getHTTPRemRespHeader($farmname) }) < $index + 1) {
        my $msg = "The index has not been found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    unless (&delHTTPRemRespHeader($farmname, $index)) {
        # success
        my $message = "The pattern $index was deleted successfully";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error deleting the pattern $index";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Output/HTTP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::HTTP::Config;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Output::HTTP

=cut

# farm parameters
sub getHTTPOutFarm ($farmname) {
    require Relianoid::Farm::HTTP::Config;
    my $farm_ref = &getHTTPFarmStruct($farmname);

    # Remove useless fields
    delete($farm_ref->{name});
    return $farm_ref;
}

sub getHTTPOutService ($farmname) {
    require Relianoid::Farm::HTTP::Service;
    my @services_list = ();

    for my $service (&getHTTPFarmServices($farmname)) {
        my $service_ref = &getHTTPServiceStruct($farmname, $service);
        push @services_list, $service_ref;
    }

    return \@services_list;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Post.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Net::Util;
use Relianoid::Farm::Core;
use Relianoid::Farm::Factory;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Post

=cut

my $eload = eval { require Relianoid::ELoad };

sub add_farm_controller ($json_obj) {
    # 3 Mandatory Parameters ( 1 mandatory for HTTP or GSBL and optional for L4xNAT )
    #
    #	- farmname
    #	- profile
    #	- vip
    #	- vport: optional for L4xNAT and not used in Datalink profile.

    my $desc = "Creating a farm";

    # check if FARM NAME already exists
    unless (&getFarmType($json_obj->{farmname}) eq "1") {
        my $msg = "Error trying to create a new farm, the farm name already exists.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if (exists $json_obj->{copy_from}) {
        my $ori_type = &getFarmType($json_obj->{copy_from});
        $ori_type = 'http' if $ori_type eq 'https';

        if ($ori_type eq "1") {
            my $msg = "The farm '$json_obj->{copy_from}' does not exist.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        if (exists($json_obj->{profile}) and ($ori_type ne $json_obj->{profile})) {
            my $msg =
              "The profile '$json_obj->{profile}' does not match with the profile '$ori_type' of the farm '$json_obj->{copy_from}'.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
        else {
            $json_obj->{profile} = $ori_type;
        }
    }

    require Relianoid::Net::Interface;
    my $ip_list = &getIpAddressList();

    # Check allowed parameters
    my $params = &getAPIModel("farm-create.json");
    $params->{vport}{interval} = "1,65535" if (exists $json_obj->{profile} and $json_obj->{profile} =~ /(?:http|gslb|eproxy)/);
    $params->{vport}{required} = "true"    if (exists $json_obj->{profile} and $json_obj->{profile} ne 'datalink');
    $params->{vip}{values}     = $ip_list;

    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # VIP validation
    if ($json_obj->{profile} =~ /^DATALINK$/i) {
        # interface must be running
        if (!grep { $_ eq $json_obj->{vip} } &listallips()) {
            my $msg = "An available virtual IP must be set.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    else {
        # the ip must exist in some interface
        require Relianoid::Net::Interface;
        if (!&getIpAddressExists($json_obj->{vip})) {
            my $msg = "The vip IP must exist in some interface.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # VPORT validation
    if (!&getValidPort($json_obj->{vport}, $json_obj->{profile})) {
        my $msg = "The virtual port must be an acceptable value and must be available.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check ranges
    if ($json_obj->{vport}) {
        my @ranges = split(/,/, $json_obj->{vport});

        for my $range (@ranges) {
            next unless $range =~ /^(\d+):(\d+)$/;

            if ($1 > $2) {
                my $msg = "Range $range in virtual port is not a valid value.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    $json_obj->{interface} = &getInterfaceOfIp($json_obj->{vip});

    my $status = 0;
    if (exists $json_obj->{copy_from}) {
        $status = &runFarmCreateFrom($json_obj);
    }
    else {
        $status = &runFarmCreate($json_obj->{profile}, $json_obj->{vip}, $json_obj->{vport},
            $json_obj->{farmname}, $json_obj->{interface});
    }

    if ($status) {
        my $msg = "The $json_obj->{farmname} farm can't be created";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &log_info("Success, the farm $json_obj->{farmname} has been created successfully.", "FARMS");

    my $out_p = $json_obj;
    $out_p->{interface} = $json_obj->{interface};

    my $body = {
        description => $desc,
        params      => $out_p,
        message     => "The farm $json_obj->{farmname} has been created successfully."
    };

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'farm', 'start', $json_obj->{farmname} ],
        );
    }

    return &httpResponse({ code => 201, body => $body });
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Put.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::Core;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Put

=cut

my $eload = eval { require Relianoid::ELoad };

sub modify_farm_controller ($json_obj, $farmname) {
    my $desc = "Modify farm";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);

    if ($type eq "http" || $type eq "https") {
        require Relianoid::HTTP::Controllers::API::Farm::Put::HTTP;
        &modify_http_farm($json_obj, $farmname);
    }

    elsif ($type eq "l4xnat") {
        require Relianoid::HTTP::Controllers::API::Farm::Put::L4xNAT;
        &modify_l4xnat_farm($json_obj, $farmname);
    }

    elsif ($type eq "datalink") {
        require Relianoid::EE::HTTP::Controllers::API::Farm::Put::Datalink;
        &modify_datalink_farm($json_obj, $farmname);
    }

    elsif ($type eq "gslb" && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::Put::GSLB',
            func   => 'modify_gslb_farm',
            args   => [ $json_obj, $farmname ],
        );
    }

    elsif ($type eq "eproxy" && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::Put::Eproxy',
            func   => 'modify_eproxy_farm',
            args   => [ $json_obj, $farmname ],
        );
    }

    return;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Put/HTTP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::Base;
use Relianoid::Farm::HTTP::Config;
use Relianoid::Farm::Action;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Put::HTTP

=cut

my $eload = eval { require Relianoid::ELoad };

# PUT /farms/<farmname> Modify a http|https Farm
sub modify_http_farm ($json_obj, $farmname) {
    my $desc = "Modify HTTP farm $farmname";

    require Relianoid::Net::Interface;
    my $ip_list = &getIpAddressList();

    my $params = &getAPIModel("farm_http-modify.json");
    $params->{vip}{values}               = $ip_list;
    $params->{ciphers}{listener}         = "https";
    $params->{cipherc}{listener}         = "https";
    $params->{certname}{listener}        = "https";
    $params->{disable_sslv2}{listener}   = "https";
    $params->{disable_sslv3}{listener}   = "https";
    $params->{disable_tlsv1}{listener}   = "https";
    $params->{disable_tlsv1_1}{listener} = "https";
    $params->{disable_tlsv1_2}{listener} = "https";

    if (!$eload) {
        $params->{ciphers}{values} = [ "all", "highsecurity", "customsecurity" ];
    }

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # Get current conf
    my $farm_st = &getHTTPFarmStruct($farmname);

    my $vip   = $json_obj->{vip}   // $farm_st->{vip};
    my $vport = $json_obj->{vport} // $farm_st->{vport};

    if (exists($json_obj->{vip}) or exists($json_obj->{vport})) {
        require Relianoid::Net::Validate;
        if ($farm_st->{status} ne 'down' and not &validatePort($vip, $vport, 'http', $farmname)) {
            my $msg =
              "The '$vip' ip and '$vport' port are being used for another farm. This farm should be stopped before modifying it";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    if (exists($json_obj->{vip})) {
        if ($farm_st->{status} ne 'down') {
            require Relianoid::Net::Interface;

            my $if_name = &getInterfaceByIp($json_obj->{vip});
            my $if_ref  = &getInterfaceConfig($if_name);

            if (&getInterfaceSystemStatus($if_ref) ne "up") {
                my $msg = "The '$json_obj->{vip}' ip is not UP. This farm should be stopped before modifying it";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # Flags
    my $reload_ipds = 0;

    if (   exists $json_obj->{vport}
        || exists $json_obj->{vip}
        || exists $json_obj->{newfarmname})
    {
        if ($eload) {
            $reload_ipds = 1;

            &eload(
                module => 'Relianoid::EE::IPDS::Base',
                func   => 'runIPDSStopByFarm',
                args   => [$farmname],
            );

            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'ipds', 'stop', $farmname ],
            );
        }
    }

    ######## Functions
    # Modify Farm's Name
    if (exists($json_obj->{newfarmname})) {
        unless ($farm_st->{status} eq 'down') {
            my $msg = 'Cannot change the farm name while the farm is running';
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        #Check if the new farm's name alredy exists
        if (&getFarmExists($json_obj->{newfarmname})) {
            my $msg = "The farm $json_obj->{newfarmname} already exists, try another name.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        # Change farm name
        if (&setNewFarmName($farmname, $json_obj->{newfarmname})) {
            my $msg = "Error modifying the farm name.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        $farmname = $json_obj->{newfarmname};
    }

    # Modify Backend Connection Timeout
    if (exists $json_obj->{contimeout}) {
        if (&setHTTPFarmConnTO($json_obj->{contimeout}, $farmname) == -1) {
            my $msg = "Some errors happened trying to modify the contimeout.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify Backend Respone Timeout
    if (exists($json_obj->{restimeout})) {
        if (&setFarmTimeout($json_obj->{restimeout}, $farmname) == -1) {
            my $msg = "Some errors happened trying to modify the restimeout.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify Frequency To Check Resurrected Backends
    if (exists($json_obj->{resurrectime})) {
        if (&setFarmBlacklistTime($json_obj->{resurrectime}, $farmname) == -1) {
            my $msg = "Some errors happened trying to modify the resurrectime.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify Client Request Timeout
    if (exists($json_obj->{reqtimeout})) {
        if (&setHTTPFarmClientTimeout($json_obj->{reqtimeout}, $farmname) == -1) {
            my $msg = "Some errors happened trying to modify the reqtimeout.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify Rewrite Location Headers
    if (exists($json_obj->{rewritelocation})) {
        my $rewritelocation = 0;
        my $path            = 0;
        if ($json_obj->{rewritelocation} eq "disabled") {
            $rewritelocation = 0;
        }
        elsif ($json_obj->{rewritelocation} eq "enabled") {
            $rewritelocation = 1;
        }
        elsif ($json_obj->{rewritelocation} eq "enabled-backends") {
            $rewritelocation = 2;
        }
        elsif ($json_obj->{rewritelocation} eq "enabled-path") {
            $rewritelocation = 1;
            $path            = 1;
        }
        elsif ($json_obj->{rewritelocation} eq "enabled-backends-path") {
            $rewritelocation = 2;
            $path            = 1;
        }

        if (my $error = &setHTTPFarmRewriteL($farmname, $rewritelocation, $path)) {
            my $msg = "Some errors happened trying to modify the rewritelocation.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Enable the log connection tracking
    if (exists($json_obj->{logs})) {
        require Relianoid::Farm::HTTP::Config;
        my $status = &setHTTPFarmLogs($farmname, $json_obj->{logs});

        if ($status) {
            my $msg = "Some errors happened trying to modify the log parameter.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Enable or disable ignore 100 continue header
    if (exists($json_obj->{ignore_100_continue})
        and ($json_obj->{ignore_100_continue} ne $farm_st->{ignore_100_continue}))    # this is a bugfix
    {
        my $action = ($json_obj->{ignore_100_continue} eq "true") ? 1 : 0;

        my $status = &setHTTPFarm100Continue($farmname, $action);

        if ($status == -1) {
            my $msg = "Some errors happened trying to modify the ignore_100_continue parameter.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify HTTP Verbs Accepted
    if (exists($json_obj->{httpverb})) {
        my $code = &getHTTPFarmVerbCode($json_obj->{httpverb});
        if (&setHTTPFarmHttpVerb($code, $farmname) == -1) {
            my $msg = "Some errors happened trying to modify the httpverb.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    #Modify Error 414
    if (exists($json_obj->{error414})) {
        if (&setHTTPFarmErr($farmname, $json_obj->{error414}, "414") == -1) {
            my $msg = "Some errors happened trying to modify the error414.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    #Modify Error 500
    if (exists($json_obj->{error500})) {
        if (&setHTTPFarmErr($farmname, $json_obj->{error500}, "500") == -1) {
            my $msg = "Some errors happened trying to modify the error500.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    #Modify Error 501
    if (exists($json_obj->{error501})) {
        if (&setHTTPFarmErr($farmname, $json_obj->{error501}, "501") == -1) {
            my $msg = "Some errors happened trying to modify the error501.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    #Modify Error 503
    if (exists($json_obj->{error503})) {
        if (&setHTTPFarmErr($farmname, $json_obj->{error503}, "503") == -1) {
            my $msg = "Some errors happened trying to modify the error503.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify Farm Listener
    if (exists($json_obj->{listener})) {
        eval { &setHTTPFarmListen($farmname, $json_obj->{listener}); 1 } or do {
            my $msg = "Some errors happened trying to modify the listener.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        };

        $farm_st->{listener} = $json_obj->{listener};    # update listener type
    }

    # Discard parameters of the HTTPS listener when it is not configured
    if ($farm_st->{listener} ne "https") {
        for my $key (keys %{$params}) {
            if (    exists $json_obj->{$key}
                and exists $params->{$key}{listener}
                and $params->{$key}{listener} eq 'https')
            {
                my $msg = "The farm listener has to be 'HTTPS' to configure the parameter '$key'.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # Modify HTTPS Params
    if ($farm_st->{listener} eq "https") {
        require Relianoid::Farm::HTTP::HTTPS;

        # Cipher groups
        # API parameter => library parameter
        my %c = (
            all            => "cipherglobal",
            customsecurity => "ciphercustom",
            highsecurity   => "cipherpci",
            ssloffloading  => "cipherssloffloading",
        );
        my $ciphers_lib;

        # Modify Ciphers
        if (exists($json_obj->{ciphers})) {
            $ciphers_lib = $c{ $json_obj->{ciphers} };

            my $ssloff = 1;
            $ssloff = &eload(
                module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext',
                func   => 'getFarmCipherSSLOffLoadingSupport',
            ) if ($eload);

            unless ($ssloff) {
                &log_warn("The CPU does not support SSL offloading.", "system");
            }

            if (&setFarmCipherList($farmname, $ciphers_lib, $json_obj->{cipherc}) == -1) {
                my $msg = "Error modifying ciphers.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            $farm_st->{ciphers} = $json_obj->{ciphers};    # update ciphers value
        }

        # Modify Customized Ciphers
        if (exists($json_obj->{cipherc})) {
            $ciphers_lib = $c{ $farm_st->{ciphers} };

            if ($farm_st->{ciphers} eq "customsecurity") {
                $json_obj->{cipherc} =~ s/\ //g;
                if (&setFarmCipherList($farmname, $ciphers_lib, $json_obj->{cipherc}) == -1) {
                    my $msg = "Some errors happened trying to modify the cipherc.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
            else {
                my $msg = "'ciphers' has to be 'customsecurity' to set the 'cipherc' parameter.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        # Add Certificate to SNI list
        if (exists($json_obj->{certname})) {
            my $status;
            my $configdir = &getGlobalConfiguration('configdir');

            if (!-f "$configdir/$json_obj->{certname}") {
                my $msg = "The certificate $json_obj->{certname} has to be uploaded to use it in a farm.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            if ($eload) {
                $status = &eload(
                    module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext',
                    func   => 'setFarmCertificateSNI',
                    args   => [ $json_obj->{certname}, $farmname ],
                );
            }
            else {
                $status = &setFarmCertificate($json_obj->{certname}, $farmname);
            }

            if ($status == -1) {
                my $msg = "Some errors happened trying to modify the certname.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        # Disable security protocol
        # API parameter => l7 proxy parameter
        my %ssl_proto_hash = (
            "disable_sslv2"   => "SSLv2",
            "disable_sslv3"   => "SSLv3",
            "disable_tlsv1"   => "TLSv1",
            "disable_tlsv1_1" => "TLSv1_1",
            "disable_tlsv1_2" => "TLSv1_2",
        );

        my %bool_to_int = (
            "false" => 0,
            "true"  => 1,
        );

        my $action;
        my $ssl_proto;

        for my $key_ssl (keys %ssl_proto_hash) {
            next if (!exists $json_obj->{$key_ssl});
            next if ($farm_st->{$key_ssl} && $json_obj->{$key_ssl} eq $farm_st->{$key_ssl});

            $action    = $bool_to_int{ $json_obj->{$key_ssl} };
            $ssl_proto = $ssl_proto_hash{$key_ssl}
              if exists $ssl_proto_hash{$key_ssl};

            if (&setHTTPFarmDisableSSL($farmname, $ssl_proto, $action) == -1) {
                my $msg = "Some errors happened trying to modify $key_ssl.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    if (exists($json_obj->{vip})) {
        # the ip must exist in some interface
        require Relianoid::Net::Interface;
        unless (&getIpAddressExists($json_obj->{vip})) {
            my $msg = "The vip IP must exist in some interface.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify vip and vport
    if (exists($json_obj->{vip}) or exists($json_obj->{vport})) {
        if (&setFarmVirtualConf($vip, $vport, $farmname)) {
            my $msg = "Could not set the virtual configuration.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    &log_info("Success, some parameters have been changed in farm $farmname.", "LSLB");

    # Return the received json object updated.
    require Relianoid::HTTP::Controllers::API::Farm::Output::HTTP;

    #~ my $farm_upd = &getFarmStruct( $farmname );
    #~ for my $key ( keys %{ $json_obj } )
    #~ {
    #~ $json_obj->{ $key } = $farm_upd->{ $key };
    #~ }

    my $out_obj = &getHTTPOutFarm($farmname);

    if ($reload_ipds and $eload) {
        &eload(
            module => 'Relianoid::EE::IPDS::Base',
            func   => 'runIPDSStartByFarm',
            args   => [$farmname],
        );

        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'ipds', 'start', $farmname ],
        );
    }

    my $body = {
        description => $desc,
        params      => $out_obj,
        message     => "Some parameters have been changed in farm $farmname."
    };

    if (exists $json_obj->{newfarmname}) {
        $body->{params}{newfarmname} = $json_obj->{newfarmname};
    }

    if ($farm_st->{status} ne 'down') {
        &setFarmRestart($farmname);
        $body->{status} = 'needed restart';
    }

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Put/L4xNAT.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::Base;
use Relianoid::Farm::L4xNAT::Config;
use Relianoid::Net::Interface;
use Relianoid::Farm::Config;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Put::L4xNAT

=cut

my $eload = eval { require Relianoid::ELoad };

# PUT /farms/<farmname> Modify a l4xnat Farm
sub modify_l4xnat_farm ($json_obj, $farmname) {
    my $desc = "Modify L4xNAT farm '$farmname'";

    # Flags
    my $status = &getFarmStatus($farmname);

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Removed
    if ($json_obj->{algorithm} && $json_obj->{algorithm} =~ /^(prio)$/) {
        my $msg = "'Prio' algorithm is not supported anymore.";
        return &httpErrorResponse({ code => 410, desc => $desc, msg => $msg });
    }

    require Relianoid::Net::Interface;
    my $ip_list = &getIpAddressList();

    # Modify the vport if protocol is set to 'all'
    if (   (exists $json_obj->{protocol} and $json_obj->{protocol} eq 'all')
        or (exists $json_obj->{vport} and $json_obj->{vport} eq '*'))
    {
        $json_obj->{vport}    = "*";      # fixme
        $json_obj->{protocol} = "all";    # fixme
    }
    if (exists $json_obj->{persistence}
        and $json_obj->{persistence} eq 'none')
    {
        $json_obj->{persistence} = '';
    }

    # Check allowed parameters
    my $params = &getAPIModel("farm_l4xnat-modify.json");
    $params->{vip}{values} = $ip_list;

    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    if ($json_obj->{protocol} && $json_obj->{protocol} =~ /^(?:amanda|irc|netbios-ns|sane)$/) {
        my $msg = "'$json_obj->{protocol}' protocol is not supported anymore.";
        return &httpErrorResponse({ code => 410, desc => $desc, msg => $msg });
    }

    # Get current vip & vport & proto
    my $vip   = $json_obj->{vip}      // &getFarmVip('vip',  $farmname);
    my $vport = $json_obj->{vport}    // &getFarmVip('vipp', $farmname);
    my $proto = $json_obj->{protocol} // &getL4FarmParam('proto', $farmname);

    # Extend parameter checks
    if (exists $json_obj->{protocol} and $json_obj->{protocol} ne 'all') {
        if ($vport eq '*') {
            my $msg = "Protocol can not be '$json_obj->{protocol}' with port '$vport'";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    if (exists $json_obj->{vport} and $json_obj->{vport} ne '*') {
        if ($proto eq 'all') {
            my $msg = "Port can not be '$json_obj->{vport}' with protocol '$proto'";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # check ranges
    if (exists $json_obj->{vport}) {
        my @ranges = split(/,/, $json_obj->{vport});
        for my $range (@ranges) {
            if ($range =~ /^(\d+):(\d+)$/) {
                if ($1 > $2) {
                    my $msg = "Range $range in virtual port is not a valid value.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
        }
    }

    if (   exists($json_obj->{vip})
        or exists($json_obj->{vport})
        or exists($json_obj->{protocol}))
    {
        require Relianoid::Net::Validate;
        require Relianoid::Farm::L4xNAT::Config;
        if ($status eq 'up' and not &validatePort($vip, $vport, $proto, $farmname)) {
            my $msg =
              "The '$vip' ip and '$vport' port are being used for another farm. This farm should be stopped before modifying it";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        if (exists($json_obj->{vip})) {
            require Relianoid::Farm::L4xNAT::Backend;

            my $backends = &getL4FarmServers($farmname);
            unless (!@{$backends}[0]
                || &ipversion(@{$backends}[0]->{ip}) eq &ipversion($vip))
            {
                my $msg = "Invalid VIP address, VIP and backends can't be from diferent IP version.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            # the vip must be UP
            if ($status ne 'down') {
                require Relianoid::Net::Interface;
                my $if_name = &getInterfaceByIp($json_obj->{vip});
                my $if_ref  = &getInterfaceConfig($if_name);
                if (&getInterfaceSystemStatus($if_ref) ne "up") {
                    my $msg = "The '$json_obj->{vip}' ip is not UP. This farm should be stopped before modifying it";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
        }

        if (exists($json_obj->{vport})) {
            # VPORT validation
            if (!&getValidPort($vport, "L4XNAT")) {
                my $msg = "The virtual port must be an acceptable value and must be available.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    my $reload_ipds = 0;
    if (   exists $json_obj->{vport}
        || exists $json_obj->{vip}
        || exists $json_obj->{newfarmname})
    {
        if ($eload) {
            $reload_ipds = 1;

            &eload(
                module => 'Relianoid::EE::IPDS::Base',
                func   => 'runIPDSStopByFarm',
                args   => [$farmname],
            );

            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'ipds', 'stop', $farmname ],
            );

            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'farm', 'stop', $farmname ],
            );
        }
    }

    ####### Functions

    # Modify Farm's Name
    if (exists($json_obj->{newfarmname})) {
        unless (&getL4FarmParam('status', $farmname) eq 'down') {
            my $msg = 'Cannot change the farm name while running';
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        if ($json_obj->{newfarmname} ne $farmname) {
            #Check if the new farm's name alredy exists
            if (&getFarmExists($json_obj->{newfarmname})) {
                my $msg = "The farm $json_obj->{newfarmname} already exists, try another name.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            #Change farm name
            require Relianoid::Farm::Action;
            my $fnchange = &setNewFarmName($farmname, $json_obj->{newfarmname});
            if ($fnchange == -1) {
                my $msg = "The name of the farm can't be modified, delete the farm and create a new one.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            $farmname = $json_obj->{newfarmname};
        }
    }

    # Modify Load Balance Algorithm
    if (exists($json_obj->{algorithm})) {
        my $error = &setFarmAlgorithm($json_obj->{algorithm}, $farmname);
        if ($error) {
            my $msg = "Some errors happened trying to modify the algorithm.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify Persistence Mode
    if (exists($json_obj->{persistence})) {
        my $persistence = $json_obj->{persistence};

        if (&getL4FarmParam('persist', $farmname) ne $persistence) {
            my $statusp = &setFarmSessionType($persistence, $farmname);
            if ($statusp) {
                my $msg = "Some errors happened trying to modify the persistence.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # Modify Protocol Type
    if (exists($json_obj->{protocol})) {
        my $error = &setL4FarmParam('proto', $json_obj->{protocol}, $farmname);
        if ($error) {
            my $msg = "Some errors happened trying to modify the protocol.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify NAT Type
    if (exists($json_obj->{nattype})) {
        if (&getL4FarmParam('mode', $farmname) ne $json_obj->{nattype}) {
            my $error = &setL4FarmParam('mode', $json_obj->{nattype}, $farmname);
            if ($error) {
                my $msg = "Some errors happened trying to modify the nattype.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # Modify IP Address Persistence Time To Limit
    if (exists($json_obj->{ttl})) {
        my $error = &setFarmMaxClientTime(0, $json_obj->{ttl}, $farmname);
        if ($error) {
            my $msg = "Some errors happened trying to modify the ttl.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
        $json_obj->{ttl} = $json_obj->{ttl} + 0;
    }

    # Modify vip and vport
    if (exists($json_obj->{vip}) or exists($json_obj->{vport})) {
        if (&setFarmVirtualConf($vip, $vport, $farmname)) {
            my $msg = "Could not set the virtual configuration.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify logs
    if (exists($json_obj->{logs})) {
        my $msg = &modifyLogsParam($farmname, $json_obj->{logs});
        if (defined $msg && length $msg) {
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # no error found, return successful response
    &log_info("Success, some parameters have been changed in farm $farmname.", "LSLB");

    if (&getL4FarmParam('status', $farmname) eq 'up' and $eload) {
        if ($reload_ipds) {
            &eload(
                module => 'Relianoid::EE::IPDS::Base',
                func   => 'runIPDSStartByFarm',
                args   => [$farmname],
            );

            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'farm', 'start', $farmname ],
            );

            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'ipds', 'start', $farmname ],
            );
        }
        else {
            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'farm', 'restart', $farmname ],
            );
        }
    }

    my $body = {
        description => $desc,
        params      => $json_obj,
        message     => "Some parameters have been changed in farm $farmname."
    };

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Service.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::Core;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Service

=cut

my $eload = eval { require Relianoid::ELoad };

# POST
sub add_farm_service_controller ($json_obj, $farmname) {
    require Relianoid::Farm::Service;

    my $desc = "New service";

    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # check if the service exists
    if (grep { $json_obj->{id} eq $_ } &getFarmServices($farmname)) {
        my $msg = "Error, the service $json_obj->{id} already exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);

    # validate farm profile
    if ($type eq "gslb") {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::GSLB',
            func   => 'new_gslb_farm_service',
            args   => [ $json_obj, $farmname ]
        );
    }
    elsif ($type !~ /^https?$/) {
        my $msg = "The farm profile $type does not support services actions.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_service-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # HTTP profile
    require Relianoid::HTTP::Controllers::API::Farm::Get::HTTP;
    require Relianoid::Farm::Base;
    require Relianoid::Farm::HTTP::Service;

    my $result = &setFarmHTTPNewService($farmname, $json_obj->{id});

    # check if a service with such name already exists
    if ($result == 1) {
        my $msg = "Service name " . $json_obj->{id} . " already exists.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the service name has invalid characters
    if ($result == 3) {
        my $msg = "Service name is not valid, only allowed numbers, letters and hyphens.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Return 0 on success
    if ($result) {
        my $msg = "Error creating the service $json_obj->{id}.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no error found, return successful response
    &log_info("Success, a new service has been created in farm $farmname with id $json_obj->{id}.", "FARMS");

    my $body = {
        description => $desc,
        params      => { id => $json_obj->{id} },
        message     => "A new service has been created in farm $farmname with id $json_obj->{id}."
    };

    if (&getFarmStatus($farmname) ne 'down') {
        if ($type eq "eproxy" && $eload) {
            $body->{status} = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Action',
                func   => 'runEproxyFarmReload',
                args   => [ { farm_name => $farmname } ],
            );
            require Relianoid::EE::Cluster;
            &runClusterRemoteManager('farm', 'reload', $farmname);
        }
        else {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }
    }

    return &httpResponse({ code => 201, body => $body });
}

# GET

#GET /farms/<name>/services/<service>
sub get_farm_service_controller ($farmname, $servicename) {
    require Relianoid::HTTP::Controllers::API::Farm::Get::HTTP;
    require Relianoid::Farm::Config;
    require Relianoid::Farm::HTTP::Service;

    my $desc = "Get services of a farm";

    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);

    my @services;
    if ($type =~ /http/i) {
        @services = &getHTTPFarmServices($farmname);
    }
    elsif ($type eq "eproxy" && $eload) {
        @services = @ { &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Service',
            func   => 'getEproxyFarmServices',
            args   => [ { farm_name => $farmname } ]
        ) };
    }
    else {
        my $msg = "This functionality only is available for HTTP or eproxy farms.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the service is available
    if (!grep { $servicename eq $_ } @services) {
        my $msg = "The required service does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $service;
    if ($type =~ /http/i) {
        $service = &getHTTPServiceStruct($farmname, $servicename);
    }
    elsif ($type eq "eproxy" && $eload) {
        $service = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Service',
            func   => 'getEproxyServiceStruct',
            args   => [ { farm_name => $farmname, service_name => $servicename } ]
        );
    }

    my $body    = {
        description => $desc,
        params      => $service,
    };

    return &httpResponse({ code => 200, body => $body });
}

# PUT

sub modify_farm_service_controller ($json_obj, $farmname, $service) {
    require Relianoid::Farm::Base;
    require Relianoid::Farm::Service;

    my $desc = "Modify service";
    my $output_params;
    my $bk_msg = "";

    # validate FARM NAME
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate FARM TYPE
    my $type = &getFarmType($farmname);

    unless ($type eq 'gslb' || $type eq 'http' || $type eq 'https' || $type eq 'eproxy') {
        my $msg = "The $type farm profile does not support services settings.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the farm profile gslb is supported
    if ($type eq "gslb") {
        unless (my $found_service = grep { $service eq $_ } &getFarmServices($farmname)) {
            my $msg = "Could not find the requested service.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::GSLB',
            func   => 'modify_gslb_service',
            args   => [ $json_obj, $farmname, $service ]
        );
    }
    elsif ($type eq "eproxy" && $eload) {
        my $args = $json_obj;
        $args->{ farm_name } = $farmname;
        &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Service',
            func   => 'setEproxyServiceStruct',
            args   => [ $args ]
        );
        $output_params = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Service',
            func   => 'getEproxyServiceStruct',
            args   => [ { farm_name => $farmname, service_name => $service } ]
        );
        delete $output_params->{ farm_filename };
    }
    else {
        unless (my $found_service = grep { $service eq $_ } &getFarmServices($farmname)) {
            my $msg = "Could not find the requested service.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        # From here everything is about HTTP farms
        require Relianoid::Farm::HTTP::Config;
        require Relianoid::Farm::HTTP::Service;

        my $params = &getAPIModel("farm_http_service-modify.json");

        # Check allowed parameters
        if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
        }

        # translate params
        if (exists $json_obj->{persistence} and $json_obj->{persistence} eq 'NONE') {
            $json_obj->{persistence} = "";
        }

        # modifying params
        if (exists $json_obj->{vhost}) {
            &setHTTPFarmVS($farmname, $service, "vs", $json_obj->{vhost});
        }

        if (exists $json_obj->{urlp}) {
            &setHTTPFarmVS($farmname, $service, "urlp", $json_obj->{urlp});
        }

        if (exists $json_obj->{redirect}) {
            my $redirect = $json_obj->{redirect};

            &setHTTPFarmVS($farmname, $service, "redirect", $redirect);

            # delete service's backends if redirect has been configured
            if ($redirect) {
                require Relianoid::Farm::HTTP::Backend;
                my $backends = scalar @{ &getHTTPFarmBackends($farmname, $service) };

                if ($backends) {
                    $bk_msg = "The backends of $service have been deleted.";

                    for (my $id = $backends - 1 ; $id >= 0 ; $id--) {
                        &runHTTPFarmServerDelete($id, $farmname, $service);
                    }
                }
            }
        }

        if (exists $json_obj->{redirecttype}) {
            my $redirecttype = $json_obj->{redirecttype};
            &setHTTPFarmVS($farmname, $service, "redirecttype", $redirecttype);
        }

        if (exists $json_obj->{leastresp}) {
            if ($json_obj->{leastresp} eq "true") {
                &setHTTPFarmVS($farmname, $service, "dynscale", $json_obj->{leastresp});
            }
            elsif ($json_obj->{leastresp} eq "false") {
                &setHTTPFarmVS($farmname, $service, "dynscale", "");
            }
        }

        if (exists $json_obj->{persistence}) {
            my $session = $json_obj->{persistence} || 'nothing';
            my $old_persistence;

            if ($eload) {
                require Relianoid::Farm::Config;
                $old_persistence = &getPersistence($farmname);
            }

            if (my $error = &setHTTPFarmVS($farmname, $service, "session", $session)) {
                my $msg = "It's not possible to change the persistence parameter.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            if ($eload) {
                my $new_persistence = &getPersistence($farmname);
                if (($new_persistence == 1) and ($old_persistence == 0)) {
                    &eload(
                        module => 'Relianoid::EE::Ssyncd',
                        func   => 'setSsyncdFarmDown',
                        args   => [$farmname],
                    );
                }
                elsif (($new_persistence == 0) and ($old_persistence == 1)) {
                    &eload(
                        module => 'Relianoid::EE::Ssyncd',
                        func   => 'setSsyncdFarmUp',
                        args   => [$farmname],
                    );
                }
            }
        }

        my $session = &getHTTPFarmVS($farmname, $service, "sesstype");

        # It is necessary evaluate first session, next ttl and later persistence
        if (exists $json_obj->{sessionid}) {
            if ($session =~ /^(URL|COOKIE|HEADER)$/) {
                &setHTTPFarmVS($farmname, $service, "sessionid", $json_obj->{sessionid});
            }
        }

        if (exists $json_obj->{ttl}) {
            if ($session =~ /^(IP|BASIC|URL|PARM|COOKIE|HEADER)$/) {
                my $error = &setHTTPFarmVS($farmname, $service, "ttl", "$json_obj->{ttl}");
                if ($error) {
                    my $msg = "Could not change the ttl parameter.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
        }

        # Cookie insertion
        if (scalar grep { /^cookie/ } keys %{$json_obj}) {
            if ($eload) {
                my $msg = &eload(
                    module   => 'Relianoid::EE::HTTP::Controllers::API::Farm::Service::Ext',
                    func     => 'modify_service_cookie_insertion',
                    args     => [ $farmname, $service, $json_obj ],
                    just_ret => 1,
                );

                if (defined $msg && length $msg) {
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
            else {
                my $msg = "Cookie insertion feature not available.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        if (exists $json_obj->{httpsb}) {
            if ($json_obj->{httpsb} ne &getHTTPFarmVS($farmname, $service, 'httpsbackend')) {
                if ($json_obj->{httpsb} eq "true") {
                    &setHTTPFarmVS($farmname, $service, "httpsbackend", $json_obj->{httpsb});
                }
                elsif ($json_obj->{httpsb} eq "false") {
                    &setHTTPFarmVS($farmname, $service, "httpsbackend", "");
                }
            }
        }

        # Redirect code
        if (exists $json_obj->{redirect_code}) {
            if ($eload) {
                my $err = &eload(
                    module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
                    func   => 'setHTTPServiceRedirectCode',
                    args   => [ $farmname, $service, $json_obj->{redirect_code} ],
                );

                if ($err) {
                    my $msg = "Error modifying redirect code.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
            else {
                my $msg = "Redirect code feature not available.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        if ($eload) {
            # sts options
            if (exists $json_obj->{sts_status}) {
                # status
                if ($type ne 'https') {
                    my $msg = "The farms have to be HTTPS to modify STS";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
                my $err = &eload(
                    module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
                    func   => 'setHTTPServiceSTSStatus',
                    args   => [ $farmname, $service, $json_obj->{sts_status} ],
                );

                if ($err) {
                    my $msg = "Error modifying STS status.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }

            if (exists $json_obj->{sts_timeout}) {
                if ($type ne 'https') {
                    my $msg = "The farms have to be HTTPS to modify STS";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }

                my $err = &eload(
                    module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
                    func   => 'setHTTPServiceSTSTimeout',
                    args   => [ $farmname, $service, $json_obj->{sts_timeout} ],
                );

                if ($err) {
                    my $msg = "Error modifying STS status.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
        }

        # no error found, return succesful response
        require Relianoid::HTTP::Controllers::API::Farm::Get::HTTP;
        $output_params = &get_http_service_struct($farmname, $service);
    }

    &log_info("Success, some parameters have been changed in service $service in farm $farmname.", "FARMS");

    my $body = {
        description => "Modify service $service in farm $farmname",
        params      => $output_params,
    };

    $body->{message} = $bk_msg ? $bk_msg : "The service $service has been updated successfully.";

    if (&getFarmStatus($farmname) ne 'down') {
        if ($type eq "eproxy" && $eload) {
            $body->{status} = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Action',
                func   => 'runEproxyFarmReload',
                args   => [ { farm_name => $farmname } ],
            );
            require Relianoid::EE::Cluster;
            &runClusterRemoteManager('farm', 'reload', $farmname);
        }
        else {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }
    }

    return &httpResponse({ code => 200, body => $body });
}

# DELETE

# DELETE /farms/<farmname>/services/<servicename> Delete a service of a Farm
sub delete_farm_service_controller ($farmname, $service) {
    my $desc = "Delete service";

    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # check the farm type is supported
    my $type = &getFarmType($farmname);

    if ($type eq "gslb" && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::GSLB',
            func   => 'delete_gslb_service',
            args   => [ $farmname, $service ]
        );
    }
    elsif ($type !~ /^https?$/) {
        my $msg = "The farm profile $type does not support services actions.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::Farm::Base;
    require Relianoid::Farm::HTTP::Service;

    # Check that the provided service is configured in the farm
    my @services = &getHTTPFarmServices($farmname);
    my $found    = 0;

    for my $farmservice (@services) {
        if ($service eq $farmservice) {
            $found = 1;
            last;
        }
    }

    unless ($found) {
        my $msg = "Invalid service name, please insert a valid value.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $error = &delHTTPFarmService($farmname, $service);

    # check if the service is in use
    if ($error == -2) {
        my $msg = "The service is used by a zone.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the service could not be deleted
    if ($error) {
        my $msg = "Service $service in farm $farmname hasn't been deleted.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no errors found, returning successful response
    &log_info("Success, the service $service has been deleted in farm $farmname.", "FARMS");

    my $message = "The service $service has been deleted in farm $farmname.";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
    };

    if (&getFarmStatus($farmname) ne 'down') {
        if ($type eq "eproxy" && $eload) {
            $body->{status} = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Action',
                func   => 'runEproxyFarmReload',
                args   => [ { farm_name => $farmname } ],
            );
            require Relianoid::EE::Cluster;
            &runClusterRemoteManager('farm', 'reload', $farmname);
        }
        else {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }
    }

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Graph.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::RRD;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Graph

=cut

my $eload = eval { require Relianoid::ELoad };

#GET the list of graphs availables in the load balancer
sub list_graphs_controller () {
    require Relianoid::Stats;

    my @farms = ();
    for my $graph (&getGraphs2Show("Farm")) {
        $graph =~ s/-farm$//;
        push(@farms, $graph);
    }

    if ($eload) {
        @farms = @{
            &eload(
                module => 'Relianoid::EE::RBAC::Group::Core',
                func   => 'getRBACResourcesFromList',
                args   => [ 'farms', \@farms ],
            )
        };
    }

    my @net = ();
    for my $graph (&getGraphs2Show("Network")) {
        $graph =~ s/iface$//;
        push(@net, $graph);
    }

    my @sys = ("cpu", "load", "ram", "swap");

    # Get mount point of disks
    my @mount_points;
    my $partitions = &getDiskPartitionsInfo();

    for my $key (keys %{$partitions}) {
        # mount point : root/mount_point
        push(@mount_points, "root$partitions->{$key}{mount_point}");
    }

    @mount_points = sort @mount_points;
    push @sys, { disks => \@mount_points };

    my @vpns = ();
    if ($eload) {
        for my $graph (&getGraphs2Show("VPN")) {
            $graph =~ s/-vpn$//;
            push(@vpns, $graph);
        }
        @vpns = @{
            &eload(
                module => 'Relianoid::EE::RBAC::Group::Core',
                func   => 'getRBACResourcesFromList',
                args   => [ 'vpns', \@vpns ],
            )
        };
    }
    my $body = {
        description => "These are the possible graphs, you'll be able to access to the daily, weekly, monthly or yearly graph",
        system      => \@sys,
        interfaces  => \@net,
        farms       => \@farms
    };

    if ($eload) {
        $body->{ipds} = \@farms;
        $body->{vpns} = \@vpns;
    }

    return &httpResponse({ code => 200, body => $body });
}

# GET all system graphs
sub list_sys_graphs_controller () {
    require Relianoid::Stats;

    # System values
    my @sys = ("cpu", "load", "ram", "swap");

    # Get mount point of disks
    my @mount_points;
    my $partitions = &getDiskPartitionsInfo();

    for my $key (keys %{$partitions}) {
        # mount point : root/mount_point
        push(@mount_points, "root$partitions->{$key}{mount_point}");
    }

    @mount_points = sort @mount_points;
    push @sys, { disk => \@mount_points };

    my $body = {
        description =>
          "These are the possible system graphs, you'll be able to access to the daily, weekly, monthly or yearly graph",
        system => \@sys
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET system graphs
sub get_sys_graphs_controller ($key) {
    my $desc = "Get $key graphs";

    $key = 'mem'   if ($key eq 'ram');
    $key = 'memsw' if ($key eq 'swap');

    # Print Graph Function
    my @graphs = ();
    for my $freq ('daily', 'weekly', 'monthly', 'yearly') {
        my $g = &printGraph($key, $freq);
        push @graphs,
          {
            frequency  => $freq,
            graph      => $g->{img},
            start_time => $g->{start},
            last_time  => $g->{last},
          };
    }

    my $body = { description => $desc, graphs => \@graphs };

    return &httpResponse({ code => 200, body => $body });
}

# GET frequency system graphs
sub get_sys_graphs_freq_controller ($key, $frequency) {
    my $desc = "Get $frequency $key graphs";

    $key = 'mem'   if ($key eq 'ram');
    $key = 'memsw' if ($key eq 'swap');

    # Print Graph Function
    my $graph = &printGraph($key, $frequency);
    my $body  = {
        description => $desc,
        graphs      => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last}
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET a system graph using an interval
# /graphs/system/cpu/custom/start/11-25-2020-05:55/end/11-25-2020-22:25
sub get_sys_graphs_interval_controller ($key, $start, $end) {
    my $desc = "Get $key graphs";

    $key = 'mem'   if ($key eq 'ram');
    $key = 'memsw' if ($key eq 'swap');

    # Print Graph Function
    my $graph = &printGraph($key, $start, $end);
    my $body  = {
        description => $desc,
        graphs      => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last}
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET all interface graphs
sub list_iface_graphs_controller () {
    my @iface = ();
    for my $graph (&getGraphs2Show("Network")) {
        $graph =~ s/iface$//;
        push(@iface, $graph);
    }

    my $body = {
        description =>
          "These are the possible interface graphs, you'll be able to access to the daily, weekly, monthly or yearly graph",
        interfaces => \@iface
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET interface graphs
sub get_iface_graphs_controller ($iface) {
    require Relianoid::Net::Interface;

    my $desc              = "Get interface graphs";
    my @system_interfaces = &getInterfaceList();

    # validate NIC NAME
    if (!grep { $iface eq $_ } @system_interfaces) {
        my $msg = "Nic interface not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # graph for this farm doesn't exist
    elsif (!grep { /${iface}iface$/ } &getGraphs2Show("Network")) {
        my $msg = "There is no rrd files yet.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Print Graph Function
    my @graphs = ();
    for my $freq ('daily', 'weekly', 'monthly', 'yearly') {
        my $g = &printGraph("${iface}iface", $freq);
        push @graphs,
          {
            frequency  => $freq,
            graph      => $g->{img},
            start_time => $g->{start},
            last_time  => $g->{last},
          };
    }

    my $body = { description => $desc, graphs => \@graphs };

    return &httpResponse({ code => 200, body => $body });
}

# GET frequency interface graphs
sub get_iface_graphs_frec_controller ($iface, $frequency) {
    require Relianoid::Net::Interface;

    my $desc              = "Get interface graphs";
    my @system_interfaces = &getInterfaceList();

    # validate NIC NAME
    if (!grep { $iface eq $_ } @system_interfaces) {
        my $msg = "Nic interface not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }
    elsif (!grep { /${iface}iface$/ } &getGraphs2Show("Network")) {
        my $msg = "There is no rrd files yet.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Print Graph Function
    my $graph = &printGraph("${iface}iface", $frequency);
    my $body  = {
        description => $desc,
        graphs      => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last}
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET interface graph in an interval
sub get_iface_graphs_interval_controller ($iface, $start, $end) {
    require Relianoid::Net::Interface;

    my $desc              = "Get interface graphs";
    my @system_interfaces = &getInterfaceList();

    # validate NIC NAME
    if (!grep { $iface eq $_ } @system_interfaces) {
        my $msg = "Nic interface not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }
    elsif (!grep { /${iface}iface$/ } &getGraphs2Show("Network")) {
        my $msg = "There is no rrd files yet.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Print Graph Function
    my $graph = &printGraph("${iface}iface", $start, $end);
    my $body  = {
        description => $desc,
        graphs      => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last}
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET all farm graphs
sub list_farm_graphs_controller () {
    my @farms = ();
    for my $graph (&getGraphs2Show("Farm")) {
        $graph =~ s/-farm$//;
        push(@farms, $graph);
    }

    if ($eload) {
        my $ref_farm = &eload(
            module => 'Relianoid::EE::RBAC::Group::Core',
            func   => 'getRBACResourcesFromList',
            args   => [ 'farms', \@farms ]
        );
        @farms = @{$ref_farm};
    }

    my $body = {
        description =>
          "These are the possible farm graphs, you'll be able to access to the daily, weekly, monthly or yearly graph",
        farms => \@farms
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET farm graphs
sub get_farm_graphs_controller ($farmName) {
    require Relianoid::Farm::Core;

    my $desc = "Get farm graphs";

    # this farm doesn't exist
    if (!&getFarmExists($farmName)) {
        my $msg = "$farmName doesn't exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # graph for this farm doesn't exist
    elsif (!grep { "${farmName}-farm" eq $_ } &getGraphs2Show("Farm")) {
        my $msg = "There are no rrd files yet.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Print Graph Function
    my @graphs = ();
    for my $freq ('daily', 'weekly', 'monthly', 'yearly') {
        my $g = &printGraph("$farmName-farm", $freq);
        push @graphs,
          {
            frequency  => $freq,
            graph      => $g->{img},
            start_time => $g->{start},
            last_time  => $g->{last},
          };
    }

    my $body = { description => $desc, graphs => \@graphs };

    return &httpResponse({ code => 200, body => $body });
}

# GET frequency farm graphs
sub get_farm_graphs_frec_controller ($farmName, $frequency) {
    require Relianoid::Farm::Core;

    my $desc = "Get farm graphs";

    # this farm doesn't exist
    if (!&getFarmExists($farmName)) {
        my $msg = "$farmName doesn't exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # graph for this farm doesn't exist
    elsif (!grep { /$farmName-farm/ } &getGraphs2Show("Farm")) {
        my $msg = "There is no rrd files yet.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Print Graph Function
    my $graph = &printGraph("$farmName-farm", $frequency);
    my $body  = {
        description => $desc,
        graphs      => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last}
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET farm graph in an interval
sub get_farm_graphs_interval_controller ($farmName, $start, $end) {
    require Relianoid::Farm::Core;

    my $desc = "Get farm graphs";

    # this farm doesn't exist
    if (!&getFarmExists($farmName)) {
        my $msg = "$farmName doesn't exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # graph for this farm doesn't exist
    elsif (!grep { /$farmName-farm/ } &getGraphs2Show("Farm")) {
        my $msg = "There is no rrd files yet.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Print Graph Function
    my $graph = &printGraph("$farmName-farm", $start, $end);
    my $body  = {
        description => $desc,
        graphs      => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last}
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET mount points list
sub list_disks_graphs_controller () {
    require Relianoid::Stats;

    my @mount_points;
    my $partitions = &getDiskPartitionsInfo();

    for my $key (keys %{$partitions}) {
        # mount point : root/mount_point
        push(@mount_points, "root$partitions->{$key}{mount_point}");
    }

    @mount_points = sort @mount_points;

    my $body = {
        description => "List disk partitions",
        params      => \@mount_points,
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET disk graphs for all periods
sub get_disk_graphs_controller ($mount_point) {
    require Relianoid::Stats;

    $mount_point =~ s/^root[\/]?/\//;    # remove leading 'root/'
    my $desc  = "Disk partition usage graphs";
    my $parts = &getDiskPartitionsInfo();

    my ($part_key) =
      grep { $parts->{$_}{mount_point} eq $mount_point } keys %{$parts};

    unless ($part_key) {
        my $msg = "Mount point not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $dev_id = $parts->{$part_key}{rrd_id};
    my @graphs = ();
    for my $freq ('daily', 'weekly', 'monthly', 'yearly') {
        my $g = &printGraph($dev_id, $freq);
        push @graphs,
          {
            frequency  => $freq,
            graph      => $g->{img},
            start_time => $g->{start},
            last_time  => $g->{last},
          };
    }
    my $body = {
        description => $desc,
        graphs      => \@graphs,
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET disk graph for a single period
sub get_disk_graphs_freq_controller ($mount_point, $frequency) {
    require Relianoid::Stats;

    my $desc  = "Disk partition usage graph";
    my $parts = &getDiskPartitionsInfo();
    $mount_point =~ s/^root[\/]?/\//;

    my ($part_key) =
      grep { $parts->{$_}{mount_point} eq $mount_point } keys %{$parts};

    unless ($part_key) {
        my $msg = "Mount point not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $dev_id = $parts->{$part_key}{rrd_id};
    my $graph  = &printGraph($dev_id, $frequency);
    my $body   = {
        description => $desc,
        graph       => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last},
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET disk graph in an interval
sub get_disk_graphs_interval_controller ($mount_point, $start, $end) {
    require Relianoid::Stats;

    my $desc  = "Disk partition usage graph";
    my $parts = &getDiskPartitionsInfo();
    $mount_point =~ s/^root[\/]?/\//;

    my ($part_key) =
      grep { $parts->{$_}{mount_point} eq $mount_point } keys %{$parts};

    unless ($part_key) {
        my $msg = "Mount point not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $dev_id = $parts->{$part_key}{rrd_id};

    my $graph = &printGraph($dev_id, $start, $end);
    my $body  = {
        description => $desc,
        graph       => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last},
    };

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Ids.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Ids

=cut

require Relianoid::Ids;

# GET /ids
sub list_ids_controller () {
    my $desc = "Get a load balancer object IDs";

    my $tree = &getIdsTree();

    my $body = {
        description => $desc,
        params      => $tree,
    };

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Interface/Gateway.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Interface::Gateway

=cut

sub get_gateway_controller ($ip_ver) {
    require Relianoid::Net::Route;

    my $desc = "Default gateway";
    my $ip_v = ($ip_ver == 6) ? 6 : 4;

    my $addr    = ($ip_v == 6) ? &getIPv6DefaultGW()   : &getDefaultGW();
    my $if_name = ($ip_v == 6) ? &getIPv6IfDefaultGW() : &getIfDefaultGW();

    my $body = {
        description => $desc,
        params      => {
            address   => $addr,
            interface => $if_name,
        },
    };

    return &httpResponse({ code => 200, body => $body });
}

sub modify_gateway_controller ($json_obj, $ip_ver) {
    require Relianoid::Net::Route;

    my $desc       = "Modify default gateway";
    my $ip_v       = ($ip_ver == 6) ? 6                   : 4;
    my $default_gw = ($ip_v == 6)   ? &getIPv6DefaultGW() : &getDefaultGW();
    my $ip_format  = ($ip_v == 6)   ? 'IPv6_addr'         : 'IPv4_addr';

    my $params = &getAPIModel("gateway-modify.json");

    # if default gateway is not configured requires address and interface
    if (!$default_gw) {
        $params->{interface}{required} = "true";
        $params->{address}{required}   = "true";
    }
    $params->{address}{valid_format} = $ip_format;

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # validate INTERFACE
    if (exists $json_obj->{interface}) {
        require Relianoid::Net::Interface;

        my @system_interfaces = &getInterfaceList();

        unless (grep ({ $json_obj->{interface} eq $_ } @system_interfaces)) {
            my $msg = "Gateway interface not found.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }

    my $interface = $json_obj->{interface};
    my $address   = $json_obj->{address} // $default_gw;

    unless ($interface) {
        $interface = ($ip_ver == 6) ? &getIPv6IfDefaultGW() : &getIfDefaultGW();
    }

    require Relianoid::Net::Interface;
    my $if_ref = &getInterfaceConfig($interface);

    # check if network is correct
    require Relianoid::Net::Validate;

    unless (&validateGateway($if_ref->{addr}, $if_ref->{mask}, $address)) {
        my $msg = "The gateway is not valid for the network.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &log_debug("applyRoutes interface:$interface address:$address if_ref:$if_ref", "NETWORK")
      if &debug();

    my $error = &applyRoutes("global", $if_ref, $address);

    if ($error) {
        my $msg = "The default gateway hasn't been changed";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $msg  = "The default gateway has been changed successfully";
    my $body = {
        description => $desc,
        success     => "true",
        message     => $msg,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub delete_gateway_controller ($ip_ver) {
    require Relianoid::Net::Route;
    require Relianoid::Net::Interface;

    my $desc = "Remove default gateway";
    my $ip_v = ($ip_ver == 6) ? 6 : 4;

    my $defaultgwif = ($ip_v == 6) ? &getIPv6IfDefaultGW() : &getIfDefaultGW();
    my $if_ref      = &getInterfaceConfig($defaultgwif, $ip_v);
    $$if_ref{ip_v} //= $ip_v;

    my $error = &delRoutes("global", $if_ref);

    if ($error) {
        my $msg = "The default gateway hasn't been deleted";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $addr    = ($ip_v == 6) ? &getIPv6DefaultGW()   : &getDefaultGW();
    my $if_name = ($ip_v == 6) ? &getIPv6IfDefaultGW() : &getIfDefaultGW();

    my $msg  = "The default gateway has been deleted successfully";
    my $body = {
        description => $desc,
        message     => $msg,
        params      => {
            address   => $addr,
            interface => $if_name,
        },
    };

    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Interface/Generic.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Interface::Generic

=cut

# GET /interfaces Get params of the interfaces
sub list_interfaces_controller () {
    require Relianoid::Net::Interface;

    my $desc = "List interfaces";
    my $if_list_ref;

    $if_list_ref = &get_interface_list_struct();

    my $body = {
        description => $desc,
        interfaces  => $if_list_ref,
    };

    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Interface/NIC.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Interface::NIC

=cut

sub delete_nic_controller ($nic) {
    require Relianoid::Net::Core;
    require Relianoid::Net::Route;
    require Relianoid::Net::Interface;

    my $desc   = "Delete nic interface";
    my $ip_v   = 4;
    my $if_ref = &getInterfaceConfig($nic, $ip_v);

    if (!$if_ref) {
        my $msg = "There is no configuration for the network interface.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($eload) {
        if ($if_ref->{addr}) {
            my $msg = &eload(
                module => 'Relianoid::EE::Net::Ext',
                func   => 'isManagementIP',
                args   => [ $if_ref->{addr} ],
            );
            if ($msg) {
                $msg = "The interface cannot be modified. $msg";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        my $zcl_conf = &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'getClusterConfig',
        );

        if (defined $zcl_conf->{_}{interface}
            and $zcl_conf->{_}{interface} eq $if_ref->{name})
        {
            my $msg = "The cluster interface $if_ref->{name} cannot be modified.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        if (defined $if_ref->{is_slave} and $if_ref->{is_slave} eq "true") {
            my $msg = "The slave interface $if_ref->{name} cannot be modified.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        if (defined $zcl_conf->{_}{track_interface}) {
            my @track_interface =
              split(/\s/, $zcl_conf->{_}{track_interface});
            if (grep { $_ eq $if_ref->{name} } @track_interface) {
                my $msg = "The interface $if_ref->{name} cannot be modified because it is been tracked by the cluster.
						If you still want to modify it, remove it from the cluster track interface list.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # not delete the interface if it has some vlan configured
    my @child = &getInterfaceChild($nic);
    if (@child) {
        my $child_string = join(', ', @child);
        my $msg          = "It is not possible to delete $nic because there are virtual interfaces using it: $child_string.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if some farm is using this ip
    if ($if_ref->{addr}) {
        require Relianoid::Farm::Base;
        my @farms = &getFarmListByVip($if_ref->{addr});
        if (@farms) {
            my $str = join(', ', @farms);
            my $msg = "This interface is being used as vip in the farm(s): $str.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    if ($eload && $if_ref->{addr}) {
        # check if some VPN is using this ip
        my $vpns = &eload(
            module => 'Relianoid::EE::VPN::Util',
            func   => 'getVpnByIp',
            args   => [ $if_ref->{addr} ],
        );

        if (@{$vpns}) {
            my $str = join(', ', @{$vpns});
            my $msg = "The interface is being used as Local Gateway in VPN(s): $str";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        $vpns = &eload(
            module => 'Relianoid::EE::VPN::Util',
            func   => 'getVpnByNet',
            args   => [ $if_ref->{net} ],
        );

        if (@{$vpns}) {
            my $str = join(', ', @{$vpns});
            my $msg = "The interface is being used as Local Network in VPN(s): $str";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    eval {
        die if &delRoutes("local", $if_ref);
        die if &delIf($if_ref);
    };

    if ($@) {
        &log_error("Module failed: $@", 'net');
        my $msg = "The configuration for the network interface $nic can't be deleted.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $message = "The configuration for the network interface $nic has been deleted.";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /interfaces Get params of the interfaces
sub list_nic_controller () {
    require Relianoid::Net::Interface;

    my $desc         = "List NIC interfaces";
    my $nic_list_ref = &get_nic_list_struct();

    my $body = {
        description => $desc,
        interfaces  => $nic_list_ref,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub get_nic_controller ($nic) {
    require Relianoid::Net::Interface;

    my $desc      = "Show NIC interface";
    my $interface = &get_nic_struct($nic);

    unless ($interface) {
        my $msg = "Nic interface not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $body = {
        description => $desc,
        interface   => $interface,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub actions_nic_controller ($json_obj, $nic) {
    require Relianoid::Net::Interface;

    my $desc = "Action on nic interface";
    my $ip_v = 4;

    # validate NIC
    unless (grep { $nic eq $_->{name} } &getInterfaceTypeList('nic')) {
        my $msg = "Nic interface not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Check allowed parameters
    my $params = &getAPIModel("nic-action.json");
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    if ($eload) {
        my $zcl_conf = &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'getClusterConfig',
        );

        if (defined $zcl_conf->{_}{track_interface}) {
            my @track_interface = split(/\s/, $zcl_conf->{_}{track_interface});

            if (grep { $_ eq $nic } @track_interface) {
                my $msg = "The interface $nic cannot be modified because it is been tracked by the cluster. "
                  . "If you still want to modify it, remove it from the cluster track interface list.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    my $if_ref = &getInterfaceConfig($nic, $ip_v);

    # validate action parameter
    if ($json_obj->{action} eq "up") {
        require Relianoid::Net::Core;
        require Relianoid::Net::Route;

        # Delete routes in case that it is not a vini
        if ($if_ref->{addr}) {
            &delRoutes("local", $if_ref);
            &addIp($if_ref);
        }

        my $state = &upIf($if_ref, 'writeconf');

        if (!$state) {
            require Relianoid::Net::Util;
            &applyRoutes("local", $if_ref) if $if_ref->{addr};

            # put all dependant interfaces up
            &setIfacesUp($nic, "vlan");
            &setIfacesUp($nic, "vini") if $if_ref;
        }
        else {
            my $msg = "The interface $nic could not be set UP";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    elsif ($json_obj->{action} eq "down") {
        if ($eload && $if_ref->{addr}) {
            my $msg = &eload(
                module => 'Relianoid::EE::Net::Ext',
                func   => 'isManagementIP',
                args   => [ $if_ref->{addr} ],
            );
            if ($msg) {
                $msg = "The interface cannot be stopped. $msg";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        require Relianoid::Net::Core;
        my $state = &downIf($if_ref, 'writeconf');

        if ($state) {
            my $msg = "The interface $nic could not be set DOWN";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my $msg  = "The $nic NIC is $json_obj->{action}";
    my $body = {
        description => $desc,
        params      => { action => $json_obj->{action} },
        message     => $msg
    };

    return &httpResponse({ code => 200, body => $body });
}

sub modify_nic_controller ($json_obj, $nic) {
    require Relianoid::Net::Interface;
    require Relianoid::Net::Core;
    require Relianoid::Net::Route;
    require Relianoid::Net::Validate;

    my $desc = "Configure NIC interface";

    # validate NIC NAME
    my $type = &getInterfaceType($nic);

    unless ($type eq 'nic') {
        my $msg = "NIC interface not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }
    my $params = &getAPIModel("nic-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # Delete old interface configuration
    my $if_ref = &getInterfaceConfig($nic) // &getSystemInterface($nic);

    # Ignore the dhcp parameter if it is equal to the configured one
    delete $json_obj->{dhcp}
      if (exists $json_obj->{dhcp} && $json_obj->{dhcp} eq $if_ref->{dhcp});

    my @child = &getInterfaceChild($nic);

    if (exists $json_obj->{dhcp}) {
        # only allow dhcp when no other parameter was sent
        if ($json_obj->{dhcp} eq 'true') {
            if (   exists $json_obj->{ip}
                or exists $json_obj->{netmask}
                or exists $json_obj->{gateway})
            {
                my $msg = "It is not possible set 'ip', 'netmask' or 'gateway' while 'dhcp' is going to be set up.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
        elsif (!exists $json_obj->{ip}) {
            if (@child) {
                my $msg =
                  "This interface has appending some virtual interfaces, please, set up a new 'ip' in the current networking range.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # check if network is correct

    my $new_if;
    if ($if_ref) {
        $new_if = {
            addr    => $json_obj->{ip}      // $if_ref->{addr},
            mask    => $json_obj->{netmask} // $if_ref->{mask},
            gateway => $json_obj->{gateway} // $if_ref->{gateway},
        };
    }
    else {
        $new_if = {
            addr    => $json_obj->{ip},
            mask    => $json_obj->{netmask},
            gateway => $json_obj->{gateway} // undef,
        };
    }

    # Make sure the address, mask and gateway belong to the same stack
    if ($new_if->{addr}) {
        my $ip_v = &ipversion($new_if->{addr});
        my $gw_v = &ipversion($new_if->{gateway});

        if (!&validateNetmask($new_if->{mask}, $ip_v)) {
            my $msg = "The netmask is not valid";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        if ($new_if->{gateway} && $ip_v ne $gw_v) {
            my $msg = "Invalid IP stack version match.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    if (exists $json_obj->{ip} or exists $json_obj->{netmask}) {
        # check ip and netmask are configured
        unless ($new_if->{addr} ne "" and $new_if->{mask} ne "") {
            my $msg =
              "The networking configuration is not valid. It needs an IP ('$new_if->{addr}') and a netmask ('$new_if->{mask}')";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        # Do not modify gateway or netmask if exists a virtual interface using this interface
        my @wrong_conf;
        for my $child_name (@child) {
            my $child_if = &getInterfaceConfig($child_name);
            unless (&validateGateway($child_if->{addr}, $new_if->{mask}, $new_if->{addr})) {
                push @wrong_conf, $child_name;
            }
        }

        if (@wrong_conf) {
            my $child_string = join(', ', @wrong_conf);
            my $msg          = "The virtual interface(s): '$child_string' will not be compatible with the new configuration.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # check the gateway is in network
    if ($new_if->{gateway}) {
        unless (&validateGateway($new_if->{addr}, $new_if->{mask}, $new_if->{gateway})) {
            my $msg = "The gateway is not valid for the network.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # check if network exists in other interface
    if ($json_obj->{ip} or $json_obj->{netmask}) {
        my $if_used =
          &checkNetworkExists($new_if->{addr}, $new_if->{mask}, $nic);
        if ($if_used) {
            my $msg = "The network already exists in the interface $if_used.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Check new IP address is not in use
    my $different_ip = ((not $if_ref->{addr}) or ($new_if->{addr} ne $if_ref->{addr}));
    if ($json_obj->{ip} and $different_ip) {
        require Relianoid::Net::Util;
        my @activeips = &listallips();
        for my $ip (@activeips) {
            if ($ip eq $json_obj->{ip}) {
                my $msg = "IP address $json_obj->{ip} already in use.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    my @farms;
    my $vpns_localgw  = [];
    my $vpns_localnet = [];
    my $warning_msg;

    if (   exists $json_obj->{ip}
        or (exists $json_obj->{dhcp})
        or (exists $json_obj->{netmask}))
    {
        if (exists $json_obj->{ip}
            or (exists $json_obj->{dhcp}))
        {
            if ($eload) {
                if ($if_ref->{addr}) {
                    my $msg = &eload(
                        module => 'Relianoid::EE::Net::Ext',
                        func   => 'isManagementIP',
                        args   => [ $if_ref->{addr} ],
                    );
                    if ($msg) {
                        $msg = "The interface cannot be modified. $msg";
                        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                    }
                }

                my $zcl_conf = &eload(
                    module => 'Relianoid::EE::Cluster',
                    func   => 'getClusterConfig',
                );

                if (defined $zcl_conf->{_}{interface}
                    and $zcl_conf->{_}{interface} eq $if_ref->{name})
                {
                    my $msg = "The cluster interface $if_ref->{name} cannot be modified.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }

                if (defined $if_ref->{is_slave}
                    and $if_ref->{is_slave} eq "true")
                {
                    my $msg = "The slave interface $if_ref->{name} cannot be modified.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }

            # check if some farm is using this ip
            if ($if_ref->{addr}) {
                require Relianoid::Farm::Base;
                @farms = &getFarmListByVip($if_ref->{addr});
            }

            $vpns_localgw = &eload(
                module => 'Relianoid::EE::VPN::Util',
                func   => 'getVpnByIp',
                args   => [ $if_ref->{addr} ],
            ) if $eload;
        }

        # check if its a new network and a vpn using old network
        if (exists $json_obj->{ip} or exists $json_obj->{netmask}) {
            # check if network is changed
            my $mask = $json_obj->{netmask} // $if_ref->{mask};
            if (not &validateGateway($if_ref->{addr}, $if_ref->{mask}, $json_obj->{ip})
                or $if_ref->{mask} ne $mask)
            {
                my $net = NetAddr::IP->new($if_ref->{addr}, $if_ref->{mask})->cidr();
                $vpns_localnet = &eload(
                    module => 'Relianoid::EE::VPN::Util',
                    func   => 'getVpnByNet',
                    args   => [$net],
                ) if $eload;
            }
        }

        if (@farms or @{$vpns_localgw} or @{$vpns_localnet}) {
            if (    not exists $json_obj->{ip}
                and exists $json_obj->{dhcp}
                and $json_obj->{dhcp} eq 'false')
            {
                my $str_objects;
                my $str_function;
                if (@farms) {
                    $str_objects  = " and farms";
                    $str_function = " and farm VIP";
                }
                if (@{$vpns_localgw} or @{$vpns_localnet}) {
                    $str_objects .= " and vpns";
                }
                if (@{$vpns_localgw}) {
                    $str_function .= " and Local Gateway";
                }
                if (@{$vpns_localnet}) {
                    $str_function .= " and Local Network";
                }
                $str_objects  = substr($str_objects,  5);
                $str_function = substr($str_function, 5);

                my $msg =
                  "This interface is been used by some $str_objects, please, set up a new 'ip' in order to be used as $str_function.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            if (!$json_obj->{force} || $json_obj->{force} ne 'true') {
                my $str_objects;
                my $str_function;
                if (@farms) {
                    $str_objects  = " and farms";
                    $str_function = " and as farm VIP in the farm(s): " . join(', ', @farms);
                }
                if (@{$vpns_localgw} or @{$vpns_localnet}) {
                    $str_objects .= " and vpns";
                }
                if (@{$vpns_localgw}) {
                    $str_function .= " and as Local Gateway in the VPN(s): " . join(', ', @{$vpns_localgw});
                }
                if (@{$vpns_localnet}) {
                    $str_function .= " and as Local Network in the VPN(s): " . join(', ', @{$vpns_localnet});
                }
                $str_objects  = substr($str_objects,  5);
                $str_function = substr($str_function, 5);

                my $msg =
                  "The IP is being used $str_function. If you are sure, repeat with parameter 'force'. All $str_objects using this interface will be restarted.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # END CHECKS

    if ($if_ref->{addr}) {
        # remove custom routes
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Net::Routing',
                func   => 'updateRoutingVirtualIfaces',
                args   => [ $if_ref->{parent}, $json_obj->{ip} // $if_ref->{addr} ],
            );
        }

        # Delete old IP and Netmask from system to replace it
        &delIp($if_ref->{name}, $if_ref->{addr}, $if_ref->{mask});

        # Remove routes if the interface has its own route table: nic and vlan
        &delRoutes("local", $if_ref);

        $if_ref = undef;
    }

    # Setup new interface configuration structure
    $if_ref            = &getInterfaceConfig($nic) // &getSystemInterface($nic);
    $if_ref->{addr}    = $json_obj->{ip}      if exists $json_obj->{ip};
    $if_ref->{mask}    = $json_obj->{netmask} if exists $json_obj->{netmask};
    $if_ref->{gateway} = $json_obj->{gateway} if exists $json_obj->{gateway};
    $if_ref->{ip_v}    = &ipversion($if_ref->{addr});
    $if_ref->{net}     = &getAddressNetwork($if_ref->{addr}, $if_ref->{mask}, $if_ref->{ip_v});
    $if_ref->{dhcp}    = $json_obj->{dhcp} if exists $json_obj->{dhcp};

    # set DHCP
    my $set_flag        = 1;
    my $nic_config_file = "";
    if (exists $json_obj->{dhcp}) {
        if ($json_obj->{dhcp} eq "true") {
            require Relianoid::Lock;
            $nic_config_file = &getGlobalConfiguration('configdir') . "/if_$if_ref->{name}_conf";
            &lockResource($nic_config_file, "l");
        }

        my $func = ($json_obj->{dhcp} eq 'true') ? "enableDHCP" : "disableDHCP";
        &eload(
            module => 'Relianoid::EE::Net::DHCP',
            func   => $func,
            args   => [$if_ref],
        );

        if (   $json_obj->{dhcp} eq 'false' and not exists $json_obj->{ip}
            or $json_obj->{dhcp} eq 'true')
        {
            $set_flag = 0;
        }
    }
    if (!&setInterfaceConfig($if_ref)) {
        if ($json_obj->{dhcp} eq "true") {
            require Relianoid::Lock;
            &lockResource($nic_config_file, "ud");
        }
        my $msg = "Errors found trying to modify interface $nic";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Free the resource
    if ($json_obj->{dhcp} and $json_obj->{dhcp} eq "true") {
        require Relianoid::Lock;
        &lockResource($nic_config_file, "ud");
    }

    # set up
    if ($if_ref->{addr} and $if_ref->{mask} and $set_flag) {
        eval {
            # Add new IP, netmask and gateway
            # sometimes there are expected errors pending to be controlled
            &addIp($if_ref);

            # Writing new parameters in configuration file
            &writeRoutes($if_ref->{name});

            # Put the interface up
            my $previous_status = $if_ref->{status};

            if ($previous_status eq "up") {
                if (&upIf($if_ref, 'writeconf') == 0) {
                    $if_ref->{status} = "up";
                    &applyRoutes("local", $if_ref);
                    if ($if_ref->{ip_v} eq "4") {
                        my $if_gw = &getGlobalConfiguration('defaultgwif');
                        if ($if_ref->{name} eq $if_gw) {
                            my $defaultgw = &getGlobalConfiguration('defaultgw');
                            &applyRoutes("global", $if_ref, $defaultgw);
                        }
                    }
                    elsif ($if_ref->{ip_v} eq "6") {
                        my $if_gw = &getGlobalConfiguration('defaultgwif6');
                        if ($if_ref->{name} eq $if_gw) {
                            my $defaultgw = &getGlobalConfiguration('defaultgw6');
                            &applyRoutes("global", $if_ref, $defaultgw);
                        }
                    }
                }
                else {
                    $if_ref->{status} = $previous_status;
                }
            }

            # if the GW is changed, change it in all appending virtual interfaces
            if (exists $json_obj->{gateway}) {
                for my $appending (&getInterfaceChild($nic)) {
                    my $app_config = &getInterfaceConfig($appending);
                    $app_config->{gateway} = $json_obj->{gateway};
                    &setInterfaceConfig($app_config);
                }
            }

            # modify netmask on all dependent interfaces
            if (exists $json_obj->{netmask}) {
                for my $appending (&getInterfaceChild($nic)) {
                    my $app_config = &getInterfaceConfig($appending);
                    &delRoutes("local", $app_config);
                    &downIf($app_config);
                    $app_config->{mask} = $json_obj->{netmask};
                    &setInterfaceConfig($app_config);
                }
            }

            # put all dependent interfaces up
            require Relianoid::Net::Util;
            &setIfacesUp($nic, "vini");

            # change farm vip,
            if (@farms) {
                require Relianoid::Farm::Config;
                &setAllFarmByVip($json_obj->{ip}, \@farms);
                &reloadFarmsSourceAddress();
            }
            if (@{$vpns_localgw}) {
                my $error = &eload(
                    module => 'Relianoid::EE::VPN::Config',
                    func   => 'setAllVPNLocalGateway',
                    args   => [ $if_ref->{addr}, $vpns_localgw ],
                );
                $warning_msg .= $error->{desc} if ($error->{code});
            }
            if (@{$vpns_localnet}) {
                my $net =
                  NetAddr::IP->new($if_ref->{net}, $if_ref->{mask})->cidr();
                my $error = &eload(
                    module => 'Relianoid::EE::VPN::Config',
                    func   => 'setAllVPNLocalNetwork',
                    args   => [ $net, $vpns_localnet ],
                );
                $warning_msg .= $error->{desc} if ($error->{code});
            }
        };

        if ($@) {
            &log_error("Module failed: $@", "net");
            my $msg = "Errors found trying to modify interface $nic";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my $iface_out = &get_nic_struct($nic);
    my $body      = {
        description => $desc,
        params      => $iface_out,
        message     => "The $nic NIC has been updated successfully."
    };
    $body->{warning} = $warning_msg if ($warning_msg);

    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Interface/VLAN.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Interface::VLAN

=cut

my $eload = eval { require Relianoid::ELoad };

#  POST /interfaces/vlan Create a new vlan network interface
sub add_vlan_controller ($json_obj) {
    require Relianoid::Net::Util;
    require Relianoid::Net::Validate;
    require Relianoid::Net::Interface;

    my $desc = "Add a vlan interface";

    # validate VLAN NAME
    my $nic_re      = &getValidFormat('nic_interface');
    my $vlan_tag_re = &getValidFormat('vlan_tag');

    my $params = &getAPIModel("vlan-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my $dhcp_flag = (exists $json_obj->{dhcp} and $json_obj->{dhcp} ne "false");
    my $ip_mand   = (exists $json_obj->{ip}   and exists $json_obj->{netmask});
    my $ip_opt    = (exists $json_obj->{ip} or exists $json_obj->{netmask} or exists $json_obj->{gateway});

    unless (($dhcp_flag and not $ip_opt) or (not $dhcp_flag and $ip_mand)) {
        my $msg =
          "It is mandatory set an 'ip' and its 'netmask' or enabling the 'dhcp'. It is not allow to send 'ip', 'netmask' or 'gateway' when 'dhcp' is true.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Check if interface already exists
    my $if_ref = &getInterfaceConfig($json_obj->{name});
    if ($if_ref) {
        my $msg = "VLAN network interface $json_obj->{name} already exists.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # vlan_name = pather_name + . + vlan_tag
    # size < 16: size = pather_name.vlan_tag:virtual_name
    if (length $json_obj->{name} > 13) {
        my $msg = "VLAN interface name has a maximum length of 13 characters";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($json_obj->{name} !~ /^($nic_re)\.($vlan_tag_re)$/) {
        my $msg = "Interface name is not valid";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    $json_obj->{parent} = $1;
    $json_obj->{tag}    = $2;

    # validate PARENT
    my $if_parent = &getInterfaceConfig($json_obj->{parent});
    unless (defined $if_parent) {
        my $msg = "The parent interface $json_obj->{parent} doesn't exist";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check that nic interface is no slave of a bonding
    my $is_slave;

    for my $if_ref (&getInterfaceTypeList('nic')) {
        if ($if_ref->{name} eq $json_obj->{parent}) {
            $is_slave = $if_ref->{is_slave};
            last;
        }
    }

    if ($is_slave && $is_slave eq 'true') {
        my $msg = "It is not possible create a VLAN interface from a NIC slave.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # validate VLAN TAG
    unless ($json_obj->{tag} >= 1 && $json_obj->{tag} <= 4094) {
        my $msg = "The VLAN tag must be in the range 1-4094, both included";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    ## Validates all creation parameters, now check the setting parameters

    # setup parameters of vlan
    my $socket = IO::Socket::INET->new(Proto => 'udp');

    $if_ref = {
        name   => $json_obj->{name},
        dev    => $json_obj->{parent},
        status => $if_parent->{status},
        vlan   => $json_obj->{tag},
        dhcp   => $json_obj->{dhcp} // 'false',
        mac    => $socket->if_hwaddr($json_obj->{parent}),
        type   => 'vlan'
    };
    $if_ref->{mac} = lc $json_obj->{mac}
      if ($eload && exists $json_obj->{mac});

    if (exists $json_obj->{ip}) {
        $json_obj->{ip_v} = ipversion($json_obj->{ip});

        if (!&validateNetmask($json_obj->{netmask}, $json_obj->{ip_v})) {
            my $msg = "The netmask is not valid";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        # check if network exists in other interface
        if ($json_obj->{ip} or $json_obj->{netmask}) {
            my $if_used =
              &checkNetworkExists($json_obj->{ip}, $json_obj->{netmask});
            if ($if_used) {
                my $msg = "The network already exists in the interface $if_used.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        $if_ref->{addr}    = $json_obj->{ip};
        $if_ref->{mask}    = $json_obj->{netmask};
        $if_ref->{gateway} = $json_obj->{gateway} // '';
        $if_ref->{ip_v}    = &ipversion($json_obj->{ip});
        $if_ref->{net} =
          &getAddressNetwork($if_ref->{addr}, $if_ref->{mask}, $if_ref->{ip_v});

        # Make sure the address, mask and gateway belong to the same stack
        if ($if_ref->{addr}) {
            my $ip_v = &ipversion($if_ref->{addr});
            my $gw_v = &ipversion($if_ref->{gateway});

            my $mask_v =
                ($ip_v == 4 && &getValidFormat('IPv4_mask', $if_ref->{mask})) ? 4
              : ($ip_v == 6 && &getValidFormat('IPv6_mask', $if_ref->{mask})) ? 6
              :                                                                 '';

            if ($ip_v ne $mask_v
                || ($if_ref->{gateway} && $ip_v ne $gw_v))
            {
                my $msg = "Invalid IP stack version match.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        if ($if_ref->{gateway}) {
            unless (&validateGateway($if_ref->{addr}, $if_ref->{mask}, $if_ref->{gateway})) {
                my $msg = "Gateway does not belong to the interface subnet.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # creating
    if (&createVlan($if_ref)) {
        my $msg = "The $json_obj->{name} vlan network interface can't be created";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # configuring
    if ($dhcp_flag) {
        my $func = ($json_obj->{dhcp} eq 'true') ? "enableDHCP" : "disableDHCP";
        my $err  = &eload(
            module => 'Relianoid::EE::Net::DHCP',
            func   => $func,
            args   => [$if_ref],
        );

        if ($err) {
            my $msg = "The $json_obj->{name} vlan network interface can't be configured";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    else {
        if (&setVlan($if_ref, $json_obj)) {
            my $msg = "The $json_obj->{name} vlan network interface can't be configured";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my $body = {
        description => $desc,
        params      => &get_vlan_struct($json_obj->{name}),
        message     => "The $json_obj->{name} VLAN has been created successfully."
    };

    return &httpResponse({ code => 201, body => $body });
}

sub delete_vlan_controller ($vlan) {
    my $desc = "Delete VLAN interface";
    my $ip_v = 4;

    require Relianoid::Net::Interface;

    my $if_ref = &getInterfaceConfig($vlan, $ip_v);

    # validate VLAN interface
    if (!$if_ref) {
        my $msg = "The VLAN interface $vlan doesn't exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($eload) {
        if ($if_ref->{addr}) {
            my $msg = &eload(
                module => 'Relianoid::EE::Net::Ext',
                func   => 'isManagementIP',
                args   => [ $if_ref->{addr} ],
            );
            if ($msg) {
                $msg = "The interface cannot be modified. $msg";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        my $zcl_conf = &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'getClusterConfig',
        );
        if (defined $zcl_conf->{_}{track_interface}) {
            my @track_interface =
              split(/\s/, $zcl_conf->{_}{track_interface});
            if (grep { $_ eq $if_ref->{name} } @track_interface) {
                my $msg = "The interface $if_ref->{name} cannot be modified because it is been tracked by the cluster.
						If you still want to modify it, remove it from the cluster track interface list.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # check if some farm is using this ip
    require Relianoid::Farm::Base;
    my @farms = &getFarmListByVip($if_ref->{addr});
    if (@farms) {
        my $str = join(', ', @farms);
        my $msg = "This interface is being used as vip in the farm(s): $str.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($eload) {
        # check if some VPN is using this ip
        my $vpns = &eload(
            module => 'Relianoid::EE::VPN::Util',
            func   => 'getVpnByIp',
            args   => [ $if_ref->{addr} ],
        );
        if (@{$vpns}) {
            my $str = join(', ', @{$vpns});
            my $msg = "This interface is being used as Local Gateway in VPN(s): $str";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
        $vpns = &eload(
            module => 'Relianoid::EE::VPN::Util',
            func   => 'getVpnByNet',
            args   => [ $if_ref->{net} ],
        );
        if (@{$vpns}) {
            my $str = join(', ', @{$vpns});
            my $msg = "This interface is being used as Local Network in VPN(s): $str";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my @child = &getInterfaceChild($vlan);
    if (@child) {
        my $child_string = join(', ', @child);
        my $msg          = "Before removing $vlan interface, delete the virtual interfaces: $child_string.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::Net::Core;
    require Relianoid::Net::Route;

    eval {
        die if &delRoutes("local", $if_ref);
        die if &downIf($if_ref, 'writeconf');
        die if &delIf($if_ref);
    };

    if ($@) {
        &log_error("Module failed: $@", "net");
        my $msg = "The VLAN interface $vlan can't be deleted";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $message = "The VLAN interface $vlan has been deleted.";
    my $body    = {
        description => $desc,
        message     => $message,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub list_vlan_controller () {
    require Relianoid::Net::Interface;

    my $desc        = "List VLAN interfaces";
    my $output_list = &get_vlan_list_struct();

    my $body = {
        description => $desc,
        interfaces  => $output_list,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub get_vlan_controller ($vlan) {
    require Relianoid::Net::Interface;

    my $desc      = "Show VLAN interface $vlan";
    my $interface = &get_vlan_struct($vlan);

    unless ($interface) {
        my $msg = "VLAN interface not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $body = {
        description => $desc,
        interface   => $interface,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub actions_vlan_controller ($json_obj, $vlan) {
    require Relianoid::Net::Interface;

    my $desc = "Action on vlan interface";
    my $ip_v = 4;

    my $params = &getAPIModel("vlan-action.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # validate VLAN
    unless (grep { $vlan eq $_->{name} } &getInterfaceTypeList('vlan')) {
        my $msg = "VLAN interface not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $if_ref = &getInterfaceConfig($vlan, $ip_v);

    # validate action parameter
    if ($json_obj->{action} eq "up") {
        require Relianoid::Net::Validate;
        require Relianoid::Net::Route;
        require Relianoid::Net::Core;

        # Create vlan if required if it doesn't exist
        my $exists = &ifexist($if_ref->{name});
        if ($exists eq "false") {
            &createIf($if_ref);
        }

        # Delete routes in case that it is not a vini
        &delRoutes("local", $if_ref);

        # Add IP
        &addIp($if_ref);

        # Check the parent's status before up the interface
        my $parent_if_name   = &getParentInterfaceName($if_ref->{name});
        my $parent_if_status = 'up';

        if ($parent_if_name) {
            my $parent_if_ref = &getSystemInterface($parent_if_name);
            $parent_if_status = &getInterfaceSystemStatus($parent_if_ref);
        }

        # validate PARENT INTERFACE STATUS
        unless ($parent_if_status eq 'up') {
            my $msg = "The interface $if_ref->{name} has a parent interface DOWN, check the interfaces status";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        my $state = &upIf($if_ref, 'writeconf');

        if (!$state) {
            &applyRoutes("local", $if_ref);

            # put all dependant interfaces up
            require Relianoid::Net::Util;
            &setIfacesUp($if_ref->{name}, "vini");
        }
        else {
            my $msg = "The interface $if_ref->{name} could not be set UP";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    elsif ($json_obj->{action} eq "down") {
        if ($eload) {
            if ($if_ref->{addr}) {
                my $msg = &eload(
                    module => 'Relianoid::EE::Net::Ext',
                    func   => 'isManagementIP',
                    args   => [ $if_ref->{addr} ],
                );
                if ($msg) {
                    $msg = "The interface cannot be stopped. $msg";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
            my $zcl_conf = &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'getClusterConfig',
            );
            if (defined $zcl_conf->{_}{track_interface}) {
                my @track_interface = split(/\s/, $zcl_conf->{_}{track_interface});

                if (grep { $_ eq $if_ref->{name} } @track_interface) {
                    my $msg = "The interface $if_ref->{name} cannot be modified because it is been tracked by the cluster.
							If you still want to modify it, remove it from the cluster track interface list.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
        }

        require Relianoid::Net::Core;
        my $state = &downIf($if_ref, 'writeconf');

        if ($state) {
            my $msg = "The interface could not be set DOWN";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my $body = {
        description => $desc,
        params      => { action => $json_obj->{action} },
        message     => "The $vlan VLAN is $json_obj->{action}."
    };

    return &httpResponse({ code => 200, body => $body });
}

sub modify_vlan_controller ($json_obj, $vlan) {
    require Relianoid::Net::Interface;
    require Relianoid::Net::Core;
    require Relianoid::Net::Validate;
    require NetAddr::IP;

    my $desc   = "Modify VLAN interface";
    my $if_ref = &getInterfaceConfig($vlan);
    my $old_ip = $if_ref->{addr};

    my @farms;
    my $vpns_localgw  = [];
    my $vpns_localnet = [];
    my $warning_msg;

    # Check interface errors
    unless ($if_ref) {
        my $msg = "VLAN interface not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("vlan-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my @child = &getInterfaceChild($vlan);

    my $dhcp_status = $json_obj->{dhcp} // $if_ref->{dhcp};

    # only allow dhcp when no other parameter was sent
    if ($dhcp_status eq 'true') {
        if (   exists $json_obj->{ip}
            or exists $json_obj->{netmask}
            or exists $json_obj->{gateway})
        {
            my $msg = "It is not possible set 'ip', 'netmask' or 'gateway' while 'dhcp' is enabled.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    if (not exists $json_obj->{ip} and exists $json_obj->{dhcp} and @child) {
        my $msg =
          "This interface has appending some virtual interfaces, please, set up a new 'ip' in the current networking range.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if (   exists $json_obj->{ip}
        or exists $json_obj->{netmask}
        or exists $json_obj->{gateway})
    {
        my $new_if = {
            addr    => $json_obj->{ip}      // $if_ref->{addr},
            mask    => $json_obj->{netmask} // $if_ref->{mask},
            gateway => $json_obj->{gateway} // $if_ref->{gateway},
        };

        # Make sure the address, mask and gateway belong to the same stack
        if ($new_if->{addr}) {
            my $ip_v = &ipversion($new_if->{addr});
            my $gw_v = &ipversion($new_if->{gateway});

            if (!&validateNetmask($new_if->{mask}, $ip_v)) {
                my $msg = "The netmask is not valid";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            if ($new_if->{gateway} && $ip_v ne $gw_v) {
                my $msg = "Invalid IP stack version match.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        if (exists $json_obj->{ip} or exists $json_obj->{netmask}) {
            # check ip and netmask are configured
            unless ($new_if->{addr} ne "" and $new_if->{mask} ne "") {
                my $msg =
                  "The networking configuration is not valid. It needs an IP ('$new_if->{addr}') and a netmask ('$new_if->{mask}')";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            # Do not modify gateway or netmask if exists a virtual interface using this interface
            my @wrong_conf;
            for my $child_name (@child) {
                my $child_if = &getInterfaceConfig($child_name);
                unless (&validateGateway($child_if->{addr}, $new_if->{mask}, $new_if->{addr})) {
                    push @wrong_conf, $child_name;
                }
            }

            if (@wrong_conf) {
                my $child_string = join(', ', @wrong_conf);
                my $msg          = "The virtual interface(s): '$child_string' will not be compatible with the new configuration.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        # check if network exists in other interface
        if ($json_obj->{ip} or $json_obj->{netmask}) {
            my $if_used =
              &checkNetworkExists($new_if->{addr}, $new_if->{mask}, $vlan);
            if ($if_used) {
                my $msg = "The network already exists in the interface $if_used.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        # check the gateway is in network
        if ($new_if->{gateway}) {
            unless (&validateGateway($new_if->{addr}, $new_if->{mask}, $new_if->{gateway})) {
                my $msg = "The gateway is not valid for the network.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        # Check new IP address is not in use
        if ($json_obj->{ip} and ($new_if->{addr} ne $if_ref->{addr})) {
            require Relianoid::Net::Util;
            my @activeips = &listallips();
            for my $ip (@activeips) {
                if ($ip eq $json_obj->{ip}) {
                    my $msg = "IP address $json_obj->{ip} already in use.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
        }
    }

    if (   exists $json_obj->{ip}
        or (exists $json_obj->{dhcp})
        or (exists $json_obj->{netmask}))
    {
        if (exists $json_obj->{ip}
            or (exists $json_obj->{dhcp}))
        {
            if ($if_ref->{addr}) {
                if ($eload) {
                    my $msg = &eload(
                        module => 'Relianoid::EE::Net::Ext',
                        func   => 'isManagementIP',
                        args   => [ $if_ref->{addr} ],
                    );
                    if ($msg) {
                        $msg = "The interface cannot be modified. $msg";
                        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                    }
                }
            }

            # check if some farm is using this ip
            require Relianoid::Farm::Base;
            @farms        = &getFarmListByVip($if_ref->{addr});
            $vpns_localgw = &eload(
                module => 'Relianoid::EE::VPN::Util',
                func   => 'getVpnByIp',
                args   => [ $if_ref->{addr} ],
            ) if $eload;
        }

        # check if its a new network and a vpn using old network
        if (exists $json_obj->{ip} or exists $json_obj->{netmask}) {
            # check if network is changed
            my $mask = $json_obj->{netmask} // $if_ref->{mask};
            if (not &validateGateway($if_ref->{addr}, $if_ref->{mask}, $json_obj->{ip})
                or $if_ref->{mask} ne $mask)
            {
                my $net =
                  NetAddr::IP->new($if_ref->{addr}, $if_ref->{mask})->cidr();
                $vpns_localnet = &eload(
                    module => 'Relianoid::EE::VPN::Util',
                    func   => 'getVpnByNet',
                    args   => [$net],
                ) if $eload;
            }
        }

        if (@farms or @{$vpns_localgw} or @{$vpns_localnet}) {
            if (    not exists $json_obj->{ip}
                and exists $json_obj->{dhcp}
                and $json_obj->{dhcp} eq 'false')
            {
                my $str_objects;
                my $str_function;
                if (@farms) {
                    $str_objects  = " and farms";
                    $str_function = " and farm VIP";
                }
                if (@{$vpns_localgw} or @{$vpns_localnet}) {
                    $str_objects .= " and vpns";
                }
                if (@{$vpns_localgw}) {
                    $str_function .= " and Local Gateway";
                }
                if (@{$vpns_localnet}) {
                    $str_function .= " and Local Network";
                }
                $str_objects  = substr($str_objects,  5);
                $str_function = substr($str_function, 5);

                my $msg =
                  "This interface is been used by some $str_objects, please, set up a new 'ip' in order to be used as $str_function.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
            if ($json_obj->{force} ne 'true') {
                my $str_objects;
                my $str_function;
                if (@farms) {
                    $str_objects  = " and farms";
                    $str_function = " and as farm VIP in the farm(s): " . join(', ', @farms);
                }
                if (@{$vpns_localgw} or @{$vpns_localnet}) {
                    $str_objects .= " and vpns";
                }
                if (@{$vpns_localgw}) {
                    $str_function .= " and as Local Gateway in the VPN(s): " . join(', ', @{$vpns_localgw});
                }
                if (@{$vpns_localnet}) {
                    $str_function .= " and as Local Network in the VPN(s): " . join(', ', @{$vpns_localnet});
                }
                $str_objects  = substr($str_objects,  5);
                $str_function = substr($str_function, 5);

                my $msg =
                  "The IP is being used $str_function. If you are sure, repeat with parameter 'force'. All $str_objects using this interface will be restarted.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    if (exists $json_obj->{dhcp}) {
        my $func = ($json_obj->{dhcp} eq 'true') ? "enableDHCP" : "disableDHCP";
        my $err  = &eload(
            module => 'Relianoid::EE::Net::DHCP',
            func   => $func,
            args   => [$if_ref],
        );

        if ($err) {
            my $msg = "Errors found trying to enabling dhcp for the interface $vlan";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Delete old parameters
    if ($if_ref) {
        require Relianoid::Net::Core;
        require Relianoid::Net::Route;

        # Delete old IP and Netmask from system to replace it
        &delIp($$if_ref{name}, $$if_ref{addr}, $$if_ref{mask});

        # Remove routes if the interface has its own route table: nic and vlan
        &delRoutes("local", $if_ref);
    }

    $if_ref->{addr} = $json_obj->{ip} if (exists $json_obj->{ip});
    $if_ref->{mac}  = lc $json_obj->{mac}
      if ($eload && exists $json_obj->{mac});
    $if_ref->{mask}    = $json_obj->{netmask} if exists $json_obj->{netmask};
    $if_ref->{gateway} = $json_obj->{gateway} if exists $json_obj->{gateway};
    $if_ref->{ip_v}    = &ipversion($if_ref->{addr});
    $if_ref->{net} =
      &getAddressNetwork($if_ref->{addr}, $if_ref->{mask}, $if_ref->{ip_v});

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Net::Routing',
            func   => 'updateRoutingVirtualIfaces',
            args   => [ $if_ref->{parent}, $old_ip ],
        );
    }

    require Relianoid::Lock;
    my $vlan_config_file = &getGlobalConfiguration('configdir') . "/if_$if_ref->{name}_conf";
    my $dhcp_flag        = $json_obj->{dhcp} // $if_ref->{dhcp};

    if (($dhcp_flag ne 'true') and not($if_ref->{addr} and $if_ref->{mask})) {
        my $msg = "Cannot configure the interface without address or without netmask.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    elsif ($dhcp_flag eq "true") {
        &lockResource($vlan_config_file, "l");
    }

    require Relianoid::Net::Interface;
    if (&setVlan($if_ref, $json_obj)) {
        #Release lock file
        &lockResource($vlan_config_file, "ud") if ($dhcp_flag eq "true");

        my $msg = "Errors found trying to modify interface $vlan";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    #Release lock file
    &lockResource($vlan_config_file, "ud") if ($dhcp_flag eq "true");

    if (@farms) {
        require Relianoid::Farm::Config;
        &setAllFarmByVip($json_obj->{ip}, \@farms);
        &reloadFarmsSourceAddress();
    }

    if (@{$vpns_localgw}) {
        my $error = &eload(
            module => 'Relianoid::EE::VPN::Config',
            func   => 'setAllVPNLocalGateway',
            args   => [ $json_obj->{ip}, $vpns_localgw ],
        );
        $warning_msg .= $error->{desc} if ($error->{code});
    }
    if (@{$vpns_localnet}) {
        my $net   = NetAddr::IP->new($if_ref->{net}, $if_ref->{mask})->cidr();
        my $error = &eload(
            module => 'Relianoid::EE::VPN::Config',
            func   => 'setAllVPNLocalNetwork',
            args   => [ $net, $vpns_localnet ],
        );
        $warning_msg .= $error->{desc} if ($error->{code});
    }

    my $if_out = &get_vlan_struct($vlan);
    my $body   = {
        description => $desc,
        params      => $if_out,
        message     => "The $vlan VLAN has been updated successfully"
    };
    $body->{warning} = $warning_msg if ($warning_msg);

    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Interface/Virtual.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Interface::Virtual

=cut

my $eload = eval { require Relianoid::ELoad };

# POST /interfaces/virtual Create a new virtual network interface
sub add_virtual_controller ($json_obj) {
    my $desc = "Add a virtual interface";

    my $nic_re         = &getValidFormat('nic_interface');
    my $vlan_re        = &getValidFormat('vlan_interface');
    my $virtual_tag_re = &getValidFormat('virtual_tag');

    my $params = &getAPIModel("virtual-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # virtual_name = pather_name + . + virtual_tag
    # size < 16: size = pather_name:virtual_name
    if (length $json_obj->{name} > 15) {
        my $msg = "Virtual interface name has a maximum length of 15 characters";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    unless ($json_obj->{name} =~ /^($nic_re|$vlan_re):($virtual_tag_re)$/) {
        my $msg = "Interface name is not valid";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    $json_obj->{parent} = $1;
    $json_obj->{vini}   = $2;

    my $vlan_tag_re = &getValidFormat('vlan_tag');
    $json_obj->{parent} =~ /^($nic_re)(?:\.($vlan_tag_re))?$/;
    $json_obj->{dev}  = $1;
    $json_obj->{vlan} = $2;

    require Relianoid::Net::Validate;
    $json_obj->{ip_v} = ipversion($json_obj->{ip});

    # validate PARENT
    # virtual interfaces require a configured parent interface
    my $parent_exist = &ifexist($json_obj->{parent});
    my $if_parent =
      &getInterfaceConfig($json_obj->{parent}, $json_obj->{ip_v});
    unless ($parent_exist eq "true" && $if_parent) {
        my $msg = "The parent interface $json_obj->{parent} doesn't exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    if ($if_parent->{type} eq 'nic' and not $if_parent->{addr}) {
        my $msg = "The parent interface $json_obj->{parent} must be configured.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Check network interface errors
    # A virtual interface cannnot exist in two stacks
    my $if_ref = &getInterfaceConfig($json_obj->{name}, $json_obj->{ip_v});

    if ($if_ref) {
        my $msg = "Network interface $json_obj->{name} already exists.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Check new IP address is not in use
    require Relianoid::Net::Util;

    my @activeips = &listallips();

    for my $ip (@activeips) {
        if ($ip eq $json_obj->{ip}) {
            my $msg = "IP address $json_obj->{ip} already in use.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # setup parameters of virtual interface
    $if_ref = &getInterfaceConfig($json_obj->{parent}, $json_obj->{ip_v});

    # $json_obj->{addr} must exist in getInterfaceSystemStatus()
    $json_obj->{addr}  = $json_obj->{ip};
    $if_ref->{status}  = &getInterfaceSystemStatus($json_obj);
    $if_ref->{name}    = $json_obj->{name};
    $if_ref->{vini}    = $json_obj->{vini};
    $if_ref->{addr}    = $json_obj->{ip};
    $if_ref->{gateway} = "" if !$if_ref->{gateway};
    $if_ref->{type}    = 'virtual';
    $if_ref->{dhcp}    = 'false';

    unless (&validateGateway($if_parent->{addr}, $if_ref->{mask}, $if_ref->{addr})) {
        my $msg = "IP Address $json_obj->{ip} must be same net than the parent interface.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::Net::Core;
    require Relianoid::Net::Route;

    eval {
        die if &addIp($if_ref);

        my $state = &upIf($if_ref, 'writeconf');

        if ($state == 0) {
            $if_ref->{status} = "up";
            &applyRoutes("local", $if_ref);
        }

        &setInterfaceConfig($if_ref) or die;
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::RBAC::Group::Config',
                func   => 'addRBACUserResource',
                args   => [ $if_ref->{name}, 'interfaces' ],
            );
        }
    };

    if ($@) {
        &log_error("Module failed: $@", "net");
        my $msg = "The $json_obj->{name} virtual network interface can't be created";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'interface', 'start', $if_ref->{name} ],
    ) if ($eload);

    my $body = {
        description => $desc,
        params      => {
            name    => $if_ref->{name},
            ip      => $if_ref->{addr},
            netmask => $if_ref->{mask},
            gateway => $if_ref->{gateway},
            mac     => $if_ref->{mac},
        },
        message => "The $if_ref->{name} Virtual interface has been created successfully"
    };

    return &httpResponse({ code => 201, body => $body });
}

sub delete_virtual_controller ($virtual) {
    require Relianoid::Net::Interface;

    my $desc   = "Delete virtual interface";
    my $ip_v   = 4;
    my $if_ref = &getInterfaceConfig($virtual, $ip_v);

    if (!$if_ref) {
        my $msg = "The virtual interface $virtual doesn't exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if some farm is using this ip
    require Relianoid::Farm::Base;

    my @farms = &getFarmListByVip($if_ref->{addr});

    if (@farms) {
        my $str = join(', ', @farms);
        my $msg = "This interface is being used as farm vip in the farm(s): $str.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my @child = &getInterfaceChild($virtual);

    if (@child) {
        my $child_string = join(', ', @child);
        my $msg          = "Before removing $virtual interface, disable the floating IPs: $child_string.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::Net::Route;
    require Relianoid::Net::Core;

    eval {
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'interface', 'stop', $if_ref->{name} ],
            );

            &eload(
                module => 'Relianoid::EE::Net::Routing',
                func   => 'delRoutingDependIfaceVirt',
                args   => [$if_ref],
            );
        }

        if ($if_ref->{status} eq 'up') {
            # removing before in the remote node
            die if &delRoutes("local", $if_ref);
            die if &downIf($if_ref, 'writeconf');
        }
        die if &delIf($if_ref);
    };

    if ($@) {
        &log_error("Module failed: $@", "net");
        my $msg = "The virtual interface $virtual can't be deleted";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'interface', 'delete', $if_ref->{name} ],
        );
    }

    my $message = "The virtual interface $virtual has been deleted.";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub list_virtual_controller () {
    require Relianoid::Net::Interface;

    my $desc        = "List virtual interfaces";
    my $output_list = &get_virtual_list_struct();

    if ($eload) {
        $output_list = &eload(
            module => 'Relianoid::EE::RBAC::Group::Core',
            func   => 'getRBACUserSet',
            args   => [ 'interfaces', $output_list ],
        );
    }

    my $body = {
        description => $desc,
        interfaces  => $output_list,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub get_virtual_controller ($virtual) {
    require Relianoid::Net::Interface;

    my $desc      = "Show virtual interface $virtual";
    my $interface = &get_virtual_struct($virtual);

    unless ($interface) {
        my $msg = "Virtual interface not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $body = {
        description => $desc,
        interface   => $interface,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub actions_virtual_controller ($json_obj, $virtual) {
    require Relianoid::Net::Interface;

    my $desc = "Action on virtual interface";
    my $ip_v = 4;

    my $params = &getAPIModel("virtual-action.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # validate VLAN
    unless (grep { $virtual eq $_->{name} } &getInterfaceTypeList('virtual')) {
        my $msg = "Virtual interface not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $if_ref = &getInterfaceConfig($virtual, $ip_v);

    if ($json_obj->{action} eq "up") {
        require Relianoid::Net::Core;

        &addIp($if_ref);

        # Check the parent's status before up the interface
        my $parent_if_name   = &getParentInterfaceName($if_ref->{name});
        my $parent_if_status = 'up';

        if ($parent_if_name) {
            my $parent_if_ref = &getSystemInterface($parent_if_name);
            $parent_if_status = &getInterfaceSystemStatus($parent_if_ref);
        }

        unless ($parent_if_status eq 'up') {
            my $msg = "The interface $if_ref->{name} has a parent interface DOWN, check the interfaces status";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        my $state = &upIf($if_ref, 'writeconf');
        if (!$state) {
            require Relianoid::Net::Route;
            &applyRoutes("local", $if_ref);

            &eload(
                module => 'Relianoid::EE::Net::Routing',
                func   => 'applyRoutingDependIfaceVirt',
                args   => [ 'add', $if_ref ]
            ) if $eload;
        }
        else {
            my $msg = "The interface could not be set UP";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'interface', 'start', $if_ref->{name} ],
        ) if ($eload);
    }
    elsif ($json_obj->{action} eq "down") {
        require Relianoid::Net::Core;

        my $state = &downIf($if_ref, 'writeconf');

        if ($state) {
            my $msg = "The interface could not be set DOWN";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'interface', 'stop', $if_ref->{name} ],
            );
        }
    }

    my $body = {
        description => $desc,
        params      => { action => $json_obj->{action} },
        message     => "The $if_ref->{name} Virtual interface is $json_obj->{action}"
    };

    return &httpResponse({ code => 200, body => $body });
}

sub modify_virtual_controller ($json_obj, $virtual) {
    require Relianoid::Net::Interface;
    require Net::Netmask;

    my $desc   = "Modify virtual interface";
    my $if_ref = &getInterfaceConfig($virtual);
    my $old_ip = $if_ref->{addr};
    my @farms;

    my $params = &getAPIModel("virtual-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    unless ($if_ref) {
        my $msg = "Virtual interface not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my @child = &getInterfaceChild($virtual);

    if (@child) {
        my $child_string = join(', ', @child);
        my $msg          = "Before modifying $virtual interface, disable the floating IPs: $child_string.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::Farm::Base;

    @farms = &getFarmListByVip($if_ref->{addr});

    # check if ip exists in other interface
    if ($json_obj->{ip}) {
        if ($json_obj->{ip} ne $if_ref->{addr}) {
            require Relianoid::Net::Util;

            if (grep { $json_obj->{ip} eq $_ } &listallips()) {
                my $msg = "The IP address is already in use for other interface.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        if (@farms and $json_obj->{force} ne 'true') {
            my $str = join(', ', @farms);
            my $msg =
              "The IP is being used as farm vip in the farm(s): $str. If you are sure, repeat with parameter 'force'. All farms using this interface will be restarted.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    require Relianoid::Net::Validate;
    my $if_ref_parent = &getInterfaceConfig($if_ref->{parent});

    unless (&validateGateway($if_ref_parent->{addr}, $if_ref_parent->{mask}, $json_obj->{ip})) {
        my $msg = "IP address $json_obj->{ip} must be on the same network than the parent interface.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::Net::Core;

    my $state = $if_ref->{status};
    &downIf($if_ref) if $state eq 'up';

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'interface', 'stop', $if_ref->{name} ],
        );
    }

    eval {
        # Set the new params
        $if_ref->{addr} = $json_obj->{ip};

        if ($state eq 'up') {
            require Relianoid::Net::Route;
            die if &addIp($if_ref);
            &upIf($if_ref);
            &applyRoutes("local", $if_ref);
        }

        # Add new IP, netmask and gateway
        &setInterfaceConfig($if_ref) or die;

        if ($eload and $old_ip) {
            &eload(
                module => 'Relianoid::EE::Net::Routing',
                func   => 'updateRoutingVirtualIfaces',
                args   => [ $if_ref->{parent}, $old_ip, $json_obj->{ip} ],
            );
        }

        # change farm vip,
        if (@farms) {
            require Relianoid::Farm::Config;

            &setAllFarmByVip($json_obj->{ip}, \@farms);
        }
    };

    if ($@) {
        &log_error("Module failed: $@", "net");
        my $msg = "Errors found trying to modify interface $virtual";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'interface', 'start', $if_ref->{name} ],
        );
        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'farm', 'restart_farms', @farms ],
        );
    }

    my $body = {
        description => $desc,
        params      => $json_obj,
        message     => "The $if_ref->{name} Virtual interface has been updated successfully"
    };

    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Letsencrypt.pm ===

#!/usr/bin/perl
##############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Letsencrypt

=cut

my $eload = eval { require Relianoid::ELoad };

# GET /certificates/letsencrypt
sub list_le_cert_controller () {
    require Relianoid::Letsencrypt;

    my $desc         = "List LetsEncrypt certificates";
    my $certificates = &getLetsencryptCertificates();
    my @out;

    if ($certificates) {
        for my $cert (@{$certificates}) {
            push @out, &getLetsencryptCertificateInfo($cert->{name});
        }
    }
    if ($eload) {
        my $wildcards = &eload(
            module => 'Relianoid::EE::Letsencrypt::Wildcard',
            func   => 'getLetsencryptWildcardCertificates'
        );

        for my $cert (@{$wildcards}) {
            push @out,
              &eload(
                module => 'Relianoid::EE::Letsencrypt::Wildcard',
                func   => 'getLetsencryptWildcardCertificateInfo',
                args   => [ $cert->{name} ]
              );
        }
    }

    my $body = {
        description => $desc,
        params      => \@out,
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /certificates/letsencrypt/le_cert_re
sub get_le_cert_controller ($le_cert_name) {
    require Relianoid::Letsencrypt;

    my $desc    = "Show Let's Encrypt certificate $le_cert_name";
    my $le_cert = &getLetsencryptCertificates($le_cert_name);

    if (not defined $le_cert_name or not @{$le_cert}) {
        my $msg = "Let's Encrypt certificate $le_cert_name not found!";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $out = &getLetsencryptCertificateInfo($le_cert_name);

    my $body = {
        description => $desc,
        params      => $out,
    };

    return &httpResponse({ code => 200, body => $body });
}

# POST /certificates/letsencrypt
sub add_le_cert_controller ($json_obj) {
    require Relianoid::Certificate;
    require Relianoid::Letsencrypt;
    require Relianoid::Net::Interface;
    require Relianoid::Farm::Core;

    my $ip_list   = &getIpAddressList();
    my @farm_list = &getFarmsByType("http");

    my $desc   = "Create LetsEncrypt certificate";
    my $params = &getAPIModel("letsencrypt-create.json");
    $params->{vip}{values}      = $ip_list;
    $params->{farmname}{values} = \@farm_list;

    # avoid farmname when no HTTP Farm exists
    if (not @farm_list and defined $json_obj->{farmname}) {
        my $msg = "There is no HTTP Farms in the system, use 'vip' param instead.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # vip or farmname has to be defined
    if (    not $json_obj->{vip}
        and not $json_obj->{farmname}
        and defined $json_obj->{domains})
    {
        my $msg = "No 'vip' or 'farmname' param found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # avoid wildcards domains
    if (grep { /^\*/ } @{ $json_obj->{domains} }) {
        my $msg = "Wildcard domains are not allowed.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # check if the cert exists
    my $force   = "false";
    my $le_cert = &getLetsencryptCertificates($json_obj->{domains}[0]);
    if (@{$le_cert}) {
        if (exists $json_obj->{force} and $json_obj->{force} eq 'true') {
            $force = "true";
        }
        else {
            my $msg =
              "Let's Encrypt certificate $json_obj->{domains}[0] already exists! Why not use the '--renew' instead? If you are sure, use the '--force' parameter.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # check farm has to be listening on port 80 and up
    if (defined $json_obj->{farmname}) {
        require Relianoid::Farm::Base;
        if (&getFarmVip('vipp', $json_obj->{farmname}) ne 80) {
            my $msg = "Farm $json_obj->{farmname} must be listening on Port 80.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        require Relianoid::Farm::HTTP::Config;
        if (&getHTTPFarmStatus($json_obj->{farmname}) ne "up") {
            my $msg = "Farm $json_obj->{farmname} must be up.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }

    # check any farm listening on vip and port 80 and up
    my $le_farm_port = 80;
    if (defined $json_obj->{vip}) {
        require Relianoid::Net::Validate;
        if (&validatePort($json_obj->{vip}, $le_farm_port, "tcp") == 0) {
            #vip:port is in use
            require Relianoid::Farm::Base;
            require Relianoid::Farm::HTTP::Config;

            for my $farm (&getFarmListByVip($json_obj->{vip})) {
                if (    &getHTTPFarmVip("vipp", $farm) eq "$le_farm_port"
                    and &getHTTPFarmStatus($farm) eq "up")
                {
                    my $msg = "Farm $farm is listening on 'vip' $json_obj->{vip} and Port $le_farm_port.";
                    return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
                }
            }
            my $msg = "The system has a process listening on 'vip' $json_obj->{vip} and Port $le_farm_port.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }

    # check Email config
    my $le_conf = &getLetsencryptConfig();
    if (!$le_conf->{email}) {
        my $msg = "Letsencrypt email is not configured.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $error =
      &runLetsencryptObtain($json_obj->{farmname}, $json_obj->{vip}, $json_obj->{domains}, $json_obj->{test}, $force);
    if ($error) {
        my $strdomains = join(", ", @{ $json_obj->{domains} });
        my $msg        = "The Letsencrypt certificate for Domain $strdomains can't be created";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &log_info("Success, the Letsencrypt certificate has been created successfully.", "letsencrypt");

    my $out  = &getLetsencryptCertificateInfo($json_obj->{domains}[0]);
    my $body = {
        description => $desc,
        params      => $out,
        message     => "The Letsencrypt certificate has been created successfully."
    };

    return &httpResponse({ code => 200, body => $body });
}

# DELETE /certificates/letsencrypt/le_cert_re
sub delete_le_cert_controller ($le_cert_name) {
    my $desc = "Delete LetsEncrypt certificate";

    require Relianoid::Letsencrypt;

    my $le_cert = &getLetsencryptCertificates($le_cert_name);
    if (!@{$le_cert}) {
        my $msg = "Let's Encrypt certificate $le_cert_name not found!";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $cert_name = $le_cert_name;
    $cert_name =~ s/\./\_/g;
    $cert_name .= ".pem";

    # check the certificate is being used by a Farm
    require Relianoid::Certificate;
    my $farms_used = &getCertFarmsUsed($cert_name);
    if (@{$farms_used}) {
        my $msg =
          "Let's Encrypt Certificate $le_cert_name can not be deleted because it is in use by " . join(", ", @{$farms_used});
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($eload) {
        # check the certificate is being used by API web server
        my $status = &eload(
            module => 'Relianoid::EE::System::HTTP',
            func   => 'getHttpsCertUsed',
            args   => ['$cert_name']
        );
        if ($status == 0) {
            my $msg = "Let's Encrypt Certificate $le_cert_name can not be deleted because it is in use by HTTPS server";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # revoke LE cert
    my $error = &runLetsencryptDestroy($le_cert_name);
    if ($error) {
        my $msg = "Let's Encrypt Certificate can not be removed";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # delete autorenewal
    &unsetLetsencryptCron($le_cert_name);

    # delete RELIANOID cert if exists
    my $cert_dir = &getGlobalConfiguration('certdir');
    &delCert($cert_name) if (-f "$cert_dir\/$cert_name");

    if (-f "$cert_dir\/$cert_name") {
        my $msg = "Error deleting certificate $cert_name.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &log_info("Success, the Let's Encrypt certificate has been deleted successfully.", "letsencrypt");

    my $msg  = "Let's Encrypt Certificate $le_cert_name has been deleted.";
    my $body = {
        description => $desc,
        success     => "true",
        message     => $msg,
    };
    return &httpResponse({ code => 200, body => $body });
}

# POST /certificates/letsencrypt/le_cert_re/actions
sub actions_le_cert_controller ($json_obj, $le_cert_name) {
    my $desc = "Let's Encrypt certificate actions";

    require Relianoid::Certificate;
    require Relianoid::Letsencrypt;

    # check the certificate is a LE cert
    my $le_cert = &getLetsencryptCertificates($le_cert_name);
    if (!@{$le_cert}) {
        my $msg = "Let's Encrypt certificate $le_cert_name not found!";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::Net::Interface;
    my $ip_list = &getIpAddressList();
    require Relianoid::Farm::Core;
    my @farm_list = &getFarmsByType("http");

    my $params = &getAPIModel("letsencrypt-action.json");
    $params->{vip}{values}      = $ip_list;
    $params->{farmname}{values} = \@farm_list;

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # avoid farmname when no HTTP Farm exists
    if (not @farm_list and defined $json_obj->{farmname}) {
        my $msg = "There is no HTTP Farms in the system, use 'vip' param instead.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # vip or farmname has to be defined
    if (    not $json_obj->{vip}
        and not $json_obj->{farmname})
    {
        my $msg = "No 'vip' or 'farmname' param found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # check farm has to be listening on port 80 and up
    if (defined $json_obj->{farmname}) {
        require Relianoid::Farm::Base;
        if (&getFarmVip('vipp', $json_obj->{farmname}) ne 80) {
            my $msg = "Farm $json_obj->{farmname} must be listening on Port 80.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        require Relianoid::Farm::HTTP::Config;
        if (&getHTTPFarmStatus($json_obj->{farmname}) ne "up") {
            my $msg = "Farm $json_obj->{farmname} must be up.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }

    # check any farm listening on vip and port 80 and up
    my $le_farm_port = 80;
    if (defined $json_obj->{vip}) {
        require Relianoid::Net::Validate;
        if (&validatePort($json_obj->{vip}, $le_farm_port, "tcp") == 0) {
            #vip:port is in use
            require Relianoid::Farm::Base;
            require Relianoid::Farm::HTTP::Config;

            for my $farm (&getFarmListByVip($json_obj->{vip})) {
                if (    &getHTTPFarmVip("vipp", $farm) eq "$le_farm_port"
                    and &getHTTPFarmStatus($farm) eq "up")
                {
                    my $msg = "Farm $farm is listening on 'vip' $json_obj->{vip} and Port $le_farm_port.";
                    return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
                }
            }
            my $msg = "The system has a process listening on 'vip' $json_obj->{vip} and Port $le_farm_port.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }

    # check Email config
    my $le_conf = &getLetsencryptConfig();
    if (!$le_conf->{email}) {
        my $msg = "Letsencrypt email is not configured.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $error_ref = &runLetsencryptRenew($le_cert_name, $json_obj->{farmname}, $json_obj->{vip}, $json_obj->{force_renewal},
        $json_obj->{test});
    if ($error_ref->{code}) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_ref->{desc} });
    }

    &log_info("Success, the Letsencrypt certificate has been renewed successfully.", "letsencrypt");

    my @farms_restarted;
    my @farms_restarted_error;
    if (    (defined $json_obj->{restart})
        and ($json_obj->{restart} eq "true"))
    {
        my $cert_name = $le_cert_name;
        $cert_name =~ s/\./\_/g;
        $cert_name .= ".pem";

        my $error;
        require Relianoid::Farm::Action;
        require Relianoid::Farm::Base;
        for my $farm (@{ getCertFarmsUsed($cert_name) }) {
            # restart farm used and up
            if (&getFarmStatus($farm) ne 'down') {
                $error = &runFarmStop($farm, "");
                if ($error) {
                    push @farms_restarted_error, $farm;
                    next;
                }
                $error = &runFarmStart($farm, "");
                if ($error) {
                    push @farms_restarted_error, $farm;
                    next;
                }
                push @farms_restarted, $farm;
            }
        }

        # restart on backup node
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'farm', 'restart_farms', @farms_restarted ],
            ) if @farms_restarted;
        }
    }

    my $info_msg;
    if (@farms_restarted) {
        $info_msg = "The following farms were been restarted: " . join(", ", @farms_restarted);
    }
    if (@farms_restarted_error) {
        $info_msg = "The following farms could not been restarted: " . join(", ", @farms_restarted_error);
    }

    my $msg  = "The Let's Encrypt certificate $le_cert_name has been renewed successfully.";
    my $out  = &getLetsencryptCertificateInfo($le_cert_name);
    my $body = {
        description => $desc,
        params      => $out,
        message     => $msg
    };
    $body->{warning} = $info_msg if defined $info_msg;
    return &httpResponse({ code => 200, body => $body });
}

# PUT /certificates/letsencrypt/le_cert_re
sub set_le_cert_controller ($json_obj, $le_cert_name) {
    my $desc = "Modify Let's Encrypt certificate";

    require Relianoid::Certificate;
    require Relianoid::Letsencrypt;

    # check the certificate is a LE cert
    my $le_cert = &getLetsencryptCertificates($le_cert_name);
    if (!@{$le_cert}) {
        my $msg = "Let's Encrypt certificate $le_cert_name not found!";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("letsencrypt-modify.json");

    # dyn_values model
    if (defined $json_obj->{vip}) {
        require Relianoid::Net::Interface;
        my $ip_list = &getIpAddressList();
        $params->{vip}{values} = $ip_list;
    }
    if (defined $json_obj->{farmname}) {
        require Relianoid::Farm::Core;
        my @farm_list = &getFarmsByType("http");
        $params->{farmname}{values} = \@farm_list;
    }

    # depends_on model
    if (defined $json_obj->{farmname}) {
        delete $params->{vip} if defined $json_obj->{vip};
    }

    if (    (defined $json_obj->{autorenewal})
        and ($json_obj->{autorenewal} eq "false"))
    {
        delete $params->{force_renewal} if defined $params->{force_renewal};
        delete $params->{restart}       if defined $params->{restart};
        delete $params->{vip}           if defined $params->{vip};
        delete $params->{farmname}      if defined $params->{farmname};
    }

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # depends_on model
    # vip or farmname has to be defined
    if (    not $json_obj->{vip}
        and not $json_obj->{farmname}
        and $json_obj->{autorenewal} eq "true")
    {
        my $msg = "No 'vip' or 'farmname' param found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # check farm has to be listening on port 80 and up
    if (defined $json_obj->{farmname}) {
        require Relianoid::Farm::Base;
        if (&getFarmVip('vipp', $json_obj->{farmname}) ne 80) {
            my $msg = "Farm $json_obj->{farmname} must be listening on Port 80.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        require Relianoid::Farm::HTTP::Config;
        if (&getHTTPFarmStatus($json_obj->{farmname}) ne "up") {
            my $msg = "Farm $json_obj->{farmname} must be up.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }

    # check any farm listening on vip and port 80 and up
    my $le_farm_port = 80;
    if (defined $json_obj->{vip}) {
        require Relianoid::Net::Validate;
        if (&validatePort($json_obj->{vip}, $le_farm_port, "tcp") == 0) {
            #vip:port is in use
            require Relianoid::Farm::Base;
            require Relianoid::Farm::HTTP::Config;

            for my $farm (&getFarmListByVip($json_obj->{vip})) {
                if (    &getHTTPFarmVip("vipp", $farm) eq "$le_farm_port"
                    and &getHTTPFarmStatus($farm) eq "up")
                {
                    my $msg = "Farm $farm is listening on 'vip' $json_obj->{vip} and Port $le_farm_port.";
                    return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
                }
            }
            my $msg = "The system has a process listening on 'vip' $json_obj->{vip} and Port $le_farm_port.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }

    # check Email config
    my $le_conf = &getLetsencryptConfig();
    if (!$le_conf->{email}) {
        my $msg = "Letsencrypt email is not configured.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $msg;
    if ($json_obj->{autorenewal} eq "true") {
        my $error = &setLetsencryptCron($le_cert_name, $json_obj->{farmname}, $json_obj->{vip}, $json_obj->{force_renewal},
            $json_obj->{restart});

        if ($error) {
            my $msg = "The Auto Renewal for Let's Encrypt certificate $le_cert_name can't be enabled";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        &log_info("Success, the Auto Renewal for Letsencrypt certificate has been enabled successfully.", "letsencrypt");
        $msg = "The Auto Renewal for Let's Encrypt certificate $le_cert_name has been enabled successfully.";
    }
    else {
        my $error = &unsetLetsencryptCron($le_cert_name);
        if ($error) {
            my $msg = "The Auto Renewal for Let's Encrypt certificate $le_cert_name can't be disabled";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
        &log_info("Success, the Auto Renewal for Letsencrypt certificate has been disabled successfully.",
            "letsencrypt");
        $msg = "The Auto Renewal for Let's Encrypt certificate $le_cert_name has been disabled successfully.";
    }

    my $out  = &getLetsencryptCertificateInfo($le_cert_name);
    my $body = {
        description => $desc,
        params      => $out,
        message     => $msg,
    };
    return &httpResponse({ code => 200, body => $body });
}

# GET /certificates/letsencrypt/config
sub get_le_conf_controller () {
    my $desc = "Get LetsEncrypt Config";

    require Relianoid::Letsencrypt;
    my $out  = &getLetsencryptConfig();
    my $body = {
        description => $desc,
        params      => $out,
    };
    return &httpResponse({ code => 200, body => $body });
}

# PUT /certificates/letsencrypt/config
sub set_le_conf_controller ($json_obj) {
    my $desc   = "Modify LetsEncrypt Config";
    my $params = &getAPIModel("letsencrypt_config-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    require Relianoid::Letsencrypt;
    my $error = &setLetsencryptConfig($json_obj);
    if ($error) {
        my $msg = "The Letsencrypt Config can't be updated";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    my $msg  = "The Letsencrypt Config has been updated successfully.";
    my $out  = &getLetsencryptConfig();
    my $body = {
        description => $desc,
        success     => "true",
        message     => $msg,
        params      => $out,
    };
    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Session.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Session

=cut

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::CGI;
use Relianoid::HTTP;
use Relianoid::HTTP::Auth;

use CGI::Session;

my $LOG_TAG = "";
$LOG_TAG = "API"    if get_http_api_key();
$LOG_TAG = "WEBGUI" if (exists $ENV{HTTP_COOKIE});

=pod

=head1 session_login_controller

C<POST /session>

Authentication via HTTP basic access authentication, using the HTTP header

C<Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==>

B<Arguments>: 

IMPORTANT:

- Relianoid::HTTP::POST() has an exception to not include arguments when 
C<POST /session> is called, because the web GUI is sending a non-empty body.

- This call should have no body, so also no content type.

=cut

sub session_login_controller () {
    my $desc    = "Login to new session";
    my $session = CGI::Session->new(&getCGI());

    unless ($session && !$session->param('is_logged_in')) {
        my $msg = "Already logged in a session";
        return &httpErrorResponse({ code => 401, desc => $desc, msg => $msg });
    }

    # not validated credentials
    my ($username, $password) = &getAuthorizationCredentials();

    unless (&authenticateCredentials($username, $password)) {
        $session->delete();
        $session->flush();

        my $msg = "The username and/or password are incorrect";
        return &httpErrorResponse({ code => 401, desc => $desc, msg => $msg });
    }

    # check if the user has got permissions
    my (undef, undef, undef, $webgui_group) = getgrnam('webgui');
    if (!grep { /(^| )$username( |$)/ } $webgui_group) {
        my $msg = "The user $username has not web permissions";
        return &httpErrorResponse({ code => 401, desc => $desc, msg => $msg });
    }

    require Relianoid::SystemInfo;

    $session->param('is_logged_in', 1);
    $session->param('username',     $username);
    my $session_timeout = &getGlobalConfiguration('session_timeout') // 30;
    $session->expire('is_logged_in', '+' . $session_timeout . 'm');

    my ($header) = split("\r\n", $session->header());
    my (undef, $session_cookie) = split(': ', $header);

    my $body = {
        host    => &getHostname(),
        user    => $username,
        version => &getGlobalConfiguration("version"),
    };

    if (my $eload = eval { require Relianoid::ELoad }) {
        $body->{key} = eload(module => 'Relianoid::EE::Certificate::Activation', func => 'getNodeKey');
    }

    &log_info("Login successful for user: $username", $LOG_TAG);

    return &httpResponse({
        code    => 200,
        body    => $body,
        headers => { 'Set-cookie' => "${session_cookie}; SameSite=None; Secure; HttpOnly" },
    });
}

# DELETE /session
sub session_logout_controller () {
    my $desc = "Logout of session";
    my $cgi  = &getCGI();

    unless ($cgi->http('Cookie')) {
        my $msg = "Session cookie not found";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $session = CGI::Session->new($cgi);

    unless ($session && $session->param('is_logged_in')) {
        my $msg = "Session expired or not found";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $username = $session->param('username');
    my $ip_addr  = $session->param('_SESSION_REMOTE_ADDR');

    &log_info("Logged out user $username from $ip_addr", $LOG_TAG);

    $session->delete();
    $session->flush();

    return &httpResponse({ code => 200 });
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/Stats.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::System;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Stats

=cut

my $eload = eval { require Relianoid::ELoad };

# Get all farm stats
sub _get_all_farm_stats_controller () {
    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    my @files = &getFarmList();
    my @farms;

    for my $file (@files) {
        my $name = &getFarmName($file);
        my $type = &getFarmType($name);

        if ($type eq 'eproxy' && $eload) {
            my $farm_stats = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Stats',
                func   => 'getEproxyFarmStats',
                args   => [ { 'farm_name' => $name } ],
            );
            push(@farms, $farm_stats);
        }
        else {
            my $status      = &getFarmVipStatus($name);
            my $vip         = &getFarmVip('vip',  $name);
            my $port        = &getFarmVip('vipp', $name);
            my $established = 0;
            my $pending     = 0;

            # datalink has no stats
            if ($type eq 'datalink') {
                $established = undef;
                $pending     = undef;
            }
            elsif ($status ne "down") {
                require Relianoid::Net::ConnStats;
                require Relianoid::Farm::Stats;

                my $netstat;
                $netstat = &getConntrack('', $vip, '', '', '')
                if $type !~ /^https?$/;

                $pending     = &getFarmSYNConns($name, $netstat);
                $established = &getFarmEstConns($name, $netstat);
            }

            push @farms,
            {
                farmname    => $name,
                profile     => $type,
                status      => $status,
                vip         => $vip,
                vport       => $port,
                established => $established,
                pending     => $pending,
            };
        }
    }

    if ($eload) {
        @farms = @{
            &eload(
                module => 'Relianoid::EE::RBAC::Group::Core',
                func   => 'getRBACUserSet',
                args   => [ 'farms', \@farms ],
            )
        };
    }

    return \@farms;
}

#Get Farm Stats
sub get_farm_stats_controller ($farmname, $servicename = undef) {
    if ($farmname eq 'modules') { return; }
    if ($farmname eq 'total')   { return; }

    require Relianoid::Farm::Core;

    my $desc = "Get farm stats";

    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);

    if (defined $servicename
        && ($type ne 'http' && $type ne 'https' && $type ne 'gslb'))
    {
        my $msg = "The $type farm profile does not support services.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($type eq "http" || $type eq "https") {
        require Relianoid::Farm::HTTP::Stats;

        if (defined $servicename) {
            # validate SERVICE
            require Relianoid::Farm::Service;
            my @services      = &getFarmServices($farmname);
            my $found_service = grep { $servicename eq $_ } @services;

            if (not $found_service) {
                my $msg = "The service $servicename does not exist for $farmname.";
                return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
            }
        }

        my $stats = &getHTTPFarmBackendsStats($farmname, $servicename);

        my $body;
        if ($stats eq -1) {
            $body = {
                warning        => "It was not possible to extract the sessions.",
                description    => $desc,
                backends       => [],
                sessions       => [],
                total_sessions => 0,
            };
        }
        else {
            $body = {
                description    => $desc,
                backends       => $stats->{backends},
                sessions       => $stats->{sessions},
                total_sessions => $#{ $stats->{sessions} } + 1,
            };
        }
        return &httpResponse({ code => 200, body => $body });
    }

    if ($type eq "l4xnat") {
        my $backends = [];
        my $sessions = [];

        require Relianoid::Farm::L4xNAT::Config;

        if (&getL4FarmStatus($farmname) ne "down") {
            require Relianoid::Farm::L4xNAT::Stats;
            $backends = &getL4FarmBackendsStats($farmname);

            require Relianoid::HTTP::Adapters::Backend;
            &getBackendsResponse($backends, $type, [ 'established', 'pending' ]);

            require Relianoid::Farm::L4xNAT::Sessions;
            $sessions = &listL4FarmSessions($farmname);
        }

        my $body = {
            description    => $desc,
            backends       => $backends,
            sessions       => $sessions,
            total_sessions => $#{$sessions} + 1,
        };

        return &httpResponse({ code => 200, body => $body });
    }

    if ($type eq "gslb" && $eload) {
        my $gslb_stats;

        my $gslbStatus = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Config',
            func   => 'getGSLBFarmStatus',
            args   => [$farmname],
        );
        if ($gslbStatus ne "down") {
            if (defined $servicename) {
                my @services = &eload(
                    module => 'Relianoid::EE::Farm::GSLB::Service',
                    func   => 'getGSLBFarmServices',
                    args   => [$farmname],
                );

                # check if the SERVICE exists
                unless (grep { $servicename eq $_ } @services) {
                    my $msg = "Could not find the requested service.";
                    return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
                }
            }
            $gslb_stats = &eload(
                module => 'Relianoid::EE::Farm::GSLB::Stats',
                func   => 'getGSLBFarmBackendsStats',
                args   => [ $farmname, $servicename ],
                decode => 'true'
            );
        }

        my $body = {
            description => $desc,
            backends    => $gslb_stats->{backends} // [],
            client      => $gslb_stats->{udp}      // [],
            server      => $gslb_stats->{tcp}      // [],
            extended    => $gslb_stats->{stats}    // [],
        };

        return &httpResponse({ code => 200, body => $body });
    }

    if ($type eq "eproxy" && $eload) {
        my $backend_stats = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Stats',
            func   => 'getEproxyFarmBackendsStats',
            args   => [{ farm_name => $farmname, service_name => $servicename}],
        );

        my $body = {
            description    => $desc,
            backends       => $backend_stats,
#            sessions       => $stats->{sessions},
#            total_sessions => $#{ $stats->{sessions} } + 1,
        };
        return &httpResponse({ code => 200, body => $body });
    }

}

#Get Farm Stats
sub list_farms_stats_controller () {
    my $farms = &_get_all_farm_stats_controller();

    my $body = {
        description => "List all farms stats",
        farms       => $farms,
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET /stats
sub get_stats_controller () {
    require Relianoid::Stats;
    require Relianoid::SystemInfo;

    my @data_mem  = &getMemStats();
    my @data_load = &getLoadStats();
    my @data_net  = &getNetworkStats();
    my @data_cpu  = &getCPU();

    my $out = {
        'hostname' => &getHostname(),
        'date'     => &getDate(),
    };

    for my $x (0 .. @data_mem - 1) {
        my $name  = $data_mem[$x][0];
        my $value = $data_mem[$x][1] + 0;
        $out->{memory}{$name} = $value;
    }

    for my $x (0 .. @data_load - 1) {
        my $name  = $data_load[$x][0];
        my $value = $data_load[$x][1] + 0;

        $name =~ s/ /_/;
        $name = 'Last_1' if $name eq 'Last';
        $out->{load}{$name} = $value;
    }

    for my $x (0 .. @data_cpu - 1) {
        my $name  = $data_cpu[$x][0];
        my $value = $data_cpu[$x][1] + 0;

        $name =~ s/CPU//;
        $out->{cpu}{$name} = $value;
    }

    $out->{cpu}{cores} = &getCpuCores();

    for my $x (0 .. @data_net - 1) {
        my $name;
        if ($x % 2 == 0) {
            $name = $data_net[$x][0] . ' in';
        }
        else {
            $name = $data_net[$x][0] . ' out';
        }
        my $value = $data_net[$x][1] + 0;
        $out->{network}{$name} = $value;
    }

    my $body = {
        description => "System stats",
        params      => $out
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET /stats/system/network
sub get_stats_network_controller () {
    require Relianoid::Stats;
    require Relianoid::SystemInfo;

    my @interfaces = &getNetworkStats('hash');
    my $output;
    $output->{hostname}   = &getHostname();
    $output->{date}       = &getDate();
    $output->{interfaces} = \@interfaces;

    my $body = {
        description => "Network interefaces usage",
        params      => $output
    };

    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/Backup.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Backup;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::Backup

=cut

# GET /system/backup
sub list_backups_controller () {
    my $desc    = "Get backups";
    my $backups = &getBackup();

    return &httpResponse({ code => 200, body => { description => $desc, params => $backups } });
}

# POST /system/backup
sub create_backup_controller ($json_obj) {
    my $desc = "Create a backups";

    my $params = &getAPIModel("system_backup-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    if (&getExistsBackup($json_obj->{name})) {
        my $msg = "A backup already exists with this name.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $error = &createBackup($json_obj->{name});
    if ($error) {
        my $msg = "Error creating backup.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $msg  = "Backup $json_obj->{ 'name' } was created successfully.";
    my $body = {
        description => $desc,
        params      => $json_obj->{name},
        message     => $msg,
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /system/backup/BACKUP
sub download_backup_controller ($backup) {
    my $desc = "Download a backup";

    if (!&getExistsBackup($backup)) {
        my $msg = "Not found $backup backup.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $backup_dir           = &getGlobalConfiguration('backupdir');
    my $backup_filename      = &getBackupFilename($backup);

    return &httpDownloadResponse(desc => $desc, dir => $backup_dir, file => $backup_filename);
}

# PUT /system/backup/BACKUP
sub upload_backup_controller ($upload_filehandle, $name) {
    my $desc = "Upload a backup";

    if (!$upload_filehandle || !$name) {
        my $msg = "It's necessary to add a data binary file.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    elsif (&getExistsBackup($name)) {
        my $msg = "A backup already exists with this name.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    elsif (!&getValidFormat('backup', $name)) {
        my $msg = "The backup name has invalid characters.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $error = &uploadBackup($name, $upload_filehandle);
    if ($error == 1) {
        my $msg = "Error creating backup.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    elsif ($error == 2) {
        my $msg = "$name is not a valid backup.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $msg  = "Backup $name was created successfully.";
    my $body = { description => $desc, params => $name, message => $msg };

    return &httpResponse({ code => 200, body => $body });
}

# DELETE /system/backup/BACKUP
sub delete_backup_controller ($backup) {
    my $desc = "Delete backup $backup'";

    if (!&getExistsBackup($backup)) {
        my $msg = "$backup doesn't exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $error = &deleteBackup($backup);

    if ($error) {
        my $msg = "There was a error deleting list $backup.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $msg  = "The list $backup has been deleted successfully.";
    my $body = {
        description => $desc,
        success     => "true",
        message     => $msg,
    };

    return &httpResponse({ code => 200, body => $body });
}

# POST /system/backup/BACKUP/actions
sub restore_backup_controller ($json_obj, $backup) {
    my $desc = "Restore a backup to the system";

    my $params = &getAPIModel("system_backup-restore.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    if (!&getExistsBackup($backup)) {
        my $msg = "Not found $backup backup.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $b_version   = &getBackupVersion($backup);
    my $sys_version = &getGlobalConfiguration('version');
    if ($b_version ne $sys_version) {
        if (not exists $json_obj->{force}
            or (exists $json_obj->{force} and $json_obj->{force} ne 'true'))
        {
            my $msg =
              "The backup version ($b_version) is different to the Relianoid version ($sys_version). The parameter 'force' must be used to force the restore.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
        else {
            &log_info("Restoring The backup version ($b_version) is different to the Relianoid version ($sys_version).");
        }
    }

    my $msg   = "The restore was properly applied. Some changes need a system reboot to work.";
    my $error = &restoreBackup($backup);

    if ($error) {
        $msg = "There was a error restoring the backup.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    return &httpResponse({ code => 200, body => { description => $desc, message => $msg } });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/Info.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::System;

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::Info

=cut

# show license
# GET /system/license/($license_re)
sub get_license_controller ($format) {
    my $desc = "Get license";
    my $licenseFile;

    if ($format eq 'txt') {
        $licenseFile = &getGlobalConfiguration('licenseFileTxt');
    }
    elsif ($format eq 'html') {
        $licenseFile = &getGlobalConfiguration('licenseFileHtml');
    }
    else {
        my $msg = "Not found license.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $file = &slurpFile($licenseFile);

    return &httpResponse({ code => 200, body => $file, type => 'text/plain' });
}

# GET /system/supportsave
sub get_supportsave_controller () {
    my $desc = "Get supportsave file";

    my $req_size = &checkSupportSaveSpace();
    if ($req_size) {
        my $space = &getSpaceFormatHuman($req_size);
        my $msg   = "Supportsave cannot be generated because '/tmp' needs '$space' Bytes of free space";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $ss_filename = &getSupportSave();

    return &httpDownloadResponse(desc => $desc, dir => '/tmp', file => $ss_filename);
}

# GET /system/version
sub get_version_controller () {
    require Relianoid::SystemInfo;

    my $desc = "Get version";

    my $params = {
        'kernel_version'    => &getKernelVersion(),
        'relianoid_version' => &getGlobalConfiguration('version'),
        'hostname'          => &getHostname(),
        'system_date'       => &getDate(),
        'appliance_version' => &getApplianceVersion(),
    };

    # For compatibility with previous versions
    $params->{zevenet_version} = $params->{relianoid_version};

    my $body = { description => $desc, params => $params };

    return &httpResponse({ code => 200, body => $body });
}

# GET /system/info
sub get_system_info_controller () {
    require Relianoid::SystemInfo;
    require Relianoid::User;
    require Relianoid::API;

    my $desc = "Get the system information";

    my @api_versions = &getApiVersionsList();

    my $params = {
        'system_date'             => &getDate(),
        'appliance_version'       => &getApplianceVersion(),
        'kernel_version'          => &getKernelVersion(),
        'relianoid_version'       => &getGlobalConfiguration('version'),
        'hostname'                => &getHostname(),
        'user'                    => &getUser(),
        'supported_zapi_versions' => \@api_versions,
        'supported_api_versions'  => \@api_versions,
        'last_zapi_version'       => $api_versions[-1],
        'last_api_version'        => $api_versions[-1],
        'edition'                 => $eload ? "enterprise" : "community",
        'language'                => &getGlobalConfiguration('lang'),
        'platform'                => &getGlobalConfiguration('cloud_provider'),
    };

    # For compatibility with previous versions
    $params->{zevenet_version} = $params->{relianoid_version};

    if ($eload) {
        $params = &eload(
            module => 'Relianoid::EE::System::Ext',
            func   => 'getSystemInfoExt',
            args   => [$params],
        );
    }

    my $body = { description => $desc, params => $params };
    return &httpResponse({ code => 200, body => $body });
}

# POST /system/language
sub set_language_controller ($json_obj) {
    my $desc   = "Modify the WebGUI language";
    my $params = &getAPIModel("system_language-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # Check allowed parameters
    &setGlobalConfiguration('lang', $json_obj->{language});

    return &httpResponse({
        code => 200,
        body => {
            description => $desc,
            params      => { language => &getGlobalConfiguration('lang') },
            message     => "The WebGui language has been configured successfully"
        }
    });
}

# GET /system/language
sub get_language_controller () {
    my $desc = "List the WebGUI language";
    my $lang = &getGlobalConfiguration('lang') || 'en';

    return &httpResponse({
        code => 200,
        body => {
            description => $desc,
            params      => { lang => $lang },
        }
    });
}

# GET /system/packages
sub get_packages_info_controller () {
    require Relianoid::System::Packages;

    my $desc   = "Relianoid packages list info";
    my $output = &getSystemPackagesUpdatesList();

    if (defined $output->{number}) {
        $output->{number} += 0;
    }

    return &httpResponse({ code => 200, body => { description => $desc, params => $output } });
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/Log.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::System::Log;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::Log

=cut

#	GET	/system/logs
sub list_logs_controller () {
    my $desc = "Get logs";
    my $logs = &getLogs();

    return &httpResponse({ code => 200, body => { description => $desc, params => $logs } });
}

#	GET	/system/logs/LOG
sub download_logs_controller ($logFile) {
    my $desc     = "Download log file '$logFile'";
    my $logfiles = &getLogs();
    my $error    = 1;

    # check if the file exists
    for my $file (@{$logfiles}) {
        if ($file->{file} eq $logFile) {
            $error = 0;
            last;
        }
    }

    if ($error) {
        my $msg = "Not found $logFile file.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Download function ends communication if itself finishes successful. It is not necessary send "200 OK" msg
    my $logdir = &getGlobalConfiguration('logdir');

    return &httpDownloadResponse(desc => $desc, dir => $logdir, file => $logFile);
}

#	GET	/system/logs/LOG/lines/LINES
sub show_logs_controller ($logFile, $lines_number) {
    my $desc     = "Show a log file";
    my $logfiles = &getLogs();
    my $error    = 1;

    # check if the file exists
    for my $file (@{$logfiles}) {
        if ($file->{file} eq $logFile) {
            $error = 0;
            last;
        }
    }

    if ($error) {
        my $msg = "Not found $logFile file.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $lines = &getLogLines($logFile, $lines_number);
    my $body  = { description => $desc, log => $lines };

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/Service/DNS.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::Service::DNS

=cut

# GET /system/dns
sub get_dns_controller () {
    require Relianoid::System::DNS;

    my $desc = "Get dns";
    my $dns  = &getDns();

    return &httpResponse({ code => 200, body => { description => $desc, params => $dns } });
}

#  POST /system/dns
sub set_dns_controller ($json_obj) {
    require Relianoid::System::DNS;

    my $desc = "Modify the DNS";

    my $params = &getAPIModel("system_dns-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    for my $key (keys %{$json_obj}) {
        my $msg = &setDns($key, $json_obj->{$key});
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg }) if $msg;
    }

    my $dns = &getDns();

    return &httpResponse({
        code => 200,
        body => {
            description => $desc,
            params      => $dns,
            message     => "The DNS service has been updated successfully."
        }
    });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/Service/NTP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::Service::NTP

=cut

# GET /system/ntp
sub get_ntp_controller () {
    my $desc = "Get ntp";
    my $ntp  = &getGlobalConfiguration('ntp');

    return &httpResponse({
        code => 200,
        body => { description => $desc, params => { "server" => $ntp } }
    });
}

#  POST /system/ntp
sub set_ntp_controller ($json_obj) {
    my $desc = "Post ntp";

    my $params = &getAPIModel("system_ntp-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my $error = &setGlobalConfiguration('ntp', $json_obj->{server});

    if ($error) {
        my $msg = "There was a error modifying ntp.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $ntp = &getGlobalConfiguration('ntp');
    return &httpResponse({
        code => 200,
        body => {
            description => $desc,
            params      => $ntp,
            message     => "The NTP service has been updated successfully."
        }
    });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/Service/Proxy.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::System::Proxy;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::Service::Proxy

=cut

# GET /system/proxy
sub get_proxy_controller () {
    my $desc = "Get proxy configuration";

    return &httpResponse({
        code => 200,
        body => { description => $desc, params => &getProxyResponse() }
    });
}

#  POST /system/proxy
sub set_proxy_controller ($json_obj) {
    my $desc   = "Configuring proxy";
    my $params = &getAPIModel("system_proxy-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    if (&setProxy($json_obj)) {
        my $msg = "There was a error modifying the proxy configuration.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Proxy needs to be updated in apt module
    require Relianoid::Apt;
    &setAPTProxy();

    return &httpResponse({
        code => 200,
        body => {
            description => $desc,
            params      => &getProxyResponse(),
            message     => "The Proxy service has been updated successfully."
        }
    });
}

sub getProxyResponse () {
    my $proxy = &getProxy();

    return {
        "http_proxy"  => $proxy->{http_proxy},
        "https_proxy" => $proxy->{https_proxy}
    };
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/Service/SNMP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::SNMP;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::Service::SNMP

=cut

# GET /system/snmp
sub get_snmp_controller () {
    my $desc = "Get snmp";
    my $snmp = &translateSNMPConfigToApi(&getSnmpdConfig());

    return &httpResponse({ code => 200, body => { description => $desc, params => $snmp } });
}

#  POST /system/snmp
sub set_snmp_controller ($json_obj) {
    my $desc = "Post snmp";

    require Relianoid::Net::Interface;
    my $ip_list = &getIpAddressList();
    push @{$ip_list}, '*';

    my $params = &getAPIModel("system_snmp-modify.json");
    $params->{ip}{values} = $ip_list;

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # check scope value
    if (defined $json_obj->{scope}) {
        my $network = NetAddr::IP->new($json_obj->{scope})->network();
        if ($network ne $json_obj->{scope}) {
            my $msg = "The value '$json_obj->{ 'scope' }' is not a valid network value for the parameter 'scope'.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my $snmp = &getSnmpdConfig();

    my $status = $json_obj->{status} // $snmp->{status};
    my $port   = $json_obj->{port}   // $snmp->{port};
    my $ip     = $json_obj->{ip}     // $snmp->{ip};

    if (($port ne $snmp->{port}) or ($ip ne $snmp->{ip})) {
        if ($status eq 'true' and not &validatePort($ip, $port, 'udp', undef, 'snmp')) {
            my $msg = "The '$ip' ip and '$port' port are in use.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    delete $json_obj->{status} if exists $json_obj->{status};
    for my $key (keys %{$json_obj}) {
        $snmp->{$key} = $json_obj->{$key};
    }

    my $error = &setSnmpdConfig($snmp);
    &translateSNMPConfigToApi($snmp);

    if ($error) {
        my $msg = "There was an error modifying SNMP.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($status eq 'true' && $snmp->{status} eq 'false') {
        &setSnmpdStatus('true');
    }
    elsif ($status eq 'false' && $snmp->{status} eq 'true') {
        &setSnmpdStatus('false');
    }
    elsif ($status ne 'false' && $snmp->{status} ne 'false') {
        &setSnmpdStatus('false');
        &setSnmpdStatus('true');
    }

    # wait to check pid values
    sleep(1);
    $snmp->{status} = &getSnmpdStatus();

    return &httpResponse({
        code => 200,
        body => {
            description => $desc,
            params      => $snmp,
            message     => "The SNMP service has been updated successfully."
        }
    });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/User.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

require Relianoid::User;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::User

=cut

my $eload = eval { require Relianoid::ELoad };

# 	GET /system/users
sub get_system_user_controller () {
    my $user = &getUser();

    my $desc = "Retrieve the user $user";

    if ('root' eq $user) {
        require Relianoid::API;

        my $api_status = &getAPI("status");
        my $params     = {
            user             => $user,
            api_permissions  => $api_status,
            zapi_permissions => $api_status,
            service          => 'local'

            # it is configured if the status is up
            # 'api_key'	=> &getAPI( "api_key" ),
        };

        return &httpResponse({
            code => 200,
            body => { description => $desc, params => $params }
        });
    }

    elsif ($eload) {
        my $params = &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::RBAC::User',
            func   => 'get_system_user_rbac',
        );

        if ($params) {
            return &httpResponse({
                code => 200,
                body => { description => $desc, params => $params }
            });
        }
    }

    my $msg = "The user is not found";
    return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
}

#  POST /system/users
sub set_system_user_controller ($json_obj) {
    require Relianoid::Login;

    my $error = 0;
    my $user  = &getUser();
    my $desc  = "Modify the user $user";

    my $params = &getAPIModel("system_user-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # check to change password
    if ($json_obj->{newpassword}) {
        if (not exists $json_obj->{password}) {
            my $msg = "The parameter password is required.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        elsif ($json_obj->{newpassword} eq $json_obj->{password}) {
            my $msg = "The new password must be different to the current password.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
        if ($eload) {
            my $local_user = &eload(
                module => 'Relianoid::EE::RBAC::User::Core',
                func   => 'getRBACUserLocal',
                args   => [$user],
            );
            if (!$local_user) {
                my $msg = "The $user User is not valid to change password.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        if (!&checkValidUser($user, $json_obj->{password})) {
            my $msg = "Invalid current password.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    if ($json_obj->{password}) {
        if (not exists $json_obj->{newpassword}) {
            my $msg = "The parameter newpassword is required.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    if ($user eq 'root') {
        # modify password
        if (exists $json_obj->{newpassword}) {
            $error = &changePassword($user, $json_obj->{newpassword}, $json_obj->{newpassword});

            if ($error) {
                my $msg = "Modifying $user.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        # modify api_key. change this parameter before than API permissions
        if (exists $json_obj->{api_key}) {
            if ($eload) {
                my $api_user = &eload(
                    module => 'Relianoid::EE::RBAC::User::Core',
                    func   => 'getRBACUserByAPIKey',
                    args   => [ $json_obj->{api_key} ],
                );

                if ($api_user and $api_user ne $user) {
                    my $msg = "The api_key is not valid.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
            &setAPI('key', $json_obj->{api_key});
        }

        # modify API permissions
        my $json_api_permissions = $json_obj->{api_permissions} // $json_obj->{zapi_permissions};

        if (defined $json_api_permissions) {
            if ($json_api_permissions eq 'true' && !&getAPI('api_key')) {
                my $msg = "It is necessary a api_key to enable the API permissions.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            if ($json_api_permissions eq 'true' && &getAPI("status") eq 'false') {
                &setAPI("enable");
            }
            elsif ($json_api_permissions eq 'false' && &getAPI("status") eq 'true') {
                &setAPI("disable");
            }
        }
    }

    elsif ($eload) {
        $error = &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::RBAC::User',
            func   => 'set_system_user_rbac',
            args   => [$json_obj],
        );
    }

    else {
        my $msg = "The user is not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $msg  = "Settings was changed successfully.";
    my $body = { description => $desc, message => $msg };

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Ids.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Log;
use Relianoid::Config;
use Config::Tiny;

my $eload = eval { require Relianoid::ELoad; };

# TODO
# ipds-rbl-domains
# waf-ruleset
# waf-files

# string to use when a branch of the id tree finishes
my $FIN = undef;

=pod

=head1 Module

Relianoid::Ids

=cut

=pod

=head1 getIdsTree

=cut

sub getIdsTree () {
    require Relianoid::Farm::Core;
    require Relianoid::FarmGuardian;
    require Relianoid::Net::Interface;
    require Relianoid::Certificate;
    require Relianoid::Backup;
    require Relianoid::System::Log;

    my $l4_default_srv_tag = "default_service";

    my $tree = $FIN;
    $tree->{farms} = $FIN;

    for my $type ('https', 'http', 'l4xnat', 'gslb', 'datalink') {
        my @farms = &getFarmsByType($type);

        # add farm
        for my $f (@farms) {
            require Relianoid::Farm::Service;
            $tree->{farms}{$f}{services} = $FIN;

            # add srv
            my @srv = ($type =~ /http|gslb/) ? &getFarmServices($f) : ($l4_default_srv_tag);

            for my $s (@srv) {
                require Relianoid::Farm::Backend;

                $tree->{farms}{$f}{services}{$s}{backends} = $FIN;

                # add bk
                my $bks = &getFarmServerIds($f, $s);

                for my $b (@{$bks}) {
                    $tree->{farms}{$f}{services}{$s}{backends}{$b} = $FIN;
                }

                my $fg = &getFGFarm($f, ($type =~ /datalink|l4xnat/) ? undef : $s);

                $tree->{farms}{$f}{services}{$s}{fg}{$fg} = $FIN if ($fg ne '');
            }

            # add certificates
            if ($type =~ /http/) {
                my @cnames;
                if ($eload) {
                    @cnames = &eload(module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext', func => 'getFarmCertificatesSNI', args => [$f],);
                }
                else {
                    require Relianoid::Farm::HTTP::HTTPS;
                    @cnames = (&getFarmCertificate($f));
                }
                $tree->{farms}{$f}{certificates} = &addIdsArrays(\@cnames);
            }

            if ($eload) {
                # add zones
                if ($type eq 'gslb') {
                    my @zones = &eload(module => 'Relianoid::EE::Farm::GSLB::Zone', func => 'getGSLBFarmZones', args => [$f],);
                    $tree->{farms}{$f}{zones} = &addIdsArrays(\@zones);
                }

                # add bl
                my @bl = &eload(module => 'Relianoid::EE::IPDS::Blacklist::Core', func => 'listBLByFarm', args => [$f],);

                $tree->{farms}{$f}{ipds}{blacklists} = &addIdsArrays(\@bl);

                # add dos
                my @dos = &eload(module => 'Relianoid::EE::IPDS::DoS::Core', func => 'listDOSByFarm', args => [$f],);
                $tree->{farms}{$f}{ipds}{dos} = &addIdsArrays(\@dos);

                # add rbl
                my @rbl = &eload(module => 'Relianoid::EE::IPDS::RBL::Core', func => 'listRBLByFarm', args => [$f],);
                $tree->{farms}{$f}{ipds}{rbl} = &addIdsArrays(\@rbl);

                #add waf
                if ($type =~ /http/) {
                    my @waf = &eload(module => 'Relianoid::EE::IPDS::WAF::Core', func => 'listWAFByFarm', args => [$f],);
                    $tree->{farms}{$f}{ipds}{waf} = &addIdsArrays(\@waf);
                }
            }
        }
    }

    # add fg
    my @fg = &getFGList();
    $tree->{farmguardians} = &addIdsArrays(\@fg);

    # add ssl certs
    my @certs = &getCertFiles();
    $tree->{certificates} = &addIdsArrays(\@certs);

    # add interfaces
    my @if_list = ('nic', 'vlan', 'virtual');
    push @if_list, 'bond' if ($eload);

    for my $type (@if_list) {
        my $if_key = ($type eq 'bond') ? 'bonding' : $type;
        $tree->{interfaces}{$if_key} = $FIN;

        my @list = &getInterfaceTypeList($type);

        for my $if (@list) {
            $tree->{interfaces}{$if_key}{ $if->{name} } = $FIN;
        }
    }

    # add routing
    require Relianoid::Net::Route;
    my @routing_table = listRoutingTablesNames();
    $tree->{routing}{tables} = &addIdsArrays(\@routing_table);

    if ($eload) {
        # add floating interfaces
        my $float = &eload(module => 'Relianoid::EE::Net::Floating', func => 'getFloatingList',);
        $tree->{interfaces}{floating} = &addIdsArrays($float);

        # add ipds rules
        $tree->{ipds} = &eload(module => 'Relianoid::EE::IPDS::Core', func => 'getIPDSIds',);

        # add rbac
        my @users  = &eload(module => 'Relianoid::EE::RBAC::User::Core',   func => 'getRBACUserList',);
        my @groups = &eload(module => 'Relianoid::EE::RBAC::Group::Core',  func => 'getRBACGroupList',);
        my @roles  = &eload(module => 'Relianoid::EE::RBAC::Role::Config', func => 'getRBACRolesList',);
        $tree->{rbac}{users}  = &addIdsArrays(\@users);
        $tree->{rbac}{roles}  = &addIdsArrays(\@roles);
        $tree->{rbac}{groups} = &addIdsArrays(\@groups);

        for my $g (@groups) {
            my $g_cfg = &eload(module => 'Relianoid::EE::RBAC::Group::Core', func => 'getRBACGroupObject', args => [$g]);

            $tree->{rbac}{groups}{$g}{users}      = &addIdsArrays($g_cfg->{users});
            $tree->{rbac}{groups}{$g}{farms}      = &addIdsArrays($g_cfg->{farms});
            $tree->{rbac}{groups}{$g}{interfaces} = &addIdsArrays($g_cfg->{interfaces});
        }

        # add aliases
        my $alias_bck_ref = &eload(module => 'Relianoid::EE::Alias', func => 'getAlias', args => ['backend'],);
        my $alias_if_ref  = &eload(module => 'Relianoid::EE::Alias', func => 'getAlias', args => ['interface'],);
        $tree->{aliases}{backends}   = &addIdsKeys($alias_bck_ref);
        $tree->{aliases}{interfaces} = &addIdsKeys($alias_if_ref);
    }

    # add backups
    my $backups = &getBackup();
    for my $b (@{$backups}) {
        $tree->{system}{backup}{ $b->{name} } = $FIN;
    }

    # add logs
    my $logs = &getLogs();
    $tree->{system}{logs} = $FIN;
    for my $l (@{$logs}) {
        $tree->{system}{logs}{ $l->{file} } = $FIN;
    }

    return $tree;
}

=pod

=head1 addIdsKeys

=cut

sub addIdsKeys ($hash_ref) {
    my @arr_keys = keys %{$hash_ref};
    return &addIdsArrays(\@arr_keys);
}

=pod

=head1 addIdsArrays

=cut

sub addIdsArrays ($arr) {
    my $out = {};

    for my $it (@{$arr}) {
        $out->{$it} = $FIN;
    }

    return (!keys %{$out}) ? undef : $out;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/JSON.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use JSON;
use Relianoid::Lock;

my $json = JSON->new->utf8->pretty(1);

# canonical: if true or missing => sort keys
$json->canonical([1]);

=pod

=head1 Module

Relianoid::JSON

=cut

=pod

=head1 decodeJSONFile

=cut

sub decodeJSONFile ($file) {
    my $file_str;
    my $fh = &openlock($file, 'r');
    return if !defined $fh;

    {
        local $/ = undef;
        $file_str = <$fh>;
    }
    close $fh;

    my $f_json;

    eval { $f_json = $json->decode($file_str); };
    if ($@) {
        &log_error("Error decoding the file $file");
        &log_debug("json: $@");
    }

    return $f_json;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Letsencrypt.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Letsencrypt

=cut

=pod

=head1 getLetsencryptConfigPath

Returns the dirpath for Letsencrypt Config

Parameters:

    none

Returns:

    string -  dir path.

=cut

sub getLetsencryptConfigPath () {
    return &getGlobalConfiguration('le_config_path');
}

=pod

=head1 getLetsencryptConfig

Returns the Letsencrypt Config

Parameters:

    none

Returns:

    Hash ref - Letsencrypt Configuration

=cut

sub getLetsencryptConfig () {
    return { email => &getGlobalConfiguration('le_email') };
}

=pod

=head1 setLetsencryptConfig

Set the Letsencrypt Config

Parameters:

    Hash ref

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub setLetsencryptConfig ($le_conf_re) {
    return &setGlobalConfiguration('le_email', $le_conf_re->{email});
}

=pod

=head1 getLetsencryptCronFile

Returns the Letsencrypt Cron Filepath

Parameters:

    none

Returns:

    string - Letsencrypt Cron filepath

=cut

sub getLetsencryptCronFile () {
    return &getGlobalConfiguration('le_cron_file');
}

=pod

=head1 getLetsencryptCertificates

Returns Letsencrypt Certificates

Parameters:

    le_cert_name - String. LE Certificate Name. None means all certificates.

Returns:

    Hash ref - Letsencrypt Certificates

=cut

sub getLetsencryptCertificates ($le_cert_name = undef) {
    my $le_certs_ref = [];

    my $le_config_path = &getLetsencryptConfigPath();
    my $le_live_path   = $le_config_path . "live";

    my $certs;
    if (defined $le_cert_name) {
        push @{$certs}, "$le_cert_name";
    }
    else {
        opendir(my $directory, "$le_live_path");
        while (defined(my $file = readdir $directory)) {
            next if $file eq ".";
            next if $file eq "..";
            push @{$certs}, $file if -d "$le_live_path/$file";
        }
        closedir($directory);
    }

    require Crypt::OpenSSL::X509;
    my $cert_ref;
    my $domains;

    for my $cert (@{$certs}) {
        # name
        $cert_ref->{name} = $cert;

        # key path
        my $key_path = $le_live_path . "/" . $cert . "/privkey.pem";
        $cert_ref->{keypath} = $key_path if (-l $key_path);

        # certificate path
        my $cert_path = $le_live_path . "/" . $cert . "/fullchain.pem";
        if (-l $cert_path) {
            $cert_ref->{certpath} = $cert_path;

            # domains
            eval {
                my $x509 = Crypt::OpenSSL::X509->new_from_file($cert_ref->{certpath});
                my $exts = $x509->extensions_by_name();
                if (defined $exts->{subjectAltName}) {
                    my $value = $exts->{subjectAltName}->to_string() . ", ";
                    @{$domains} = $value =~ /(?:DNS:(.*?), )/g;
                }
            };
            $cert_ref->{domains} = $domains;
        }

        push @{$le_certs_ref}, $cert_ref if defined $domains;
        $cert_ref = undef;
        $domains  = undef;
    }

    return $le_certs_ref;
}

=pod

=head1 getLetsencryptCertificateInfo

Returns the Letsencrypt no Wildcard Certificates Info

Parameters:

    le_cert_name . LE Certificate name

Returns:

    Hash ref - Letsencrypt Certificate Info

=cut

sub getLetsencryptCertificateInfo ($le_cert_name) {
    my $cert_ref  = {};
    my $cert_info = &getLetsencryptCertificates($le_cert_name);

    return if (!$cert_info);

    $cert_info = @{$cert_info}[0];

    require Crypt::OpenSSL::X509;

    my $status = "unknown";
    my $CN     = "";
    my $ISSUER = "";
    my $x509;
    my @domains;

    eval {
        $x509 = Crypt::OpenSSL::X509->new_from_file($cert_info->{certpath});
        my $time_offset = 60 * 60 * 24 * 15;    # 15 days
        if ($x509->checkend(0)) { $status = 'expired' }
        else {
            $status = ($x509->checkend($time_offset)) ? 'about to expire' : 'valid';
        }
        if (defined $x509->subject_name()->get_entry_by_type('CN')) {
            $CN = $x509->subject_name()->get_entry_by_type('CN')->value;
        }
        if (defined $x509->issuer_name()) {
            for my $entry (@{ $x509->issuer_name()->entries() }) {
                $ISSUER .= $entry->value() . ",";
            }
            chop $ISSUER;
        }
        my $exts = $x509->extensions_by_name();
        if (defined $exts->{subjectAltName}) {
            my $value = $exts->{subjectAltName}->to_string() . ", ";
            @domains = $value =~ /(?:DNS:(.*?), )/g;
        }
    };

    $cert_ref->{file}     = $cert_info->{certpath};
    $cert_ref->{type}     = 'LE Certificate';
    $cert_ref->{wildcard} = 'false';
    $cert_ref->{status}   = $status;

    if ($@) {
        $cert_ref->{CN}         = '';
        $cert_ref->{issuer}     = '';
        $cert_ref->{creation}   = '';
        $cert_ref->{expiration} = '';
        $cert_ref->{domains}    = '';
    }
    else {
        $cert_ref->{CN}         = $CN;
        $cert_ref->{issuer}     = $ISSUER;
        $cert_ref->{creation}   = $x509->notBefore();
        $cert_ref->{expiration} = $x509->notAfter();
        $cert_ref->{domains}    = \@domains;
    }

    my $autorenewal = &getLetsencryptCron($le_cert_name);
    $cert_ref->{autorenewal} = $autorenewal if $autorenewal;

    return $cert_ref;
}

=pod

=head1 setLetsencryptFarmService

Configure the Letsencrypt Service on a Farm

Parameters:

    farm_name - Farm Name.
    vip - Virtual IP to use with Temporal Farm.

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub setLetsencryptFarmService ($farm_name, $vip) {
    # if no exists farm return -1,
    my $le_service = &getGlobalConfiguration('le_service');
    my $le_farm    = &getGlobalConfiguration('le_farm');

    my $error;

    require Relianoid::Farm::Core;

    # create a temporal farm
    if ($farm_name eq $le_farm) {
        require Relianoid::Farm::HTTP::Factory;

        if ($error = &runHTTPFarmCreate($vip, 80, $farm_name, "HTTP")) {
            &log_error("Error creating temporal Farm $farm_name", "letsencrypt");
            return 1;
        }

        &log_info("The temporal Farm $farm_name has been created", "letsencrypt");
    }

    #create Letsencrypt service
    require Relianoid::Farm::HTTP::Service;

    # check Letsencrypt service
    my $service_ref = &getHTTPFarmServices($farm_name, $le_service);
    if (not $service_ref) {
        if ($eload) {
            $error = &setFarmHTTPNewService($farm_name, $le_service);
        }
        else {
            $error = &setFarmHTTPNewServiceFirst($farm_name, $le_service);
        }

        if ($error) {
            &log_error("Error creating the service $le_service", "letsencrypt");
            return 1;
        }

        &log_info("The Service $le_service in Farm $farm_name has been created", "letsencrypt");
    }
    else {
        &log_warn("The Service $le_service in Farm $farm_name already exists", "letsencrypt");
    }

    if ($eload) {
        #Move the service to position 0
        if (not $service_ref or $service_ref->{$le_service}) {
            $error = &eload(
                module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
                func   => 'setHTTPFarmMoveService',
                args   => [ $farm_name, $le_service, 0 ],
            );
            if ($error) {
                &log_error("Error moving the service $le_service", "letsencrypt");
                return 4;
            }
        }
        else {
            &log_warn("The Service $le_service in Farm $farm_name is already in the first position", "letsencrypt");
        }
    }

    # create local Web Server Backend
    require Relianoid::Farm::HTTP::Backend;
    $error = &setHTTPFarmServer("", "127.0.0.1", 80, "", "", $farm_name, $le_service);
    if ($error) {
        &log_error("Error creating the Local Web Server backend on service $le_service", "letsencrypt");
        return 2;
    }

    # create Letsencrypt URL Pattern http challenge
    $error = &setHTTPFarmVS($farm_name, $le_service, "urlp", "^/.well-known/acme-challenge/");
    if ($error) {
        &log_error("Error creating the URL pattern on service $le_service", "letsencrypt");
        return 3;
    }

    &log_info("The Service $le_service in Farm $farm_name has been configured", "letsencrypt");

    # Restart the farm
    require Relianoid::Farm::Action;

    if ($error = &runFarmStop($farm_name, "")) {
        &log_error("Error stopping the farm $farm_name", "letsencrypt");
        return 5;
    }

    $error = &runFarmStart($farm_name, "");
    if ($error) {
        &log_error("Error starting the farm $farm_name", "letsencrypt");
        return 6;
    }

    &log_info("The Farm $farm_name has been restarted", "letsencrypt");

    return 0;
}

=pod

=head1 unsetLetsencryptFarmService

Remove the Letsencrypt Service on a Farm

Parameters:

    farm_name - Farm Name.

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub unsetLetsencryptFarmService ($farm_name) {
    # if no exists farm return -1,
    my $le_service = &getGlobalConfiguration('le_service');
    my $le_farm    = &getGlobalConfiguration('le_farm');

    if ($farm_name eq $le_farm) {
        require Relianoid::Farm::Action;

        if (my $error = &runFarmStop($farm_name)) {
            &log_error("Error stopping the farm $farm_name", "letsencrypt");
            return 1;
        }

        if (my $error = &runFarmDelete($farm_name)) {
            &log_error("Error deleting the farm $farm_name", "letsencrypt");
            return 2;
        }

        &log_info("The Farm $farm_name has been deleted", "letsencrypt");
    }
    else {
        require Relianoid::Farm::HTTP::Service;

        if (&getHTTPFarmServices($farm_name, $le_service)) {
            if (my $error = &delHTTPFarmService($farm_name, $le_service)) {
                &log_error("Error Deleting the service $le_service on farm $farm_name", "letsencrypt");
                return 3;
            }
            &log_info("The service $le_service on farm $farm_name has been deleted", "letsencrypt");

            # Restart the farm
            require Relianoid::Farm::Action;

            if (my $error = &runFarmStop($farm_name, "")) {
                &log_error("Error stopping the farm $farm_name", "letsencrypt");
                return 1;
            }

            if (my $error = &runFarmStart($farm_name, "")) {
                &log_error("Error starting the farm $farm_name", "letsencrypt");
                return 4;
            }

            &log_info("The Farm $farm_name has been restarted", "letsencrypt");
        }
        else {
            &log_warn("The Service $le_service in Farm $farm_name can not be deleted, it does not exist", "letsencrypt");
        }
    }

    return 0;
}

=pod

=head1 runLetsencryptLocalWebserverStart

Start Local Webserver listening on localhost:80

Parameters:

    None

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub runLetsencryptLocalWebserverStart () {
    my $http_dir                 = &getGlobalConfiguration('http_server_dir');
    my $pid_file                 = "$http_dir/var/run/cherokee_localhost.pid";
    my $le_webserver_config_file = &getGlobalConfiguration('le_webserver_config_file');
    my $http_bin                 = &getGlobalConfiguration('http_bin');

    my $rc = 0;

    my $status = &getLetsencryptLocalWebserverRunning();

    if ($status == 1) {
        &log_info("$http_bin -d -C $le_webserver_config_file", "letsencrypt");
        &logAndRunBG("$http_bin -d -C $le_webserver_config_file");
    }

    use Time::HiRes qw(usleep);
    my $retry     = 0;
    my $max_retry = 50;
    while (not -f $pid_file and $retry < $max_retry) {
        $retry++;
        usleep(100_000);
    }
    if (not -f $pid_file) {
        &log_error("Error starting Local Web Server", "letsencrypt");
        $rc = 1;
    }
    else {
        &log_info("Letsencrypt Local Web Server is running", "letsencrypt");
    }

    return $rc;
}

=pod

=head1 runLetsencryptLocalWebserverStop

Stop Local Webserver listening on localhost:80

Parameters:

    None

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub runLetsencryptLocalWebserverStop () {
    my $http_dir = &getGlobalConfiguration('http_server_dir');
    my $pid_file = "$http_dir/var/run/cherokee_localhost.pid";
    my $pid      = "0";
    my $kill_bin = &getGlobalConfiguration('kill_bin');
    my $cat_bin  = &getGlobalConfiguration('cat_bin');

    my $status = &getLetsencryptLocalWebserverRunning();

    if ($status == 0) {
        $pid = &logAndGet("$cat_bin $pid_file");
        my $error = &logAndRun("$kill_bin -15 $pid");
        if ($error) {
            &log_error("Error stopping Letsencrypt Local Web Server", "letsencrypt");
            return 1;
        }
        use Time::HiRes qw(usleep);
        my $retry     = 0;
        my $max_retry = 20;
        while (-f $pid_file and $retry < $max_retry) {
            $retry++;
            usleep(100_000);
        }
        unlink $pid_file if (-f $pid_file);
        &log_info("Letsencrypt Local Web Server is stopped", "letsencrypt");
    }

    return 0;
}

=pod

=head1 getLetsencryptLocalWebserverRunning

Check Local Webserver is running

Parameters:

    None

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub getLetsencryptLocalWebserverRunning () {
    my $rc;
    my $http_dir = &getGlobalConfiguration('http_server_dir');
    my $pid_file = "$http_dir/var/run/cherokee_localhost.pid";

    if (-f $pid_file) {
        use Relianoid::System;

        if (&checkPidFileRunning($pid_file)) {
            &log_warn("Letsencrypt Local Webser is not running but PID file $pid_file exists!", "letsencrypt");
            unlink $pid_file;
        }
        $rc = 0;
    }
    else {
        my $pgrep                    = &getGlobalConfiguration('pgrep');
        my $http_bin                 = &getGlobalConfiguration('http_bin');
        my $le_webserver_config_file = &getGlobalConfiguration('le_webserver_config_file');

        if (&logAndRunCheck("$pgrep -f \"$http_bin -d -C $le_webserver_config_file\"")) {
            &log_warn("Letsencrypt Local Webserver is running but no PID file $pid_file exists!", "letsencrypt");
            $rc = 2;
        }
        else {
            $rc = 1;
        }
    }

    return $rc;
}

=pod

=head1 setLetsencryptCert

Create RELIANOID Pem Certificate. Dot characters are replaced with underscore character.

Parameters:

    le_cert_name - Certificate main domain name.

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub setLetsencryptCert ($le_cert_name) {
    my $rc = 1;

    my $le_cert_conf = &getLetsencryptCertificates($le_cert_name);
    if (@{$le_cert_conf}) {
        $le_cert_conf = @{$le_cert_conf}[0];
        if (    (defined $le_cert_conf->{certpath})
            and (defined $le_cert_conf->{keypath}))
        {
            if (    (-e $le_cert_conf->{keypath})
                and (-e $le_cert_conf->{certpath}))
            {
                my $cert_name = $le_cert_name;
                $cert_name =~ s/\./_/g;
                my $cat_bin   = &getGlobalConfiguration('cat_bin');
                my $cert_dir  = &getGlobalConfiguration('certdir');
                my $cert_file = "$cert_dir/${cert_name}.pem";
                &logAndRun("$cat_bin $le_cert_conf->{keypath} $le_cert_conf->{certpath} > $cert_file");
                return 1 if (!-f $cert_file);
                $rc = 0;
            }
        }
    }

    return $rc;
}

=pod

=head1 runLetsencryptObtain

Obtain a new LetsEncrypt Certificate for the Domains especified.

Parameters:

    farm_name - Farm Name where Letsencrypt will connect.
    vip - VIP where the new Farm and service is created. The virtual Port will be 80.
    domains_list - List of Domains the certificate is created for.
    test - if "true" the action simulates all the process but no certificate is created.
    force - if "true" forces an update cert and renewal the domains if exists.

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub runLetsencryptObtain ($farm_name = undef, $vip = undef, $domains_list = undef, $test = undef, $force = undef) {
    return 1 if (!$domains_list);
    return 2 if (!$vip && !$farm_name);
    my $status;
    my $rc = 0;

    my $le_farm = &getGlobalConfiguration('le_farm');
    $farm_name = $le_farm if (!$farm_name);

    # check is a wildcard
    my $challenge = "http";

    # start local Web Server
    $status = &runLetsencryptLocalWebserverStart();

    return 1 if $status;

    # add le service
    $status = &setLetsencryptFarmService($farm_name, $vip);
    return 2 if $status;

    # run le_binary command
    my $test_opt      = ($test eq "true")  ? "--test-cert"                      : "";
    my $force_opt     = ($force eq "true") ? "--force-renewal --break-my-certs" : "";
    my $certname_opt  = "--cert-name " . @{$domains_list}[0];
    my $domains_opt   = "-d " . join(',', @{$domains_list});
    my $fullchain_opt = "--fullchain-path " . &getGlobalConfiguration('le_fullchain_path');
    my $method_opt;

    if ($challenge eq "http") {
        $method_opt = "--webroot --webroot-path " . &getGlobalConfiguration('le_webroot_path');
    }
    my $configdir_opt = "--config-dir " . &getLetsencryptConfigPath();
    my $email_opt     = "-m " . &getLetsencryptConfig()->{email};
    my $challenge_opt = "--preferred-challenges $challenge";
    my $opts          = "--agree-tos --no-eff-email -n";

    my $le_binary    = &getGlobalConfiguration('le_certbot_bin');
    my @command_args = (
        $le_binary,     "certonly", $certname_opt, $domains_opt,   $fullchain_opt, $method_opt,
        $configdir_opt, $email_opt, $test_opt,     $challenge_opt, $force_opt,     $opts
    );

    my $cmd = join " ", @command_args;

    &log_info("Executing Letsencrypt obtain command : $cmd", "letsencrypt");

    $status = &logRunAndGet($cmd, "array", 1);

    if ($status->{stderr} and ($challenge eq "http")) {
        &log_error("Letsencrypt obtain command failed!: $status->{stdout}[-1]", "letsencrypt");
        $rc = 3;
    }
    else {
        # create RELIANOID PEM cert
        $status = &setLetsencryptCert(@{$domains_list}[0]);

        if ($status) {
            &log_error("Letsencrypt create PEM cert failed!", "letsencrypt");
            $rc = 4;
        }
    }

    # delete le service
    &unsetLetsencryptFarmService($farm_name);

    # stop local Web Server
    &runLetsencryptLocalWebserverStop();

    return $rc;
}

=pod

=head1 runLetsencryptDestroy

Revoke a LetsEncrypt Certificate.

Parameters:

    le_cert_name - LE Certificate name.

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub runLetsencryptDestroy ($le_cert_name) {
    my $le_config_path = &getLetsencryptConfigPath();
    my $local_path     = &getGlobalConfiguration('localconfig');
    my $le_backup_file = "$local_path/le_backup-$le_cert_name.tgz";
    my $rm_bck_cmd     = "rm -f $le_backup_file";

    return 1 if (!$le_cert_name);
    return 2 if (!-d "$le_config_path/live/$le_cert_name");

    if (-f "$le_backup_file") {
        &logAndRun($rm_bck_cmd);
    }

    my $le_binary = &getGlobalConfiguration('le_certbot_bin');

    # run le_binary revoke command ??
    # revoke --cert-path /PATH/TO/live/$cert_name/cert.pem --key-path /PATH/TO/live/$cert_name/privkey.pem

    # run le_binary delete command
    # delete --cert-name $cert_name --config-dir $le_config_path --reason unspecified

    my $certname_opt  = "--cert-name " . $le_cert_name;
    my $configdir_opt = "--config-dir " . &getLetsencryptConfigPath();
    my $opts          = "--reason unspecified";

    my $cmd = "$le_binary delete $certname_opt $configdir_opt $opts";
    &log_info("Executing Letsencrypt obtain command : $cmd", "letsencrypt");

    my $status = &logRunAndGet($cmd, "array");
    if ($status->{stderr}) {
        &log_error("Letsencrypt delete command failed!", "letsencrypt");
        return 3;
    }
    return 3 if (-d "$le_config_path/live/$le_cert_name");

    return 0;
}

=pod

=head1 runLetsencryptRenew

Renew a LetsEncrypt Certificate.

Parameters:

    le_cert_name  - LetsEncrypt Certificate Name
    farm_name     - Farm Name where Letsencrypt will connect.
    vip           - VIP where the new Farm and service is created. The virtual Port will be 80.
    force         - if "true" forces a renew even the cert not yet due for renewal( over 30 days for expire ).
    lock_fh       - FileHandle to lock the process

Returns: hash reference

Error object.

    code - integer - Error code. 0 on success.
    desc - string - Description of the error.

=cut

sub runLetsencryptRenew ($le_cert_name, $farm_name, $vip, $force, $lock_fh) {
    my $status;
    my $error_ref = { code => 0 };

    if (!$le_cert_name) {
        $error_ref->{code} = 1;
        $error_ref->{desc} = "No 'certificate' param found";
        return $error_ref;
    }

    if (!$vip && !$farm_name) {
        $error_ref->{code} = 1;
        $error_ref->{desc} = "No 'farm' param or 'vip' param found";
        return $error_ref;
    }

    my $le_farm = &getGlobalConfiguration('le_farm');
    $farm_name = $le_farm if (!$farm_name);

    # Lock process
    my $lock_le_renew_fh;
    if (not $lock_fh) {
        my $lock_le_renew = "/tmp/letsencrypt-renew.lock";
        if (not -f $lock_le_renew) {
            my $touch = &getGlobalConfiguration('touch');
            &logAndRun("$touch $lock_le_renew");
        }
        $lock_le_renew_fh = &openlock($lock_le_renew, "w");
    }
    else {
        $lock_le_renew_fh = $lock_fh;
    }

    # start local Web Server
    $status = &runLetsencryptLocalWebserverStart();

    if ($status) {
        $error_ref->{code} = 1;
        $error_ref->{desc} = "Letsencrypt Local Webserver can not be created.";
        close $lock_le_renew_fh;
        return $error_ref;
    }

    # add le service
    $status = &setLetsencryptFarmService($farm_name, $vip);
    if ($status) {
        $error_ref->{code} = 2;
        $error_ref->{desc} = "Letsencrypt Service can not be created.";
        close $lock_le_renew_fh;
        return $error_ref;
    }

    # run le_binary command
    my $test_opt  = &isLetsencryptStaging($le_cert_name) ? "--test-cert"                      : "";
    my $force_opt = ($force eq "true")                   ? "--force-renewal --break-my-certs" : "";

    my $fullchain_opt = "--fullchain-path " . &getGlobalConfiguration('le_fullchain_path');
    my $webroot_opt   = "--webroot --webroot-path " . &getGlobalConfiguration('le_webroot_path');
    my $configdir_opt = "--config-dir " . &getLetsencryptConfigPath();
    my $email_opt     = "-m " . &getLetsencryptConfig()->{email};
    my $opts          = "--preferred-challenges http-01 --agree-tos --no-eff-email -n --no-random-sleep-on-renew";

    my $le_binary = &getGlobalConfiguration('le_certbot_bin');
    my $cmd =
      "$le_binary certonly -d $le_cert_name $fullchain_opt $webroot_opt $configdir_opt $email_opt $test_opt $force_opt $opts";

    &log_info("Executing Letsencrypt renew command : $cmd", "letsencrypt");
    $status = &logRunAndGet($cmd, "array");

    alarm(0);

    if ($status->{stderr}) {
        my $error_response = "Error creating new order";

        if (my ($le_msg) = grep { /$error_response/ } @{ $status->{stdout} }) {
            &log_error("$le_msg", "letsencrypt");
            $error_ref->{code} = 6;
            $error_ref->{desc} = $le_msg;
        }
        else {
            my $le_msg = "Letsencrypt renew command failed!";
            &log_error($le_msg, "letsencrypt");
            $error_ref->{code} = 3;
            $error_ref->{desc} = $le_msg;
        }
    }
    else {
        # check is not due to renewal response
        my $renewal_response = "Cert not yet due for renewal";

        if (grep { /$renewal_response/ } @{ $status->{stdout} }) {
            my $le_msg = "Letsencrypt certificate '$le_cert_name' not yet due for renewal!";
            &log_error($le_msg, "letsencrypt");
            $error_ref->{code} = 5;
            $error_ref->{desc} = $le_msg;
        }
        else {
            # create RELIANOID PEM cert
            $status = &setLetsencryptCert($le_cert_name);

            if ($status) {
                my $le_msg = "Letsencrypt create PEM cert failed!";
                &log_error($le_msg, "letsencrypt");
                $error_ref->{code} = 4;
                $error_ref->{desc} = $le_msg;
            }
        }
    }

    # delete le service
    &unsetLetsencryptFarmService($farm_name);

    # stop local Web Server
    &runLetsencryptLocalWebserverStop();

    close $lock_le_renew_fh;
    return $error_ref;
}

=pod

=head1 isLetsencryptStaging

Check the LetsEncrypt Certificate API server.

Parameters:

    le_cert_name - Certificate Name.

Returns: integer - 1 for staging, 0 for production.

=cut

sub isLetsencryptStaging ($le_cert_name) {
    my $le_config_path = &getLetsencryptConfigPath();
    my $rc             = 0;

    return $rc if (!$le_cert_name);

    my $le_cert_renewal_file = "$le_config_path/renewal/$le_cert_name.conf";

    if (-f $le_cert_renewal_file) {
        require Config::Tiny;

        my $le_cert_renewal_conf = Config::Tiny->read($le_cert_renewal_file);
        my $le_api_server        = $le_cert_renewal_conf->{renewalparams}{server};

        $rc = int($le_api_server =~ /acme-staging/);
    }

    return $rc;
}

=pod

=head1 setLetsencryptCron

Set a cron entry for an automatic renewal Letsencrypt certificate

Parameters:

    le_cert_name - LE Cert Name
    farm_name    - Farm Name where Letsencrypt will connect.
    vip          - VIP where the new Farm and service is created. The virtual Port will be 80.
    force        - if "true" forces a renew flag even the cert not yet due for renewal( over 30 days for expire ).
    restart      - if "true" forces a restart flag to restart farms affected by the certificate.

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub setLetsencryptCron ($le_cert_name, $farm_name, $vip, $force, $restart) {
    my $rc = 0;

    return 1 if (!$le_cert_name);
    return 2 if (!$vip && !$farm_name) or ($vip && $farm_name);

    my $le_cron_file   = &getLetsencryptCronFile();
    my $le_renewal_bin = &getGlobalConfiguration('le_renewal_bin');
    my $minute         = int rand(59);

    require Relianoid::Lock;
    &ztielock(\my @le_cron_list, $le_cron_file);
    my $frequency = "$minute 22 * * * ";
    my $command   = "root $le_renewal_bin --cert $le_cert_name";
    @le_cron_list = grep { !/ $command / } @le_cron_list;

    $command .= " --farm $farm_name" if $farm_name;
    $command .= " --vip $vip"        if $vip;
    $command .= " --force"           if (defined $force   and ($force eq "true"));
    $command .= " --restart"         if (defined $restart and ($restart eq "true"));

    push @le_cron_list, "$frequency $command";
    untie @le_cron_list;

    return $rc;
}

=pod

=head1 unsetLetsencryptCron

Delete a cron entry for an automatic renewal Letsencrypt certificate

Parameters:

    le_cert_name - LE Cert Name

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub unsetLetsencryptCron ($le_cert_name) {
    my $rc = 0;

    return 1 if (!$le_cert_name);

    my $le_cron_file   = &getLetsencryptCronFile();
    my $le_renewal_bin = &getGlobalConfiguration('le_renewal_bin');

    require Relianoid::Lock;
    &ztielock(\my @le_cron_list, $le_cron_file);
    my $command = "root $le_renewal_bin --cert $le_cert_name";
    @le_cron_list = grep { !/ $command / } @le_cron_list;
    untie @le_cron_list;

    return $rc;
}

=pod

=head1 getLetsencryptCron

get the cron entry for an automatic renewal Letsencrypt certificate

Parameters:

    le_cert_name - LE Cert Name

Returns:

    Hash - cron entry Hash ref with values on successful.

=cut

sub getLetsencryptCron ($le_cert_name) {
    my $cron_ref = {
        status  => "disabled",
        farm    => undef,
        vip     => undef,
        force   => undef,
        restart => undef
    };

    my $le_cron_file   = &getLetsencryptCronFile();
    my $le_renewal_bin = &getGlobalConfiguration('le_renewal_bin');

    my @le_cron_list = ();
    if (open my $fd, '<', $le_cron_file) {
        @le_cron_list = <$fd>;
        close $fd;
        chomp(@le_cron_list);
    }
    else {
        log_debug("Could not open $le_cron_file: $!");
    }

    my $command = "root $le_renewal_bin --cert $le_cert_name";
    my @le_cron = grep { / $command / } @le_cron_list;

    if (scalar @le_cron > 0) {
        require Relianoid::Validate;

        my $farm_name = &getValidFormat('farm_name');
        my $vip       = &getValidFormat('ip_addr');

        if ($le_cron[0] =~ /$command(?: --farm ($farm_name))?(?: --vip ($vip))?(?:( --force))?(?:( --restart))?$/) {
            $cron_ref->{status}  = "enabled";
            $cron_ref->{farm}    = $1;
            $cron_ref->{vip}     = $2;
            $cron_ref->{force}   = defined $3 ? "true" : "false";
            $cron_ref->{restart} = defined $4 ? "true" : "false";
        }
    }

    return $cron_ref;
}

=pod

=head1 getLetsencryptCertConfigIsBroken

Detect if the LetsEncrypt configuration folder is broken

Parameters:

    cert_name - the name of the certificate

Returns:

    Integer - 0 if it's not broken, 1 if it's broken.

=cut

sub getLetsencryptCertConfigIsBroken ($cert_name) {
    my $le_fullchain_path = &getGlobalConfiguration('le_fullchain_path');
    my $broken            = 0;
    my $cmd               = "find $le_fullchain_path/live/$cert_name/ -type l ! -exec test -e \{\} \\; -print";

    my $output = &logAndGet($cmd);
    if (   ($output ne "")
        or (!-f "$le_fullchain_path/renewal/$cert_name.conf")
        or (!-d "$le_fullchain_path/archive/$cert_name/"))
    {
        $broken = 1;
        &log_error("Detected LetsEncrypt configuration broken", "letsencrypt");
    }

    return $broken;
}

=pod

=head1 runLetsencryptCertConfigBackup

Create a backup for the Lets Encrypt configuration

Parameters:

    cert_name - the name of the certificate

Returns:

    Integer - 0 on succesful, 1 if there was a problem generating the backup.

=cut

sub runLetsencryptCertConfigBackup ($cert_name) {
    my $le_fullchain_path = &getGlobalConfiguration('le_fullchain_path');
    my $le_backup_path    = &getGlobalConfiguration('localconfig');
    my $le_backup_file    = "le_backup-$cert_name.tgz";
    my $cmd =
      "cd $le_fullchain_path && tar zcf $le_backup_path/$le_backup_file live/$cert_name/ archive/$cert_name/ renewal/$cert_name.conf";
    my $output = 0;

    &log_info("Creating LetsEncrypt Configuration Backup to $le_backup_path/$le_backup_file", "letsencrypt");
    if (-f "$le_backup_path/$le_backup_file") {
        &logAndRun("mv $le_backup_path/$le_backup_file $le_backup_path/$le_backup_file.bck");
    }
    $output = &logAndRun($cmd);
    if (-f "$le_backup_path/$le_backup_file.bck") {
        if ($output) {
            &log_error("Creating LetsEncrypt Configuration Backup Failed, recovering backup", "letsencrypt");
            &logAndRun("mv $le_backup_path/$le_backup_file.bck $le_backup_path/$le_backup_file");
        }
        else {
            &logAndRun("rm $le_backup_path/$le_backup_file.bck");
        }
    }

    return $output;
}

=pod

=head1 runLetsencryptCertConfigRecovery

Apply a backup recovery for the Lets Encrypt configuration

Parameters:

    cert_name - the name of the certificate

Returns:

    Integer - 0 if recovery successful, 1 if there was a problem with the recovery.

=cut

sub runLetsencryptCertConfigRecovery ($cert_name) {
    my $le_fullchain_path = &getGlobalConfiguration('le_fullchain_path');
    my $le_backup_path    = &getGlobalConfiguration('localconfig');
    my $le_backup_file    = "le_backup-$cert_name.tgz";
    my $cmd =
      "cd $le_fullchain_path && rm -rf live/$cert_name/ archive/$cert_name/ renewal/$cert_name.conf && tar zxf $le_backup_path/$le_backup_file";
    my $output = 0;

    if (-f "$le_backup_path/$le_backup_file") {
        &log_info("Recovery LetsEncrypt Configuration Backup from $le_backup_path/$le_backup_file", "letsencrypt");
        &logAndRun($cmd);
        $output = 1;
    }
    else {
        &log_warn("No backup available to recover at $le_backup_path/$le_backup_file", "letsencrypt");
        $output = 1;
    }

    return $output;
}

=pod

=head1 runLetsencryptCertConfigProtection

Protection to ensure that the configuration files in letsencrypt are not corrupted.
Always maintain a copy to be deployed in case a corruption is detected.

Parameters:

    cert_name - the name of the certificate

Returns:

    Integer - 0 if not recovery required, 1 if it was recovered.

=cut

sub runLetsencryptCertConfigProtection ($cert_name) {
    my $output = 0;

    if (!&getLetsencryptCertConfigIsBroken($cert_name)) {
        &runLetsencryptCertConfigBackup($cert_name);
    }
    else {
        $output = &runLetsencryptCertConfigRecovery($cert_name);
        $output = 1;
    }

    return $output;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Lock.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Fcntl ':flock';    #use of lock functions

use Relianoid::Log;

my $lock_file = undef;
my $lock_fh   = undef;

=pod

=head1 Module

Relianoid::Lock

=cut

=pod

=head1 getLockFile

Write a lock file based on a input path

=cut

sub getLockFile ($lock) {
    # replace slash with underscore
    $lock =~ s/\//_/g;
    $lock = "/tmp/$lock.lock";

    return $lock;
}

=pod

=head1 openlock

Open file and lock it, return the filehandle.

    Usage:

        my $filehandle = &openlock( $path, 'r' );

    Lock is exclusive when the file is openend for writing.
    Lock is shared when the file is openend for reading.
    So only opening for writing is blocking the file for other uses.

    Opening modes:

        r - Read
        w - Write
        a - Append

        t - text mode. To enforce encoding UTF-8.
        b - binary mode. To make sure no information is lost.

    'r', 'w' and 'a' are mutually exclusive.
    't' and 'b' are mutually exclusive.

    If neither 't' or 'b' are used on the mode parameter, the default Perl mode is used.

    Take in mind, if you are executing process in parallel, if any of them remove the tmp locking file,
    the resource will be unlocked.

Parameters:

    path - Absolute or relative path to the file to be opened.
    mode - Mode used to open the file.

Returns:

    scalar - File handle

=cut

sub openlock ($path, $mode) {
    my $binmode  = $mode =~ s/b//;
    my $textmode = $mode =~ s/t//;

    if ($binmode && $textmode) {
        log_error("Raw and UTF-8 encoding cannot be used at the same time");
        return;
    }

    my $encoding = '';
    if    ($textmode) { $encoding = ":encoding(UTF-8)" }
    elsif ($binmode)  { $encoding = ":raw :bytes" }

    my $open_mode;
    if    ($mode eq 'a') { $open_mode = '>>' }
    elsif ($mode eq 'w') { $open_mode = '>' }
    elsif ($mode eq 'r') { $open_mode = '<' }

    if (not $open_mode) {
        log_error("Bad open mode");
        return;
    }

    my $fh;
    my $open_mode_with_layer = $encoding ? "${open_mode} ${encoding}" : $open_mode;

    if (open($fh, $open_mode_with_layer, $path)) {    ## no critic (RequireBriefOpen)
        if ($binmode) {
            binmode $fh;
        }
    }
    else {
        &log_error("Error opening the file $path: $!");
        return;
    }

    if ($open_mode eq ">") {
        # exclusive lock for writing
        flock $fh, LOCK_EX;
    }
    else {
        # shared lock for reading
        flock $fh, LOCK_SH;
    }

    return $fh;
}

=pod

=head1 ztielock

tie aperture with lock

    Usage:

        $handleArray = &tielock($file);

    Examples:

        $handleArray = &tielock("test.dat");
        $handleArray = &tielock($filename);

Parameters:

    file_name - Path to File.

Returns:

    scalar - Reference to the array with the content of the file.

Bugs:

    Not used yet.

=cut

sub ztielock ($array_ref, $file_name) {
    require Tie::File;

    my $o = tie @{$array_ref}, "Tie::File", $file_name;
    return $o->flock;
}

=pod

=head1 copyLock

=cut

sub copyLock ($ori, $dst) {
    my $fhOri = &openlock($ori, 'r') or return 1;
    my $fhDst = &openlock($dst, 'w') or do { close $fhOri; return 1; };

    while (my $line = <$fhOri>) {
        print $fhDst $line;
    }

    close $fhOri;
    close $fhDst;

    return 0;
}

=pod

=head1 lockResource

    lock or release an API resource.

Parameters:

    resource - Path to file.
    operation - l (lock), u (unlock), ud (unlock, delete the lock file), r (read)

Bugs:

    Not used yet.

=cut

sub lockResource ($resource, $oper) {
    # TODO: Define here the available resources
    # bonding
    # crl
    # ...

    if ($oper =~ /l/) {
        $lock_file = &getLockFile($resource);
        $lock_fh   = &openlock($lock_file, 'w');
    }
    elsif ($oper =~ /u/) {
        close $lock_fh;
        unlink $lock_file if ($oper =~ /d/);
    }
    elsif ($oper =~ /r/) {
        $lock_file = &getLockFile($resource);
        $lock_fh   = &openlock($lock_file, 'r');
    }

    return;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Log.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use Unix::Syslog qw(:macros :subs);    # Syslog macros

use Relianoid::Debug;

=pod

=head1 Module

Relianoid::Log 

=cut

sub warning_signal (@args) {
    print STDERR @args;
    log_warn("@args");
    return;
}

# Get the program name for logs messages
my $program_name =
    ($0 ne '-e')                                     ? $0
  : (exists $ENV{_} && $ENV{_} !~ /enterprise.bin$/) ? $ENV{_}
  :                                                    $^X;

my $basename = (split('/', $program_name))[-1];

=pod

=head1 _log

Write logs through syslog

Usage:

    &_log($text, $priority, $tag);

Examples:

    &_log("This is a message.", "info", "LSLB");
    &_log("Some errors happened.", "err", "FG");
    &_log("testing debug mode", "debug", "SYSTEM");

The different debug levels are:

    1 - Command executions.
        API inputs.
    2 - The command standart output, when there isn't any error.
        API outputs.
        Parameters modified in configuration files.
    3 - (reserved)
    4 - (reserved)
    5 - Profiling.

Parametes:

    message - String to be written in log.
    type    - Log level. info, error, debug, debug2, warn. Default: info
    tag     - RBAC, LSLB, GSLB, DSLB, IPDS, FG, NOTIF, NETWORK, MONITOR, SYSTEM, CLUSTER, AWS

Returns:

    none - .

=cut

sub _log ($message, $type = 'info', $tag = '') {
    if ($tag eq 'PROFILING') {
        $type = "debug5";
        return if &debug() < 5;
    }

    if ($type =~ /^debug(\d)?$/i) {
        my $log_debug_level = $1 // 1;

        # skip logs messages not included in the log level
        if (&debug() lt $log_debug_level) {
            return;
        }

        $type = "DEBUG";
        $type .= $log_debug_level if $log_debug_level > 1;
    }
    else {
        $type = uc($type);
    }

    if ($tag) {
        $tag = lc "${tag} :: ";
    }

    openlog($basename, LOG_PID, LOG_LOCAL0);
    syslog(LOG_INFO, "(${type}) ${tag}${message}");
    closelog();

    return;
}

sub log_info ($message, $tag = '') {
    return _log($message, 'info', $tag);
}

sub log_warn ($message, $tag = '') {
    return _log($message, 'warning', $tag);
}

sub log_error ($message, $tag = '') {
    return _log($message, 'error', $tag);
}

sub log_debug ($message, $tag = '') {
    return _log($message, 'debug', $tag);
}

sub log_debug2 ($message, $tag = '') {
    return _log($message, 'debug2', $tag);
}

sub log_debug3 ($message, $tag = '') {
    return _log($message, 'debug3', $tag);
}

sub log_debug4 ($message, $tag = '') {
    return _log($message, 'debug4', $tag);
}

sub log_debug5 ($message, $tag = '') {
    return _log($message, 'debug5', $tag);
}

=pod

=head1 logAndRun

Log and run the command string input parameter returning execution error code.

Parameters:

    command - String with the command to be run.

Returns:

    integer - Return code.

See Also:

    Widely used.

=cut

sub logAndRun ($command) {
    my $program     = $basename;
    my @cmd_output  = `$command 2>&1`;
    my $return_code = $?;

    if ($return_code) {
        &log_error("${program} running: ${command}", "SYSTEM");
        &log_error("out: @cmd_output",               "SYSTEM") if @cmd_output;
        &log_error("last command failed!",           "SYSTEM");
    }
    else {
        &log_debug("${program} running: ${command}", "SYSTEM");
        &log_debug2("out: @cmd_output", "SYSTEM");
    }

    return $return_code;
}

=pod

=head1 logAndRunBG

Non-blocking version of logging and running a command, returning execution error code.

Parameters:

    command - String with the command to be run.

Returns:

    boolean - true on error, false on success launching the command.

=cut

sub logAndRunBG ($command) {
    my $program = $basename;

    # system("command &") always returns 0
    my $return_code = system("$command >/dev/null 2>&1 &");

    if ($return_code) {
        &log_error("${program} running: ${command}", "SYSTEM");
        &log_error("last command failed!",           "SYSTEM");
    }
    else {
        &log_debug("${program} running: ${command}", "SYSTEM");
    }

    return $return_code;
}

=pod

=head1 run_with_env

Run a command with the environment parameters customized.

Parameters:

    exec - Command to run.

Returns:

    integer - Returns 0 on success or another value on failure

See Also:

    <runFarmGuardianStart>, <_runHTTPFarmStart>, <runHTTPFarmCreate>, <_runGSLBFarmStart>, <_runGSLBFarmStop>, <runGSLBFarmReload>, <runGSLBFarmCreate>

=cut

sub run_with_env (@command) {
    my $program = $basename;

    my @cmd_output = `. /etc/profile -notbui >/dev/null 2>&1 && @command 2>&1`;
    my $errno      = $?;

    if ($errno) {
        &log_error("${program} running: @command", "SYSTEM");
        &log_error("@cmd_output",                  "SYSTEM") if @cmd_output;
        &log_error("last command failed!",         "SYSTEM");
    }
    else {
        &log_debug("${program} running: @command", "SYSTEM");
        &log_debug2("out: @cmd_output", "SYSTEM");
    }

    return $errno;
}

=pod

=head1 logAndGet

Execute a command in the system to get the output. If the command fails,
it logs the error and returns a empty string or array.
It returns only the standard output, it does not return stderr.

Parameters:

    command - String with the command to be run in order to get info from the system.
    output format - Force that the output will be convert to 'string' or 'array'. String by default
    stderr flag - If this parameter is different of 0, the stderr will be added to the command output '2>&1'

Returns:

    Array ref or string - data obtained from the system. The type of output is specified
    in the type input param

See Also:

    logAndRun

TODO:

    Add an option to manage exclusively the output error and discard the standard output

=cut

sub logAndGet ($cmd, $type = 'string', $add_stderr = 0) {
    my $tmp_err  = ($add_stderr) ? '&1' : "/tmp/err.log";
    my $out      = `$cmd 2>$tmp_err` // '';
    my $err_code = $? >> 8;

    if (&debug() >= 2) {
        &log_debug2("Executed (out: $err_code): $cmd", "system");
    }

    if ($err_code and not $add_stderr) {
        # execute again, removing stdout and getting stderr
        if (open(my $fh, '<', $tmp_err)) {
            local $/ = undef;
            my $err_str = <$fh>;
            &log_debug2("sterr: $err_str", "SYSTEM");
            close $fh;
        }
        else {
            &log_error("file '$tmp_err' not found", "SYSTEM");
        }
    }

    chomp($out);

    # logging if there is not any error
    &log_debug3("out: $out", "SYSTEM");

    if ($type eq 'array') {
        my @out = split("\n", $out);
        return \@out;
    }

    return $out;
}

=pod

=head1 logAndRunCheck

It executes a command but is does not log anything if it fails. This functions
is useful to check things in the system as if a process is running or doing connectibity tests.
This function will log the command if the loglevel is greater than 1, and will
log the error output if the loglevel is greater than 2.

Parameters:

    command - String with the command to be run.

Returns:

    integer - error code of the command. 0 on success or another value on failure

See Also:

    logAndRun

=cut

sub logAndRunCheck ($command) {
    my $program = $basename;

    my @cmd_output  = `$command 2>&1`;
    my $return_code = $? >> 8;

    if (&debug() >= 2) {
        &log_debug2("${program} err_code '${return_code}' checking: ${command}", "SYSTEM");
    }
    if (&debug() >= 3) {
        &log_debug3("${program} output: @cmd_output", "SYSTEM");
    }

    # returning error code of the execution
    return $return_code;
}

=pod

=head1 logRunAndGet

Execute a command in the system to get both the standard output and the stderr.

Parameters:

    command - String with the command to be run in order to get info from the system.
    format - Force that the output will be convert to 'string' or 'array'. String by default.
    outflush - Flush standard output. If true, the standard output will be sent to null.

Returns:

    Hash ref - hash reference with the items:

    stdout - standard output of the command executed in the given format. If 'array'
             format is selected, then a hash array is provided. 'string' by default.

    stderr - output error code of the command executed.

=cut

sub logRunAndGet ($command, $format = 'string', $outflush = 0) {
    $command .= " 2>&1";
    $command .= " > /dev/null" if ($outflush);

    my @get = ($_ = qx{$command}, $? >> 8);

    my $exit;
    $exit->{stdout} = $get[0];
    $exit->{stderr} = $get[1];

    &log_debug("Executed (out: $exit->{stderr}): $command", "system");

    if ($format eq 'array') {
        my @out = split("\n", $get[0]);
        $exit->{stdout} = \@out;
    }

    return $exit;
}

=pod

=head1 run3

Execute a command and returns errno, stdout and stderr of such command.

Parameters:

    command - String with the command to be run.

Returns:

    ($errno, \@stdout, \@stderr) - Array with:

    errno  - Scalar integer. The value is the error number returned.
    stdout - Array reference. Each element of the array is a line of stdout.
    stderr - Array reference. Each element of the array is a line of stderr.

=cut

sub run3 ($command) {
    require IPC::Open3;
    require Symbol;

    my $in_fh;
    my $out_fh;
    my $err_fh = Symbol::gensym();                                        # required to separate stdout and stderr
    my $pid    = IPC::Open3::open3($in_fh, $out_fh, $err_fh, $command);
    waitpid($pid, 0);
    my $status = $? >> 8;

    chomp(my @out = <$out_fh>);
    chomp(my @err = <$err_fh>);
    return ($status, \@out, \@err);
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Login.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $passfile = "/etc/shadow";

=pod

=head1 Module

Relianoid::Login

=cut

=pod

=head1 changePassword

Change the password of a username.

Parameters:

    user - User name.
    newpass - New password.
    verifypass - New password again.

Returns:

    integer - ERRNO or return code .

Bugs:

    Verify password? Really?!

=cut

sub changePassword ($user, $newpass, $verifypass) {
    $verifypass = $newpass if (!$verifypass);

    ##write \$ instead $
    $newpass    =~ s/\$/\\\$/g;
    $verifypass =~ s/\$/\\\$/g;

    chomp($newpass);
    chomp($verifypass);

    ##no move the next lines
    my $cmd = "
/usr/bin/passwd $user 2>/dev/null<<EOF
$newpass
$verifypass
EOF
    ";

    my $output = system($cmd );
    if ($output) {
        &log_error("Error trying to change the $user password");
    }
    else { &log_info("The $user password was changed"); }

    return $output;
}

=pod

=head1 checkValidUser

Validate an user's password.

Parameters:

    user - User name.
    curpasswd - Password.

Returns:

    scalar - Boolean. 1 for valid password, or 0 for invalid one.

Bugs:

    Not a bug, but using pam would be desirable.

See Also:

    API v4: <set_user>

=cut

sub checkValidUser ($user, $passwd_in) {
    my $output = 0;
    use Authen::Simple::Passwd;
    my $passwd = Authen::Simple::Passwd->new(path => "$passfile");
    if ($passwd->authenticate($user, $passwd_in)) {
        $output = 1;
    }

    return $output;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Net/ConnStats.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;

my %conntrack_proto = (
    icmp => 1,
    tcp  => 6,
    udp  => 17,
    gre  => 47,
    sctp => 132,
);

=pod

=head1 Module

Relianoid::Net::ConnStats

=cut

=pod

=head1 getConntrack

Get the connections list.

Parameters:

    orig_src -
    orig_dst -
    reply_src -
    reply_dst -
    protocol -

Returns:

    array ref - Filtered netstat array reference.

=cut

sub getConntrack ($orig_src, $orig_dst, $reply_src, $reply_dst, $protocol) {
    # remove newlines in every argument
    chomp($orig_src, $orig_dst, $reply_src, $reply_dst, $protocol);

    # add iptables options to every available value
    $orig_src  = "-s $orig_src"  if ($orig_src);
    $orig_dst  = "-d $orig_dst"  if ($orig_dst);
    $reply_src = "-r $reply_src" if ($reply_src);
    $reply_dst = "-q $reply_dst" if ($reply_dst);
    $protocol  = "-p $protocol"  if ($protocol);

    my $conntrack     = &getGlobalConfiguration('conntrack');
    my $conntrack_cmd = "$conntrack -L $orig_src $orig_dst $reply_src $reply_dst $protocol";

    # return an array reference
    my @output = @{ &logAndGet($conntrack_cmd, "array") };

    # my $conns_count = scalar @output;
    # &log_info( "getConntrack command: $conntrack_cmd", "MONITOR" );
    # &log_info( "getConntrack returned $conns_count connections.", "MONITOR" );

    return \@output;
}

=pod

=head1 getNetstatFilter

Filter conntrack output

Parameters:

    proto - Protocol: "tcp", "udp", more?
    state - State: ??
    ninfo - Ninfo: ??
    fpid - Fpid: ??
    netstat - Output from getConntrack

Returns:

    array ref - Filtered netstat array reference.

=cut

# Returns array execution of netstat
sub getNetstatFilter ($proto, $state, $ninfo, $fpid, $netstat) {
    my $lfpid = $fpid;
    chomp($lfpid);

    if ($lfpid) {
        $lfpid = "\ $lfpid\/";
    }

    if ($proto ne "tcp" && $proto ne "udp") {
        $proto = "";
    }

    my $filter = "${proto}.* ${ninfo} .* ${state}.*${lfpid}";
    my @output = grep { /$filter/ } @{$netstat};
    my $output = \@output;

    # my $conns_count = scalar @output;
    # &log_info( "getNetstatFilter filter: '$filter'", "MONITOR" );
    # &log_info( "getNetstatFilter returned $conns_count connections.", "MONITOR" );

    return $output;
}

=pod

=head1 getConntrackParams

Get Conntrack params for a filter

Example:

    my $filter = {
        proto         => 'tcp',
        orig_dst      => $vip,
        orig_port_dst => $vip_port,
        state         => 'ESTABLISHED',
    };

Parameters:

    hash ref - Filter of connections

    FILTER PARAMETERS

    src, orig_src IP_ADDRESS
        Match only entries whose source address in the original direction equals the one specified as argument.
        Implies "--mask-src" when CIDR notation is used.

    dst, orig_dst IP_ADDRESS
        Match only entries whose destination address in the original direction equals the one specified as argument.
        Implies "--mask-dst" when CIDR notation is used.

    reply_src IP_ADDRESS
        Match only entries whose source address in the reply direction equals the one specified as argument.

    reply_dst IP_ADDRESS
        Match only entries whose destination address in the reply direction equals the one specified as argument.

    proto PROTO
        Specify layer four (TCP, UDP, ...) protocol.

    family PROTO
        Specify layer three (ipv4, ipv6) protocol This option is only required in conjunction with "-L, --dump".
        If this option is not passed, the default layer 3 protocol will be IPv4.

    timeout TIMEOUT
        Specify the timeout.

    mark MARK[/MASK]
        Specify  the conntrack mark. Optionally, a mask value can be specified.
        In "--update" mode, this mask specifies the bits that should be zeroed before XORing the MARK value into the ctmark.
        Otherwise, the mask is logically ANDed with the existing mark before the comparision.
        In "--create" mode, the mask is ignored.

    label LABEL
        Specify a conntrack label. 
        This option is only available in conjunction with "-L, --dump", "-E, --event", "-U --update" or "-D --delete".
        Match entries whose labels match at least those specified.
        Use multiple -l commands to specify multiple labels that need to be set.
        Match entries whose labels matches at least those specified as arguments.
        --label-add LABEL Specify the conntrack label to add to to the selected conntracks.
        This option is only available in conjunction with "-I, --create" or "-U, --update".
        --label-del [LABEL] Specify the conntrack label to delete from the selected conntracks.
        If no label is given, all labels are  deleted. This option is only available in conjunction with "-U, --update".

    secmark SECMARK
        Specify the conntrack selinux security mark.

    status [ASSURED|SEEN_REPLY|FIXED_TIMEOUT|EXPECTED|UNSET][,...]
        Specify the conntrack status.

    src_nat
        Filter source NAT connections.

    dst_nat
        Filter destination NAT connections.

    any_nat
        Filter any NAT connections.

    zone
        Filter by conntrack zone. See iptables CT target for more information.

    orig_zone
        Filter by conntrack zone in original direction.  See iptables CT target for more information.

    reply_zone
        Filter by conntrack zone in reply direction.  See iptables CT target for more information.

    tuple_src IP_ADDRESS
        Specify the tuple source address of an expectation.  Implies "--mask-src" when CIDR notation is used.

    tuple_dst IP_ADDRESS
        Specify the tuple destination address of an expectation.  Implies "--mask-dst" when CIDR notation is used.

    mask_src IP_ADDRESS
        Specify  the  source  address mask.
        For conntrack this option is only available in conjunction with "-L, --dump", "-E, --event", "-U --update" or "-D --delete".
        For expectations this option is only available in conjunction with "-I, --create".

    mask_dst IP_ADDRESS
        Specify the destination address mask. Same limitations as for "--mask-src".



    PROTOCOL FILTER PARAMETERS

    TCP-specific fields:

    sport, orig_port_src PORT
        Source port in original direction

    dport, orig_port_dst PORT
        Destination port in original direction

    reply_port_src PORT
        Source port in reply direction

    reply_port_dst PORT
        Destination port in reply direction

    state [NONE | SYN_SENT | SYN_RECV | ESTABLISHED | FIN_WAIT | CLOSE_WAIT | LAST_ACK | TIME_WAIT | CLOSE | LISTEN]
        TCP state


    UDP-specific fields:

    sport, orig_port_src PORT
        Source port in original direction

    dport, orig_port_dst PORT
        Destination port in original direction

    reply_port_src PORT
        Source port in reply direction

    reply_port_dst PORT
        Destination port in reply direction

Returns:

    unsigned integer - Number of connections found with the filter applied.

=cut

sub getConntrackParams ($filter) {
    my $conntrack_bin    = &getGlobalConfiguration('conntrack');
    my $conntrack_params = '';

    if (my @protocols = split(/\s/, $filter->{proto})) {
        my @found_protocols = ();
        for my $protocol (@protocols) {
            my $proto_code = $conntrack_proto{$protocol};
            if (defined $proto_code) {
                push(@found_protocols, $proto_code);
            }
            else {
                carp("Protocol '$protocol' not found in conntrack_proto");
            }
        }
        if (@found_protocols) {
            $conntrack_params = "--proto @found_protocols";
        }
    }

    for my $filter_key (keys %$filter) {
        next if $filter_key eq 'proto';

        my $param = $filter_key;
        $param =~ s/_/-/g;

        $conntrack_params = join(" ", $conntrack_params, "--$param $filter->{ $filter_key }");
    }

    return $conntrack_params;
}

=pod

=head1 getConntrackCount

Parameters:

    $conntrack_params - filter received from getConntrackParams()

Returns:

    integer - Count of connection matching the received filter.

=cut

sub getConntrackCount ($conntrack_params) {
    my $conntrack_bin = &getGlobalConfiguration('conntrack');
    my $conntrack_cmd = "$conntrack_bin -L $conntrack_params 2>&1 >/dev/null";

    require Relianoid::Debug;

    &log_debug("Conntrack count: $conntrack_cmd", "MONITOR") if &debug();

    # Do not use the function 'logAndGet', this function manages the output error and code
    my $summary = `$conntrack_cmd`;
    my $error   = $?;
    my ($count) = $summary =~ m/: ([0-9]+) flow entries have been shown./;

    &log_error("Conntrack count: An error happened running the command: $conntrack_cmd", "MONITOR")
      if $error;

    return $count + 0;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Net/Core.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use Relianoid::Core;

my $ip_bin = &getGlobalConfiguration('ip_bin');
my $eload  = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Net::Core

=cut

=pod

=head1 createIf

Create VLAN network interface

Parameters:

    if_ref - Network interface hash reference.

Returns:

    integer - ip command return code.

=cut

# create network interface
sub createIf ($if_ref) {
    my $status = 1;

    if (defined $$if_ref{vlan} && $$if_ref{vlan} ne '') {
        &log_info("Creating vlan $$if_ref{name}", "NETWORK");

        my $ip_cmd = "$ip_bin link add link $$if_ref{dev} name $$if_ref{name} type vlan id $$if_ref{vlan}";
        $status = &logAndRun($ip_cmd);
    }

    return $status;
}

=pod

=head1 upIf

Bring up network interface in system and optionally in configuration file

Parameters:

    if_ref - network interface hash reference.
    writeconf - true value to apply change in interface configuration file. Optional.

Returns:

    integer - return code of ip command.

See Also:

    <downIf>

=cut

# up network interface
sub upIf ($if_ref, $writeconf = 0) {
    my $configdir = &getGlobalConfiguration('configdir');
    my $status    = 0;
    $if_ref->{status} = 'up';

    my $ip_cmd = "$ip_bin link set dev $$if_ref{name} up";

    $status = &logAndRun($ip_cmd);

    # not check virtual interfaces
    if ($if_ref->{type} ne "virtual") {
        #check if link is up after ip link up; checks /sys/class/net/$$if_ref{name}/operstate
        my $cat       = &getGlobalConfiguration('cat_bin');
        my $status_if = &logAndGet("$cat /sys/class/net/$$if_ref{name}/operstate");

        &log_info("Link status for $$if_ref{name} is $status_if", "NETWORK");

        if ($status_if =~ /down/) {
            use Time::HiRes qw(usleep);

            &log_info("Waiting link up for $$if_ref{name}", "NETWORK");

            my $max_retry = 50;
            my $retry     = 0;

            while ($status_if =~ /down/ and $retry < $max_retry) {
                $status_if = &logAndGet("$cat /sys/class/net/$$if_ref{name}/operstate");

                if ($status_if !~ /down/) {
                    &log_info("Link up for $$if_ref{name}", "NETWORK");
                    last;
                }

                $retry++;
                usleep 100_000;
            }

            if ($status_if =~ /down/) {
                $status = 1;
                &log_warn("No link up for $$if_ref{name}", "NETWORK");
                &downIf({ name => $if_ref->{name} }, '');
            }
        }
    }

    if ($writeconf) {
        my $file = "$configdir/if_$$if_ref{name}_conf";

        require Config::Tiny;
        my $fileHandler = Config::Tiny->new();
        $fileHandler = Config::Tiny->read($file) if (-f $file);

        $fileHandler->{ $if_ref->{name} }{status} = "up";
        $fileHandler->write($file);
    }

    if (not $status and $eload and $if_ref->{dhcp} eq 'true') {
        $status = &eload(
            'module' => 'Relianoid::EE::Net::DHCP',
            'func'   => 'startDHCP',
            'args'   => [ $if_ref->{name} ],
        );
    }

    # calculate new backend masquerade IPs
    require Relianoid::Farm::Config;
    &reloadFarmsSourceAddress();

    return $status;
}

=pod

=head1 downIf

Bring down network interface in system and optionally in configuration file

Parameters:

    if_ref - network interface hash reference.

Returns:

    integer - return code of ip command.
    writeconf - true value to apply change in interface configuration file. Optional.

=cut

# down network interface in system and configuration file
sub downIf ($if_ref, $writeconf = 0) {
    my $status;

    if (ref $if_ref ne 'HASH') {
        &log_error("Wrong argument putting down the interface", "NETWORK");
        return -1;
    }

    if ($eload and $if_ref->{dhcp} and $if_ref->{dhcp} eq 'true') {
        $status = &eload(
            'module' => 'Relianoid::EE::Net::DHCP',
            'func'   => 'stopDHCP',
            'args'   => [ $if_ref->{name} ],
        );
    }

    my $ip_cmd;

    # For Eth and Vlan
    if (not defined $$if_ref{vini} or not length $$if_ref{vini}) {
        $ip_cmd = "$ip_bin link set dev $$if_ref{name} down";
    }

    # For Vini
    else {
        my ($routed_iface) = split(":", $$if_ref{name});

        $ip_cmd = "$ip_bin addr del $$if_ref{addr}/$$if_ref{mask} dev $routed_iface";

        &eload(
            module => 'Relianoid::EE::Net::Routing',
            func   => 'applyRoutingDependIfaceVirt',
            args   => [ 'del', $if_ref ]
        ) if $eload;
    }

    &setRuleIPtoTable($$if_ref{name}, $$if_ref{addr}, "del");
    $status = &logAndRun($ip_cmd);

    # Set down status in configuration file
    if ($writeconf) {
        my $configdir = &getGlobalConfiguration('configdir');
        my $file      = "$configdir/if_$$if_ref{name}_conf";

        require Config::Tiny;
        my $fileHandler = Config::Tiny->new();
        $fileHandler = Config::Tiny->read($file) if (-f $file);

        $fileHandler->{ $if_ref->{name} }{status} = "down";
        $fileHandler->write($file);
    }

    # calculate new backend masquerade IPs
    require Relianoid::Farm::Config;
    &reloadFarmsSourceAddress();

    return $status;
}

=pod

=head1 stopIf

Stop network interface, this removes the IP address instead of putting the interface down.

This is an alternative to downIf which performs better in hardware
appliances. Because if the interface is not brought down it wont take
time to bring the interface back up and enable the link.

Parameters:

    if_ref - network interface hash reference.

Returns:

    integer - return code of ip command.

Bugs:

    Remove VLAN interface and bring it up.

See Also:

    <downIf>

    Only used in: relianoid

=cut

# stop network interface
sub stopIf ($if_ref) {
    &log_info("Stopping interface $$if_ref{name}", "NETWORK");

    my $status = 0;
    my $if     = $$if_ref{name};

    # If $if is Vini do nothing
    if (!$$if_ref{vini}) {
        # If $if is a Interface, delete that IP
        my $ip_cmd = "$ip_bin address flush dev $$if_ref{name}";
        $status = &logAndRun($ip_cmd);

        # If $if is a Vlan, delete Vlan
        if ($$if_ref{vlan} ne '') {
            $ip_cmd = "$ip_bin link delete $$if_ref{name} type vlan";
            $status = &logAndRun($ip_cmd);
        }

        #ensure Link Up
        if ($$if_ref{status} eq 'up') {
            $ip_cmd = "$ip_bin link set dev $$if_ref{name} up";
            $status = &logAndRun($ip_cmd);
        }

        my $rttables = &getGlobalConfiguration('rttables');

        # Delete routes table
        open my $fh, '<', $rttables;
        my @contents = <$fh>;
        close $fh;

        @contents = grep { !/^...\ttable_$if$/ } @contents;

        open $fh, '>', $rttables;
        print $fh @contents;
        close $fh;
    }
    else {
        my @ifphysic = split(/:/, $if);
        my $ip       = $$if_ref{addr};

        if ($ip =~ /\./) {
            use Net::IPv4Addr qw(ipv4_network);
            my (undef, $mask) = ipv4_network("$ip / $$if_ref{mask}");
            my $cmd = "$ip_bin addr del $ip/$mask brd + dev $ifphysic[0] label $if";

            &logAndRun("$cmd");

            &eload(
                module => 'Relianoid::EE::Net::Routing',
                func   => 'applyRoutingDependIfaceVirt',
                args   => [ 'del', $if_ref ]
            ) if $eload;
        }
    }

    return $status;
}

=pod

=head1 delIf

Remove system and stored settings and statistics of a network interface.

Parameters:

    if_ref - network interface hash reference.

Returns:

    integer - return code ofip command.

=cut

sub delIf ($if_ref) {
    my $status;

    # remove dhcp configuration
    if (exists $if_ref->{dhcp} and $if_ref->{dhcp} eq 'true') {
        &eload(
            module => 'Relianoid::EE::Net::DHCP',
            func   => 'disableDHCP',
            args   => [$if_ref],
        );
    }

    require Relianoid::Net::Interface;
    $status = &cleanInterfaceConfig($if_ref);
    if ($status) {
        return $status;
    }

    &setRuleIPtoTable($$if_ref{name}, $$if_ref{addr}, "del");

    # Block for any kind of network interface, except virtual interfaces
    if (not(defined $$if_ref{vini} && length $$if_ref{vini})) {
        # If $if is a gre Tunnel, delete gre
        if ($$if_ref{type} eq 'gre') {
            my $ip_cmd = "$ip_bin tunnel delete $$if_ref{name} mode gre";
            $status = &logAndRun($ip_cmd);
        }
        else {
            my $is_dhcp = defined $if_ref->{dhcp} && $if_ref->{dhcp} eq 'true';

            if (! $is_dhcp && $$if_ref{addr}) {
                # If $if is a Interface, delete that IP
                my $ip_cmd = "$ip_bin addr del $$if_ref{addr}/$$if_ref{mask} dev $$if_ref{name}";

                if (length $if_ref->{addr} && length $if_ref->{mask}) {
                    $status = &logAndRun($ip_cmd);
                }
            }

            # If $if is a Vlan, delete Vlan
            if (defined $$if_ref{vlan} and length $$if_ref{vlan}) {
                my $ip_cmd = "$ip_bin link delete $$if_ref{name} type vlan";
                $status = &logAndRun($ip_cmd);
            }
        }

        #delete custom routes
        &eload(
            module => 'Relianoid::EE::Net::Routing',
            func   => 'delRoutingDependIface',
            args   => [ $$if_ref{name} ],
        ) if ($eload);

        # check if alternative stack is in use
        my $ip_v_to_check = ($$if_ref{ip_v} == 4) ? 6 : 4;
        my $interface     = &getInterfaceConfig($$if_ref{name}, $ip_v_to_check);

        if (!$interface
            || ($interface->{type} eq "bond" and not exists $interface->{addr}))
        {
            &deleteRoutesTable($$if_ref{name});
        }
    }

    # delete graphs
    require Relianoid::RRD;
    &delGraph($$if_ref{name}, "iface");

    if ($eload) {
        # delete alias
        &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'delAlias',
            args   => [ 'interface', $$if_ref{name} ]
        );

        #delete from RBAC
        &eload(
            module => 'Relianoid::EE::RBAC::Group::Config',
            func   => 'delRBACResource',
            args   => [ $$if_ref{name}, 'interfaces' ],
        );

        #reload netplug
        if (!defined($$if_ref{vini}) || $$if_ref{vini} eq '') {
            &eload(
                module => 'Relianoid::EE::Net::Ext',
                func   => 'reloadNetplug',
            );
        }
    }

    return $status;
}

=pod

=head1 delIp

Deletes an IP address from an interface

Parameters:

    if - Name of interface.
    ip - IP address.
    netmask - Network mask.

Returns:

    integer - ip command return code.

See Also:

    <addIp>

=cut

# Execute command line to delete an IP from an interface
sub delIp ($if, $ip, $netmask) {
    if (!defined $ip || $ip eq '') {
        return 0;
    }

    &log_info("Deleting ip $ip/$netmask from interface $if", "NETWORK");

    # Vini
    if ($if =~ /\:/) {
        ($if) = split(/\:/, $if);
    }

    &setRuleIPtoTable($if, $ip, "del");
    my $ip_cmd = "$ip_bin addr del $ip/$netmask dev $if";
    my $status = &logAndRun($ip_cmd);

    return $status;
}

=pod

=head1 isIp

It checks if an IP is already applied in the dev

Parameters:

    if_ref - network interface hash reference.

Returns:

    integer - 0 if the IP is not applied or 1 if it is

See Also:

    <delIp>, <setIfacesUp>

=cut

sub isIp ($if_ref) {
    # finish if the address is already assigned
    my $routed_iface = $$if_ref{dev};
    $routed_iface .= ".$$if_ref{vlan}" if defined $$if_ref{vlan} && $$if_ref{vlan} ne '';

    my @ip_output = @{ &logAndGet("$ip_bin -$$if_ref{ip_v} addr show dev $routed_iface", "array") };

    if (grep { /$$if_ref{addr}\// } @ip_output) {
        &log_debug2("The IP '$$if_ref{addr}' already is applied in '$routed_iface'", "NETWORK");
        return 1;
    }

    return 0;
}

=pod

=head1 addIp

Add an IPv4 to an Interface, Vlan or Vini

Parameters:

    if_ref - network interface hash reference.

Returns:

    integer - ip command return code.

See Also:

    <delIp>, <setIfacesUp>

=cut

# Execute command line to add an IPv4 to an Interface, Vlan or Vini
sub addIp ($if_ref) {
    unless (ref $if_ref eq 'HASH') {
        croak("required network interface hash reference");
    }

    unless (exists $$if_ref{addr}) {
        carp("network interface has no address field");
        return 0;
    }

    unless ($$if_ref{addr} and length $$if_ref{addr}) {
        return 0;
    }

    &log_info("Adding IP $$if_ref{addr}/$$if_ref{mask} to interface $$if_ref{name}", "NETWORK");

    # Do not add automatically route in the main table
    # The routes are managed by relianoid
    my $extra_params = "noprefixroute";
    my $ip_cmd;
    my $if_announce   = "";
    my $broadcast_opt = ($$if_ref{ip_v} == 4) ? 'broadcast +' : '';

    if ($$if_ref{ip_v} == 6) {
        $extra_params .= ' nodad';
    }

    # $if is a Virtual Network Interface
    if (defined $$if_ref{vini} && $$if_ref{vini} ne '') {
        my ($toif) = split(':', $$if_ref{name});

        $ip_cmd = "$ip_bin addr add $$if_ref{addr}/$$if_ref{mask} $broadcast_opt dev $toif label $$if_ref{name} $extra_params";
        $if_announce = $toif;
    }

    # $if is a Network Interface
    else {
        $ip_cmd      = "$ip_bin addr add $$if_ref{addr}/$$if_ref{mask} $broadcast_opt dev $$if_ref{name} $extra_params";
        $if_announce = "$$if_ref{name}";
    }

    my $status = 0;

    # The command will fail if the address already exists
    unless (isIp($if_ref)) {
        $status = &logAndRun($ip_cmd);
    }

    #if arp_announce is enabled then send garps to network
    eval {
        if ($eload) {
            my $cl_status = &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'getClusterNodeStatus',
                args   => [],
            );

            if (   &getGlobalConfiguration('arp_announce') eq "true"
                && $cl_status ne "backup")
            {
                require Relianoid::Net::Util;

                &log_info("Announcing garp $if_announce and $$if_ref{addr} ");
                &sendGArp($if_announce, $$if_ref{addr});
            }
        }
    };

    &setRuleIPtoTable($$if_ref{name}, $$if_ref{addr}, "add");

    return $status;
}

=pod

=head1 setRuleIPtoTable

Add / delete a rule for the IP in order to force the traffic to the associated table_<nic>
it only applies if global param $duplicated_net is true

Parameters:

    iface:  Main interface, nic, bond o vlan
    IP:     main IP or VIP
    action: add / del

Returns:

    0 if ok, 1 if failed

=cut

sub setRuleIPtoTable ($iface, $ip, $action) {
    if (!defined($ip) || $ip eq '') {
        return 0;
    }

    my $prio = &getGlobalConfiguration('routingRulePrioIfacesDuplicated');

    if (&getGlobalConfiguration('duplicated_net') ne "true") {
        #this feature is not in use
        return 0;
    }

    #In case <if>:<name> is sent
    my @ifname = split(/:/, $iface);
    my $ip_cmd = "$ip_bin rule $action from $ip/32 lookup table_$ifname[0] prio $prio";
    return (&execIpCmd($ip_cmd) > 0);
}

=pod

=head1 execIpCmd

    This function replaces to logAndRun to exec ip commands. It does not print
    error message if the command already was applied or removed.

Parameters:

    Ip Command: command line with the ip command

Returns:

    Integer - It returns 0 on success, -1 if the command is already applied or 1 if there was an error

=cut

sub execIpCmd ($command) {
    # do not use the logAndGet function, this function is managing the error output and error code
    my @cmd_output  = `$command 2>&1`;
    my $return_code = $?;

    if ($return_code == 512)    # code 2 in shell
    {
        my $msg =
          ($command =~ /add/)
          ? "Trying to apply the rule but it already was applied"
          : "Trying to remove the rule but it was not found";
        &log_debug($msg,                "net");
        &log_debug("running: $command", "SYSTEM");
        &log_debug2("out: @cmd_output", "SYSTEM");
        $return_code = -1;
    }
    elsif ($return_code) {
        &log_error("Command failed: $command", "SYSTEM");
        &log_error("out: @cmd_output",         "SYSTEM");
        $return_code = 1;
    }
    else {
        &log_debug("running: $command", "SYSTEM");
        &log_debug2("out: @cmd_output", "SYSTEM");
        $return_code = 0;
    }

    return $return_code;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Net/Interface.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures state);

use Carp;

my $eload = eval { require Relianoid::ELoad };

my $ip_bin = &getGlobalConfiguration('ip_bin');

=pod

=head1 Module

Relianoid::Net::Interface

=cut

sub getInterfaceConfigFile ($if_name) {
    my $configdir = &getGlobalConfiguration('configdir');
    return "$configdir/if_${if_name}_conf";
}

=pod

=head1 $if_ref

Reference to a hash representation of a network interface.
It can be found dereferenced and used as a (%iface or %interface) hash.

    name     - Interface name.
    addr     - IP address. Empty if not configured.
    mask     - Network mask. Empty if not configured.
    gateway  - Interface gateway. Empty if not configured.
    status   - 'up' for enabled, or 'down' for disabled.
    ip_v     - IP version, 4 or 6.
    dev      - Name without VLAN or Virtual part (same as NIC or Bonding)
    vini     - Part of the name corresponding to a Virtual interface. Can be empty.
    vlan     - Part of the name corresponding to a VLAN interface. Can be empty.
    mac      - Interface hardware address.
    type     - Interface type: nic, bond, vlan, virtual.
    parent   - Interface which this interface is based/depends on.
    float    - Floating interface selected for this interface. For routing interfaces only.
    is_slave - Whether the NIC interface is a member of a Bonding interface. For NIC interfaces only.
    dhcp     - The DHCP service is enabled or not for the current interface.

See also:

    <getInterfaceConfig>, <setInterfaceConfig>, <getSystemInterface>

=cut

=pod

=head1 getInterfaceConfig

Get a hash reference with the stored configuration of a network interface.

Parameters:

    if_name - Interface name.

Returns:

    Hash ref - Reference to a network interface hash ($if_ref). undef if the network interface was not found.

Bugs:

    The configuration file exists but there isn't the requested stack.

=cut

sub getInterfaceConfig ($if_name, $ip_v = '') {
    unless (defined $if_name) {
        &log_debug2('getInterfaceConfig got undefined interface name', 'network');
    }

    my $configdir       = &getGlobalConfiguration('configdir');
    my $config_filename = "$configdir/if_${if_name}_conf";

    require Config::Tiny;
    my $fileHandler = Config::Tiny->new();

    if (-f $config_filename) {
        $fileHandler = Config::Tiny->read($config_filename);
    }

    #Return undef if the file doesn't exists and the iface is not a NIC
    if (!-f $config_filename && $if_name =~ /\.|\:/) {
        return;
    }

    #Return undef if the file doesn't exists and the iface is a gre Tunnel
    if (!-f $config_filename && &getInterfaceType($if_name) eq 'gre') {
        return;
    }

    require IO::Socket;
    my $socket = IO::Socket::INET->new(Proto => 'udp');

    my $iface = {
        addr    => undef,
        mask    => undef,
        gateway => undef,
    };

    $iface->{name}    = $fileHandler->{$if_name}{name} // $if_name;
    $iface->{addr}    = $fileHandler->{$if_name}{addr}    if (length $fileHandler->{$if_name}{addr});
    $iface->{mask}    = $fileHandler->{$if_name}{mask}    if (length $fileHandler->{$if_name}{mask});
    $iface->{gateway} = $fileHandler->{$if_name}{gateway} if (length $fileHandler->{$if_name}{gateway});
    $iface->{status}  = $fileHandler->{$if_name}{status} // '';
    $iface->{dev}     = $if_name;
    $iface->{vini}    = undef;
    $iface->{vlan}    = undef;
    $iface->{mac}     = $fileHandler->{$if_name}{mac} // undef;
    $iface->{type}    = &getInterfaceType($iface->{name});
    $iface->{parent}  = &getParentInterfaceName($iface->{name});

    if (not $ip_v and defined $iface->{addr}) {
        if ($iface->{addr} =~ /:/) {
            $ip_v = '6';
        }
        elsif ($iface->{addr} =~ /\./) {
            $ip_v = '4';
        }
    }

    $iface->{ip_v}    = $ip_v;
    $iface->{net}     = &getAddressNetwork($iface->{addr}, $iface->{mask}, $iface->{ip_v}) if $iface->{addr};
    $iface->{dhcp}    = $fileHandler->{$if_name}{dhcp} || 'false'                          if ($eload);
    $iface->{isolate} = $fileHandler->{$if_name}{isolate} // 'false'                       if ($eload);

    if ($iface->{dev} =~ /:/) {
        ($iface->{dev}, $iface->{vini}) = split(':', $iface->{dev});
    }

    if (!$iface->{name}) {
        $iface->{name} = $if_name;
    }

    # dot must be escaped
    if ($iface->{dev} =~ /./) {
        ($iface->{dev}, $iface->{vlan}) = split('\.', $iface->{dev});
    }

    $iface->{mac} = $socket->if_hwaddr($iface->{dev})
      if (!defined $iface->{mac});

    # Interfaces without ip do not get HW addr via socket,
    # in those cases get the MAC from the OS.
    unless ($iface->{mac}) {
        if (-f "/sys/class/net/$if_name/address") {
            open my $fh, '<', "/sys/class/net/$if_name/address";
            chomp($iface->{mac} = <$fh>);
            close $fh;
        }
    }

    if ($eload) {
        if ((!exists($iface->{vini}) || !defined($iface->{vini}) || $iface->{vini} eq '') && $iface->{addr}) {
            require Config::Tiny;
            my $float = Config::Tiny->read(&getGlobalConfiguration('floatfile'));
            $iface->{float} = $float->{_}{ $iface->{name} } // '';
        }
    }

    state $saved_bond_slaves = 0;

    if ($eload && $iface->{type} eq 'nic') {
        # not die if the appliance has not a certificate
        eval {
            unless ($saved_bond_slaves) {
                @TMP::bond_slaves = &eload(
                    module => 'Relianoid::EE::Net::Bonding',
                    func   => 'getAllBondsSlaves',
                );

                $saved_bond_slaves = 1;
            }
        };

        $iface->{is_slave} =
          (grep { $iface->{name} eq $_ } @TMP::bond_slaves) ? 'true' : 'false';
    }

    # for virtual interface, overwrite mask and gw with parent values
    if ($iface->{type} eq 'vini') {
        my $if_parent = &getInterfaceConfig($iface->{parent});
        $iface->{mask}    = $if_parent->{mask};
        $iface->{gateway} = $if_parent->{gateway};
    }

    return $iface;
}

=pod

=head1 getInterfaceConfigParam

Gets a hash reference of configuration params of a network interface.

Parameters:

    if_name    - Interface name.
    params_ref - Array ref of params

Returns:

    config_ref - Hash ref - Reference to a network interface config params hash ($config_ref).

=cut

sub getInterfaceConfigParam ($if_name, $params_ref) {
    my $config_ref;
    my $config_filename = &getInterfaceConfigFile($if_name);

    #Return undef if the file doesn't exists and the iface is not a NIC
    if (!-f $config_filename && $if_name =~ /\.|\:/) {
        return;
    }

    #Return undef if the file doesn't exists and the iface is a gre Tunnel
    if (!-f $config_filename && &getInterfaceType($if_name) eq 'gre') {
        return;
    }

    require Config::Tiny;
    my $if_config;
    if (!-f "$config_filename") {
        require Relianoid::File;
        createFile($config_filename);
        $if_config = Config::Tiny->new;
    }
    else {
        $if_config = Config::Tiny->read($config_filename);
    }

    for my $param (@{$params_ref}) {
        if (defined $if_config->{$if_name}{$param}) {
            $config_ref->{$param} = $if_config->{$if_name}{$param};
        }
        else {
            $config_ref->{$param} = undef;
        }
    }
    $config_ref->{name} = $if_name if not $config_ref->{name};
    return $config_ref;
}

=pod

=head1 setInterfaceConfig

Store a network interface configuration.

Parameters:

    if_ref - Reference to a network interface hash.

Returns:

    boolean - 1 on success, or 0 on failure.

=cut

sub setInterfaceConfig ($if_ref) {
    require Config::Tiny;

    my $fileHandle = Config::Tiny->new;
    if (ref $if_ref ne 'HASH') {
        &log_warn("Input parameter is not a hash reference", "NETWORK");
        return;
    }

    if (&debug() > 2) {
        require Data::Dumper;
        &log_debug3("setInterfaceConfig: " . Data::Dumper->Dumper($if_ref), "NETWORK");
    }

    my @if_params       = ('status', 'name', 'addr', 'mask', 'gateway', 'mac', 'dhcp', 'isolate');
    my $configdir       = &getGlobalConfiguration('configdir');
    my $config_filename = "$configdir/if_$$if_ref{name}_conf";

    if (!-f $config_filename) {
        require Relianoid::File;
        return 0 if (&createFile($config_filename));
    }

    $fileHandle = Config::Tiny->read($config_filename);

    for my $field (@if_params) {
        $fileHandle->{ $if_ref->{name} }{$field} = $if_ref->{$field};
    }

    if (!exists $fileHandle->{status}) {
        $fileHandle->{ $if_ref->{name} }{status} = $if_ref->{status} // "up";
    }

    return 0 if not $fileHandle->write($config_filename);

    return 1;
}

=pod

=head1 cleanInterfaceConfig

Remove the configuration information of a interface from its config file

Parameters:

    if_ref - Reference to a network interface hash.

Returns:

    Integer - 0 on success, or another value on failure.

=cut

sub cleanInterfaceConfig ($if_ref) {
    my $configdir = &getGlobalConfiguration('configdir');
    my $file      = "$configdir/if_$$if_ref{name}\_conf";
    my $err       = 0;

    if (!-f $file) {
        &log_info("The file $file has not been found", "NETWORK");
        return 1;
    }

    require Config::Tiny;
    my $fileHandler = Config::Tiny->new();
    $fileHandler = Config::Tiny->read($file);
    $fileHandler->{ $if_ref->{name} } = {
        mask    => "",
        status  => $fileHandler->{ $if_ref->{name} }{status},
        addr    => "",
        mac     => $if_ref->{mac},
        gateway => "",
        dhcp    => "false"
    };

    $fileHandler->write("$file");
    if (($$if_ref{name} ne $$if_ref{dev}) or ($$if_ref{type} eq 'gre')) {
        unlink($file) or return 1;
    }

    return $err;
}

=pod

=head1 getDevVlanVini

Get a hash reference with the interface name divided into: dev, vlan, vini.

Parameters:

    if_name - Interface name.

Returns:

    Reference to a hash with:

    dev  - NIC or Bonding part of the interface name.
    vlan - VLAN part of the interface name.
    vini - Virtual interface part of the interface name.

=cut

sub getDevVlanVini ($if_name) {
    my %if = (dev => $if_name);

    if ($if{dev} =~ /:/) {
        ($if{dev}, $if{vini}) = split ':', $if{dev};
    }

    if ($if{dev} =~ /\./)    # dot must be escaped
    {
        ($if{dev}, $if{vlan}) = split '\.', $if{dev};
    }

    return \%if;
}

=pod

=head1 getConfigInterfaceList

Get a reference to an array of all the interfaces saved in files.

Parameters:

    params_ref - Array ref of params. undef means all params

Returns:

    scalar - reference to array of configured interfaces.

=cut

sub getConfigInterfaceList ($params_ref = undef) {
    my @interfaces = ();
    my $configdir  = &getGlobalConfiguration('configdir');
    my @filenames  = ();

    if (opendir my $dir, $configdir) {
        @filenames = readdir $dir;
        closedir $dir;
    }
    else {
        &log_error("Error reading directory $configdir: $!", "NETWORK");
    }

    for my $filename (@filenames) {
        unless ($filename =~ /if_(.+)_conf/) {
            next;
        }

        my $if_name = $1;
        my $if_ref;

        if (defined $params_ref) {
            $if_ref = &getInterfaceConfigParam($if_name, $params_ref);
        }
        else {
            $if_ref = &getInterfaceConfig($if_name);
        }

        if (defined $if_ref) {
            push @interfaces, $if_ref;
        }
    }

    return \@interfaces;
}

=pod

=head1 getInterfaceSystemStatus

Get the status of an network interface in the system.

Parameters:

    if_ref - Reference to a network interface hash.

Returns:

    scalar - 'up' or 'down'.

=cut

sub getInterfaceSystemStatus ($if_ref) {
    my $parent_if_name = &getParentInterfaceName($if_ref->{name});
    my $status_if_name = $if_ref->{name};

    if (defined $if_ref->{vini} and length $if_ref->{vini}) {
        $status_if_name = $parent_if_name;
    }

    my $ip_bin    = &getGlobalConfiguration('ip_bin');
    my $ip_output = &logAndGet("$ip_bin link show $status_if_name");
    $ip_output =~ / state (\w+) /;
    my $if_status = lc $1;

    # if not up or down, ex: UNKNOWN
    if ($if_status !~ /^(?:up|down)$/) {
        my ($flags) = $ip_output =~ /<(.+)>/;
        my @flags = split(',', $flags);

        my $flag_up   = 0;
        my $flag_down = 0;
        for my $flag (@flags) {
            $flag_up++   if ($flag eq "UP");
            $flag_down++ if ($flag eq "NO-CARRIER");
        }
        if ($flag_up and not $flag_down) {
            $if_status = 'up';
        }
        else {
            $if_status = 'down';
        }
    }

    # Set as down vinis not available
    if (defined $if_ref->{vini} and length $if_ref->{vini}) {
        $ip_output = &logAndGet("$ip_bin addr show $status_if_name");
        if ($ip_output !~ /$if_ref->{addr}/) {
            return "down";
        }
    }

    # if it is not a virtual in down
    unless (defined $if_ref->{vini} and length $if_ref->{vini} and $if_ref->{status} eq 'down') {
        $if_ref->{status} = $if_status;
    }

    return $if_ref->{status} if $if_ref->{status} eq 'down';
    return $if_ref->{status} if !$parent_if_name;

    my $params        = [ "name", "addr", "status" ];
    my $parent_if_ref = &getInterfaceConfigParam($parent_if_name, $params);

    # vlans do not require the parent interface to be configured
    return $if_ref->{status} if !$parent_if_ref;

    return &getInterfaceSystemStatus($parent_if_ref);
}

=pod

=head1 getInterfaceSystemStatusAll

Get a hash of the status of all network interfaces in the system.

Parameters:

    none

Returns:

    Hash ref - Hash with name and status values.

=cut

sub getInterfaceSystemStatusAll () {
    my $ip_bin    = &getGlobalConfiguration('ip_bin');
    my $ip_output = &logAndGet("$ip_bin -o link", "array");
    my $links_ref;

    for my $link (@{$ip_output}) {
        if ($link =~ /^\d+: ([a-zA-Z0-9\-]+(?:\.\d{1,4})?)(?:@[a-zA-Z0-9\-]+)?: <(.+)> .+ state (\w+) /) {
            my $interface = $1;
            my $flag      = $2;
            my $status    = lc $3;

            if ($status ne "up" and $status ne "down") {
                my @flags     = split(',', $flag);
                my $flag_up   = 0;
                my $flag_down = 0;
                for my $flag (@flags) {
                    $flag_up++   if ($flag eq "UP");
                    $flag_down++ if ($flag eq "NO-CARRIER");
                }
                if ($flag_up and not $flag_down) {
                    $status = 'up';
                }
                else {
                    $status = 'down';
                }
            }
            $links_ref->{$interface} = $status;
        }
    }

    $ip_output = &logAndGet("$ip_bin -o addr", "array");
    my $addr_ref;
    for my $addr (@{$ip_output}) {
        if ($addr =~
            /^\d+: ([a-zA-Z0-9\-]+)(?:\.\d{1,4})?\s+(inet(?:\d)? (.*) (?:brd .*)?) scope .+ ([a-zA-Z0-9\-]+(?:\.\d{1,4})?:[a-zA-Z0-9\-]+)\\ /
          )
        {
            my $parent  = $1;
            my $virtual = $4;
            $addr_ref->{$virtual} = $links_ref->{$parent};
        }
    }
    $links_ref = { %{$links_ref}, %{$addr_ref} } if $addr_ref;
    return $links_ref;
}

=pod

=head1 getParentInterfaceName

    Get the parent interface name.

Parameters:

    if_name - Interface name.

Returns:

    string - Parent interface name or undef if there is no parent interface (NIC and Bonding).

=cut

sub getParentInterfaceName ($if_name) {
    my $if_ref = &getDevVlanVini($if_name);
    my $parent_if_name;

    my $is_vlan    = defined $if_ref->{vlan} && length $if_ref->{vlan};
    my $is_virtual = defined $if_ref->{vini} && length $if_ref->{vini};

    # child interface: eth0.100:virtual => eth0.100
    if ($is_virtual && $is_vlan) {
        $parent_if_name = "$$if_ref{dev}.$$if_ref{vlan}";
    }

    # child interface: eth0:virtual => eth0
    elsif ($is_virtual && !$is_vlan) {
        $parent_if_name = $if_ref->{dev};
    }

    # child interface: eth0.100 => eth0
    elsif (!$is_virtual && $is_vlan) {
        $parent_if_name = $if_ref->{dev};
    }

    # child interface: eth0 => undef
    elsif (!$is_virtual && !$is_vlan) {
        $parent_if_name = undef;
    }

    return $parent_if_name;
}

=pod

=head1 getActiveInterfaceList

Get a reference to a list of all running (up) and configured network interfaces.

Parameters: 
    none - .

Returns:

    scalar - reference to an array of network interface hashrefs.

=cut

sub getActiveInterfaceList () {
    my @configured_interfaces = @{ &getConfigInterfaceList() };

    # sort list
    @configured_interfaces =
      sort { $a->{name} cmp $b->{name} } @configured_interfaces;

    # apply device status heritage
    $_->{status} = &getInterfaceSystemStatus($_) for @configured_interfaces;

    # discard interfaces down
    @configured_interfaces =
      grep { $_->{status} eq 'up' } @configured_interfaces;

    # find maximun lengths for padding
    my $max_dev_length = 0;
    my $max_ip_length  = 0;

    for my $iface (@configured_interfaces) {
        if ($iface->{status} eq 'up') {
            next unless $iface->{addr};
            my $dev_length = length $iface->{name};
            $max_dev_length = $dev_length if $dev_length > $max_dev_length;

            my $ip_length = length $iface->{addr};
            $max_ip_length = $ip_length if $ip_length > $max_ip_length;
        }
    }

    # make padding
    for my $iface (@configured_interfaces) {
        next unless $iface->{addr};
        my $dev_ip_padded = sprintf("%-${max_dev_length}s -> %-${max_ip_length}s", $$iface{name}, $$iface{addr});
        $dev_ip_padded =~ s/ +$//;
        $dev_ip_padded =~ s/ /&nbsp;/g;

        $iface->{dev_ip_padded} = $dev_ip_padded;
    }

    return \@configured_interfaces;
}

=pod

=head1 getSystemInterfaceList

Get a reference to a list with all the interfaces, configured and not configured.

Parameters:

    none

Returns:

    scalar - reference to an array with configured and system network interfaces.

=cut

sub getSystemInterfaceList () {
    use IO::Interface qw(:flags);

    my @interfaces;    # output

    my @configured_interfaces;
    my $interface_ref = &getInterfaceNameStruct("vlan");

    for my $vlan (@{$interface_ref}) {
        my $if_ref = &getInterfaceConfig($vlan);
        push @configured_interfaces, $if_ref if $if_ref;
    }

    $interface_ref = &getInterfaceNameStruct("virtual");

    for my $virtual (@{$interface_ref}) {
        my $if_ref = &getInterfaceConfig($virtual);
        push @configured_interfaces, $if_ref if $if_ref;
    }

    my $socket            = IO::Socket::INET->new(Proto => 'udp');
    my @system_interfaces = &getInterfaceList();

    my $all_status = &getInterfaceSystemStatusAll();

    ## Build system device "tree"
    for my $if_name (sort @system_interfaces) {
        # ignore vlans and vinis
        next if $if_name =~ /\./;
        next if $if_name =~ /:/;

        # ignore loopback device
        next if $if_name =~ /^lo$/;

        # ignore fallback device from ip_gre module
        next if $if_name =~ /^gre0$|^gretap0$|^erspan0$/;

        # ignore fallback device from ip6_gre module
        next if $if_name =~ /^ip6gre0$|^ip6tnl0$/;

        # ignore fallback device from sit module
        next if $if_name =~ /^sit0$/;

        # ignore fallback device from ip_vti module
        #next if $if_name =~ /^ip_vti0$/;
        # ignore fallback device from ipip module
        #next if $if_name =~ /^tunl0$/;

        my $if_ref;
        my $if_flags = $socket->if_flags($if_name);

        my %if_parts = %{ &getDevVlanVini($if_name) };

        # run for IPv4 and IPv6
        $if_ref = &getInterfaceConfig($if_name);

        if (!$$if_ref{addr}) {
            # populate not configured interface
            $$if_ref{status} = ($if_flags & IFF_UP) ? "up" : "down";
            $$if_ref{mac}    = $socket->if_hwaddr($if_name);
            $$if_ref{name}   = $if_name;
            $$if_ref{addr}   = '';
            $$if_ref{mask}   = '';
            $$if_ref{dev}    = $if_parts{dev};
            $$if_ref{vlan}   = $if_parts{vlan};
            $$if_ref{vini}   = $if_parts{vini};
            $$if_ref{ip_v}   = '';
            $$if_ref{type}   = &getInterfaceType($if_name);
        }

        if (!($if_flags & IFF_RUNNING) && ($if_flags & IFF_UP)) {
            $$if_ref{link} = "off";
        }

        $if_ref->{status} = $all_status->{ $if_ref->{name} };

        # add interface to the list
        push(@interfaces, $if_ref);

        # add vlans and virtuals belonging the dev
        for my $if_conf (@configured_interfaces) {
            next if $if_conf->{dev} ne $if_ref->{dev};
            next if not $if_conf->{parent};

            $if_conf->{status} = $all_status->{ $if_conf->{name} };
            push(@interfaces, $if_conf);
        }
    }

    return \@interfaces;
}

=pod

=head1 getSystemInterface

Get a reference to a network interface hash from the system configuration, not the stored configuration.

Parameters:

    if_name - Interface name.

Returns:

    scalar - reference to a network interface hash as is on the system or undef if not found.

See Also:

    <getInterfaceConfig>, <setInterfaceConfig>

=cut

sub getSystemInterface ($if_name) {
    my $if_ref = { name => $if_name };

    use IO::Interface qw(:flags);

    my %if_parts = %{ &getDevVlanVini($$if_ref{name}) };
    my $socket   = IO::Socket::INET->new(Proto => 'udp');
    my $if_flags = $socket->if_flags($$if_ref{name});

    $$if_ref{mac} = $socket->if_hwaddr($$if_ref{name});
    return if not $$if_ref{mac};

    $$if_ref{status} = ($if_flags & IFF_UP) ? "up" : "down";
    $$if_ref{addr}   = '';
    $$if_ref{mask}   = '';
    $$if_ref{dev}    = $if_parts{dev};
    $$if_ref{vlan}   = $if_parts{vlan};
    $$if_ref{vini}   = $if_parts{vini};
    $$if_ref{type}   = &getInterfaceType($$if_ref{name});
    $$if_ref{parent} = &getParentInterfaceName($$if_ref{name});

    state $saved_bond_slaves = 0;

    if ($eload && $$if_ref{type} eq 'nic') {
        # not die if the appliance has not a certificate
        eval {
            unless ($saved_bond_slaves) {
                @TMP::bond_slaves = &eload(
                    module => 'Relianoid::EE::Net::Bonding',
                    func   => 'getAllBondsSlaves',
                );

                $saved_bond_slaves = 1;
            }
        };

        $$if_ref{is_slave} =
          (grep { $$if_ref{name} eq $_ } @TMP::bond_slaves) ? 'true' : 'false';
    }

    return $if_ref;
}

=pod

=head1 getInterfaceType

Get the type of a network interface from its name using linux 'hints'.

Original source code in bash:

http://stackoverflow.com/questions/4475420/detect-network-connection-type-in-linux

Translated to perl and adapted by Relianoid

Interface types: nic, virtual, vlan, bond, dummy or lo.

Parameters:

    if_name - Interface name.

Returns:

    scalar - Interface type: nic, virtual, vlan, bond, dummy or lo.

=cut

sub getInterfaceType ($if_name) {
    my $type;

    if (!defined $if_name || $if_name eq '') {
        return;
    }

    # interface for cluster when is in maintenance mode
    return 'dummy' if $if_name eq 'cl_maintenance';

    # interfaces added by ip_gre module
    if (   $if_name eq 'gre0'
        or $if_name eq 'gretap0'
        or $if_name eq 'erspan0')
    {
        return 'ip_gre_fallback';
    }

    # interfaces added by ip6_gre module
    return 'ip6_gre_fallback' if $if_name eq 'ip6gre0';

    # interfaces added by ip6_tunnel module
    #return 'ip6_tunnel_fallback' if $if_name eq 'ip6tnl0';
    # interfaces added by ip6_vti module
    #return 'ip6_vti_fallback' if $if_name eq 'ip_vti0';
    # interfaces added by sit module
    #return 'sit_fallback' if $if_name eq 'sit0';
    # interfaces added by ipip module
    #return 'ipip_fallback' if $if_name eq 'tunl0';

    if (!-d "/sys/class/net/$if_name") {
        my $configdir = &getGlobalConfiguration('configdir');
        my $found     = (-f "$configdir/if_${if_name}_conf" && $if_name =~ /^.+\:.+$/);

        if (!$found) {
            my ($parent_if) = split(':', $if_name);
            my $quoted_if   = quotemeta $if_name;
            my $ip_bin      = &getGlobalConfiguration('ip_bin');
            my @out         = @{ &logAndGet("$ip_bin addr show $parent_if", "array") };

            $found = grep { /inet .+ $quoted_if$/ } @out;
        }

        if ($found) {
            return 'virtual';
        }
        else {
            # vpn interfaces that are being deleted will exit here
            # return an empty string to be able to compare with strings
            return '';
        }
    }

    my $code;    # read type code
    {
        my $if_type_filename = "/sys/class/net/$if_name/type";

        if (open(my $fh, '<', $if_type_filename)) {
            chomp($code = <$fh>);
            close $fh;
        }
        else {
            log_error("Could not open file ${if_type_filename}: $!");
            return;
        }
    }

    if ($code == 1) {
        $type = 'nic';

        # Ethernet, may also be wireless, ...
        if (-f "/proc/net/vlan/$if_name") {
            $type = 'vlan';
        }
        elsif (-d "/sys/class/net/$if_name/bonding") {
            $type = 'bond';
        }

        #elsif ( -d "/sys/class/net/$if_name/wireless" || -l "/sys/class/net/$if_name/phy80211" )
        #{
        #	$type = 'wlan';
        #}
        #elsif ( -d "/sys/class/net/$if_name/bridge" )
        #{
        #	$type = 'bridge';
        #}
        #elsif ( -f "/sys/class/net/$if_name/tun_flags" )
        #{
        #	$type = 'tap';
        #}
        #elsif ( -d "/sys/devices/virtual/net/$if_name" )
        #{
        #	$type = 'dummy' if $if_name =~ /^dummy/;
        #}
    }
    elsif ($code == 24) {
        $type = 'nic';    # firewire ;; # IEEE 1394 IPv4 - RFC 2734
    }
    elsif ($code == 32) {
        if (-d "/sys/class/net/$if_name/bonding") {
            $type = 'bond';
        }

        #elsif ( -d "/sys/class/net/$if_name/create_child" )
        #{
        #	$type = 'ib';
        #}
        #else
        #{
        #	$type = 'ibchild';
        #}
    }

    elsif ($code == 512) {
        $type = 'ppp';    # PPP
    }

    #elsif ( $code == 768 )
    #{
    #	$type = 'ipip';    # IPIP tunnel
    #}
    #elsif ( $code == 769 )
    #{
    #	$type = 'ip6tnl';    # IP6IP6 tunnel
    #}
    elsif ($code == 772) { $type = 'lo'; }

    #elsif ( $code == 776 )
    #{
    #	$type = 'sit';       # sit0 device - IPv6-in-IPv4
    #}
    elsif ($code == 778) {
        $type = 'gre';    # GRE over IP
    }

    #elsif ( $code == 783 )
    #{
    #	$type = 'irda';      # Linux-IrDA
    #}
    #elsif ( $code == 801 )   { $type = 'wlan_aux'; }
    #elsif ( $code == 65534 ) { $type = 'tun'; }

    # The following case statement still has to be replaced by something
    # which does not rely on the interface names.
    # case $if_name in
    # 	ippp*|isdn*) type=isdn;;
    # 	mip6mnha*)   type=mip6mnha;;
    # esac

    return $type if defined $type;

    my $msg = "Could not recognize the type of the interface $if_name.";

    &log_error($msg, "NETWORK");

    return;
}

=pod

=head1 getInterfaceTypeList

Get a list of hashrefs with interfaces of a single type.

Types supported are: nic, bond, vlan, virtual and gre.

Parameters:

    list_type - Network interface type.
    iface_name - Interface name

Returns:

    list - list of network interfaces hashrefs.

=cut

sub getInterfaceTypeList ($list_type, $iface_name = undef) {
    my @interfaces = ();

    if (grep { $list_type eq $_ } qw(nic bond vlan gre)) {
        my @system_interfaces;

        if ($iface_name) {
            push @system_interfaces, $iface_name;
        }
        else {
            @system_interfaces = sort &getInterfaceList();
        }

        for my $if_name (@system_interfaces) {
            if ($list_type eq &getInterfaceType($if_name)) {
                my $output_if = &getInterfaceConfig($if_name);

                if (   !$output_if
                    || !$output_if->{mac}
                    || (defined $output_if->{is_slave} && $output_if->{is_slave} eq 'true'))
                {
                    $output_if = &getSystemInterface($if_name);
                }

                push(@interfaces, $output_if);
            }
        }
    }
    elsif ($list_type eq 'virtual') {
        require Relianoid::Validate;

        opendir my $conf_dir, &getGlobalConfiguration('configdir');
        my $virt_if_re = &getValidFormat('virt_interface');

        my $parents_list;
        for my $file_name (sort readdir $conf_dir) {
            if ($file_name =~ /^if_($virt_if_re)_conf$/) {
                my $if_name = $1;
                next if ($iface_name and ($iface_name ne $if_name));
                my $iface = &getInterfaceConfig($if_name);

                #$iface->{status} = &getInterfaceSystemStatus( $iface );

                # put the mac, gateway and netmask of the parent interface
                if (not defined $parents_list->{ $iface->{parent} }) {
                    $parents_list->{ $iface->{parent} } =
                      &getInterfaceConfig($iface->{parent});
                }
                $iface->{mask}    = $parents_list->{ $iface->{parent} }{mask};
                $iface->{mac}     = $parents_list->{ $iface->{parent} }{mac};
                $iface->{gateway} = $parents_list->{ $iface->{parent} }{gateway};
                push(@interfaces, $iface);
            }
        }
    }
    else {
        my $msg = "Interface type '$list_type' is not supported.";
        &log_error($msg, "NETWORK");
        die($msg);
    }

    return @interfaces;
}

=pod

=head1 getAppendInterfaces

Get vlans or virtual interfaces configured from a interface.
If the interface is a nic or bonding, this function return the virtual interfaces
create from the VLANs, for example: eth0.2:virt

Parameters:

    ifaceName - Interface name.
    type - Interface type: vlan or virtual.

Returns:

    scalar - reference to an array of interfaces names.

=cut

# Get vlan or virtual interfaces appended from a interface
sub getAppendInterfaces ($if_parent, $type) {
    my @output      = ();
    my @list        = &getInterfaceList();
    my $vlan_tag    = &getValidFormat('vlan_tag');
    my $virtual_tag = &getValidFormat('virtual_tag');

    for my $if (@list) {
        if ($type eq 'vlan') {
            push @output, $if if ($if =~ /^$if_parent\.$vlan_tag$/);
        }

        if ($type eq 'virtual') {
            push @output, $if
              if ($if =~ /^$if_parent(?:\.$vlan_tag)?\:$virtual_tag$/);
        }
    }

    return \@output;
}

=pod

=head1 getInterfaceList

Return a list of all network interfaces detected in the system.

Parameters:

    None.

Returns:

    array - list of network interface names.
    array empty - if no network interface is detected.

See Also:

    <listActiveInterfaces>

=cut

sub getInterfaceList () {
    my @if_list = ();
    push @if_list, &getLinkNameList();
    push @if_list, &getVirtualInterfaceNameList();
    return @if_list;
}

=pod

=head1 getVirtualInterfaceNameList

Get a list of the virtual interfaces names.

Parameters:

    none - .

Returns:

    list - Every virtual interface name.

=cut

sub getVirtualInterfaceNameList () {
    require Relianoid::Validate;

    opendir(my $conf_dir, &getGlobalConfiguration('configdir'));
    my $virt_if_re = &getValidFormat('virt_interface');
    my @interfaces;

    for my $filename (readdir($conf_dir)) {
        push @interfaces, $1 if ($filename =~ /^if_($virt_if_re)_conf$/);
    }

    closedir($conf_dir);

    return @interfaces;
}

=pod

=head1 getLinkInterfaceNameList

Get a list of the link interfaces names. (nic, bond and vlan)

Parameters:

    none - .

Returns:

    list - Every link interface name.

=cut

sub getLinkNameList () {
    my $sys_net_dir = &getGlobalConfiguration('sys_net_dir');

    # Get link interfaces (nic, bond and vlan)
    opendir(my $if_dir, $sys_net_dir);
    my @if_list = grep { -l "$sys_net_dir/$_" } readdir $if_dir;
    closedir $if_dir;

    return @if_list;
}

=pod

=head1 getInterfaceNameStruct

Get a struct configured interfaces names.

Parameters:

    $if_type - Type of interface. nic, bonding, vlan,virtual.

Returns:

    Hash ref - Struct of every interface name divided by type or List if type param is defined.

=cut

sub getInterfaceNameStruct ($if_type = undef) {
    my $interfaces_ref;

    my $bonding_struct;
    if ($eload) {
        my $params = ["name"];
        $bonding_struct = &eload(
            module => 'Relianoid::EE::Net::Bonding',
            func   => 'getBondListStruct',
            args   => [$params]
        );
    }

    opendir(my $conf_dir, &getGlobalConfiguration('configdir'));
    for my $filename (readdir($conf_dir)) {
        if ($filename =~ /^if_([a-zA-Z0-9\-]+)(?:\.(\d{1,4}))?(?:\:([a-zA-Z0-9\-]+))?_conf$/) {
            my $interface = $1;
            my $tag       = $2;
            my $virtual   = $3;

            my $type = "nic";

            if ($eload) {
                $type = "bond" if (exists $bonding_struct->{$interface});
            }

            if (defined $virtual) {
                if (defined $if_type) {
                    $interface .= ".$tag" if (defined $tag);
                    push @{$interfaces_ref}, "$interface:$virtual"
                      if ($if_type eq "virtual");
                }
                elsif (defined $tag) {
                    $interfaces_ref->{$type}{$interface}{vlan}{$tag}{virtual}{$virtual} =
                      undef;
                }
                else {
                    if (not exists $interfaces_ref->{$type}{$interface}{virtual}{$virtual}) {
                        $interfaces_ref->{$type}{$interface}{virtual}{$virtual} = undef;
                    }
                }
            }
            else {
                if (defined $tag) {
                    if (defined $if_type) {
                        push @{$interfaces_ref}, "$interface.$tag"
                          if ($if_type eq "vlan");
                        next;
                    }
                    elsif (not exists $interfaces_ref->{$type}{$interface}{vlan}{$tag}) {
                        $interfaces_ref->{$type}{$interface}{vlan}{$tag} = undef;
                    }
                }
                else {
                    if (defined $if_type) {
                        push @{$interfaces_ref}, $interface
                          if ($if_type eq $type);
                        next;
                    }
                    elsif (not exists $interfaces_ref->{$type}{$interface}) {
                        $interfaces_ref->{$type}{$interface} = undef;
                    }
                }
            }
        }
    }
    closedir($conf_dir);

    return $interfaces_ref;
}

=pod

=head1 getInterfaceByIp

Ask for the name of the interface using the IP address

Parameters:

    IP - IP address

Returns:

    String - Interface name

=cut

sub getInterfaceByIp ($ip) {
    require Relianoid::Net::Validate;

    my $output         = "";
    my $ip_ver         = &ipversion($ip);
    my $addr_ref       = NetAddr::IP->new($ip);
    my $params         = [ "name", "addr" ];
    my $interface_list = &getConfigInterfaceList($params);

    if ($ip_ver == 4) {
        for my $if_ref (@{$interface_list}) {
            if (    $if_ref->{addr}
                and $if_ref->{addr} eq $ip
                and &ipversion($if_ref->{addr}) eq $ip_ver)
            {
                $output = $if_ref->{name};
                last;
            }
        }
    }
    elsif ($ip_ver == 6) {
        for my $if_ref (@{$interface_list}) {
            if (NetAddr::IP->new($if_ref->{addr}) eq $addr_ref) {
                $output = $if_ref->{name};
                last;
            }
        }
    }

    return $output;
}

=pod

=head1 getIpAddressExists

Return if an IP address is used on any interface

Parameters:

    IP - IP address

Returns:

    Integer - 0 if it doesn't exist or 1 if the IP already exists

=cut

sub getIpAddressExists ($ip) {
    require Relianoid::Net::Validate;

    my $output         = 0;
    my $ip_ver         = &ipversion($ip);
    my $params         = ["addr"];
    my $interface_list = &getConfigInterfaceList($params);

    if ($ip_ver == 4) {
        for my $if_ref (@{$interface_list}) {
            if (    $if_ref->{addr}
                and $if_ref->{addr} eq $ip
                and &ipversion($if_ref->{addr}) eq $ip_ver)
            {
                $output = 1;
                last;
            }
        }
    }
    elsif ($ip_ver == 6) {
        my $addr_ref = NetAddr::IP->new($ip);
        for my $if_ref (@{$interface_list}) {
            if (NetAddr::IP->new($if_ref->{addr}) eq $addr_ref) {
                $output = 1;
                last;
            }
        }
    }

    return $output;
}

=pod

=head1 getIpAddressList

It returns a list with the IPv4 and IPv6 that exist in the system

Parameters:

    none

Returns:

    Array ref - List of IPs

=cut

sub getIpAddressList () {
    my @out    = ();
    my $params = ["addr"];
    for my $if_ref (@{ &getConfigInterfaceList($params) }) {
        if ($if_ref->{addr}) {
            push @out, $if_ref->{addr};
        }
    }

    return \@out;
}

=pod

=head1 getInterfaceChild

Show the interfaces that depends directly of the interface.
From a nic, bonding and VLANs interfaces depend the virtual interfaces.
From a virtual interface depends the floating interfaces.

Parameters:

    string - Interface name.

Returns:

    array - List of interface names.

=cut

sub getInterfaceChild ($if_name) {
    unless (length $if_name) {
        croak('required non-empty string');
    }

    my $if_type = &getInterfaceType($if_name);

    unless (defined $if_type) {
        croak('Network interface not found');
    }

    my @output      = ();
    my $virtual_tag = &getValidFormat('virtual_tag');

    # show floating interfaces used by this virtual interface
    if ($if_type eq 'virtual') {
        if ($eload) {
            require Config::Tiny;
            my $float = Config::Tiny->read(&getGlobalConfiguration('floatfile'));

            for my $iface (keys %{ $float->{_} }) {
                push @output, $iface if ($float->{_}{$iface} eq $if_name);
            }
        }
    }

    # the other type of interfaces can have virtual interfaces as child
    # vlan, bond and nic
    else {
        push @output, grep { "${if_name}:${virtual_tag}" eq $_ } &getVirtualInterfaceNameList();
    }

    return @output;
}

=pod

=head1 getAddressNetwork

Parameters:

    $addr - string - IP address.
    $mask - string or number.
    $ip_v - IP version 4 or 6, optional.

Returns:

    string

=cut

sub getAddressNetwork ($addr, $mask, $ip_v = undef) {
    require NetAddr::IP;
    require Scalar::Util;

    my $net;

    if (not Scalar::Util::looks_like_number($ip_v)) {
        $net  = undef;
        $ip_v = ipversion($addr);
    }

    if ($ip_v == 4) {
        my $ip = NetAddr::IP->new($addr, $mask);
        $net = lc $ip->network()->addr();
    }
    elsif ($ip_v == 6) {
        my $ip = NetAddr::IP->new6($addr, $mask);
        $net = lc $ip->network()->addr();
    }

    return $net;
}

=pod

=head1 get_interface_list_struct

Parameters:

    none

Returns:

    reference to a list of interface hashes

=cut

sub get_interface_list_struct () {
    require Relianoid::User;

    my @output_list;

    # Configured interfaces list
    my @interfaces = @{ &getSystemInterfaceList() };    #140

    # get cluster interfaces
    my $cluster_if;

    if ($eload) {
        $cluster_if = &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'getClusterInterfaces',     # 100
        );
    }

    my $rbac_mod;
    my $rbac_if_list = [];
    my $user         = &getUser();

    if ($eload && ($user ne 'root')) {
        $rbac_mod     = 1;
        $rbac_if_list = &eload(
            module => 'Relianoid::EE::RBAC::Group::Core',    # 100
            func   => 'getRBACUsersResources',
            args   => [ $user, 'interfaces' ],
        );
    }

    # to include 'has_vlan' to nics
    my $interfaces_ref = &getInterfaceNameStruct();

    my $all_status = &getInterfaceSystemStatusAll();
    for my $if_ref (@interfaces) {
        # Exclude cluster maintenance interface
        next if $if_ref->{type} eq 'dummy';

        # Exclude no user's virtual interfaces, but pass the physical ones
        next if ($rbac_mod
             && ($if_ref->{type} ne 'virtual' || !grep { $if_ref->{name} eq $_ } @{$rbac_if_list})
             && ($if_ref->{type} eq 'virtual'));

        $if_ref->{status} = $all_status->{ $if_ref->{name} };

        # Any key must cotain a value or "" but can't be null
        if (!defined $if_ref->{name})    { $if_ref->{name}    = ""; }
        if (!defined $if_ref->{addr})    { $if_ref->{addr}    = ""; }
        if (!defined $if_ref->{mask})    { $if_ref->{mask}    = ""; }
        if (!defined $if_ref->{gateway}) { $if_ref->{gateway} = ""; }
        if (!defined $if_ref->{status})  { $if_ref->{status}  = ""; }
        if (!defined $if_ref->{mac})     { $if_ref->{mac}     = ""; }

        my $if_conf = {
            name    => $if_ref->{name},
            ip      => $if_ref->{addr},
            netmask => $if_ref->{mask},
            gateway => $if_ref->{gateway},
            status  => $if_ref->{status},
            mac     => $if_ref->{mac},
            type    => $if_ref->{type},
            # ipv     => $if_ref->{ip_v},
        };

        if ($eload and $if_ref->{type} ne 'virtual') {
            $if_conf->{dhcp} = $if_ref->{dhcp};
        }

        if ($if_ref->{type} eq 'nic') {
            my @bond_slaves = ();

            @bond_slaves = &eload(
                module => 'Relianoid::EE::Net::Bonding',
                func   => 'getAllBondsSlaves',
            ) if ($eload);

            $if_conf->{is_slave} = (grep { $$if_ref{name} eq $_ } @bond_slaves) ? 'true' : 'false';

            if (exists $interfaces_ref->{ $if_ref->{type} }{ $if_ref->{name} }{vlan}) {
                $if_conf->{has_vlan} = 'true';
            }
            $if_conf->{has_vlan} = 'false' unless $if_conf->{has_vlan};
        }

        if ($cluster_if && @{$cluster_if} && grep { $if_ref->{name} eq $_ } @{$cluster_if}) {
            $if_conf->{is_cluster} = 'true';
        }

        push @output_list, $if_conf;
    }

    if ($eload) {
        my $out = \@output_list;
        $out = &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'addAliasInterfaceStruct',
            args   => [$out],
        );
    }
    return \@output_list;
}

=pod

=head1 get_nic_struct

Parameters:

    $nic - NIC interface name

Returns:

    reference to a nic interface hash

=cut

sub get_nic_struct ($nic) {
    my $interface;
    my @nic_list = &getInterfaceTypeList('nic', $nic);
    my $if_ref   = $nic_list[0];

    $if_ref->{status} = &getInterfaceSystemStatus($if_ref);

    # Any key must contain a value or "" but can't be null
    if (!defined $if_ref->{name})    { $if_ref->{name}    = ""; }
    if (!defined $if_ref->{addr})    { $if_ref->{addr}    = ""; }
    if (!defined $if_ref->{mask})    { $if_ref->{mask}    = ""; }
    if (!defined $if_ref->{gateway}) { $if_ref->{gateway} = ""; }
    if (!defined $if_ref->{status})  { $if_ref->{status}  = ""; }
    if (!defined $if_ref->{mac})     { $if_ref->{mac}     = ""; }

    $interface = {
        name    => $if_ref->{name},
        ip      => $if_ref->{addr},
        netmask => $if_ref->{mask},
        gateway => $if_ref->{gateway},
        status  => $if_ref->{status},
        mac     => $if_ref->{mac},
    };

    $interface->{is_slave} = $if_ref->{is_slave} if $eload;
    $interface->{dhcp}     = $if_ref->{dhcp}     if $eload;
    if ($eload) {
        $interface = &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'addAliasInterfaceStruct',
            args   => [$interface],
        );
    }

    return $interface;
}

=pod

=head1 get_nic_list_struct

Parameters:

    none

Returns:

    reference to a list of interface hashes of nics

=cut

sub get_nic_list_struct () {
    my $interface_ref = &getInterfaceNameStruct();
    my $all_status    = &getInterfaceSystemStatusAll();
    my $cluster_if;
    my @output_list;

    if ($eload) {
        $cluster_if = &eload(module => 'Relianoid::EE::Cluster', func => 'getClusterInterfaces');
    }

    for my $if_ref (&getInterfaceTypeList('nic')) {
        $if_ref->{status} = $all_status->{ $if_ref->{name} };

        # Any key must cotain a value or "" but can't be null
        if (!defined $if_ref->{name})    { $if_ref->{name}    = ""; }
        if (!defined $if_ref->{addr})    { $if_ref->{addr}    = ""; }
        if (!defined $if_ref->{mask})    { $if_ref->{mask}    = ""; }
        if (!defined $if_ref->{gateway}) { $if_ref->{gateway} = ""; }
        if (!defined $if_ref->{status})  { $if_ref->{status}  = ""; }
        if (!defined $if_ref->{mac})     { $if_ref->{mac}     = ""; }

        my $if_conf = {
            name    => $if_ref->{name},
            ip      => $if_ref->{addr},
            netmask => $if_ref->{mask},
            gateway => $if_ref->{gateway},
            status  => $if_ref->{status},
            mac     => $if_ref->{mac},
        };

        if ($eload) {
            $if_conf = &eload(
                module => 'Relianoid::EE::Alias',
                func   => 'addAliasInterfaceStruct',
                args   => [$if_conf],
            );
        }

        $if_conf->{is_slave} = $if_ref->{is_slave}        if $eload;
        $if_conf->{dhcp}     = $if_ref->{dhcp} // 'false' if $eload;

        if (    $cluster_if
            and @{$cluster_if}
            and grep { defined $_ and $if_ref->{name} eq $_ } @{$cluster_if})
        {
            $if_conf->{is_cluster} = 'true';
        }

        if (exists $interface_ref->{nic}{ $if_ref->{name} }{vlan}) {
            $if_conf->{has_vlan} = 'true';
        }

        $if_conf->{has_vlan} = 'false' unless $if_conf->{has_vlan};

        push @output_list, $if_conf;
    }

    return \@output_list;
}

=pod

=head1 get_vlan_struct

Parameters:

    $vlan - VLAN interface name

Returns:

    reference to a VLAN interface hash

=cut

sub get_vlan_struct ($vlan) {
    my @vlan_list = &getInterfaceTypeList('vlan', $vlan);
    my $interface = $vlan_list[0];

    return unless $interface;

    $interface->{status} = &getInterfaceSystemStatus($interface);

    # Any key must contain a value or "" but can't be null
    if (!defined $interface->{name})    { $interface->{name}    = ""; }
    if (!defined $interface->{addr})    { $interface->{addr}    = ""; }
    if (!defined $interface->{mask})    { $interface->{mask}    = ""; }
    if (!defined $interface->{gateway}) { $interface->{gateway} = ""; }
    if (!defined $interface->{status})  { $interface->{status}  = ""; }
    if (!defined $interface->{mac})     { $interface->{mac}     = ""; }

    my $output = {
        name    => $interface->{name},
        ip      => $interface->{addr},
        netmask => $interface->{mask},
        gateway => $interface->{gateway},
        status  => $interface->{status},
        mac     => $interface->{mac},
    };

    if ($eload) {
        $output = &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'addAliasInterfaceStruct',
            args   => [$output],
        );
    }
    $output->{dhcp} = $interface->{dhcp} // 'false' if $eload;

    return $output;
}

=pod

=head1 get_vlan_list_struct

Parameters:

    none

Returns:

    reference to a list of interface hashes of VLANs

=cut

sub get_vlan_list_struct () {
    my @output_list;
    my $cluster_if;

    if ($eload) {
        # get cluster interfaces
        $cluster_if = &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'getClusterInterfaces',
        );
    }

    my $all_status = &getInterfaceSystemStatusAll();
    for my $if_ref (&getInterfaceTypeList('vlan')) {
        $if_ref->{status} = $all_status->{ $if_ref->{name} };

        # Any key must cotain a value or "" but can't be null
        if (!defined $if_ref->{name})    { $if_ref->{name}    = ""; }
        if (!defined $if_ref->{addr})    { $if_ref->{addr}    = ""; }
        if (!defined $if_ref->{mask})    { $if_ref->{mask}    = ""; }
        if (!defined $if_ref->{gateway}) { $if_ref->{gateway} = ""; }
        if (!defined $if_ref->{status})  { $if_ref->{status}  = ""; }
        if (!defined $if_ref->{mac})     { $if_ref->{mac}     = ""; }

        my $if_conf = {
            name    => $if_ref->{name},
            ip      => $if_ref->{addr},
            netmask => $if_ref->{mask},
            gateway => $if_ref->{gateway},
            status  => $if_ref->{status},
            mac     => $if_ref->{mac},
            parent  => $if_ref->{parent},
        };

        if ($eload) {
            $if_conf = &eload(
                module => 'Relianoid::EE::Alias',
                func   => 'addAliasInterfaceStruct',
                args   => [$if_conf],
            );
        }
        $if_conf->{dhcp} = $if_ref->{dhcp} // 'false' if $eload;

        if ($cluster_if && @{$cluster_if} && (grep { $if_ref->{name} eq $_ } @{$cluster_if})) {
            $if_conf->{is_cluster} = 'true';
        }

        push @output_list, $if_conf;
    }

    return \@output_list;
}

=pod

=head1 get_virtual_struct

Parameters:

    $virtual - Virtual interface name

Returns:

    reference to a Virtual interface hash

=cut

sub get_virtual_struct ($virtual) {
    my @virtual_list = &getInterfaceTypeList('virtual', $virtual);
    my $interface    = $virtual_list[0];

    return unless $interface;

    $interface->{status} = &getInterfaceSystemStatus($interface);

    # Any key must contain a value or "" but can't be null
    if (!defined $interface->{name})    { $interface->{name}    = ""; }
    if (!defined $interface->{addr})    { $interface->{addr}    = ""; }
    if (!defined $interface->{mask})    { $interface->{mask}    = ""; }
    if (!defined $interface->{gateway}) { $interface->{gateway} = ""; }
    if (!defined $interface->{status})  { $interface->{status}  = ""; }
    if (!defined $interface->{mac})     { $interface->{mac}     = ""; }

    my $output = {
        name    => $interface->{name},
        ip      => $interface->{addr},
        netmask => $interface->{mask},
        gateway => $interface->{gateway},
        status  => $interface->{status},
        mac     => $interface->{mac},
    };

    if ($eload) {
        $output = &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'addAliasInterfaceStruct',
            args   => [$output],
        );
    }

    return $output;
}

=pod

=head1 get_virtual_list_struct

Parameters:

    none

Returns:

    reference to a list of virtual interface hashes

=cut

sub get_virtual_list_struct () {
    my @output_list = ();
    my $all_status  = &getInterfaceSystemStatusAll();
    for my $if_ref (&getInterfaceTypeList('virtual')) {
        $if_ref->{status} = $all_status->{ $if_ref->{name} };

        # Any key must cotain a value or "" but can't be null
        if (!defined $if_ref->{name})    { $if_ref->{name}    = ""; }
        if (!defined $if_ref->{addr})    { $if_ref->{addr}    = ""; }
        if (!defined $if_ref->{mask})    { $if_ref->{mask}    = ""; }
        if (!defined $if_ref->{gateway}) { $if_ref->{gateway} = ""; }
        if (!defined $if_ref->{status})  { $if_ref->{status}  = "down"; }
        if (!defined $if_ref->{mac})     { $if_ref->{mac}     = ""; }

        push @output_list,
          {
            name    => $if_ref->{name},
            ip      => $if_ref->{addr},
            netmask => $if_ref->{mask},
            gateway => $if_ref->{gateway},
            status  => $if_ref->{status},
            mac     => $if_ref->{mac},
            parent  => $if_ref->{parent},
          };
    }

    if ($eload) {
        my $out = \@output_list;
        $out = &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'addAliasInterfaceStruct',
            args   => [$out],
        );
    }

    return \@output_list;
}

=pod

=head1 setVlan

Store a VLAN network interface configuration.

Parameters:

    if_ref - Reference to a network interface hash.
    params - Reference to the hash of params to modify.

Returns:

    boolean - 0 on success, or 1 on failure.

=cut

sub setVlan ($if_ref, $params) {
    my $err = 0;

    require Relianoid::Net::Core;
    require Relianoid::Net::Route;

    my $oldIf_ref = &getInterfaceConfig($if_ref->{name});

    if ($if_ref->{dhcp} and $if_ref->{dhcp} eq "true") {
        $if_ref->{addr}    = "";
        $if_ref->{net}     = "";
        $if_ref->{mask}    = "";
        $if_ref->{gateway} = "";
    }

    if (length $if_ref->{mac} == 0) {
        my $parent_if_name = &getParentInterfaceName($if_ref->{name});
        my $parent_config  = &getInterfaceConfig($parent_if_name);

        $if_ref->{mac} = $parent_config->{mac};
    }

    # Creating a new interface
    if (!defined $oldIf_ref) {
        $err = &createVlan($if_ref);
        return 1 if $err;
    }

    # Modifying
    my $oldAddr;

    # Add new IP, netmask and gateway
    if ($if_ref->{addr} and length $if_ref->{addr}) {
        return 1 if &addIp($if_ref);
        return 1 if &writeRoutes($if_ref->{name});

        $oldAddr = $oldIf_ref->{addr};
    }

    my $state = 1;

    if ($if_ref->{status} eq 'up') {
        $state = &upIf($if_ref, 1);
    }

    return 1 if not &setInterfaceConfig($if_ref);

    if ($state == 0) {
        $if_ref->{status} = "up";

        if ($if_ref->{addr}) {
            return 1 if &applyRoutes("local", $if_ref);
        }
    }

    if ($eload && exists $params->{mac}) {
        if (&eload(module => 'Relianoid::EE::Net::Mac', func => 'addMAC', args => [ $if_ref->{name}, $if_ref->{mac} ])) {
            return 1;
        }
    }

    # if the GW is changed, change it in all appending virtual interfaces
    if ($if_ref->{gateway}) {
        for my $appending (&getInterfaceChild($if_ref->{name})) {
            my $app_config = &getInterfaceConfig($appending);
            $app_config->{gateway} = $params->{gateway};
            &setInterfaceConfig($app_config);
        }
    }

    # if the netmask is changed, change it in all appending virtual interfaces
    if (exists $params->{netmask}) {
        for my $appending (&getInterfaceChild($if_ref->{name})) {
            my $app_config = &getInterfaceConfig($appending);
            &delRoutes("local", $app_config);
            &downIf($app_config);
            $app_config->{mask} = $params->{netmask};
            &setInterfaceConfig($app_config);
        }
    }

    # put all dependant interfaces up
    require Relianoid::Net::Util;
    &setIfacesUp($if_ref->{name}, "vini");

    if ($oldAddr) {
        require Relianoid::Farm::Base;
        my @farms = &getFarmListByVip($oldAddr);

        # change farm vip,
        if (@farms) {
            require Relianoid::Farm::Config;
            &setAllFarmByVip($params->{ip}, \@farms);
        }
    }

    return 0;
}

=pod

=head1 createVlan

Create a VLAN from an interface hash

Parameters:

    $if_ref - VLAN interface reference 

Returns: integer

    0        - On success
    Non-zero - If there was an error

=cut

sub createVlan ($if_ref) {
    require Relianoid::Net::Core;
    require Relianoid::Net::Route;

    my $err = 0;

    $err = &createIf($if_ref);

    if (!$err) {
        &writeRoutes($if_ref->{name});
    }

    if (!$err) {
        $err = 2 if (!&setInterfaceConfig($if_ref));
    }

    if ($err) {
        &log_error("The vlan $if_ref->{name} could not be created", "NETWORK");
    }
    else {
        &log_info("The vlan $if_ref->{name} was created properly", "NETWORK");
    }

    return $err;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Net/Route.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use Relianoid::Core;

my $eload = eval { require Relianoid::ELoad };

my $ip_bin = &getGlobalConfiguration('ip_bin');

=pod

=head1 Module

Relianoid::Net::Route

=cut

=pod

=head1 writeRoutes

It sets a routing table id and name pair in rt_tables file.

Only required setting up a routed interface. Complemented in delIf()

Parameters:

    if_name - network interface name.

Returns:

    none

=cut

# create table route identification, complemented in delIf()
sub writeRoutes ($if_name) {
    my $rttables = &getGlobalConfiguration('rttables');

    &log_debug("Creating table 'table_$if_name'");

    open my $fh, '<', $rttables;
    my @contents = <$fh>;
    close $fh;

    # the table is already in the file, nothig to do
    if (grep { /^...\ttable_$if_name$/ } @contents) {
        return;
    }

    my $found = "false";
    my $rtnumber;

    # Find next table number available
    for (my $i = 200 ; $i < 1000 && $found eq "false" ; $i++) {
        next if (grep { /^$i\t/ } @contents);
        $found    = "true";
        $rtnumber = $i;
    }

    if ($found eq "true") {
        open(my $fh, ">>", $rttables);
        print $fh "$rtnumber\ttable_$if_name\n";
        close $fh;

        &log_info("Created the table ID 'table_$if_name'", "network");
    }

    return;
}

=pod

=head1 deleteRoutesTable

It removes the a routing table id and name pair from the rt_tables file.

Parameters:

    if_name - network interface name.

Returns:

    none

=cut

sub deleteRoutesTable ($if_name) {
    my $rttables = &getGlobalConfiguration('rttables');

    open my $route_table_in, '<', $rttables;
    my @contents = <$route_table_in>;
    close $route_table_in;

    @contents = grep { !/\ttable_$if_name\n/ } @contents;

    open my $route_table_out, '>', $rttables;
    for my $table (@contents) {
        print $route_table_out $table;
    }
    close $route_table_out;
    return;
}

=pod

=head1 applyRoutingCmd

It creates the command to add a routing entry in a table.

Depend on the passed parameter, it can delete, add or replace the route

Parameters:

    action - it is the action to apply: add, replace or del
    if_ref - network interface hash reference
    table - it is the routing table where the entry will be added

Returns:

    Integer - Error code, it is 0 on success or another value on

TODO:

    use the 'buildRouteCmd' function

=cut

sub applyRoutingCmd ($action, $if_ref, $table) {
    use NetAddr::IP;
    my $routeparams = &getGlobalConfiguration('routeparams');
    my $ip_local    = NetAddr::IP->new($$if_ref{addr}, $$if_ref{mask});
    my $net_local   = $ip_local->network();

    &log_debug("addlocalnet: $action route for $$if_ref{name} in table $table", "NETWORK")
      if &debug();

    my $ip_cmd =
      "$ip_bin -$$if_ref{ip_v} route $action $net_local dev $$if_ref{name} src $$if_ref{addr} table $table $routeparams";

    my $err = &logAndRun($ip_cmd);
    return $err;
}

=pod

=head1 addlocalnet

Set routes to interface subnet into interface routing tables and fills the interface table.

Parameters:

    if_ref - network interface hash reference.

Returns:

    void - .

See Also:

    Only used here: <applyRoutes>

=cut

sub addlocalnet ($if_ref) {
    &log_debug("addlocalnet( name: $$if_ref{name}, addr: $$if_ref{addr}, mask: $$if_ref{mask} )", "NETWORK")
      if &debug();

    # Get network
    use NetAddr::IP;
    my $ip_local  = NetAddr::IP->new($$if_ref{addr}, $$if_ref{mask});
    my $net_local = $ip_local->network();

    # Add or replace local net to all tables
    my @links = ('main', &getLinkNameList());

    my @isolates = ();
    if ($eload) {
        @isolates = &eload(
            module => 'Relianoid::EE::Net::Routing',
            func   => 'getRoutingIsolate',
            args   => [ $$if_ref{name} ],
        );
    }

    # filling the other tables
    for my $link (@links) {
        my $skip_route = 0;
        next if $link eq 'lo';
        next if $link eq 'cl_maintenance';

        my $table = ($link eq 'main') ? 'main' : "table_$link";

        if (grep { /^(?:\*|$table)$/ } @isolates) {
            $skip_route = 1;
        }
        elsif ($link ne 'main') {
            my $iface = &getInterfaceConfig($link);

            # ignores interfaces down or not configured
            next if defined $iface->{status} and $iface->{status} ne 'up';
            next if not defined $iface->{addr};

            #if duplicated network, next
            my $ip_table        = NetAddr::IP->new($$iface{addr}, $$iface{mask});
            my $net_local_table = $ip_table->network();

            if ($net_local_table eq $net_local && $$if_ref{name} ne $link) {
                &log_error(
                    "The network $net_local of dev $$if_ref{name} is the same than the network for $link, route is not going to be applied in table $table",
                    "network"
                );
                $skip_route = 1;
            }
        }

        if (!$skip_route) {
            &applyRoutingCmd('replace', $if_ref, $table);
        }

        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Net::Routing',
                func   => 'applyRoutingTableByIface',
                args   => [ $table, $$if_ref{name} ],
            );
        }
    }

    # filling the own table
    my @ifaces = @{ &getConfigInterfaceList() };
    for my $iface (@ifaces) {
        next if $iface->{name} eq $if_ref->{name};
        my $iface_sys = &getSystemInterface($iface->{name});
        use Relianoid::Net::Core;

        next if $iface_sys->{status} ne 'up';
        next if $iface->{type} eq 'virtual';
        next if defined $iface->{is_slave} and $iface->{is_slave} eq 'true';    # Is in bonding iface
        next if (!defined $iface->{addr} || length $iface->{addr} == 0);        # IP addr doesn't exist
        next if (!&isIp($iface));

        # do not import the iface route if it is isolate
        my @isolates = ();
        if ($eload) {
            @isolates = &eload(
                module => 'Relianoid::EE::Net::Routing',
                func   => 'getRoutingIsolate',
                args   => [ $$iface{name} ],
            );
        }
        next if (grep { /^(?:\*|table_$$if_ref{name})$/ } @isolates);

        &log_debug("addlocalnet: into current interface: name $$iface{name} type $$iface{type}", "NETWORK");

        #if duplicated network, next
        my $ip    = NetAddr::IP->new($$iface{addr}, $$iface{mask});
        my $net   = $ip->network();
        my $table = "table_$$if_ref{name}";

        if ($net eq $net_local && $$iface{name} ne $$if_ref{name}) {
            &log_error(
                "The network $net of dev $$iface{name} is the same than the network for $$if_ref{name}, the route is not going to be applied in table $table",
                "network"
            );
            next;
        }

        &applyRoutingCmd('replace', $iface, $table);
    }

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Net::Routing',
            func   => 'applyRoutingCustom',
            args   => [ 'add', "table_$$if_ref{name}" ],
        );
    }

    require Relianoid::Net::Core;
    &setRuleIPtoTable($$if_ref{name}, $$if_ref{addr}, "add");

    return;
}

=pod

=head1 isRoute

Checks if any of the routes applied to the system matchs according to the input parameters.
It receives the ip route command line options and it checks the system. 
Example. "src 1.1.12.5 dev eth3 table table_eth3".

Parameters:

    route      - command line options for the "ip route list" command.
    ip_version - version used for the ip command. If this parameter is not used, 
                the command will be executed without this flag

Returns:

    Integer - It returns 1 if any applied rule matchs, or 0 if not

=cut

sub isRoute ($route, $ipv = undef) {
    $ipv = $ipv ? "-$ipv" : '';

    my $exists = 1;
    my $ip_cmd = "$ip_bin $ipv route list $route";
    my $out    = &logAndGet("$ip_cmd");

    if ($out eq '') {
        $exists = 0;
    }
    else {
        require Relianoid::Validate;
        my $ip_re = &getValidFormat('ipv4v6');
        $exists = 0
          if ($exists && $route !~ /src $ip_re/ && $out =~ /src $ip_re/);
    }

    if (&debug() > 1) {
        my $msg = ($exists) ? "(Already exists)" : "(Not found)";
        $msg .= " $ip_cmd";
        &log_debug($msg, "net");
    }

    return $exists;
}

=pod

=head1 existRoute

Checks if any of the paths applied to the system has same properties to the input.
It receives the ip route command line options and it checks the system. Example. "src 1.1.12.5 dev eth3 table table_eth3".

Parameters:

    route - command line options for the "ip route list" command.
    via   - 1 to check via
    src   - 1 to check via

Returns:

    Integer - It returns 1 if any applied rule matchs, or 0 if not

=cut

sub existRoute ($route, $via, $src) {
    require Relianoid::Validate;

    my $ip_re = &getValidFormat('ipv4v6');

    $route =~ s/via ($ip_re)// if not $via;
    $route =~ s/src ($ip_re)// if not $src;

    my $ip_cmd = "$ip_bin route list $route";
    my $out    = &logAndGet("$ip_cmd");

    my $exist = ($out eq '') ? 0 : 1;

    return $exist;
}

=pod

=head1 buildRuleCmd

It creates the command line for a routing directive.

Parameters:

    action - it is the action to apply, 'add' to create a new routing entry, 'del' to delete the requested routing entry or 'undef' to create the parameters wihout adding the 'ip route <action>'
    conf - It is a hash referece with the parameters expected to build the command. The options are:

        ip_v : is the ip version for the route
        priority : is the priority which the route will be execute. Lower priority will be executed before
        not : is the NOT logical operator
        from : is the source address or networking segment from is comming the request
        to : is the destination address or networking segment the request is comming to
        fwmark : is the traffic mark of the packet
        lookup : is the routing table where is going to be added the route

Returns:

    String - It is the command line string to execute in the system

=cut

sub buildRuleCmd ($action, $conf) {
    my $cmd = "";
    my $ipv = (exists $conf->{ip_v}) ? "-$conf->{ip_v}" : "";

    # ip rule { add | del } [ priority PRIO ] [ not ] from IP/NETMASK [ to IP/NETMASK ] [ fwmark FW_MARK ] lookup TABLE_ID
    $cmd .= "$ip_bin $ipv rule $action" if (defined $action);
    if (    (defined $action and $action ne 'list')
        and (exists $conf->{priority} and $conf->{priority} =~ /\d/))
    {
        $cmd .= " priority $conf->{priority} ";
    }
    $cmd .= " not" if (exists $conf->{not} and $conf->{not} eq 'true');
    $cmd .= " from $conf->{from}";
    $cmd .= " to $conf->{to}"
      if (exists $conf->{to} && $conf->{to} ne "");
    $cmd .= " fwmark $conf->{fwmark}"
      if (exists $conf->{fwmark} && $conf->{fwmark} ne "");
    $cmd .= " lookup $conf->{table}";

    return $cmd;
}

=pod

=head1 isRule

Check if routing rule for the given table, from or fwmark exists.

Parameters:

    conf - Rule hash reference.

Returns:

    scalar - number of times the rule was found. True if found.

Todo:

    Rules for Datalink farms are included.

=cut

sub isRule ($conf) {
    my $ipv  = (exists $conf->{ip_v}) ? "-$conf->{ip_v}" : "";
    my $cmd  = "$ip_bin $ipv rule list";
    my $rule = "";
    $rule .= " not" if (exists $conf->{not} and $conf->{not} eq 'true');
    my ($net, $netmask) = split /\//, $conf->{from};
    if (defined $netmask
        and ($netmask eq "32" or $netmask eq "255.255.255.255"))
    {
        $rule .= " from $net";
    }
    else {
        $rule .= " from $conf->{from}";
    }
    $rule .= " to $conf->{to}"
      if (exists $conf->{to} && $conf->{to} ne "");
    $rule .= " fwmark $conf->{fwmark}"
      if (exists $conf->{fwmark} && $conf->{fwmark} ne "");
    $rule .= " lookup $conf->{table}";
    $rule =~ s/^\s+//;
    $rule =~ s/\s+$//;

    my @out = @{ &logAndGet($cmd, 'array') };
    chomp @out;

    my $exist = (grep { /^\d+:\s*$rule\s*$/ } @out) ? 1 : 0;

    if (&debug() > 1) {
        my $msg = ($exist) ? "(Already existed)" : "(Not found)";
        $msg .= " $cmd";
        &log_debug($msg, "net");
    }

    return $exist;
}

=pod

=head1 applyRule

Add or delete the rule according to the given parameters.

Parameters:

    action - "add" to create a new rule or "del" to remove it.
    rule - Rule hash reference.

Returns:

    integer - ip command return code.

Bugs:

    Rules for Datalink farms are included.

=cut

sub applyRule ($action, $rule) {
    return -1 if ($rule->{table} eq "");

    if ($action eq 'add' and ((!defined $rule->{priority}) || $rule->{priority} eq '')) {
        $rule->{priority} = &genRoutingRulesPrio($rule->{type});
    }

    my $cmd    = &buildRuleCmd($action, $rule);
    my $output = &logAndRun("$cmd");

    return $output;
}

=pod

=head1 genRoutingRulesPrio

Create a priority according to the type of route is going to be created

Parameters:

    Type - type of route, the possible values are:

        'iface' for the default interface routes,
        'l4xnat' for the l4xnat backend routes,
        'http or https' for the L7 backend routes,
        'farm-datalink' for the rules applied by datalink farms,
        'user' for the customized routes created for the user,
        'vpn' for the routes applied by vpn connections

Returns:

    Integer - Priority for the route

=cut

sub genRoutingRulesPrio ($type) {
    # The maximun priority value in the system is '32766'
    my $farmL4       = &getGlobalConfiguration('routingRulePrioFarmL4');
    my $farmDatalink = &getGlobalConfiguration('routingRulePrioFarmDatalink');
    my $userInit     = &getGlobalConfiguration('routingRulePrioUserMin');
    my $userEnd      = &getGlobalConfiguration('routingRulePrioUserMax') + 1;
    my $ifacesInit   = &getGlobalConfiguration('routingRulePrioIfaces');

    my $min;
    my $max;

    # l4xnat farm rules
    if ($type eq 'l4xnat' || $type eq 'http' || $type eq 'https') {
        $min = $farmL4;
        $max = $farmDatalink;
    }

    # datalink farm rules
    elsif ($type eq 'farm-datalink') {
        $min = $farmDatalink;
        $max = $userInit;
    }

    # custom rules
    elsif ($type eq 'user') {
        $min = $userInit;
        $max = $userEnd;
    }

    # iface rules
    else {
        return $ifacesInit;
    }

    if ($eload) {
        # vpn rules
        my $vpn = &getGlobalConfiguration('routingRulePrioVPN');
        if ($type eq 'vpn') {
            $min = $vpn;
            $max = $farmL4;
        }
    }

    my $prio;
    my $prioList = &listRoutingRulesPrio();
    for ($prio = $max - 1 ; $prio >= $min ; $prio--) {
        last if (!grep { $prio eq $_ } @{$prioList});
    }

    return $prio;
}

=pod

=head1 listRoutingRulesPrio

List the priority of the rules that are currently applied in the system

Parameters:

    None

Returns:

    Array ref - list of priorities

=cut

sub listRoutingRulesPrio () {
    my $rules = &listRoutingRules();
    my @list;

    for my $r (@{$rules}) {
        push @list, $r->{priority};
    }

    @list = sort @list;
    return \@list;
}

=pod

=head1 getRuleFromIface

It returns a object with the routing parameters that are needed for creating the default route of an interface.

Parameters:

    Interface - name of the interace

Returns:

    Hash ref

    {
        table => "table_eth3",  # table where creating the entry
        type => 'iface',        # type of route rule
        from => 15.255.25.2/24, # networking segement of the interface
    }

=cut

sub getRuleFromIface ($if_ref) {
    my $from = "";
    if (defined($if_ref->{net}) && $if_ref->{net} ne '') {
        $from =
          ($if_ref->{mask} =~ /^\d$/)
          ? "$if_ref->{net}/$if_ref->{mask}"
          : NetAddr::IP->new($if_ref->{net}, $if_ref->{mask})->cidr();
    }

    my $rule = {
        table => "table_$if_ref->{name}",
        type  => 'iface',
        from  => $from,
        ip_v  => $if_ref->{ip_v}
    };

    return $rule;
}

=pod

=head1 setRule

Check and then apply action to add or delete the rule according to the parameters.

Parameters:

    action - "add" to create a new rule or "del" to remove it.
    rule - Rule hash reference

Returns:

    integer - ip command return code.

Bugs:

    Rules for Datalink farms are included.

=cut

sub setRule ($action, $rule) {
    my $output = 0;

    if (!defined($rule->{from}) || $rule->{from} eq '') {
        return 0;
    }
    if ($action !~ /^add$|^del$/) {
        return -1;
    }
    if (defined $rule->{fwmark} && $rule->{fwmark} =~ /^0x0$/) {
        return -1;
    }

    my $isrule = &isRule($rule);

    &log_debug("action '$action' and the rule exist=$isrule", "net");

    if ($action eq "add" && $isrule == 0) {
        &applyRule($action, $rule);
        $output = &isRule($rule) ? 0 : 1;
    }
    elsif ($action eq "del" && $isrule != 0) {
        &applyRule($action, $rule);
        $output = &isRule($rule);
    }

    return $output;
}

=pod

=head1 applyRoutes

Apply routes for interface or default gateway.

For "local" table set route for interface.
For "global" table set route for default gateway and save the default
gateway in global configuration file.

Parameters:

    table - "local" for interface routes or "global" for default gateway route.
    if_ref - network interface hash reference.
    gateway - Default gateway. Only required if table parameter is "global".

Returns:

    integer - ip command return code.

See Also:

    <delRoutes>

=cut

sub applyRoutes ($table, $if_ref, $gateway = undef) {
    my $if_announce = "";
    my $status      = 0;

    # do not add routes if the inteface is down
    my $if_sys = &getSystemInterface($$if_ref{name});
    if ($$if_sys{status} ne 'up') {
        return 0;
    }
    if ($$if_ref{ip_v} != 4 and $$if_ref{ip_v} != 6) {
        return 0;
    }

    unless ($$if_ref{net}) {
        require Relianoid::Net::Interface;
        $$if_ref{net} =
          &getAddressNetwork($$if_ref{addr}, $$if_ref{mask}, $$if_ref{ip_v});
    }

    # not virtual interface
    if (!defined $$if_ref{vini} || $$if_ref{vini} eq '') {
        if ($table eq "local") {
            my $gateway = $$if_ref{gateway} // '';
            &log_info("Applying $table routes in stack IPv$$if_ref{ip_v} to $$if_ref{name} with gateway \"${gateway}\"", "NETWORK");

            &addlocalnet($if_ref);

            if ($$if_ref{gateway}) {
                my $routeparams = &getGlobalConfiguration('routeparams');
                my $ip_cmd =
                  "$ip_bin -$$if_ref{ip_v} route replace default via $$if_ref{gateway} dev $$if_ref{name} table table_$$if_ref{name} $routeparams";
                $status = &logAndRun("$ip_cmd");
            }

            my $rule = &getRuleFromIface($if_ref);
            $status = &setRule("add", $rule);
        }
        else {
            # Apply routes on the global table
            if ($gateway) {
                my $routeparams = &getGlobalConfiguration('routeparams');

                my $action = "replace";
                my $system_default_gw;
                if ($$if_ref{ip_v} == 4) {
                    $system_default_gw = &getDefaultGW();
                }
                elsif ($$if_ref{ip_v} == 6) {
                    $system_default_gw = &getIPv6DefaultGW();
                }

                if (not $system_default_gw) {
                    $action = "add";
                }

                if (&existRoute("default via $gateway dev $$if_ref{name}", 1, 0)) {
                    &log_info("Gateway \"$gateway\" is already applied in $table routes in stack IPv$$if_ref{ip_v}", "NETWORK");
                }
                else {
                    &log_info("Applying $table routes in stack IPv$$if_ref{ip_v} with gateway \"$gateway\"", "NETWORK");
                    my $ip_cmd = "$ip_bin -$$if_ref{ip_v} route $action default via $gateway dev $$if_ref{name} $routeparams";
                    $status = &logAndRun("$ip_cmd");
                }
                if ($$if_ref{ip_v} == 6) {
                    &setGlobalConfiguration('defaultgw6',   $gateway);
                    &setGlobalConfiguration('defaultgwif6', $$if_ref{name});
                }
                else {
                    &setGlobalConfiguration('defaultgw',   $gateway);
                    &setGlobalConfiguration('defaultgwif', $$if_ref{name});
                }
            }
        }
        $if_announce = $$if_ref{name};
    }

    # virtual interface
    else {
        my ($toif) = split(/:/, $$if_ref{name});

        my $rule = &getRuleFromIface($if_ref);
        $rule->{table} = "table_$toif";
        $status        = &setRule("add", $rule);
        $if_announce   = $toif;
    }

    # not send garps to network if node is backup or it is in maintenance
    eval {
        if ($eload) {
            my $cl_status = &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'getClusterNodeStatus',
                args   => [],
            );
            my $cl_maintenance = &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'getClMaintenanceManual',
                args   => [],
            );

            if (($cl_status and $cl_status ne "backup") and $cl_maintenance ne "true") {
                require Relianoid::Net::Util;
                &log_info("Announcing garp $if_announce and $$if_ref{addr} ");
                &sendGArp($if_announce, $$if_ref{addr});
            }
        }
    };

    return $status;
}

=pod

=head1 delRoutes

Delete routes for interface or default gateway.

For "local" table remove route for interface.
For "global" table remove route for default gateway and removes the
default gateway in global configuration file.

Parameters:

    table - "local" for interface routes or "global" for default gateway route.
    if_ref - network interface hash reference.

Returns:

    integer - ip command return code.

See Also:

    <applyRoutes>

=cut

sub delRoutes ($table, $if_ref) {
    unless ($$if_ref{ip_v}) {
        croak("IP version stack required");
    }

    my $status = 0;

    &log_info("Deleting $table routes for IPv$$if_ref{ip_v} in interface $$if_ref{name}", "NETWORK");

    if (!defined $$if_ref{vini} || $$if_ref{vini} eq '') {
        #an interface is going to be deleted, delete the rule of the IP first
        require Relianoid::Net::Core;
        &setRuleIPtoTable($$if_ref{name}, $$if_ref{addr}, "del");

        if ($table eq "local") {
            # exists if the tables does not exist
            if (!grep { /^table_$if_ref->{name}/ } &listRoutingTablesNames()) {
                &log_debug2("The table table_$if_ref->{name} was not flushed because it was not found", "net");
                return 0;
            }

            my $ip_cmd = "$ip_bin -$$if_ref{ip_v} route flush table table_$$if_ref{name}";

            my ($errno, $out_ref, $err_ref) = &run3($ip_cmd);
            if ($errno == 2 and not @{$out_ref}) {
                if (    grep { /FIB table does not exist./ } @{$err_ref}
                    and grep { /terminated/ } @{$err_ref})
                {
                    $errno = 0;
                }
            }
            $status = $errno;

            if ($status) {
                &log_error("running: $ip_cmd",     "SYSTEM");
                &log_error("out: @{$out_ref}",     "SYSTEM") if @{$out_ref};
                &log_error("err: @{$err_ref}",     "SYSTEM") if @{$err_ref};
                &log_error("last command failed!", "SYSTEM");
            }
            else {
                &log_debug("running: $ip_cmd", "SYSTEM");
                &log_debug2("out: @{$out_ref}", "SYSTEM") if @{$out_ref};
                &log_debug2("err: @{$err_ref}", "SYSTEM") if @{$err_ref};
            }

            my $rule = &getRuleFromIface($if_ref);
            $status = &setRule("del", $rule);
            return $status;
        }
        else {
            # Delete routes on the global table
            my $ip_cmd = "$ip_bin -$$if_ref{ip_v} route del default";
            $status = &logAndRun("$ip_cmd");

            if ($status == 0) {
                if ($$if_ref{ip_v} == 6) {
                    &setGlobalConfiguration('defaultgw6',   '');
                    &setGlobalConfiguration('defaultgwif6', '');
                }
                else {
                    &setGlobalConfiguration('defaultgw',   '');
                    &setGlobalConfiguration('defaultgwif', '');
                }
            }

            return $status;
        }
    }

    return $status;
}

=pod

=head1 getDefaultGW

Get system or interface default gateway.

Parameters:

    if - interface name. Optional.

Returns:

    scalar - Gateway IP address.

See Also:

    <getIfDefaultGW>

=cut

# get default gw for interface
sub getDefaultGW ($if_name = undef) {
    my $gw;
    my @routes = ();

    if ($if_name) {
        my $routed_if = $if_name;
        if ($if_name =~ /\:/) {
            my @iface = split(/\:/, $routed_if);
            $routed_if = $iface[0];
        }

        open(my $fh, '<', &getGlobalConfiguration('rttables'));

        if (grep { /^...\ttable_${routed_if}$/ } <$fh>) {
            @routes = @{ &logAndGet("${ip_bin} route list table table_${routed_if}", "array") };
        }

        close $fh;
    }
    else {
        @routes = @{ &logAndGet("$ip_bin route list", "array") };
    }

    if (my @default_gw = grep { /^default/ } @routes) {
        my @line = split(/ /, $default_gw[0]);
        $gw = $line[2];
    }

    return $gw;
}

=pod

=head1 getIPv6DefaultGW

Get system IPv6 default gateway.

Parameters:

    none - .

Returns:

    scalar - IPv6 default gateway address.

See Also:

    <getDefaultGW>, <getIPv6IfDefaultGW>

=cut

sub getIPv6DefaultGW () {
    my @routes = @{ &logAndGet("$ip_bin -6 route list", "array") };
    my ($default_line) = grep { /^default/ } @routes;

    my $default_gw;
    if ($default_line) {
        $default_gw = (split(' ', $default_line))[2];
    }

    return $default_gw;
}

=pod

=head1 getIPv6IfDefaultGW

Get network interface to IPv6 default gateway.

Parameters:

    none - .

Returns:

    scalar - Interface to IPv6 default gateway.

See Also:

    <getIPv6DefaultGW>, <getIfDefaultGW>

=cut

sub getIPv6IfDefaultGW () {
    my @routes = @{ &logAndGet("$ip_bin -6 route list", "array") };
    my ($default_line) = grep { /^default/ } @routes;

    my $if_default_gw;
    if ($default_line) {
        $if_default_gw = (split(' ', $default_line))[4];
    }

    return $if_default_gw;
}

=pod

=head1 getIfDefaultGW

Get network interface to default gateway.

Parameters:

    none - .

Returns:

    scalar - Interface to default gateway address.

See Also:

    <getDefaultGW>, <getIPv6IfDefaultGW>

=cut

# get interface for default gw
sub getIfDefaultGW () {
    my $if_name;
    my @routes = @{ &logAndGet("$ip_bin route list", "array") };
    if (my @defgw = grep { /^default/ } @routes) {
        my @line = split(/ /, $defgw[0]);
        $if_name = $line[4];
    }

    return $if_name;
}

=pod

=head1 configureDefaultGW

Setup the configured default gateway (for IPv4 and IPv6).

Parameters:

    none

Returns:

    none

See Also:

    relianoid

=cut

sub configureDefaultGW () {
    my $defaultgw    = &getGlobalConfiguration('defaultgw');
    my $defaultgwif  = &getGlobalConfiguration('defaultgwif');
    my $defaultgw6   = &getGlobalConfiguration('defaultgw6');
    my $defaultgwif6 = &getGlobalConfiguration('defaultgwif6');

    # input: global variables $defaultgw and $defaultgwif
    if ($defaultgw && $defaultgwif) {
        my $if_ref = &getInterfaceConfig($defaultgwif, 4);
        if ($if_ref) {
            &applyRoutes("global", $if_ref, $defaultgw);
        }
    }

    # input: global variables $$defaultgw6 and $defaultgwif6
    if ($defaultgw6 && $defaultgwif6) {
        my $if_ref = &getInterfaceConfig($defaultgwif6, 6);
        if ($if_ref) {
            &applyRoutes("global", $if_ref, $defaultgw6);
        }
    }
    return;
}

=pod

=head1 listRoutingTablesNames

It lists the system routing tables by its nickname

Parameters:

    none

Returns:

    Array - List of routing tables in the system

=cut

sub listRoutingTablesNames () {
    my $rttables   = &getGlobalConfiguration('rttables');
    my @list       = ();
    my @exceptions = ('local', 'default', 'unspec');

    require Relianoid::Lock;
    my $fh = &openlock($rttables, 'r');
    chomp(my @rttables_lines = <$fh>);
    close $fh;

    for my $line (@rttables_lines) {
        next if ($line =~ /^\s*#/);

        if ($line =~ /\d+\s+([\w\-\.]+)/) {
            my $name = $1;
            next if grep { $name eq $_ } @exceptions;
            push @list, $name;
        }
    }

    return @list;
}

=pod

=head1 listRoutingRulesSys

It returns a list of the routing rules from the system.

Parameters:

    filter - filter hash reference for matching rules. No filter means all rules.

Returns:

    Array ref - list of routing rules

=cut

sub listRoutingRulesSys ($filter = undef) {
    my $filter_param;
    my @rules = ();

    if (defined $filter) {
        my @filter_params = keys %{$filter};
        $filter_param = $filter_params[0];
    }

    # get data
    my $cmd  = "$ip_bin -j -p rule list";
    my $data = &logAndGet($cmd);

    require JSON;

    my $dec_data = eval { JSON::decode_json($data); };
    if ($@) {
        &log_error("Decoding json: $@", "net");
        $dec_data = [];
    }

    # filter data
    for my $r (@{$dec_data}) {
        if (   (not defined $filter)
            or ($filter->{$filter_param} eq $r->{$filter_param}))
        {
            my $type = (exists $r->{fwmask}) ? 'farm' : 'system';

            $r->{from} = $r->{src};
            $r->{from} .= "/$r->{srclen}" if exists($r->{srclen});

            delete $r->{src};
            delete $r->{srclen};

            $r->{to} = $r->{dst}        if exists($r->{dst});
            $r->{to} .= "/$r->{dstlen}" if exists($r->{dstlen});

            delete $r->{dst};
            delete $r->{dstlen};

            $r->{type} = $type;
            $r->{not}  = 'true' if (exists $r->{not});
            push @rules, $r;
        }
    }

    return \@rules;
}

=pod

=head1 listRoutingRules

It returns a list of the routing rules. These rules are the resulting list of
join the system administred and the created by the user.

Parameters:

    none

Returns:

    Array ref - list of routing rules

=cut

sub listRoutingRules () {
    my @rules_conf = ();

    if ($eload) {
        @rules_conf = @{ &eload(module => 'Relianoid::EE::Net::Routing', func => 'listRoutingRulesConf', args => [],) };
    }

    my @priorities = ();

    for my $r (@rules_conf) {
        push @priorities, $r->{priority};
    }

    for my $sys (@{ &listRoutingRulesSys() }) {
        if (!grep { $sys->{priority} eq $_ } @priorities) {
            push @rules_conf, $sys;
        }
    }

    return \@rules_conf;
}

=pod

=head1 getRoutingOutgoing

It gets the output interface in the system

Only used for floating interfaces in getFloatingSourceAddr()

Parameters:

    ip - IP address
    mark - Optional mark. For example: '0xX'

Returns:

    Hash ref - $route_ref

Variable: $route_ref

    Hash ref that maps the route info

    $ref->{in}{ip}       - dest ip address
    $ref->{in}{mark}     - mark.
    $ref->{out}{ifname}  - Interface name for output.
    $ref->{out}{srcaddr} - IP address for output.
    $ref->{out}{table}   - Route Table name used
    $ref->{out}{custom}  - Custom route

=cut

sub getRoutingOutgoing ($ip, $mark = undef) {
    my $outgoing_ref;
    $outgoing_ref->{in}{ip}       = $ip;
    $outgoing_ref->{in}{mark}     = "";
    $outgoing_ref->{out}{ifname}  = "";
    $outgoing_ref->{out}{srcaddr} = "";
    $outgoing_ref->{out}{table}   = "";
    $outgoing_ref->{out}{custom}  = "";

    my $mark_option = "";
    if ($mark) {
        $outgoing_ref->{in}{mark} = $mark;
        $mark_option = "mark $mark";
    }

    my $cmd  = "$ip_bin -o -d route get $ip $mark_option";
    my $data = &logAndGet($cmd);

    require Relianoid::Validate;
    my $ip_re = &getValidFormat("ip_addr");

    if ($data =~ /^.* \Q$ip\E (?:via .* )?dev (.*) table (.*) src ($ip_re)(?: $mark_option)? uid (.*)/) {
        my $iface      = $1;
        my $table      = $2;
        my $sourceaddr = $3;
        my $custom     = $4;

        if ($iface eq "lo") {
            my $cmd  = "$ip_bin -o -d route list table $table type local";
            my $data = &logAndGet($cmd, "array");
            for my $route_local (@{$data}) {
                if ($route_local =~ /^local \Q$ip\E dev (.*) proto .* src .*/) {
                    $iface = $1;
                    last;
                }
            }
            $outgoing_ref->{out}{custom} = "false";
        }
        else {
            my $route_params = &getGlobalConfiguration('routeparams');
            if ($custom =~ $route_params) {
                $outgoing_ref->{out}{custom} = "false";
            }
            else {
                $outgoing_ref->{out}{custom} = "true";
            }
        }

        $outgoing_ref->{out}{ifname}  = $iface;
        $outgoing_ref->{out}{table}   = $table;
        $outgoing_ref->{out}{srcaddr} = $sourceaddr;
    }

    return $outgoing_ref;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Net/Util.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::Net::Util

=cut

=pod

=head1 getIfacesFromIf

Get List of Vinis or Vlans from a network interface.

Parameters:

    if_name - interface name.
    type - "vini" or "vlan".

Returns:

    list - list of interface references.

See Also:

    Only used in: <setIfacesUp>

=cut

# Get List of Vinis or Vlans from an interface
sub getIfacesFromIf ($if_name, $type) {
    my @ifaces;
    my @configured_interfaces = @{ &getConfigInterfaceList() };

    for my $interface (@configured_interfaces) {
        next if $$interface{name} !~ /^$if_name.+/;

        # get vinis
        if ($type eq "vini" && $$interface{vini} ne '') {
            push @ifaces, $interface;
        }

        # get vlans (including vlan:vini)
        elsif ($type eq "vlan"
            && $$interface{vlan} ne ''
            && $$interface{vini} eq '')
        {
            push @ifaces, $interface;
        }
    }

    return @ifaces;
}

=pod

=head1 setIfacesUp

Bring up all Virtual or VLAN interfaces on a network interface.

Parameters:

    if_name - Name of interface.
    type - "vini" or "vlan".

Returns:

    undef - .

Bugs:

    Set VLANs up.

=cut

# Check if there are some Virtual Interfaces or Vlan with IPv6 and previous UP status to get it up.
sub setIfacesUp ($if_name, $type) {
    if (not($type eq 'vlan' or $type eq 'vini')) {
        die("setIfacesUp: type variable must be 'vlan' or 'vini'");
    }

    my @ifaces = &getIfacesFromIf($if_name, $type);

    if (@ifaces) {
        for my $iface (@ifaces) {
            if ($iface->{status} eq 'up') {
                &addIp($iface);
                if ($iface->{type} eq 'vlan') {
                    &applyRoutes("local", $iface);
                }
            }
        }

        if ($type eq "vini") {
            &log_info("Virtual interfaces of $if_name have been put up.", "NETWORK");
        }
        elsif ($type eq "vlan") {
            &log_info("VLAN interfaces of $if_name have been put up.", "NETWORK");
        }
    }

    return;
}

=pod

=head1 sendGPing

Send gratuitous ICMP packets for L3 aware.

Parameters:

    pif - ping interface name.

Returns:

    none

See Also:

    <sendGArp>

=cut

# send gratuitous ICMP packets for L3 aware
sub sendGPing ($pif) {
    my $if_conf = &getInterfaceConfig($pif);
    my $gw      = $if_conf->{gateway};

    if ($gw) {
        my $ping_bin = &getGlobalConfiguration('ping_bin');
        my $pingc    = &getGlobalConfiguration('pingc');
        my $ping_cmd = "$ping_bin -c $pingc -I $if_conf->{addr} $gw";

        &log_info("Sending $pingc ping(s) to gateway $gw from $if_conf->{addr}", "NETWORK");
        &logAndRunBG("$ping_cmd");
    }
    return;
}

=pod

=head1 sendGArp

Send gratuitous ARP frames.

Broadcast an ip address with ARP frames through a network interface.
Also, pings the interface gateway.

Parameters:

    if - interface name.
    ip - ip address.

Returns:

    none

See Also:

    <broadcastInterfaceDiscovery>, <sendGPing>

=cut

# send gratuitous ARP frames
sub sendGArp ($if, $ip) {
    require Relianoid::Net::Validate;

    my @iface = split(':', $if);
    my $ip_v  = &ipversion($ip);

    if ($ip_v == 4) {
        my $arping_bin      = &getGlobalConfiguration('arping_bin');
        my $arp_unsolicited = &getGlobalConfiguration('arp_unsolicited');

        my $arp_arg    = $arp_unsolicited ? '-U' : '-A';
        my $arping_cmd = "$arping_bin $arp_arg -c 2 -I $iface[0] $ip";

        &log_info("$arping_cmd", "NETWORK");
        &logAndRunBG("$arping_cmd");
    }
    elsif ($ip_v == 6) {
        my $arpsend_bin = &getGlobalConfiguration('arpsend_bin');
        my $arping_cmd  = "$arpsend_bin -U -i $ip $iface[0]";

        &log_info("$arping_cmd", "NETWORK");
        &logAndRunBG("$arping_cmd");
    }

    &sendGPing($iface[0]);
    return;
}

=pod

=head1 setArpAnnounce

Set a cron task to cast a ARP packet each minute

Parameters:

    none

Returns:

    Integer - Error code: 0 on success or another value on failure

=cut

sub setArpAnnounce () {
    my $script = &getGlobalConfiguration("arp_announce_bin");
    my $path   = &getGlobalConfiguration("arp_announce_cron_path");
    my $err    = 0;

    my $fh = &openlock($path, 'w') or return 1;
    print $fh "* * * * *	root	$script &>/dev/null\n";
    close $fh;

    if (!$err) {
        $err = &setGlobalConfiguration('arp_announce', "true");
    }

    return $err;
}

=pod

=head1 unsetArpAnnounce

Remove the cron task to cast a ARP packet each minute

Parameters:

    none

Returns:

    Integer - Error code: 0 on success or another value on failure

=cut

sub unsetArpAnnounce () {
    my $path         = &getGlobalConfiguration("arp_announce_cron_path");

    if (-f $path) {
        my $rem = unlink $path;
        if (!$rem) {
            &log_error("Error deleting the file '$path'", "NETWORK");
            return 1;
        }
    }

    return &setGlobalConfiguration('arp_announce', "false");
}

=pod

=head1 iponif

Get the (primary) ip address on a network interface.

A copy of this function is in noid-cluster-notify.

Parameters:

    if - interface namm.

Returns:

    scalar - string with IP address.

See Also:

    <getInterfaceOfIp>, <_runDatalinkFarmStart>, <_runDatalinkFarmStop>, <noid-cluster-notify>

=cut

#know if and return ip
sub iponif ($if) {
    require IO::Socket;
    require Relianoid::Net::Interface;

    my $s      = IO::Socket::INET->new(Proto => 'udp');
    my $iponif = $s->if_addr($if);

    # fixes virtual interfaces IPs
    unless ($iponif) {
        my $if_ref = &getInterfaceConfig($if);
        $iponif = $if_ref->{addr};
    }

    return $iponif;
}

=pod

=head1 maskonif

Get the network mask of an network interface (primary) address.

Parameters:

    if - interface namm.

Returns:

    scalar - string with network address.

See Also:

    <_runDatalinkFarmStart>, <_runDatalinkFarmStop>

=cut

# return the mask of an if
sub maskonif ($if) {
    require IO::Socket;

    my $s        = IO::Socket::INET->new(Proto => 'udp');
    my $maskonif = $s->if_netmask($if);

    return $maskonif;
}

=pod

=head1 listallips

List all IPs used for interfaces

Parameters:

    none - .

Returns:

    list - All IP addresses.

Bugs:

    $ip !~ /127.0.0.1/
    $ip !~ /0.0.0.0/

=cut

sub listallips () {
    require Relianoid::Net::Interface;

    my @listinterfaces = ();

    for my $if_name (&getInterfaceList()) {
        my $if_ref = &getInterfaceConfig($if_name);
        push @listinterfaces, $if_ref->{addr} if ($if_ref->{addr});
    }

    return @listinterfaces;
}

=pod

=head1 setIpForward

Set IP forwarding on/off

Parameters:

    arg - "true" to turn it on or other to turn it off.

Returns:

    scalar - return

See Also:

    <_runDatalinkFarmStart>

=cut

# Enable(true) / Disable(false) IP Forwarding
sub setIpForward ($arg) {
    my $status = 0;
    my $switch = $arg eq 'true';

    &log_info("setting $arg to IP forwarding ", "NETWORK");

    # switch forwarding as requested
    $status += &logAndRun("echo $switch > /proc/sys/net/ipv4/conf/all/forwarding");
    $status += &logAndRun("echo $switch > /proc/sys/net/ipv4/ip_forward");
    $status += &logAndRun("echo $switch > /proc/sys/net/ipv6/conf/all/forwarding");

    return $status;
}

=pod

=head1 getInterfaceOfIp

Get the name of the interface with such IP address.

Parameters:

    ip - string with IP address.

Returns:

    scalar - Name of interface, if found, undef otherwise.

See Also:

    <enable_cluster>, <new_farm>, <modify_datalink_farm>

=cut

sub getInterfaceOfIp ($ip) {
    require Relianoid::Net::Interface;
    require NetAddr::IP;

    my $ref_addr = NetAddr::IP->new($ip);

    for my $iface (&getInterfaceList()) {
        # return interface if found in the listç
        my $if_ip = &iponif($iface);
        next if (!$if_ip);

        my $if_addr = NetAddr::IP->new($if_ip);

        return $iface if ($if_addr eq $ref_addr);
    }

    # returns an invalid interface name, an undefined variable
    &log_info("Warning: No interface was found configured with IP address $ip", "NETWORK");

    return;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Net/Validate.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use Relianoid::Core;

=pod

=head1 Module

Relianoid::Net::Validate

=cut

=pod

=head1 getNetIpFormat

It gets an IP and it retuns the same IP with the format that system uses for
the binary choosed

Parameters:

    ip - String with the ipv6
    bin - It is the binary for the format

Returns: string

IPv6 with the format of the binary parameter.

=cut

sub getNetIpFormat ($ip, $bin) {
    require Net::IPv6Addr;
    my $x = Net::IPv6Addr->new($ip);

    if ($bin eq 'netstat') {
        return $x->to_string_compressed();
    }
    else {
        &log_error("The bin '$bin' is not recoignized. The ip '$ip' couldn't be converted", "networking");
    }

    return $ip;
}

=pod

=head1 getProtoTransport

It returns the protocols of layer 4 that use a profile or another protocol.

Parameters:

    profile - This parameter accepts a load balancer profile 
              (for Layer 4 it returns the default one when the farm is created): 
                "http", "https", "l4xnat", "gslb"
              or another protocol:
                "tcp", "udp", "sctp", "amanda", "tftp", "netbios-ns",
                "snmp", "ftp", "irc", "pptp", "sane", "all", "sip" or "h323"

Returns: array reference

List of transport protocols that use the passed protocol.
The possible values are "udp", "tcp" or "sctp".

=cut

sub getProtoTransport ($profile) {
    my $proto = [];
    my $all   = [ "tcp", "udp", "sctp" ];

    # profiles
    if ($profile eq "gslb") {
        $proto = [ "tcp", "udp" ];
    }
    elsif ($profile eq "l4xnat") {
        $proto = ["tcp"];    # default protocol when a l4xnat farm is created
    }
    elsif ($profile =~ /^(?:tcp|udp|sctp)$/) {    # protocols
        $proto = [$profile];
    }
    elsif ($profile =~ /^(?:amanda|tftp|netbios-ns|snmp)$/) {    # udp
        $proto = ["udp"];
    }
    elsif ($profile =~ /^(?:ftp|irc|pptp|sane|https?|eproxy)$/) { # tcp
        $proto = ["tcp"];
    }
    elsif ($profile eq "all") {                                  # mix
        $proto = $all;
    }
    elsif ($profile eq "sip") {
        $proto = [ "tcp", "udp" ];
    }
    elsif ($profile eq "h323") {
        $proto = [ "tcp", "udp" ];
    }
    else {
        &log_error("The funct 'getProtoTransport' does not understand the parameter '$profile'", "networking");
    }

    return $proto;
}

=pod

=head1 validatePortKernelSpace

It checks if the IP, port and protocol are used in some l4xnat farm.
This function does the following actions to validate that the protocol
is not used:

    * Remove the incoming farmname from the farm list
    * Check only with l4xnat farms
    * Check with farms with up status
    * Check that farms contain the same VIP
    * There is not collision with multiport

Parameters:

    vip      - virtual IP
    port     - It accepts multiport string format
    proto    - it is an array reference with the list of protocols to check in the port. 
                The protocols can be 'sctp', 'udp', 'tcp' or 'all'
    farmname - It is the farm that is being modified, if this parameter is passed, 
                the configuration of this farm is ignored to avoid checking with itself. 
                This parameter is optional

Returns: integer

- 1: the incoming info is valid
- 0: there is a(nother) farm with that networking information

=cut

sub validatePortKernelSpace ($ip, $port, $proto, $farmname = undef) {
    # get l4 farms
    require Relianoid::Farm::Base;
    require Relianoid::Arrays;

    my @farm_list = &getFarmListByVip($ip);
    return 1 if !@farm_list;

    if (defined $farmname) {
        @farm_list = grep { !/^$farmname$/ } @farm_list;
        return 1 if !@farm_list;
    }

    # check intervals
    my $port_list = &getMultiporExpanded($port);

    for my $farm (@farm_list) {
        next if (&getFarmType($farm) ne 'l4xnat');
        next if (&getFarmStatus($farm) ne 'up');

        # check protocol collision
        my $f_proto = &getProtoTransport(&getL4FarmParam('proto', $farm));
        next if (!&getArrayCollision($proto, $f_proto));

        my $f_port = &getFarmVip('vipp', $farm);

        # check if farm is all ports
        if ($port eq '*' or $f_port eq '*') {
            &log_warn("Port collision with farm '$farm' for using all ports", "net");
            return 0;
        }

        # check port collision
        my $f_port_list = &getMultiporExpanded($f_port);
        my $col         = &getArrayCollision($f_port_list, $port_list);

        if (defined $col) {
            &log_warn("Port collision ($col) with farm '$farm'", "net");
            return 0;
        }
    }

    return 1;
}

=pod

=head1 getMultiporExpanded

It returns the list of ports that a multiport string contains.

Parameters:

    port - multiport port

Returns: array reference

List of ports used by the farm

=cut

sub getMultiporExpanded ($port) {
    my @total_port = ();

    if ($port ne '*') {
        for my $p (split(',', $port)) {
            my ($init, $end) = split(':', $p);

            if   (defined $end) { push @total_port, ($init .. $end); }
            else                { push @total_port, $init; }
        }
    }

    return \@total_port;
}

=pod

=head1 getMultiportRegex

It creates a regular expression to look for a list of ports.
It expands the l4xnat port format (':' for ranges and ',' for listing ports).

Parameters:

    port - port or multiport

Returns: string - Regular expression

=cut

sub getMultiportRegex ($port) {
    my $reg = $port;

    if ($port eq '*') {
        $reg = '\d+';
    }
    elsif ($port =~ /[:,]/) {
        my $total_port = &getMultiporExpanded($port);
        $reg = '(?:' . join('|', @{$total_port}) . ')';
    }

    return $reg;
}

=pod

=head1 validatePortUserSpace

It validates if the port is being used for some process in the user space

Parameters:

    ip       - IP address. If the IP is '0.0.0.0', it checks that other farm or process are not using the port
    port     - TCP port number. It accepts l4xnat multport format: intervals (55:66,70), all ports (*).
    protocol - It is an array reference with the protocols to check ("udp", "tcp" and "sctp"), if some of them is used, the function returns 0.
    farmname - If the configuration is set in this farm, the check is ignored and true. This parameters is optional.
    process  - It is the process name to ignore. It is used when a process wants to be modified with all IPs parameter. 
               The services to ignore are: "cherokee", "sshd" and "snmp"

Returns: integer

- 1: if the port and IP are valid to be used
- 0: if the port and IP are already applied in the system

=cut

sub validatePortUserSpace ($ip, $port, $proto, $farmname = undef, $process = undef) {
    my $override;

    # skip if the running farm is itself
    if (defined $farmname) {
        require Relianoid::Farm::Base;

        my $type = &getFarmType($farmname);
        if ($type =~ /http|gslb|eproxy/) {
            my $cur_vip  = &getFarmVip('vip',  $farmname);
            my $cur_port = &getFarmVip('vipp', $farmname);

            if (    &getFarmStatus($farmname) eq 'up'
                and $cur_vip eq $ip
                and $cur_port eq $port)
            {
                &log_debug("The networking configuration matches with the own farm", "networking");
                return 1;
            }
        }
        elsif ($type eq "l4xnat") {
            $override = 1;
        }
    }

    my $netstat = &getGlobalConfiguration('netstat_bin');

    my $f_ipversion = (&ipversion($ip) == 6) ? "6" : "4";
    $ip = &getNetIpFormat($ip, 'netstat') if ($f_ipversion eq '6');

    my $f       = "lpnW";
    my $f_proto = "";

    for my $p (@{$proto}) {
        # it is not supported in the system
        if   ($p eq 'sctp') { next; }
        else                { $f_proto .= "--$p "; }
    }

    my $cmd = "$netstat -$f_ipversion -${f} ${f_proto} ";
    my @out = @{ &logAndGet($cmd, 'array') };
    shift @out;
    shift @out;

    if (defined $process) {
        my $filter = '^\s*(?:[^\s]+\s+){5,6}\d+\/' . $process;
        @out = grep { !/$filter/ } @out;
        return 1 if (!@out);
    }

    # This code was modified for a bugfix. There was a issue when a l4 farm
    # is set and some management interface is set to use all the interfaces
    # my $ip_reg = ( $ip eq '0.0.0.0' ) ? '[^\s]+' : "(?:0.0.0.0|::1|$ip)";

    my $ip_reg;
    if (defined $override and $override) {
        # L4xnat overrides the user space daemons that are listening on all interfaces
        $ip_reg = ($ip eq '0.0.0.0') ? '[^\s]+' : "(?:$ip)";
    }
    else {
        # L4xnat farms does not override the user space daemons
        $ip_reg = ($ip eq '0.0.0.0') ? '[^\s]+' : "(?:0.0.0.0|::1|$ip)";
    }

    my $port_reg = &getMultiportRegex($port);

    my $filter = '^\s*(?:[^\s]+\s+){3,3}' . $ip_reg . ':' . $port_reg . '\s';
    @out = grep { /$filter/ } @out;

    if (@out) {
        &log_warn("The ip '$ip' and the port '$port' are being used for some process", "networking");
        return 0;
    }

    return 1;
}

=pod

=head1 validatePort

It checks if an IP and a port (checking the protocol) are already configured in the system.
This is used to validate that more than one process or farm are not running with the same
networking configuration.

It checks the information with the "netstat" command, if the port is not found it will look for
between the l4xnat farms (that are up).

If this function is called with more than one protocol. It will recall itself recursively
for each one.

Parameters:

    ip       - IP address. If the IP is '0.0.0.0', it checks that other farm or process are not using the port
    port     - TCP port number. It accepts l4xnat multport format: intervals (55:66,70), all ports (*).
    protocol - It is an array reference with the protocols to check, if some of them is used, the function returns 0. 
                The accepted protocols are: 'all' (no one is checked), sctp, tcp and udp
    farmname - If the configuration is set in this farm, the check is ignored and true. This parameters is optional.
    process  - It is the process name to ignore. It is used when a process wants to be modified with all IPs parameter. 
                The services to ignore are: "cherokee", "sshd" and "snmp"

Returns: integer

    1 - if the port and IP are available to be used
    0 - if the port and IP are already being used in the system

=cut

sub validatePort ($ip, $port, $proto, $farmname = undef, $process = undef) {
    if ($ip eq '*') {
        $ip = '0.0.0.0';
    }

    if (!defined $proto && !defined $farmname) {
        &log_error("Check port needs the protocol to validate the ip '$ip' and the port '$port'", "networking");
        return 0;
    }

    if (!defined $proto) {
        $proto = &getFarmType($farmname);
        if ($proto eq 'l4xnat') {
            require Relianoid::Farm::L4xNAT::Config;
            $proto = &getL4FarmParam('proto', $farmname);
        }
    }

    $proto = &getProtoTransport($proto);

    # TODO: add check for avoiding collision with datalink VIPs
    return 0 if (!&validatePortUserSpace($ip, $port, $proto, $farmname, $process));
    return 0 if (!&validatePortKernelSpace($ip, $port, $proto, $farmname));
    return 1;
}

=pod

=head1 ipisok

Check if a string has a valid IP address format.

Parameters:

    checkip - IP address string.
    version - Optional. 4 or 6 to validate IPv4 or IPv6 only.

Returns: string - "true" or "false".

=cut

sub ipisok ($checkip, $version = undef) {
    require Data::Validate::IP;
    Data::Validate::IP->import();

    if (!$version || $version == 4) {
        return "true" if is_ipv4($checkip)
    }

    if (!$version || $version == 6) {
        return "true" if is_ipv6($checkip)
    }

    return "false";
}

=pod

=head1 validIpAndNet

Validate if the input is a valid IP or networking segement

Parameters:

    ip - IP address or IP network segment. ipv4 or ipv6

Returns: integer

- 1: The IP address is valid
- 0: The IP address is not valid

=cut

sub validIpAndNet ($ip) {
    use NetAddr::IP;
    my $out = NetAddr::IP->new($ip);

    return int(defined $out);
}

=pod

=head1 ipversion

IP version number of an input IP address

Parameters:

    ip - string - IP address

Returns: integer

- 4: ipv4
- 6: ipv6
- 0: unknown

=cut

sub ipversion ($ip) {
    require Data::Validate::IP;
    Data::Validate::IP->import();

    return 4 if is_ipv4($ip);
    return 6 if is_ipv6($ip);
    return 0;
}

=pod

=head1 validateGateway

Check if the network configuration is valid. This function receive two IP
address and a net segment and check if both address are in the segment.
It is usefull to check if the gateway is correct or to check a new IP
for a interface

Parameters:

    ip      - IP from net segment
    netmask - Net segment
    new_ip  - IP to check if it is from net segment

Returns: integer

    1 - the configuration is correct
    0 - the configuration is not correct

=cut

sub validateGateway ($ip, $mask, $ip2, $mask2 = undef) {
    require NetAddr::IP;

    unless (defined $mask2) {
        $mask2 = $mask;
    }

    my $addr1 = NetAddr::IP->new($ip,  $mask);
    my $addr2 = NetAddr::IP->new($ip2, $mask2);

    return (defined $addr1 && defined $addr2 && ($addr1->network() eq $addr2->network())) ? 1 : 0;
}

=pod

=head1 ifexist

Check if an interface exists.

Look for link interfaces, Virtual interfaces return "false".
If the interface is IFF_RUNNING or configuration file exists return "true".
If interface found but not IFF_RUNNING nor configutaion file exists returns "created".

Parameters:

    nif - network interface name.

Returns: string - "true", "false" or "created".

=cut

sub ifexist ($nif) {
    use IO::Interface qw(:flags);    # Needs to load with 'use'

    require IO::Socket;
    require Relianoid::Net::Interface;

    my $s          = IO::Socket::INET->new(Proto => 'udp');
    my @interfaces = &getInterfaceList();
    my $configdir  = &getGlobalConfiguration('configdir');
    my $status;

    for my $if (@interfaces) {
        next if $if ne $nif;

        my $flags = $s->if_flags($if);

        if   ($flags & IFF_RUNNING) { $status = "up"; }
        else                        { $status = "down"; }

        if ($status eq "up" || -e "$configdir/if_$nif\_conf") {
            return "true";
        }

        return "created";
    }

    return "false";
}

=pod

=head1 checkNetworkExists

Check if a network exists in other interface

Parameters:

    ip         - string - IP address
    mask       - string - Netmask
    exception  - string - Optional. Interface name to be excluded.
                          It is used to exclude the interface that is been changed
    duplicated - string - Optional. Overrides the "check duplicated network" option.
                                    Expects "true" or "false" when defined.

Returns: string

- interface name - if the network is found
- empty string   - if the network is not found

=cut

sub checkNetworkExists ($net, $mask, $exception = undef, $duplicated = undef) {
    # $duplicated will override the configured default
    if (defined $duplicated) {
        return "" if $duplicated eq "true";
    }
    else {
        return "" if &getGlobalConfiguration("duplicated_net") eq "true";
    }

    require Relianoid::Net::Interface;
    require NetAddr::IP;

    my $net1 = NetAddr::IP->new($net, $mask);
    my @interfaces;

    my @system_interfaces = &getInterfaceList();
    my $params            = [ "name", "addr", "mask" ];

    for my $if_name (@system_interfaces) {
        next if (&getInterfaceType($if_name) !~ /^(?:nic|bond|vlan|gre)$/);

        my $output_if = &getInterfaceConfigParam($if_name, $params) || &getSystemInterface($if_name);
        push(@interfaces, $output_if);
    }

    my $found = 0;

    for my $if_ref (@interfaces) {
        next if defined $exception and $if_ref->{name} eq $exception;
        next if !$if_ref->{addr};

        # found
        my $net2 = NetAddr::IP->new($if_ref->{addr}, $if_ref->{mask});

        eval {
            if ($net1->contains($net2) or $net2->contains($net1)) {
                $found = 1;
            }
        };

        return $if_ref->{name} if $found;
    }

    return "";
}

=pod

=head1 checkDuplicateNetworkExists

Check if duplicate network exists in the interfaces

Parameters: None

Returns: string

- interface name - if the network is found
- empty string   - if the network is not found

=cut

sub checkDuplicateNetworkExists () {
    #if duplicated network is not allowed then don't check if network exists.
    require Relianoid::Config;

    return "" if &getGlobalConfiguration("duplicated_net") eq "false";

    require Relianoid::Net::Interface;
    require NetAddr::IP;

    my @interfaces = map { &getInterfaceTypeList($_) } qw(nic bond vlan);

    for my $if_ref (@interfaces) {
        my $iface = &checkNetworkExists($if_ref->{addr}, $if_ref->{mask}, $if_ref->{name}, "false");
        return $iface if $iface;
    }

    return "";
}

=pod

=head1 validBackendStack

Check if a list of backends have their IP address in the same stack (IP version) as an IP address of reference

Parameters:

    be_aref - array reference - Array of backend hashes
    ip      - string - IP address

Returns: integer

    1 - the ip is valid
    0 - the IP address is not in the same network segment

=cut

sub validBackendStack ($be_aref, $ip) {
    my $ip_stack     = &ipversion($ip);
    my $ipv_mismatch = 0;

    # check every backend ip version
    for my $be (@{$be_aref}) {
        my $current_stack = &ipversion($be->{ip});
        $ipv_mismatch = $current_stack ne $ip_stack;
        last if $ipv_mismatch;
    }

    return (!$ipv_mismatch);
}

=pod

=head1 validateNetmask

It validates if a netmask is valid for IPv4 or IPv6

Parameters:

    netmask    - string - Netmask
    ip_version - integer - Optional. 4 or 6 are the expected values.
                           If no value is passed, it checks if the netmask is valid for any IP version

Returns: integer

    1 - success
    0 - error

=cut

sub validateNetmask ($mask, $ipversion = undef) {
    unless (defined $mask) {
        croak("mask is required");
    }

    $ipversion //= 0;
    my $success = 0;
    my $ip      = "127.0.0.1";

    if ($ipversion == 0 or $ipversion == 6) {
        return 1 if ($mask =~ /^\d+$/ and $mask <= 64);
    }
    if ($ipversion == 0 or $ipversion == 4) {
        if ($mask =~ /^\d+$/) {
            $success = 1 if $mask <= 32;
        }
        else {
            require Net::Netmask;
            my $block = Net::Netmask->new($ip, $mask);
            $success = (!exists $block->{ERROR});
        }
    }

    return $success;
}

=pod

=head1 getNextAvailableLocalPort

It validates if the port is being used for some process in the user space

Parameters:

    None.

Returns:

    integer - port to be used. Undefined if there is no port available.

=cut

sub getNextAvailableLocalPort () {
    my $ip = "127.0.0.1";
    my @protocol = ('tcp');
    my $first_port = 100;
    my $last_port = 10000;

    for my $port ($first_port .. $last_port) {
        if (&validatePortUserSpace($ip, $port, \@protocol)) {
            return $port;
        }
    }

    return;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Netfilter.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Netfilter

=cut

=pod

=head1 loadNfModule

=cut

sub loadNfModule ($modname, $params) {
    my $status  = 0;
    my $lsmod   = &getGlobalConfiguration('lsmod');
    my @modules = @{ &logAndGet($lsmod, "array") };

    if (!grep { /^$modname /x } @modules) {
        my $modprobe         = &getGlobalConfiguration('modprobe');
        my $modprobe_command = "$modprobe $modname $params";

        &log_info("L4 loadNfModule: $modprobe_command", "SYSTEM");
        $status = &logAndRun("$modprobe_command");
    }

    return $status;
}

=pod

=head1 removeNfModule

=cut

sub removeNfModule ($modname) {
    my $modprobe         = &getGlobalConfiguration('modprobe');
    my $modprobe_command = "$modprobe -r $modname";

    &log_info("L4 removeNfModule: $modprobe_command", "SYSTEM");

    return &logAndRun("$modprobe_command");
}

=pod

=head1 getNewMark

=cut

sub getNewMark ($farm_name) {
    require Tie::File;
    require Relianoid::Lock;

    my $found       = 0;
    my $marknum     = 0x200;
    my $fwmarksconf = &getGlobalConfiguration('fwmarksconf');
    my @contents;

    &ztielock(\@contents, "$fwmarksconf");

    for my $i (512 .. 4095) {
        my $num = sprintf("0x%x", $i);
        if (!grep { /^$num/x } @contents) {
            $found   = 1;
            $marknum = $num;
            last;
        }
    }

    if ($found) {
        push @contents, "$marknum // FARM\_$farm_name\_";
    }

    untie @contents;

    return $marknum;
}

=pod

=head1 delMarks

=cut

sub delMarks ($farm_name = "", $mark = "") {
    require Relianoid::Lock;

    my $status      = 0;
    my $fwmarksconf = &getGlobalConfiguration('fwmarksconf');
    my @contents;

    if ($farm_name ne "") {
        &ztielock(\@contents, "$fwmarksconf");
        @contents = grep { !/ \/\/ FARM\_$farm_name\_$/ } @contents;
        untie @contents;
    }

    if ($mark ne "") {
        &ztielock(\@contents, "$fwmarksconf");
        @contents = grep { !/^$mark \/\/ FARM\_/ } @contents;
        untie @contents;
    }

    return $status;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/Nft.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::Nft

=cut

=pod

=head1 getNlbPid

Return the nftlb pid

Parameters:

    none

Returns:

    Integer - PID if successful or -1 on failure

=cut

sub getNlbPid () {
    my $nlbpidfile = &getNlbPidFile();
    my $nlbpid     = -1;

    if (!-f "$nlbpidfile") {
        return -1;
    }

    open my $fd, '<', "$nlbpidfile";
    $nlbpid = <$fd>;
    close $fd;

    if ($nlbpid eq "") {
        return -1;
    }

    return $nlbpid;
}

=pod

=head1 getNlbPidFile

Return the nftlb pid file

Parameters:

    none

Returns:

    String - Pid file path or -1 on failure

=cut

sub getNlbPidFile () {
    my $piddir     = &getGlobalConfiguration('piddir');
    my $nlbpidfile = "$piddir/nftlb.pid";

    return $nlbpidfile;
}

=pod

=head1 startNlb

Launch the nftlb daemon and create the PID file. Do
nothing if already is launched.

Parameters:

    none

Returns:

    Integer - return PID on success or <= 0 on failure

=cut

sub startNlb () {
    my $nftlbd         = &getGlobalConfiguration('bin_dir') . "/nftlbd";
    my $pidof          = &getGlobalConfiguration('pidof');
    my $nlbpidfile     = &getNlbPidFile();
    my $nlbpid         = &getNlbPid();
    my $nlbpid_current = &logAndGet("$pidof nftlb");

    if (($nlbpid eq "-1") or ($nlbpid_current eq "")) {
        &logAndRun("$nftlbd start");

        #required to wait at startup to ensure the process is up
        sleep 1;

        $nlbpid = &logAndGet("$pidof nftlb");
        if ($nlbpid eq "") {
            return -1;
        }

        open my $fd, '>', "$nlbpidfile";
        print $fd "$nlbpid";
        close $fd;
    }

    return $nlbpid;
}

=pod

=head1 httpNlbRequest

Send an action to nftlb

Parameters:

    self - hash that includes hash_keys:

    file:   file where the HTTP body response of the nftlb is saved
    method: HTTP verb for nftlb request
    uri:    HTTP URI for nftlb request
    body:   body to use in POST and PUT requests
    check:  if this parameter is defined is a flag to not print error if
            the request is used to check if a element exists.

Returns: integer

return code of the request command

=cut

sub httpNlbRequest ($self) {
    my $curl_cmd = &getGlobalConfiguration('curl_bin');
    my $body     = "";

    my $pid = &startNlb();
    if ($pid <= 0) {
        return -1;
    }

    chomp($curl_cmd);

    return -1 if not $curl_cmd;

    if (defined $self->{body} && $self->{body} ne "") {
        $body = qq(-d'$self->{body}');
    }

    my $url    = qq(http://127.0.0.1:27$self->{uri});
    my $execmd = qq($curl_cmd -w "%{http_code}" --noproxy "*" -s -H "Key: HoLa" -X "$self->{method}" $body $url);

    my $file_tmp = "/tmp/nft_$$";
    my $file     = $file_tmp;

    if ($self->{file} && $self->{file} =~ /ipds|policy/) {
        $file = $self->{file};
    }

    # Send output to a file to get only the http code by the standard output
    $execmd = $execmd . " -o $file";

    my $output = &logAndGet($execmd);

    if ($output !~ /^2/) {    # err
        my $tag = (exists $self->{check}) ? 'debug' : 'error';
        my $msg = "cmd failed: $execmd";

        if (not &debug()) {
            if (exists $self->{check}) {
                &log_debug($msg, 'system');
            }
            else {
                &log_error($msg, 'system');
            }
        }

        if (open(my $fh, '<', $file)) {
            local $/ = undef;
            my $err = <$fh>;
            close $fh;

            my $msg = "(code: $output): $err";

            if (exists $self->{check}) {
                &log_debug($msg, 'system');
            }
            else {
                &log_error($msg, 'system');
            }

            unlink $file_tmp if (-f $file_tmp);
        }
        else {
            &log_error("The file '$file' could not be opened", 'system');
        }

        return -1;
    }

    # filter ipds params into the configuration file
    if (   defined $self->{file}
        && $self->{file} ne ""
        && !-z "$file"
        && $file !~ /ipds/
        && $file !~ /policy/)

    {
        require Relianoid::Farm::L4xNAT::Config;
        &writeL4NlbConfigFile($file, $self->{file});
    }
    unlink $file_tmp if (-f $file_tmp);

    return 0;
}

=pod

=head1 execNft

Execute the nft command

Parameters:

    action		- "add", "delete", "check" or "flush"
    table		- type and name of the table to be used (ej "netdev foo")
    chain_def	- name and definition of the chain to be used
    rule		- rule or pattern in case of deletion

Returns:

    Integer - 0 on success or != 0 on failure. In case of check action,

=cut

sub execNft ($action, $table, $chain_def, $rule) {
    my $nft   = &getGlobalConfiguration('nft_bin');
    my $chain = "";
    ($chain) = $chain_def =~ /^([\w\-\.\d]+)\s*.*$/;
    my $output = 0;

    if ($action eq "add") {
        &logAndRun("$nft add table $table");
        &logAndRun("$nft add chain $table $chain_def");
        $output = &logAndRun("$nft add rule $table $chain $rule");
    }
    elsif ($action eq "delete") {
        if (!defined $chain || $chain eq "") {
            &log_info("Deleting cluster table $table");
            $output = &logAndRun("$nft delete table $table");
        }
        elsif (!defined $rule || $rule eq "") {
            $output = &logAndRun("$nft delete chain $table $chain");
        }
        else {
            my @rules = @{ &logAndGet("$nft -a list chain $table $chain", 'array') };
            for my $r (@rules) {
                my ($handle) = $r =~ / $rule.* \# handle (\d)$/;
                if ($handle ne "") {
                    $output = &logAndRun("$nft delete rule $table $chain handle $handle");
                    last;
                }
            }
        }
    }
    elsif ($action eq "check") {
        if (!defined $chain || $chain eq "") {
            $output = 1;
            my @rules = @{ &logAndGet("$nft list table $table", 'array') };
            $output = 0 if (scalar @rules == 0);
            return $output;
        }
        else {
            my @rules = @{ &logAndGet("$nft list chain $table $chain", 'array') };
            for my $r (@rules) {
                if ($r =~ / $rule /) {
                    $output = 1;
                    last;
                }
            }
        }
    }
    elsif ($action eq "flush") {
        &logAndRun("$nft add table $table");
        &logAndRun("$nft add chain $table $chain_def");
        $output = &logAndRun("$nft flush chain $table $chain");
    }

    return $output;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/RRD.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use RRDs;
use MIME::Base64;
use Relianoid::Config;

my $eload = eval { require Relianoid::ELoad };

my $width     = "600";
my $height    = "150";
my $imagetype = "PNG";

=pod

=head1 Module

Relianoid::RRD

=cut

=pod

=head1 translateRRDTime

It translates a time from API format (11-09-2020-14:05) to RRD format (11/09/2020 14:05).
Also, it returns the rrd format for daily, weekly, monthly or yearly.

Parameters:

    time - Time in API format

Returns:

    scalar - Date in RRD format

=cut

sub translateRRDTime ($time) {
    if (!defined $time) {
        return "now";
    }
    elsif ($time =~ /^([dwmy])/) {
        return "-1$1";
    }
    elsif ($time =~ /^(\d\d-\d\d-(?:\d\d)?\d\d)-(\d\d:\d\d)$/) {
        # in (api): "11-09-2020-14:05"
        # out(rrd): "11/09/2020 14:05"
        my $date = $1;
        my $hour = $2;

        $date =~ s'-'/'g;
        return "$date $hour";
    }
    return $time;
}

=pod

=head1 logRRDError

It checks if some error exists in the last RRD read and it logs it

Parameters:

    graph file - it is the graph file created of reading the RRD

Returns: integer - Error code.

- 0: success
- 1: error 

=cut

sub logRRDError ($graph) {
    my $error = RRDs::error;

    if ($error || !-s $graph) {
        $error //= 'The graph was not generated';
        &log_error("$0: unable to generate $graph: $error");
        return 1;
    }

    return 0;
}

=pod

=head1 getRRDAxisXLimits

It returns the first and last time value for a graph.
It returns the times with the RELIANOID API format (11-09-2020-14:05)

Parameters:

    start - string - Date of the begining of the chart
    last  - string - Date of the end of the chart

Returns: array

Pair of strings with the dates defining the range of a chart, both included.

=cut

sub getRRDAxisXLimits ($start, $last) {
    my $format = "%m-%d-%Y-%H:%M";

    use POSIX qw(strftime);

    ($start, $last) = RRDs::times($start, $last);

    #     0    1    2     3     4    5     6     7     8
    # my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
    my @t = localtime($last);
    $last  = strftime($format, @t);
    @t     = localtime($start);
    $start = strftime($format, @t);

    return ($start, $last);
}

=pod

=head1 printImgFile

Get a file encoded in base64 and remove it.

Parameters:

    file - Path to image file.

Returns: string

- On success: Base64 encoded image.
- On error: Empty string.

=cut

sub printImgFile ($file) {
    if (open my $png, '<', $file) {
        my $raw_string = do { local $/ = undef; <$png>; };
        my $encoded    = encode_base64($raw_string);

        close $png;

        unlink($file);
        return $encoded;
    }
    else {
        return "";
    }
}

=pod

=head1 delGraph

Remove a farm,  network interface or vpn graph.

Parameters:

    name - Name of the graph resource, without sufixes.
    type - 'farm', 'iface', 'vpn'.

Returns: Nothing

=cut

sub delGraph ($name, $type) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');

    if ($type =~ /iface/) {
        my $filename = "${collector_rrd_dir}/${name}iface.rrd";
        &log_info("Delete graph file: ${filename}", "MONITOR");
        unlink($filename);
    }

    if ($type =~ /farm/) {
        my $filename = "${collector_rrd_dir}/${name}-farm.rrd";
        &log_info("Delete graph file: ${filename}", "MONITOR");
        unlink glob($filename);

        &eload(
            module => 'Relianoid::EE::IPDS::Stats',
            func   => 'delIPDSRRDFile',
            args   => [$name],
        ) if $eload;
    }

    if ($type =~ /vpn/) {
        my $filename = "${collector_rrd_dir}/${name}-vpn.rrd";
        &log_info("Delete graph file: ${filename}", "MONITOR");
        unlink glob($filename);
    }

    return;
}

=pod

=head1 printGraph

Get a graph 'type' of a period of time base64 encoded.

Parameters:

    type - Filter or name of the graph.
    time/start - This parameter can have one of the following values: *
        * Period of time shown in the image (Possible values: daily, d, weekly, w, monthly, m, yearly, y).
        * time which the graph starts. Format: MM-DD-YYYY-HH:mm (ie: 11-09-2020-14:05)
    end - time which the graph stops. The default value is "now", the current time.

Returns: hash reference

The output hash contains the following keys:

    img   - Base64 encoded image, or an empty string on failure,
    start - firt time of the graph
    last  - last time of the graph

=cut

sub printGraph ($type, $time, $end = "now") {
    my $graph_fn = sprintf "%s/${type}_${time}.png", &getGlobalConfiguration('img_dir');

    $time = &translateRRDTime($time);
    $end  = &translateRRDTime($end);

    if ($type eq "cpu") {
        &genCpuGraph($type, $graph_fn, $time, $end);
    }
    elsif ($type =~ /^dev-*/) {
        &genDiskGraph($type, $graph_fn, $time, $end);
    }
    elsif ($type eq "load") {
        &genLoadGraph($type, $graph_fn, $time, $end);
    }
    elsif ($type eq "mem") {
        &genMemGraph($type, $graph_fn, $time, $end);
    }
    elsif ($type eq "memsw") {
        &genMemSwGraph($type, $graph_fn, $time, $end);
    }
    elsif ($type =~ /iface$/) {
        &genNetGraph($type, $graph_fn, $time, $end);
    }
    elsif ($type =~ /-farm$/) {
        &genFarmGraph($type, $graph_fn, $time, $end);
    }
    elsif ($eload and $type =~ /ipds$/) {
        &eload(
            module => 'Relianoid::EE::IPDS::Stats',
            func   => 'genIPDSGraph',
            args   => [ $type, $graph_fn, $time, $end ],
        );
    }
    elsif ($eload && $type =~ /-vpn$/) {
        &genVPNGraph($type, $graph_fn, $time);
    }
    else {
        &log_error("The requested graph '$type' is unknown");
        return {};
    }

    if (&logRRDError($graph_fn)) {
        return {};
    }

    ($time, $end) = &getRRDAxisXLimits($time, $end);

    return {
        img   => &printImgFile($graph_fn),
        start => $time,
        last  => $end
    };
}

=pod

=head1 genCpuGraph

Generate CPU usage graph image file for a period of time.

Parameters:

    type  - Database name without extension.
    graph - Path to file to be generated.
    start - time which the graph starts. Format: MM-DD-YYYY-HH:mm (ie: 11-09-2020-14:05)
    end   - time which the graph stops

Returns: Nothing

=cut

sub genCpuGraph ($type, $graph, $start, $end) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $cpu_db            = "${collector_rrd_dir}/${type}.rrd";

    if (-e $cpu_db) {
        RRDs::graph(
            $graph,
            "--imgformat=${imagetype}",
            "--start=${start}",
            "--end=${end}",
            "--width=${width}",
            "--height=${height}",
            "--alt-autoscale-max",
            "--lower-limit=0",
            "--title=CPU",
            "--vertical-label=%",
            "DEF:user=${cpu_db}:user:AVERAGE",
            "DEF:nice=${cpu_db}:nice:AVERAGE",
            "DEF:sys=${cpu_db}:sys:AVERAGE",
            "DEF:iowait=${cpu_db}:iowait:AVERAGE",
            "DEF:irq=${cpu_db}:irq:AVERAGE",
            "DEF:softirq=${cpu_db}:softirq:AVERAGE",
            "DEF:idle=${cpu_db}:idle:AVERAGE",
            "DEF:tused=${cpu_db}:tused:AVERAGE",
            "AREA:sys#DC374A:System\\t",
            "GPRINT:sys:LAST:Last\\:%8.2lf %%",
            "GPRINT:sys:MIN:Min\\:%8.2lf %%",
            "GPRINT:sys:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:sys:MAX:Max\\:%8.2lf %%\\n",
            "STACK:user#6B2E9A:User\\t\\t",
            "GPRINT:user:LAST:Last\\:%8.2lf %%",
            "GPRINT:user:MIN:Min\\:%8.2lf %%",
            "GPRINT:user:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:user:MAX:Max\\:%8.2lf %%\\n",
            "STACK:nice#ACD936:Nice\\t\\t",
            "GPRINT:nice:LAST:Last\\:%8.2lf %%",
            "GPRINT:nice:MIN:Min\\:%8.2lf %%",
            "GPRINT:nice:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:nice:MAX:Max\\:%8.2lf %%\\n",
            "STACK:iowait#8D85F3:Iowait\\t",
            "GPRINT:iowait:LAST:Last\\:%8.2lf %%",
            "GPRINT:iowait:MIN:Min\\:%8.2lf %%",
            "GPRINT:iowait:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:iowait:MAX:Max\\:%8.2lf %%\\n",
            "STACK:irq#46F2A2:Irq\\t\\t",
            "GPRINT:irq:LAST:Last\\:%8.2lf %%",
            "GPRINT:irq:MIN:Min\\:%8.2lf %%",
            "GPRINT:irq:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:irq:MAX:Max\\:%8.2lf %%\\n",
            "STACK:softirq#595959:Softirq\\t",
            "GPRINT:softirq:LAST:Last\\:%8.2lf %%",
            "GPRINT:softirq:MIN:Min\\:%8.2lf %%",
            "GPRINT:softirq:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:softirq:MAX:Max\\:%8.2lf %%\\n",
            "STACK:idle#46b971:Idle\\t\\t",
            "GPRINT:idle:LAST:Last\\:%8.2lf %%",
            "GPRINT:idle:MIN:Min\\:%8.2lf %%",
            "GPRINT:idle:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:idle:MAX:Max\\:%8.2lf %%\\n",
            "LINE1:tused#000000:Total used\\t",
            "GPRINT:tused:LAST:Last\\:%8.2lf %%",
            "GPRINT:tused:MIN:Min\\:%8.2lf %%",
            "GPRINT:tused:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:tused:MAX:Max\\:%8.2lf %%\\n"
        );
    }

    return;
}

=pod

=head1 genDiskGraph

Generate disk partition usage graph image file for a period of time.

Parameters:

    type  - Database name without extension.
    graph - Path to file to be generated.
    start - time which the graph starts. Format: MM-DD-YYYY-HH:mm (ie: 11-09-2020-14:05)
    end   - time which the graph stops

Returns: Nothing

=cut

sub genDiskGraph ($type, $graph, $start, $end) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $hd_db             = "${collector_rrd_dir}/${type}.rrd";

    my $device = $type;
    $device =~ s/hd$//;
    $device =~ s/dev-//;
    $device =~ s/-/\// if $device !~ /dm-/;

    my $mount = &getDiskMountPoint($device);

    if (-e $hd_db) {
        RRDs::graph(
            $graph,
            "--start=${start}",                        #
            "--end=${end}",                            #
            "--title=PARTITION ${mount}",              #
            "--vertical-label=SPACE",                  #
            "--width=${width}",                        #
            "--height=${height}",                      #
            "--lazy",                                  #
            "-l 0",                                    #
            "-a",                                      #
            "$imagetype",                              #
            "DEF:tot=${hd_db}:tot:AVERAGE",            #
            "DEF:used=${hd_db}:used:AVERAGE",          #
            "DEF:free=${hd_db}:free:AVERAGE",          #
            "CDEF:total=used,free,+",                  #
            "AREA:used#595959:Used\\t",                #
            "GPRINT:used:LAST:Last\\:%8.2lf %s",       #
            "GPRINT:used:MIN:Min\\:%8.2lf %s",         #
            "GPRINT:used:AVERAGE:Avg\\:%8.2lf %s",     #
            "GPRINT:used:MAX:Max\\:%8.2lf %s\\n",      #
            "STACK:free#46b971:Free\\t",               #
            "GPRINT:free:LAST:Last\\:%8.2lf %s",       #
            "GPRINT:free:MIN:Min\\:%8.2lf %s",         #
            "GPRINT:free:AVERAGE:Avg\\:%8.2lf %s",     #
            "GPRINT:free:MAX:Max\\:%8.2lf %s\\n",      #
            "LINE1:total#000000:Total\\t",             #
            "GPRINT:total:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:total:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:total:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:total:MAX:Max\\:%8.2lf %s\\n"      #
        );
    }

    return;
}

=pod

=head1 genLoadGraph

Generate system load graph image file for a period of time.

Parameters:

    type  - Database name without extension.
    graph - Path to file to be generated.
    start - Period of time shown in the graph.
    end   - End time period

Returns: Nothing

=cut

sub genLoadGraph ($type, $graph, $start, $end) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $load_db           = "${collector_rrd_dir}/${type}.rrd";

    if (-e $load_db) {
        RRDs::graph(
            $graph,                                      #
            "--imgformat=${imagetype}",                  #
            "--start=${start}",                          #
            "--end=${end}",                              #
            "--width=${width}",                          #
            "--height=${height}",                        #
            "--alt-autoscale-max",                       #
            "--lower-limit=0",                           #
            "--title=LOAD AVERAGE",                      #
            "--vertical-label=LOAD",                     #
            "DEF:load=${load_db}:load:AVERAGE",          #
            "DEF:load5=${load_db}:load5:AVERAGE",        #
            "DEF:load15=${load_db}:load15:AVERAGE",      #
            "AREA:load#729e00:last minute\\t\\t",        #
            "GPRINT:load:LAST:Last\\:%3.2lf",            #
            "GPRINT:load:MIN:Min\\:%3.2lf",              #
            "GPRINT:load:AVERAGE:Avg\\:%3.2lf",          #
            "GPRINT:load:MAX:Max\\:%3.2lf\\n",           #
            "STACK:load5#46b971:last 5 minutes\\t",      #
            "GPRINT:load5:LAST:Last\\:%3.2lf",           #
            "GPRINT:load5:MIN:Min\\:%3.2lf",             #
            "GPRINT:load5:AVERAGE:Avg\\:%3.2lf",         #
            "GPRINT:load5:MAX:Max\\:%3.2lf\\n",          #
            "STACK:load15#595959:last 15 minutes\\t",    #
            "GPRINT:load15:LAST:Last\\:%3.2lf",          #
            "GPRINT:load15:MIN:Min\\:%3.2lf",            #
            "GPRINT:load15:AVERAGE:Avg\\:%3.2lf",        #
            "GPRINT:load15:MAX:Max\\:%3.2lf\\n"          #
        );
    }

    return;
}

=pod

=head1 genMemGraph

Generate RAM memory usage graph image file for a period of time.

Parameters:

    type - Database name without extension.
    graph - Path to file to be generated.
    start - time which the graph starts. Format: MM-DD-YYYY-HH:mm (ie: 11-09-2020-14:05)
    end - time which the graph stops

Returns: Nothing

=cut

sub genMemGraph ($type, $graph, $start, $end) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $ram_db            = "${collector_rrd_dir}/${type}.rrd";

    if (-e $ram_db) {
        RRDs::graph(
            $graph,                                   #
            "--imgformat=${imagetype}",               #
            "--start=${start}",                       #
            "--end=${end}",                           #
            "--width=${width}",                       #
            "--height=${height}",                     #
            "--alt-autoscale-max",                    #
            "--lower-limit=0",                        #
            "--title=RAM",                            #
            "--vertical-label=MEMORY",                #
            "--base=1024",                            #
            "DEF:memt=${ram_db}:memt:AVERAGE",        #
            "DEF:memu=${ram_db}:memu:AVERAGE",        #
            "DEF:memf=${ram_db}:memf:AVERAGE",        #
            "DEF:memc=${ram_db}:memc:AVERAGE",        #
            "AREA:memu#595959:Used\\t\\t",            #
            "GPRINT:memu:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:memu:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:memu:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:memu:MAX:Max\\:%8.2lf %s\\n",     #
            "STACK:memf#46b971:Free\\t\\t",           #
            "GPRINT:memf:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:memf:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:memf:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:memf:MAX:Max\\:%8.2lf %s\\n",     #
            "LINE2:memc#46F2A2:Cache&Buffer\\t",      #
            "GPRINT:memc:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:memc:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:memc:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:memc:MAX:Max\\:%8.2lf %s\\n",     #
            "LINE1:memt#000000:Total\\t\\t",          #
            "GPRINT:memt:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:memt:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:memt:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:memt:MAX:Max\\:%8.2lf %s\\n"      #
        );
    }

    return;
}

=pod

=head1 genMemSwGraph

Generate swap memory usage graph image file for a period of time.

Parameters:

    type  - Database name without extension.
    graph - Path to file to be generated.
    start - time which the graph starts. Format: MM-DD-YYYY-HH:mm (ie: 11-09-2020-14:05)
    end   - time which the graph stops

Returns: Nothing

=cut

sub genMemSwGraph ($type, $graph, $start, $end) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $swap_db           = "${collector_rrd_dir}/${type}.rrd";

    if (-e $swap_db) {
        RRDs::graph(
            $graph,                                  #
            "--imgformat=${imagetype}",              #
            "--start=${start}",                      #
            "--end=${end}",                          #
            "--width=${width}",                      #
            "--height=${height}",                    #
            "--alt-autoscale-max",                   #
            "--lower-limit=0",                       #
            "--title=SWAP",                          #
            "--vertical-label=MEMORY",               #
            "--base=1024",                           #
            "DEF:swt=${swap_db}:swt:AVERAGE",        #
            "DEF:swu=${swap_db}:swu:AVERAGE",        #
            "DEF:swf=${swap_db}:swf:AVERAGE",        #
            "DEF:swc=${swap_db}:swc:AVERAGE",        #
            "AREA:swu#595959:Used\\t\\t",            #
            "GPRINT:swu:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:swu:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:swu:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:swu:MAX:Max\\:%8.2lf %s\\n",     #
            "STACK:swf#46b971:Free\\t\\t",           #
            "GPRINT:swf:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:swf:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:swf:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:swf:MAX:Max\\:%8.2lf %s\\n",     #
            "LINE2:swc#46F2A2:Cached\\t",            #
            "GPRINT:swc:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:swc:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:swc:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:swc:MAX:Max\\:%8.2lf %s\\n",     #
            "LINE1:swt#000000:Total\\t\\t",          #
            "GPRINT:swt:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:swt:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:swt:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:swt:MAX:Max\\:%8.2lf %s\\n",     #
        );
    }

    return;
}

=pod

=head1 genNetGraph

Generate network interface usage graph image file for a period of time.

Parameters:

    type  - Database name without extension.
    graph - Path to file to be generated.
    start - time which the graph starts. Format: MM-DD-YYYY-HH:mm (ie: 11-09-2020-14:05)
    end   - time which the graph stops

Returns: Nothing

=cut

sub genNetGraph ($type, $graph, $start, $end) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $interface_db      = "${collector_rrd_dir}/${type}.rrd";
    my $interface_name    = $type;
    $interface_name =~ s/iface//g;

    if (-e $interface_db) {
        RRDs::graph(
            $graph,                                                #
            "--imgformat=${imagetype}",                            #
            "--start=${start}",                                    #
            "--end=${end}",                                        #
            "--height=${height}",                                  #
            "--width=${width}",                                    #
            "--lazy",                                              #
            "-l 0",                                                #
            "--alt-autoscale-max",                                 #
            "--title=TRAFFIC ON ${interface_name}",                #
            "--vertical-label=BANDWIDTH",                          #
            "DEF:in=${interface_db}:in:AVERAGE",                   #
            "DEF:out=${interface_db}:out:AVERAGE",                 #
            "CDEF:in_bytes=in,1024,*",                             #
            "CDEF:out_bytes=out,1024,*",                           #
            "CDEF:out_bytes_neg=out_bytes,-1,*",                   #
            "AREA:in_bytes#46b971:In ",                            #
            "LINE1:in_bytes#000000",                               #
            "GPRINT:in_bytes:LAST:Last\\:%5.1lf %sByte/sec",       #
            "GPRINT:in_bytes:MIN:Min\\:%5.1lf %sByte/sec",         #
            "GPRINT:in_bytes:AVERAGE:Avg\\:%5.1lf %sByte/sec",     #
            "GPRINT:in_bytes:MAX:Max\\:%5.1lf %sByte/sec\\n",      #
            "AREA:out_bytes_neg#595959:Out",                       #
            "LINE1:out_bytes_neg#000000",                          #
            "GPRINT:out_bytes:LAST:Last\\:%5.1lf %sByte/sec",      #
            "GPRINT:out_bytes:MIN:Min\\:%5.1lf %sByte/sec",        #
            "GPRINT:out_bytes:AVERAGE:Avg\\:%5.1lf %sByte/sec",    #
            "GPRINT:out_bytes:MAX:Max\\:%5.1lf %sByte/sec\\n",     #
            "HRULE:0#000000"                                       #
        );
    }

    return;
}

=pod

=head1 genFarmGraph

Generate farm connections graph image file for a period of time.

Parameters:

    type  - Database name without extension.
    graph - Path to file to be generated.
    start - time which the graph starts. Format: MM-DD-YYYY-HH:mm (ie: 11-09-2020-14:05)
    end   - time which the graph stops

Returns:

    none

See Also:

    <printGraph>

    <genCpuGraph>, <genDiskGraph>, <genLoadGraph>, <genMemGraph>, <genMemSwGraph>, <genNetGraph>, <genLoadGraph>

=cut

sub genFarmGraph ($type, $graph, $start, $end) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $farm_db           = "${collector_rrd_dir}/${type}.rrd";
    my $farm_name         = $type;
    $farm_name =~ s/-farm$//g;

    if (-e $farm_db) {
        RRDs::graph(
            $graph,
            "--start=${start}",
            "--end=${end}",
            "--height=${height}",    #
            "--width=${width}",      #
            "--lazy",
            "-l 0",
            "-a",
            "${imagetype}",
            "--title=CONNECTIONS ON ${farm_name} farm",
            "--vertical-label=Connections",
            "DEF:pending=${farm_db}:pending:AVERAGE",
            "DEF:established=${farm_db}:established:AVERAGE",

            # "DEF:closed=$db_farm:closed:AVERAGE",
            "LINE2:pending#595959:Pending\\t",
            "GPRINT:pending:LAST:Last\\:%6.0lf ",
            "GPRINT:pending:MIN:Min\\:%6.0lf ",
            "GPRINT:pending:AVERAGE:Avg\\:%6.0lf ",
            "GPRINT:pending:MAX:Max\\:%6.0lf \\n",
            "LINE2:established#46b971:Established\\t",
            "GPRINT:established:LAST:Last\\:%6.0lf ",
            "GPRINT:established:MIN:Min\\:%6.0lf ",
            "GPRINT:established:AVERAGE:Avg\\:%6.0lf ",
            "GPRINT:established:MAX:Max\\:%6.0lf \\n"

              # "LINE2:closed#46F2A2:Closed\\t",
              # "GPRINT:closed:LAST:Last\\:%6.0lf ",
              # "GPRINT:closed:MIN:Min\\:%6.0lf ",
              # "GPRINT:closed:AVERAGE:Avg\\:%6.0lf ",
              # "GPRINT:closed:MAX:Max\\:%6.0lf \\n"
        );
    }

    return;
}

=pod

=head1 genVPNGraph

Generate VPN usage graph image file for a period of time.

Parameters:

    type - Database name without extension.
    graph - Path to file to be generated.
    time - Period of time shown in the graph.

Returns: Nothing

=cut

sub genVPNGraph ($type, $graph, $time) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $vpn_db            = "${collector_rrd_dir}/${type}.rrd";
    my $vpn_name          = $type;
    $vpn_name =~ s/-vpn$//g;

    if (-e $vpn_db) {
        RRDs::graph(
            $graph,                                                #
            "--imgformat=${imagetype}",                            #
            "--start=-1${time}",                                   #
            "--height=${height}",                                  #
            "--width=${width}",                                    #
            "--lazy",                                              #
            "-l 0",                                                #
            "--alt-autoscale-max",                                 #
            "--title=TRAFFIC ON ${vpn_name}",                      #
            "--vertical-label=BANDWIDTH",                          #
            "DEF:in=${vpn_db}:in:AVERAGE",                         #
            "DEF:out=${vpn_db}:out:AVERAGE",                       #
            "CDEF:in_bytes=in,1024,*",                             #
            "CDEF:out_bytes=out,1024,*",                           #
            "CDEF:out_bytes_neg=out_bytes,-1,*",                   #
            "AREA:in_bytes#46b971:In ",                            #
            "LINE1:in_bytes#000000",                               #
            "GPRINT:in_bytes:LAST:Last\\:%5.1lf %sByte/sec",       #
            "GPRINT:in_bytes:MIN:Min\\:%5.1lf %sByte/sec",         #
            "GPRINT:in_bytes:AVERAGE:Avg\\:%5.1lf %sByte/sec",     #
            "GPRINT:in_bytes:MAX:Max\\:%5.1lf %sByte/sec\\n",      #
            "AREA:out_bytes_neg#595959:Out",                       #
            "LINE1:out_bytes_neg#000000",                          #
            "GPRINT:out_bytes:LAST:Last\\:%5.1lf %sByte/sec",      #
            "GPRINT:out_bytes:MIN:Min\\:%5.1lf %sByte/sec",        #
            "GPRINT:out_bytes:AVERAGE:Avg\\:%5.1lf %sByte/sec",    #
            "GPRINT:out_bytes:MAX:Max\\:%5.1lf %sByte/sec\\n",     #
            "HRULE:0#000000"                                       #
        );

        my $rrdError = RRDs::error;
        print "$0: unable to generate ${graph}: ${rrdError}\n" if ($rrdError);
    }

    return;
}

=pod

=head1 getGraphs2Show

Get list of graph names by type or all of them.

Parameters:

    graphtype - 'System', 'Network', 'Farm' or 'VPN'.

Returns: string list - List of graph names

=cut

#function that returns the graph list to show
sub getGraphs2Show ($graphtype) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my @dir_list;
    my @results = ();

    if (opendir(my $dir, $collector_rrd_dir)) {
        @dir_list = readdir($dir);
        closedir($dir);
    }
    else {
        log_error("Could not open directory '$collector_rrd_dir/': $!");
        return @results;
    }

    if ($graphtype eq 'System') {
        my @disk = grep { /^dev-.*$/ } @dir_list;
        for (@disk) { s/.rrd$//g }
        @results = ("cpu", @disk, "load", "mem", "memsw");
    }
    elsif ($graphtype eq 'Network') {
        @results = grep { /iface.rrd$/ } sort @dir_list;
        for (@results) { s/.rrd$//g }
    }
    elsif ($graphtype eq 'Farm') {
        @results = grep { /farm.rrd$/ } sort @dir_list;
        for (@results) { s/.rrd$//g }
    }
    elsif ($graphtype eq 'VPN') {
        @results = grep { /vpn.rrd$/ } sort @dir_list;
        for (@results) { s/.rrd$//g }
    }
    else {
        log_error("Graph type not supported.");
    }

    return @results;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/SNMP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Log;
use Relianoid::Config;

=pod

=head1 Module

Relianoid::SNMP

=cut

=pod

=head1 setSnmpdStatus

Start or stop the SNMP service.

Parameters:

    snmpd_status - 'true' to start, or 'stop' to stop the SNMP service.

Returns:

    scalar - 0 on success, non-zero on failure.

=cut

sub setSnmpdStatus ($snmpd_status) {
    my $return_code = -1;
    my $systemctl   = &getGlobalConfiguration('systemctl');
    my $snmpd_srv   = &getGlobalConfiguration('snmpd_service');

    if ($snmpd_status eq 'true') {
        &log_info("Starting snmp service", "SYSTEM");
        &logAndRun("$systemctl enable $snmpd_srv");
        $return_code = &logAndRun("$systemctl start $snmpd_srv");
    }
    elsif ($snmpd_status eq 'false') {
        &log_info("Stopping snmp service", "SYSTEM");
        &logAndRun("$systemctl disable $snmpd_srv");
        $return_code = &logAndRun("$systemctl stop $snmpd_srv");
    }
    else {
        &log_warn("SNMP requested state is invalid", "SYSTEM");
        return -1;
    }

    return $return_code;
}

=pod

=head1 getSnmpdStatus

Get if the SNMP service is running.

Parameters:

    none

Returns:

    string - Boolean. 'true' if it is running, or 'false' if it is not running.

=cut

sub getSnmpdStatus () {
    my $pidof       = &getGlobalConfiguration('pidof');
    my $return_code = (&logAndRunCheck("$pidof snmpd")) ? 'false' : 'true';

    return $return_code;
}

=pod

=head1 setSnmpdLaunchConfig

Set configuration and disable the snmpd service.

Parameters:

    snmp_conf - Configuration for SNMP

Returns:

    integer - 0 if success, error in another case.

=cut

sub setSnmpdLaunchConfig ($snmp_conf) {
    my @config  = ("/etc/default/snmpd", "/usr/lib/systemd/system/snmpd.service");
    my $changed = 0;

    require Tie::File;

    for my $file (@config) {
        tie my @config_file, 'Tie::File', $file;

        if (   defined $snmp_conf->{trapsess}
            && $snmp_conf->{trapsess} eq "true"
            && grep { /mteTrigger/ } @config_file)
        {
            s/ -I -smux,mteTrigger,mteTriggerConf// for @config_file;
            $changed = 1;
        }
        elsif ((!defined $snmp_conf->{trapsess} || $snmp_conf->{trapsess} eq "false")
            && !grep { /mteTrigger/ } @config_file)
        {
            s/ -f / -I -smux,mteTrigger,mteTriggerConf -f / for @config_file;
            $changed = 1;
        }

        if (!grep { /LS6d / } @config_file) {
            s/-L[^\s]+ /-LS6d / for @config_file;
            $changed = 1;
        }

        untie @config_file;
    }

    if ($changed) {
        my $systemctl = &getGlobalConfiguration('systemctl');
        return &logAndRun("$systemctl daemon-reload");
    }

    return 0;
}

=pod

=head1 setSnmpdFactoryReset

Set default configuration and disable the snmpd service.

Parameters:

    none

Returns:

    integer - 0 on success, or -1 on failure.

=cut

sub setSnmpdFactoryReset () {
    my $default_snmp_conf = &getSnmpdDefaultConfig();
    my $snmpdconfig_file  = &getGlobalConfiguration('snmpdconfig_file');

    unlink($snmpdconfig_file);

    &_setSnmpdConfig($default_snmp_conf);
    &setSnmpdLaunchConfig($default_snmp_conf);
    return &setSnmpdStatus("false");
}

=pod

=head1 setSnmpdDefaultConfig

Apply default SNMP config if it was not changed by this service
before. Then, reload the service generators.

Parameters:

    none

Returns:

    scalar - Hash reference with SNMP default configuration.

=cut

sub setSnmpdDefaultConfig () {
    my $snmp_config = &getSnmpdConfig();
    if ($snmp_config->{changed} == 0) {
        $snmp_config = &setSnmpdFactoryReset();
    }
    else {
        &setSnmpdLaunchConfig($snmp_config);
    }

    return $snmp_config;
}

=pod

=head1 getSnmpdDefaultConfig

Get the default configuration of the SNMP service.

Parameters:

    none

Returns:

    scalar - Hash reference with SNMP default configuration.

		$snmpd_conf = {
				proto # agentAddress line
				ip
				port
				community # community line
				community_mode
				scope
			};

=cut

sub getSnmpdDefaultConfig () {
    my $snmpd_conf = {
        proto          => "udp",
        ip             => "*",
        port           => "161",
        community_mode => "rocommunity",
        community      => "public",
        scope          => "0.0.0.0/0",
    };

    return $snmpd_conf;
}

=pod

=head1 getSnmpdConfig

Get the configuration of the SNMP service according to the
snmpd.conf file.

Parameters:

    none

Returns:

    scalar - Hash reference with SNMP configuration.

		$snmpd_conf = {
					   status
					   proto # agentAddress line
					   ip
					   port
					   community # community line
					   community_mode
					   scope
					   authtrapenable # authtrapenable line
					   createuser_user # createuser line
					   createuser_auth
					   createuser_auth_pass
					   createuser_priv
					   createuser_priv_pass
					   iquerysecname # iquerysecname line
					   user_mode # xxuser line
					   user
					   trapsink_host # trapsink line
					   trapsink_port
					   trap2sink_host # trap2sink
					   trapsess_version # trapsess line
					   trapsess_user
					   trapsess_engine
					   trapsess_authproto
					   trapsess_authpass
					   trapsess_privproto
					   trapsess_privpass
					   trapsess_host
					   trapsess_port
					   notif_linkupdown
					   notif_defmonitors
					   load
					   disks
					   monitors # array with monitors configuration
					   changed # 1 if changed by relianoid
		}; 

=cut

sub getSnmpdConfig () {
    require Tie::File;

    my $snmpdconfig_file = &getGlobalConfiguration('snmpdconfig_file');
    my $snmpd_conf;

    $snmpd_conf->{status}  = &getSnmpdStatus();
    $snmpd_conf->{changed} = 1;

    tie my @config_file, 'Tie::File', $snmpdconfig_file;

    for my $line (@config_file) {
        next if ($line =~ /^\s*$/);
        $snmpd_conf->{changed} = 0
          if ($line =~ /^(# EXAMPLE.conf|# An example configuration file)/);
        next if ($line =~ /^\s*#/);
        chomp($line);
        if ($line =~ /^\s*agentAddress\s+/) {
            my (undef, $aline) = split(/\s+/, $line);
            if ($aline =~ /udp:|tcp:/) {
                ($snmpd_conf->{proto}, $snmpd_conf->{ip}, $snmpd_conf->{port}) = split(/:/, $aline);
            }
            else {
                ($snmpd_conf->{ip}, $snmpd_conf->{port}) = split(/:/, $aline);
            }
            $snmpd_conf->{ip} = '*' if ($snmpd_conf->{ip} eq '0.0.0.0');
        }
        elsif ($line =~ /^..community\s+/) {
            ($snmpd_conf->{community_mode}, $snmpd_conf->{community}, $snmpd_conf->{scope}) =
              split(/\s+/, $line);
            $snmpd_conf->{scope} = "0.0.0.0/0" if ($snmpd_conf->{scope} =~ /default/);
        }
        elsif ($line =~ /^trapcommunity\s+/) {
            (undef, $snmpd_conf->{trapcommunity}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^authtrapenable\s+/) {
            (undef, $snmpd_conf->{authtrapenable}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^createuser\s+/) {
            (
                undef,                               $snmpd_conf->{createuser_user}, $snmpd_conf->{createuser_auth},
                $snmpd_conf->{createuser_auth_pass}, $snmpd_conf->{createuser_priv}, $snmpd_conf->{createuser_priv_pass}
            ) = split(/\s+/, $line);
        }
        elsif ($line =~ /^iquerysecname\s+/) {
            (undef, $snmpd_conf->{iquerysecname}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^..user\s+/) {
            ($snmpd_conf->{user_mode}, $snmpd_conf->{user}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^trapsink\s+/) {
            (undef, $snmpd_conf->{trapsink_host}, $snmpd_conf->{trapsink_port}) =
              split(/\s+/, $line);
        }
        elsif ($line =~ /^trap2sink\s+/) {
            (undef, $snmpd_conf->{trap2sink_host}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^trapsess\s+/) {
            $snmpd_conf->{trapsess} = 'true';
            my @trap_line = split(/\s+/, $line);
            my $i         = 0;
            while ($i < (scalar @trap_line)) {
                if ($trap_line[$i] eq "-v") {
                    $i += 1;
                    $snmpd_conf->{trapsess_version} = $trap_line[$i];
                }
                elsif ($trap_line[$i] eq "-u") {
                    $i += 1;
                    $snmpd_conf->{trapsess_user} = $trap_line[$i];
                }
                elsif ($trap_line[$i] eq "-e") {
                    $i += 1;
                    $snmpd_conf->{trapsess_engine} = $trap_line[$i];
                }
                elsif ($trap_line[$i] eq "-a") {
                    $i += 1;
                    $snmpd_conf->{trapsess_authproto} = $trap_line[$i];
                }
                elsif ($trap_line[$i] eq "-A") {
                    $i += 1;
                    $snmpd_conf->{trapsess_authpass} = $trap_line[$i];
                }
                elsif ($trap_line[$i] eq "-x") {
                    $i += 1;
                    $snmpd_conf->{trapsess_privproto} = $trap_line[$i];
                }
                elsif ($trap_line[$i] eq "-X") {
                    $i += 1;
                    $snmpd_conf->{trapsess_privpass} = $trap_line[$i];
                }
                elsif ($i == (scalar @trap_line) - 1) {
                    if ($trap_line[$i] =~ /:/) {
                        ($snmpd_conf->{trapsess_host}, $snmpd_conf->{trapsess_port}) =
                          split(/:/, $trap_line[$i]);
                    }
                    else {
                        $snmpd_conf->{trapsess_host} = $trap_line[$i];
                        $snmpd_conf->{trapsess_port} = '162';
                    }
                }
                $i += 1;
            }
        }
        elsif ($line =~ /^linkUpDownNotifications\s+/) {
            (undef, $snmpd_conf->{notif_linkupdown}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^defaultMonitors\s+/) {
            (undef, $snmpd_conf->{notif_defmonitors}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^load\s+/) {
            (undef, $snmpd_conf->{load}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^includeAllDisks\s+/) {
            (undef, $snmpd_conf->{disks}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^monitor\s+/) {
            $snmpd_conf->{monitors} = () unless (defined $snmpd_conf->{monitors});
            (my $newline = $line) =~ s/^monitor\s+//;
            push(@{ $snmpd_conf->{monitors} }, $newline);
        }
    }

    $snmpd_conf->{ip}   = "*"   if (not defined $snmpd_conf->{ip});
    $snmpd_conf->{port} = "161" if (not defined $snmpd_conf->{port});

    untie @config_file;
    return $snmpd_conf;
}

=pod

=head1 setSnmpdConfig

Apply SNMP configuration and reload services.

Parameters:

    snmpd_conf - Hash reference with SNMP configuration.

Returns:

    integer - 0 on success, or -1 on failure.

=cut

sub setSnmpdConfig ($snmpd_conf) {
    &_setSnmpdConfig($snmpd_conf);
    &setSnmpdLaunchConfig($snmpd_conf);

    return 0;
}

=pod

=head1 _setSnmpdConfig

Store SNMP configuration.

Parameters:

    snmpd_conf - Hash reference with SNMP configuration.

Returns:

    integer - 0 on success, or -1 on failure.

=cut

sub _setSnmpdConfig ($snmpd_conf) {
    my $snmpdconfig_file = &getGlobalConfiguration('snmpdconfig_file');
    my $default_index    = 0;                                             # line to insert the configuration

    return -1 if ref $snmpd_conf ne 'HASH';

    my $ip = $snmpd_conf->{ip};
    $ip = '0.0.0.0' if ($snmpd_conf->{ip} eq '*');

    # scope has to be network range definition
    require NetAddr::IP;
    my $network = NetAddr::IP->new($snmpd_conf->{scope})->network();

    return -1 if ($network ne $snmpd_conf->{scope});

    require Relianoid::Lock;

    my @contents;
    my $lock_file = &getLockFile("snmpd_conf");
    my $lock_fh   = &openlock($lock_file, 'w');

    if (open my $config_file, '<', $snmpdconfig_file) {
        @contents = <$config_file>;
        close $config_file;
        close $lock_fh;

        @contents = grep { !/^agentAddress/ } @contents;
        @contents = grep { !/^..community/ } @contents             if (defined $snmpd_conf->{community_mode});
        @contents = grep { !/^trapcommunity/ } @contents           if (defined $snmpd_conf->{trapcommunity});
        @contents = grep { !/^authtrapenable/ } @contents          if (defined $snmpd_conf->{authtrapenable});
        @contents = grep { !/^createuser/ } @contents              if (defined $snmpd_conf->{createuser_user});
        @contents = grep { !/^iquerysecname/ } @contents           if (defined $snmpd_conf->{iquerysecname});
        @contents = grep { !/^..user/ } @contents                  if (defined $snmpd_conf->{user_mode});
        @contents = grep { !/^trapsink/ } @contents                if (defined $snmpd_conf->{trapsink});
        @contents = grep { !/^trap2sink/ } @contents               if (defined $snmpd_conf->{trap2sink});
        @contents = grep { !/^trapsess/ } @contents                if (defined $snmpd_conf->{trapsess});
        @contents = grep { !/^linkUpDownNotifications/ } @contents if (defined $snmpd_conf->{notif_linkupdown});
        @contents = grep { !/^defaultMonitors/ } @contents         if (defined $snmpd_conf->{notif_defmonitors});
        @contents = grep { !/^load/ } @contents                    if (defined $snmpd_conf->{load});
        @contents = grep { !/^includeAllDisks/ } @contents         if (defined $snmpd_conf->{disks});
        @contents = grep { !/^monitor/ } @contents                 if (defined $snmpd_conf->{monitors});
    }
    else {
        close $lock_fh;
    }

    my $index = $default_index;

    if (defined $snmpd_conf->{proto}) {
        splice @contents, $index, 0, "agentAddress $snmpd_conf->{proto}:$ip:$snmpd_conf->{port}\n";
        $index++;
    }
    else {
        splice @contents, $index, 0, "agentAddress $ip:$snmpd_conf->{port}\n";
        $index++;
    }

    if (defined $snmpd_conf->{community_mode} and $snmpd_conf->{community} and $snmpd_conf->{scope}) {
        splice @contents, $index, 0, "$snmpd_conf->{community_mode} $snmpd_conf->{community} $snmpd_conf->{scope}\n";
        $index++;
    }

    if (defined $snmpd_conf->{trapcommunity}) {
        splice @contents, $index, 0, "trapcommunity $snmpd_conf->{trapcommunity}\n";
        $index++;
    }

    if (defined $snmpd_conf->{authtrapenable}) {
        splice @contents, $index, 0, "authtrapenable $snmpd_conf->{authtrapenable}\n";
        $index++;
    }

    if (defined $snmpd_conf->{createuser_user}) {
        my $line = "createuser $snmpd_conf->{createuser_user}";
        $line .= " $snmpd_conf->{createuser_auth}"      if ($snmpd_conf->{createuser_auth});
        $line .= " $snmpd_conf->{createuser_auth_pass}" if ($snmpd_conf->{createuser_auth_pass});
        $line .= " $snmpd_conf->{createuser_priv}"      if ($snmpd_conf->{createuser_priv});
        $line .= " $snmpd_conf->{createuser_priv_pass}" if ($snmpd_conf->{createuser_priv_pass});
        $line .= "\n";
        splice @contents, $index, 0, "$line";
        $index++;

        if (defined $snmpd_conf->{user_mode}) {
            splice @contents, $index, 0, "$snmpd_conf->{user_mode} $snmpd_conf->{createuser_user}\n";
            $index++;
        }
    }

    if (defined $snmpd_conf->{iquerysecname}) {
        splice @contents, $index, 0, "iquerysecname $snmpd_conf->{iquerysecname}\n";
        $index++;
    }

    if (defined $snmpd_conf->{trapsink}) {
        splice @contents, $index, 0, "trapsink $snmpd_conf->{trapsink}\n";
        $index++;
    }

    if (defined $snmpd_conf->{trap2sink}) {
        splice @contents, $index, 0, "trap2sink $snmpd_conf->{trap2sink}\n";
        $index++;
    }

    if (defined $snmpd_conf->{trapsess}) {
        my $line = "trapsess ";
        $line .= "-v $snmpd_conf->{trapsess_version} "   if ($snmpd_conf->{trapsess_version});
        $line .= "-u $snmpd_conf->{trapsess_user} "      if ($snmpd_conf->{trapsess_user});
        $line .= "-e $snmpd_conf->{trapsess_engine} "    if ($snmpd_conf->{trapsess_engine});
        $line .= "-a $snmpd_conf->{trapsess_authproto} " if ($snmpd_conf->{trapsess_authproto});
        $line .= "-A $snmpd_conf->{trapsess_authpass} "  if ($snmpd_conf->{trapsess_authpass});
        $line .= "-x $snmpd_conf->{trapsess_privproto} " if ($snmpd_conf->{trapsess_privproto});
        $line .= "-X $snmpd_conf->{trapsess_privpass} "  if ($snmpd_conf->{trapsess_privpass});
        $line .= "$snmpd_conf->{trapsess_host}"          if ($snmpd_conf->{trapsess_host});
        $line .= ":$snmpd_conf->{trapsess_port}"         if ($snmpd_conf->{trapsess_port});
        $line .= "\n";
        splice @contents, $index, 0, "$line";
        $index++;
    }

    if (defined $snmpd_conf->{notif_linkupdown}) {
        splice @contents, $index, 0, "linkUpDownNotifications $snmpd_conf->{notif_linkupdown}\n";
        $index++;
    }

    if (defined $snmpd_conf->{notif_defmonitors}) {
        splice @contents, $index, 0, "defaultMonitors $snmpd_conf->{notif_defmonitors}\n";
        $index++;
    }

    if (defined $snmpd_conf->{load}) {
        splice @contents, $index, 0, "load $snmpd_conf->{load}\n";
        $index++;
    }

    if (defined $snmpd_conf->{disks}) {
        splice @contents, $index, 0, "includeAllDisks $snmpd_conf->{disks}\n";
        $index++;
    }

    if (defined $snmpd_conf->{monitors}) {
        for my $monitor (@{ $snmpd_conf->{monitors} }) {
            splice @contents, $index, 0, "monitor $monitor\n";
            $index++;
        }
    }

    $lock_fh = &openlock($lock_file, 'w');

    if (open my $config_file, '>', $snmpdconfig_file) {
        print $config_file @contents;
        close $config_file;
        close $lock_fh;
    }
    else {
        close $lock_fh;
        &log_warn("Could not open ${snmpdconfig_file}: $!", "SYSTEM");
        return -1;
    }

    return 0;
}

=pod

=head1 translateSNMPConfigToApi

Translate the SNMP Config params to API params.

Parameters:

    config_ref - Array of snmp config params.

Returns:

    Hash ref - Translated params.

=cut

sub translateSNMPConfigToApi ($config_ref) {
    my %params = (
        'ip'        => 'ip',
        'community' => 'community',
        'port'      => 'port',
        'scope'     => 'scope',
        'status'    => 'status',
    );

    for my $key (keys %{$config_ref}) {
        if (not defined $params{$key}) {
            delete $config_ref->{$key};
        }
    }

    return $config_ref;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Stats.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Stats

=cut

=pod

=head1 getMemStats

Get stats of memory usage of the system.

Parameters:

    format - "b" for bytes, "kb" for KBytes and "mb" for MBytes (default: mb).

Returns:

    list - Two dimensional array.

    @data = (
        [$ram_total_label,     $ram_total],
        [$ram_free_label,    $ram_free],
        ['MemUsed',  $ram_used],
        [$ram_buffers_label,    $ram_buffers],
        [$ram_cached_label,    $ram_cached],
        [$swap_total_label,   $swap_total],
        [$swap_free_label,   $swap_free],
        ['SwapUsed', $swap_used],
        [$swap_cached_label,   $swap_cached],
    );

=cut

sub getMemStats ($format = "mb") {
    my $meminfo_filename = '/proc/meminfo';

    my ($ram_total, $ram_free, $ram_used, $ram_buffers, $ram_cached, $swap_total, $swap_free, $swap_used, $swap_cached);
    my (
        $ram_total_label,  $ram_free_label,  $ram_cached_label, $ram_buffers_label,
        $swap_total_label, $swap_free_label, $swap_cached_label
    );

    unless (-f $meminfo_filename) {
        print "$0: Error: File $meminfo_filename not exist ...\n";
        exit 1;
    }

    my @lines = ();

    if (open my $file, '<', $meminfo_filename) {
        @lines = <$file>;
        close $file;
    }

    for my $line (@lines) {
        if ($line =~ /^MemTotal:/) {
            ($ram_total_label, $ram_total) = split /[: ]+/, $line;
            $ram_total = $ram_total / 1024 if $format eq "mb";
            $ram_total = $ram_total * 1024 if $format eq "b";
        }
        elsif ($line =~ /^MemFree:/) {
            ($ram_free_label, $ram_free) = split(": ", $line);
            $ram_free =~ /^\s+(\d+)\ /;
            $ram_free = $1;
            $ram_free = $ram_free / 1024 if $format eq "mb";
            $ram_free = $ram_free * 1024 if $format eq "b";
        }
        elsif ($line =~ /^MemAvailable:/) {
            my (undef, $ram_available) = split(/ +/, $line);
            $ram_available = $ram_available / 1024 if $format eq "mb";
            $ram_available = $ram_available * 1024 if $format eq "b";
            $ram_used      = $ram_total - $ram_available;
        }
        elsif ($line =~ /^Buffers:/) {
            ($ram_buffers_label, $ram_buffers) = split /[: ]+/, $line;
            $ram_buffers = $ram_buffers / 1024 if $format eq "mb";
            $ram_buffers = $ram_buffers * 1024 if $format eq "b";
        }
        elsif ($line =~ /^Cached:/) {
            ($ram_cached_label, $ram_cached) = split /[: ]+/, $line;
            $ram_cached = $ram_cached / 1024 if $format eq "mb";
            $ram_cached = $ram_cached * 1024 if $format eq "b";
        }
        elsif ($line =~ /swaptotal/i) {
            ($swap_total_label, $swap_total) = split /[: ]+/, $line;
            $swap_total = $swap_total / 1024 if $format eq "mb";
            $swap_total = $swap_total * 1024 if $format eq "b";
        }
        elsif ($line =~ /swapfree/i) {
            ($swap_free_label, $swap_free) = split /[: ]+/, $line;
            $swap_free = $swap_free / 1024 if $format eq "mb";
            $swap_free = $swap_free * 1024 if $format eq "b";
            $swap_used = $swap_total - $swap_free;
        }
        elsif ($line =~ /swapcached/i) {
            ($swap_cached_label, $swap_cached) = split /[: ]+/, $line;
            $swap_cached = $swap_cached / 1024 if $format eq "mb";
            $swap_cached = $swap_cached * 1024 if $format eq "b";
        }
    }

    return (
        [ $ram_total_label,   sprintf('%.2f', $ram_total) ],
        [ $ram_free_label,    sprintf('%.2f', $ram_free) ],
        [ 'MemUsed',          sprintf('%.2f', $ram_used) ],
        [ $ram_buffers_label, sprintf('%.2f', $ram_buffers) ],
        [ $ram_cached_label,  sprintf('%.2f', $ram_cached) ],
        [ $swap_total_label,  sprintf('%.2f', $swap_total) ],
        [ $swap_free_label,   sprintf('%.2f', $swap_free) ],
        [ 'SwapUsed',         sprintf('%.2f', $swap_used) ],
        [ $swap_cached_label, sprintf('%.2f', $swap_cached) ],
    );
}

=pod

=head1 getLoadStats

Get the system load values.

Parameters:

    none

Returns:

    list - Two dimensional array.

    @data = (
        ['Last', $last],
        ['Last 5', $last5],
        ['Last 15', $last15]
    );

=cut

sub getLoadStats () {
    my $load_filename = '/proc/loadavg';

    my $last;
    my $last5;
    my $last15;

    if (-f $load_filename) {
        my $lastline;

        open my $file, '<', $load_filename;
        while (my $line = <$file>) {
            $lastline = $line;
        }
        close $file;

        ($last, $last5, $last15) = split(" ", $lastline);
    }

    my @data = ([ 'Last', $last ], [ 'Last 5', $last5 ], [ 'Last 15', $last15 ],);

    return @data;
}

=pod

=head1 getNetworkStats

Get stats for the network interfaces.

Parameters:

    format - 'raw', 'hash' or nothing.

Returns:

    When 'format' is not defined:

    @data = (
        [
            'eth0 in',
            '46.11'
        ],
        [
            'eth0 out',
            '63.02'
        ],
        ...
    );

    When 'format' is 'raw':

    @data = (
        [
            'eth0 in',
            '48296309'
        ],
        [
            'eth0 out',
            '66038087'
        ],
        ...
    );

    When 'format' is 'hash':

    @data = (
        {
            'in' => '46.12',
            'interface' => 'eth0',
            'out' => '63.04'
        },
        ...
    );

=cut

sub getNetworkStats ($format = "") {
    my $netinfo_filename = '/proc/net/dev';

    unless (-f $netinfo_filename) {
        print "$0: Error: File $netinfo_filename not exist ...\n";
        exit 1;
    }

    my @outHash;
    my @lines;

    if (open(my $file, '<', $netinfo_filename)) {
        chomp(@lines = <$file>);
        close $file;
    }
    else {
        my $msg = "Could not open the file '$netinfo_filename': $!";
        log_error($msg);
        die $msg;
    }

    my ($in, $out);
    my @data;
    my @interface;
    my @interfacein;
    my @interfaceout;

    my $alias;
    $alias = &eload(
        module => 'Relianoid::EE::Alias',
        func   => 'getAlias',
        args   => ['interface']
    ) if $eload;

    my $i = -1;

    for my $line (@lines) {
        unless ($line =~ /\:/ && $line !~ /^\s*lo\:/) {
            next;
        }

        $i++;
        my @iface = split(":", $line);
        my $if    = $iface[0];
        $if =~ s/\ //g;

        # not show cluster maintenance interface
        $i = $i - 1 if $if eq 'cl_maintenance';
        next        if $if eq 'cl_maintenance';

        # ignore fallback device from ip_gre module
        ($i-- && next) if $if =~ /^gre0$|^gretap0$|^erspan0$/;

        # ignore fallback device from ip6_gre module
        ($i-- && next) if $if =~ /^ip6gre0$|^ip6tnl0$/;

        # ignore fallback device from sit module
        ($i-- && next) if $if =~ /^sit0$/;

        if ($line =~ /:\ /) {
            ($in, $out) = (split /\s+/, $iface[1])[ 1, 9 ];
        }
        else {
            ($in, $out) = (split /\s+/, $line)[ 0, 8 ];
            $in = (split /:/, $in)[1];
        }

        if ($format ne "raw") {
            $in  = (($in / 1024) / 1024);
            $out = (($out / 1024) / 1024);
            $in  = sprintf('%.2f', $in);
            $out = sprintf('%.2f', $out);
        }

        push @interface,    $if;
        push @interfacein,  $in;
        push @interfaceout, $out;
        push @outHash, { 'interface' => $if, 'in' => $in, 'out' => $out };

        $outHash[-1]->{alias} = $alias->{$if} if $eload;
    }

    for (my $j = 0 ; $j <= $i ; $j++) {
        push @data, [ $interface[$j] . ' in', $interfacein[$j] ], [ $interface[$j] . ' out', $interfaceout[$j] ];
    }

    if ($format eq 'hash') {
        @data = sort { $a->{interface} cmp $b->{interface} } @outHash;
    }

    return @data;
}

=pod

=head1 getCPU

Get system CPU usage stats.

Parameters:

    none

Returns:

    list - Two dimensional array.

    Example:

    @data = (
              ['CPUuser',    $cpu_user],
              ['CPUnice',    $cpu_nice],
              ['CPUsys',     $cpu_sys],
              ['CPUiowait',  $cpu_iowait],
              ['CPUirq',     $cpu_irq],
              ['CPUsoftirq', $cpu_softirq],
              ['CPUidle',    $cpu_idle],
              ['CPUusage',   $cpu_usage],
    );

=cut

sub getCPU () {
    my @data;
    my $interval         = 1;
    my $cpuinfo_filename = '/proc/stat';

    unless (-f $cpuinfo_filename) {
        print "$0: Error: File $cpuinfo_filename not exist ...\n";
        exit 1;
    }

    my $cpu_user1;
    my $cpu_nice1;
    my $cpu_sys1;
    my $cpu_idle1;
    my $cpu_iowait1;
    my $cpu_irq1;
    my $cpu_softirq1;
    my $cpu_total1;

    my $cpu_user2;
    my $cpu_nice2;
    my $cpu_sys2;
    my $cpu_idle2;
    my $cpu_iowait2;
    my $cpu_irq2;
    my $cpu_softirq2;
    my $cpu_total2;

    my @line_s;

    if (open my $file, '<', $cpuinfo_filename) {
        my @lines = <$file>;
        close $file;

        for my $line (@lines) {
            if ($line =~ /^cpu\ /) {
                @line_s       = split("\ ", $line);
                $cpu_user1    = $line_s[1];
                $cpu_nice1    = $line_s[2];
                $cpu_sys1     = $line_s[3];
                $cpu_idle1    = $line_s[4];
                $cpu_iowait1  = $line_s[5];
                $cpu_irq1     = $line_s[6];
                $cpu_softirq1 = $line_s[7];
                $cpu_total1   = $cpu_user1 + $cpu_nice1 + $cpu_sys1 + $cpu_idle1 + $cpu_iowait1 + $cpu_irq1 + $cpu_softirq1;
            }
        }
    }

    sleep $interval;

    if (open my $file, '<', $cpuinfo_filename) {
        my @lines = <$file>;
        close $file;

        for my $line (@lines) {
            if ($line =~ /^cpu\ /) {
                @line_s       = split("\ ", $line);
                $cpu_user2    = $line_s[1];
                $cpu_nice2    = $line_s[2];
                $cpu_sys2     = $line_s[3];
                $cpu_idle2    = $line_s[4];
                $cpu_iowait2  = $line_s[5];
                $cpu_irq2     = $line_s[6];
                $cpu_softirq2 = $line_s[7];
                $cpu_total2   = $cpu_user2 + $cpu_nice2 + $cpu_sys2 + $cpu_idle2 + $cpu_iowait2 + $cpu_irq2 + $cpu_softirq2;
            }
        }
    }

    my $diff_cpu_user    = $cpu_user2 - $cpu_user1;
    my $diff_cpu_nice    = $cpu_nice2 - $cpu_nice1;
    my $diff_cpu_sys     = $cpu_sys2 - $cpu_sys1;
    my $diff_cpu_idle    = $cpu_idle2 - $cpu_idle1;
    my $diff_cpu_iowait  = $cpu_iowait2 - $cpu_iowait1;
    my $diff_cpu_irq     = $cpu_irq2 - $cpu_irq1;
    my $diff_cpu_softirq = $cpu_softirq2 - $cpu_softirq1;
    my $diff_cpu_total   = $cpu_total2 - $cpu_total1;

    my $cpu_user    = (100 * $diff_cpu_user) / $diff_cpu_total;
    my $cpu_nice    = (100 * $diff_cpu_nice) / $diff_cpu_total;
    my $cpu_sys     = (100 * $diff_cpu_sys) / $diff_cpu_total;
    my $cpu_idle    = (100 * $diff_cpu_idle) / $diff_cpu_total;
    my $cpu_iowait  = (100 * $diff_cpu_iowait) / $diff_cpu_total;
    my $cpu_irq     = (100 * $diff_cpu_irq) / $diff_cpu_total;
    my $cpu_softirq = (100 * $diff_cpu_softirq) / $diff_cpu_total;

    my $cpu_usage = $cpu_user + $cpu_nice + $cpu_sys + $cpu_iowait + $cpu_irq + $cpu_softirq;

    $cpu_user    = sprintf("%.2f", $cpu_user);
    $cpu_nice    = sprintf("%.2f", $cpu_nice);
    $cpu_sys     = sprintf("%.2f", $cpu_sys);
    $cpu_iowait  = sprintf("%.2f", $cpu_iowait);
    $cpu_irq     = sprintf("%.2f", $cpu_irq);
    $cpu_softirq = sprintf("%.2f", $cpu_softirq);
    $cpu_idle    = sprintf("%.2f", $cpu_idle);
    $cpu_usage   = sprintf("%.2f", $cpu_usage);

    $cpu_user    =~ s/,/\./g;
    $cpu_nice    =~ s/,/\./g;
    $cpu_sys     =~ s/,/\./g;
    $cpu_iowait  =~ s/,/\./g;
    $cpu_softirq =~ s/,/\./g;
    $cpu_idle    =~ s/,/\./g;
    $cpu_usage   =~ s/,/\./g;

    @data = (
        [ 'CPUuser',    $cpu_user ],
        [ 'CPUnice',    $cpu_nice ],
        [ 'CPUsys',     $cpu_sys ],
        [ 'CPUiowait',  $cpu_iowait ],
        [ 'CPUirq',     $cpu_irq ],
        [ 'CPUsoftirq', $cpu_softirq ],
        [ 'CPUidle',    $cpu_idle ],
        [ 'CPUusage',   $cpu_usage ],
    );

    return @data;
}

sub getCPUUsageStats () {
    my $out;

    my @data_cpu = &getCPU();

    for my $x (0 .. @data_cpu - 1) {
        my $name  = $data_cpu[$x][0];
        my $value = $data_cpu[$x][1] + 0;

        (undef, $name) = split('CPU', $name);

        $out->{$name} = $value;
    }

    return $out;
}

=pod

=head1 getDiskSpace

Return total, used and free space for every partition in the system.

Parameters:

    none

Returns:

    list - Two dimensional array.

    @data = (
        [
            'dev-dm-0 Total',
            1981104128
        ],
        [
            'dev-dm-0 Used',
            1707397120
        ],
        [
            'dev-dm-0 Free',
            154591232
        ],
        ...
    );

See Also:

    disk-rrd.pl

=cut

sub getDiskSpace () {
    my @data;

    my $df_bin = &getGlobalConfiguration('df_bin');
    my @system = @{ &logAndGet("$df_bin -k", "array") };
    chomp(@system);
    my @df_system = @system;

    for my $line (@system) {
        next if $line !~ /^\/dev/;

        my @dd_name = split(' ', $line);
        my $dd_name = $dd_name[0];

        my ($line_df) = grep ({ /^$dd_name\s/ } @df_system);
        my @s_line = split(/\s+/, $line_df);

        my $partitions = $s_line[0];
        $partitions =~ s/\///;
        $partitions =~ s/\//-/g;

        my $tot  = $s_line[1] * 1024;
        my $used = $s_line[2] * 1024;
        my $free = $s_line[3] * 1024;

        push(@data, [ $partitions . ' Total', $tot ], [ $partitions . ' Used', $used ], [ $partitions . ' Free', $free ]);
    }

    return @data;
}

=pod

=head1 getDiskPartitionsInfo

Get a reference to a hash with the partitions devices, mount points and name of rrd database.

Parameters:

    none

Returns:

    scalar - Hash reference.

    Example:

    $partitions = {
        '/dev/dm-0' => {
            'mount_point' => '/',
            'rrd_id' => 'dev-dm-0hd'
        },
        '/dev/mapper/zva64-config' => {
            'mount_point' => '/usr/local/relianoid/config',
            'rrd_id' => 'dev-mapper-zva64-confighd'
        },
        '/dev/mapper/zva64-log' => {
            'mount_point' => '/var/log',
            'rrd_id' => 'dev-mapper-zva64-loghd'
        },
        '/dev/xvda1' => {
            'mount_point' => '/boot',
            'rrd_id' => 'dev-xvda1hd'
        }
    };

=cut

sub getDiskPartitionsInfo () {
    my $partitions;

    my $df_bin = &getGlobalConfiguration('df_bin');

    my @out      = @{ &logAndGet("$df_bin -k", "array") };
    my @df_lines = grep { /^\/dev/ } @out;
    chomp(@df_lines);

    for my $line (@df_lines) {
        my @df_line = split(/\s+/, $line);

        my $mount_point = $df_line[5];
        my $partition   = $df_line[0];
        my $part_id     = $df_line[0];
        $part_id =~ s/\///;
        $part_id =~ s/\//-/g;

        $partitions->{$partition} = {
            mount_point => $mount_point,
            rrd_id      => "${part_id}hd",
        };
    }

    return $partitions;
}

=pod

=head1 getDiskMountPoint

Get the mount point of a partition device

Parameters:

    dev - Partition device.

Returns:

    string - Mount point for such partition device.
    undef  - The partition device is not mounted

See Also:

    <genDiskGraph>

=cut

sub getDiskMountPoint ($dev) {
    my $df_bin    = &getGlobalConfiguration('df_bin');
    my @df_system = @{ &logAndGet("$df_bin -k", "array") };
    my $mount;

    for my $line_df (@df_system) {
        if ($line_df =~ /$dev/) {
            my @s_line = split("\ ", $line_df);
            chomp(@s_line);

            $mount = $s_line[5];
        }
    }

    return $mount;
}

=pod

=head1 getCPUTemp

Get the CPU temperature in celsius degrees.

Parameters:

    none

Returns:

    string - Temperature in celsius degrees.

See Also:

    temperature-rrd.pl

=cut

sub getCPUTemp () {
    my $filename = &getGlobalConfiguration("temperatureFile");
    my $lastline;

    unless (-f $filename) {
        exit 1;
    }

    open my $file, '<', $filename;

    while (my $line = <$file>) {
        $lastline = $line;
    }

    close $file;

    my @lastlines = split("\:", $lastline);
    my $temp      = $lastlines[1];
    $temp =~ s/\ //g;
    $temp =~ s/\n//g;
    $temp =~ s/C//g;

    return $temp;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/System.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Log;
use Relianoid::Config;

my $eload = eval { require Relianoid::ELoad; };

=pod

=head1 Module

Relianoid::System

=cut

=pod

=head1 getTotalConnections

Get the number of current connections on this appliance.

Parameters:

    none

Returns:

    integer - The number of connections.

=cut

sub getTotalConnections () {
    my $conntrack = &getGlobalConfiguration("conntrack");
    my $conns     = &logAndGet("$conntrack -C");
    $conns =~ s/(\d+)/$1/;
    $conns += 0;

    return $conns;
}

=pod

=head1 indexOfElementInArray

Get the index of the first position where an element if found in an array.

Parameters:

    searched_element - Element to search.
    array_ref        - Reference to the array to be searched.

Returns:

    integer - Zero or higher if the element was found. -1 if the element was not found. -2 if no array reference was received.

See Also:

    API v4: <new_bond>

=cut

sub indexOfElementInArray ($searched_element, $array_ref) {
    if (ref $array_ref ne 'ARRAY') {
        return -2;
    }

    my @arrayOfElements = @{$array_ref};
    my $index           = 0;

    for my $list_element (@arrayOfElements) {
        if ($list_element eq $searched_element) {
            last;
        }

        $index++;
    }

    # if $index is greater than the last element index
    if ($index > $#arrayOfElements) {
        # return an invalid index
        $index = -1;
    }

    return $index;
}

=pod

=head1 slurpFile

Stores the content of a file in a variable.

Parameters:

    path - string with the file location

Returns:

    string - content of the file

=cut

sub slurpFile ($path) {
    my $file;

    if (open(my $fh, '<', $path)) {
        local $/ = undef;
        $file = <$fh>;
        close $fh;
    }
    else {
        my $msg = "Could not open file '$file': $!";
        &log_info($msg);
        die $msg;
    }

    return $file;
}

=pod

=head1 getSpaceFree

It gets the free space that contains a partition. The partition is calculated
from a directory

Parameters:

    directroy - directory to know the free space

Returns:

    Integer - Number of bytes free in the partition

=cut

sub getSpaceFree ($dir) {
    my $df_bin   = &getGlobalConfiguration("df_bin");
    my $sed_bin  = &getGlobalConfiguration("sed_bin");
    my $cut_bin  = &getGlobalConfiguration("cut_bin");
    my $grep_bin = &getGlobalConfiguration("grep_bin");

    my $cmd  = "$df_bin -B1 $dir | $grep_bin -Ev '^(Filesystem|\$)' | $sed_bin -E 's/\\s+/ /g' | $cut_bin -d ' ' -f4";
    my $size = &logAndGet($cmd);

    &log_debug2("Dir: $dir, Free space (Bytes): $size");

    return $size;
}

=pod

=head1 getSpaceFormatHuman

It converts a number of bytes to human format, converting Bytes to KB, MB or GB

Parameters:

    Bytes - Number of bytes

Returns:

    String - String with size and its units

=cut

sub getSpaceFormatHuman ($size) {
    my $human = $size;
    my $unit  = 'B';

    if ($human > 1024) {
        $human = $human / 1024;
        $unit  = "KB";
    }
    if ($human > 1024) {
        $human = $human / 1024;
        $unit  = "MB";
    }
    if ($human > 1024) {
        $human = $human / 1024;
        $unit  = "GB";
    }

    $human = sprintf("%.2f", $human);
    my $out = $human . $unit;
    return $out;
}

=pod

=head1 getSupportSaveSize

It gets the aproximate size that the supportsave will need.
The size is calculated using the config and log directories size and adding
a offset of 20MB

Parameters:

    none

Returns:

    Integer - Number of bytes that supportsave will use

=cut

sub getSupportSaveSize () {
    my $offset = "20971520";                               # 20 MB
    my $dirs   = "/usr/local/relianoid/config /var/log";

    my $tar_bin = &getGlobalConfiguration('tar');
    my $wc      = &getGlobalConfiguration('wc_bin');
    my $size    = &logAndGet("$tar_bin cz - $dirs 2>/dev/null | $wc -c");

    return $offset + $size;
}

=pod

=head1 checkSupportSaveSpace

Check if the disk has enough space to create a supportsave

Parameters:

    directory - Directory where the supportsave will be created

Returns:

    Integer - It returns 0 on success or the number of bytes needed to create a supportsave

=cut

sub checkSupportSaveSpace ($dir = "/tmp") {
    my $supp_size = &getSupportSaveSize();
    my $freeSpace = &getSpaceFree($dir);

    my $out = ($freeSpace > $supp_size) ? 0 : $supp_size;

    if ($out) {
        &log_error("There is no enough free space ('$freeSpace') in the '$dir' partition. Supportsave needs '$supp_size' bytes",
            "system");
    }
    else {
        &log_debug("Checking free space ('$freeSpace') in the '$dir' partition. Supportsave needs '$supp_size' bytes",
            "system");
    }

    return $out;
}

=pod

=head1 getSupportSave

It creates a support save file used for supporting purpose. It is created in the '/tmp/' directory

Parameters:

    none

Returns:

    String - The supportsave file name is returned.

=cut

sub getSupportSave () {
    my $bin_dir   = &getGlobalConfiguration('bin_dir');
    my @ss_output = @{ &logAndGet("${bin_dir}/supportsave", "array") };

    # get the last "word" from the first line
    my $first_line = shift @ss_output;
    my $last_word  = (split(' ', $first_line))[-1];

    my $ss_path = $last_word;

    my (undef, $ss_filename) = split('/tmp/', $ss_path);

    return $ss_filename;
}

=pod

=head1 checkPidRunning

Check if Pid is running on the system.

Parameters:

    pid - pid to check.

Returns:

    scalar - 0 if success, otherwise an error.

=cut

sub checkPidRunning ($pid) {
    my $ret = 1;
    $ret = 0 if (-e "/proc/" . $pid);
    return $ret;
}

=pod

=head1 checkPidFileRunning

Check if PidFile contains a Pid is running on the system.

Parameters:

    pid_file - pid file to check.

Returns:

    scalar - 0 if success, otherwise an error.

=cut

sub checkPidFileRunning ($pid_file) {
    open my $fileh, '<', $pid_file;
    my $pid = <$fileh>;
    chomp $pid;
    close $fileh;
    return &checkPidRunning($pid);
}

=pod

=head1 setSshDefaultConfig

Apply default SSH config if it was not changed by this service
before. Then, reload the service generators.

Parameters:

    None.

Returns:

    ssh_config - Hash reference with SSH default configuration.

=cut

sub setSshDefaultConfig () {
    my $output = 0;
    $output = &eload(
        module => 'Relianoid::EE::System::SSH',
        func   => 'setSshDefaultConfigPriv',
        soft   => 1
    ) if ($eload);
    return $output;
}

=pod

=head1 setSshFactoryReset

Set default configuration of the ssh service.

Parameters:

    None.

Returns:

    integer - 0 on success, or -1 on failure.

=cut

sub setSshFactoryReset () {
    my $ssh_tpl = "/etc/ssh/sshd_config.ucf-dist";
    my $ssh_cfg = "/etc/ssh/sshd_config";
    my $output  = 0;

    if (-f $ssh_tpl) {
        my $cmd = "cp -f $ssh_tpl $ssh_cfg";
        &logAndRun($cmd);
    }

    $output = &eload(
        module => 'Relianoid::EE::System::SSH',
        func   => 'setSshFactoryResetPriv',
        soft   => 1
    ) if ($eload);
    return $output;
}

=pod

=head1 initHttpServer

Initialize required files to make http server to work.

Parameters:

    None.

Returns:

    none 0 on success other value if there is an error.

=cut

sub initHttpServer () {
    my $httpFile          = &getGlobalConfiguration('confhttp');
    my $httpFileTpl       = &getGlobalConfiguration('confhttp_tpl');
    my $httpServerKey     = &getGlobalConfiguration('http_server_key');
    my $httpServerKeyTpl  = &getGlobalConfiguration('http_server_key_tpl');
    my $httpServerCert    = &getGlobalConfiguration('http_server_cert');
    my $httpServerCertTpl = &getGlobalConfiguration('http_server_cert_tpl');
    my $output            = 0;
    my $cmd;

    if (!-f "$httpFile") {
        $cmd = "cp -f $httpFileTpl $httpFile";
        $output += &logAndRun($cmd);
    }

    if (!-f "$httpServerKey") {
        $cmd = "cp -f $httpServerKeyTpl $httpServerKey";
        $output += &logAndRun($cmd);
    }

    if (!-f "$httpServerCert") {
        $cmd = "cp -f $httpServerCertTpl $httpServerCert";
        $output += &logAndRun($cmd);
    }

    $output += &eload(
        module => 'Relianoid::EE::System::HTTP',
        func   => 'setHttpDefaultConfigPriv',
        soft   => 1
    ) if ($eload);
    return $output;
}

=pod

=head1 setHttpDefaultConfig

Apply default HTTP config if it was not changed by this service
before. Then, reload the service generators.

Parameters:

    None.

Returns:

    http_conf - Hash reference with HTTP default configuration.

=cut

sub setHttpDefaultConfig () {
    my $output = 0;
    $output = &eload(
        module => 'Relianoid::EE::System::HTTP',
        func   => 'setHttpDefaultConfigPriv',
        soft   => 1
    ) if ($eload);
    return $output;
}

=pod

=head1 restartHttpServer

Restart the HTTP web server.

Parameters:

    None.

Returns:

    none 0 on success other value if there is an error.

=cut

sub restartHttpServer () {
    my $output = 0;
    $output = &eload(
        module => 'Relianoid::EE::System::HTTP',
        func   => 'restartHttpServerPriv',
        soft   => 1
    ) if ($eload);
    return $output;
}

=pod

=head1 setHttpFactoryReset

Set default configuration of the http service.

Parameters:

    None.

Returns:

    integer - 0 on success, or -1 on failure.

=cut

sub setHttpFactoryReset () {
    my $httpFile          = &getGlobalConfiguration('confhttp');
    my $httpFileTpl       = &getGlobalConfiguration('confhttp_tpl');
    my $httpServerKey     = &getGlobalConfiguration('http_server_key');
    my $httpServerKeyTpl  = &getGlobalConfiguration('http_server_key_tpl');
    my $httpServerCert    = &getGlobalConfiguration('http_server_cert');
    my $httpServerCertTpl = &getGlobalConfiguration('http_server_cert_tpl');
    my $output            = 0;

    my $cmd = "cp -f $httpFileTpl $httpFile";
    $output += &logAndRun($cmd);

    $cmd = "cp -f $httpServerKeyTpl $httpServerKey";
    $output += &logAndRun($cmd);

    $cmd = "cp -f $httpServerCertTpl $httpServerCert";
    $output += &logAndRun($cmd);

    $output += &eload(
        module => 'Relianoid::EE::System::HTTP',
        func   => 'setHttpDefaultConfigPriv',
        soft   => 1
    ) if ($eload);

    return $output;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/System/DNS.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::System::DNS

=cut

=pod

=head1 getDns

Get the dns servers.

Parameters:

    none - .

Returns:

    scalar - Hash reference.

    Example:

    $dns = {
        primary => "value",
        secundary => "value",
    };

=cut

sub getDns () {
    my $dns     = { 'primary' => '', 'secondary' => '' };
    my $dnsFile = &getGlobalConfiguration('filedns');

    if (!-f $dnsFile) {
        return;
    }

    open(my $fh, '<', $dnsFile);
    my @file = <$fh>;
    close $fh;

    my $index = 1;
    for my $line (@file) {
        if ($line =~ /nameserver\s+([^\s]+)/) {
            $dns->{primary}   = $1 if ($index == 1);
            $dns->{secondary} = $1 if ($index == 2);

            $index++;
            last if ($index > 2);
        }
    }

    return $dns;
}

=pod

=head1 setDns

Set a primary or secondary dns server.

Parameters:

    dns - 'primary' or 'secondary'.
    value - ip addres of dns server.

Returns:

    none - .

Bugs:

    Returned value.

=cut

sub setDns ($dns, $value) {
    my $dnsFile = &getGlobalConfiguration('filedns');

    if (!-f $dnsFile) {
        my $bin = &getGlobalConfiguration('touch');
        &logAndRun("$bin $dnsFile");
    }

    require Tie::File;
    tie my @dnsArr, 'Tie::File', $dnsFile;

    my $index      = 1;
    my $line_index = 0;
    for my $line (@dnsArr) {
        $line_index++;
        if ($line =~ /\s*nameserver/) {
            $line = "nameserver $value"
              if ($index == 1 and $dns eq 'primary' and $value ne '');
            $line = "nameserver $value"
              if ($index == 2 and $dns eq 'secondary' and $value ne '');
            splice @dnsArr, ($line_index - 1)
              if ($index == 2 and $dns eq 'secondary' and $value eq '');
            $index++;
            last if ($index > 2);
        }
    }

    # if there is not any nameserver, add one
    push @dnsArr, "nameserver $value"
      if ($index == 1 and $value ne '');

    # if the secondary nameserver has not been found, add it
    push @dnsArr, "nameserver $value"
      if ($index == 2 and $dns eq 'secondary' and $value ne '');

    untie @dnsArr;

    return 0;
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/System/Log.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::System::Log

=cut

=pod

=head1 getLogs

Get list of log files.

Parameters:

    none

Returns:

    scalar - Array reference.

    Array element example:

    {
        'file' => $line,
        'date' => $datetime_string
    }

=cut

sub getLogs () {
    my @logs;
    my $logdir = &getGlobalConfiguration('logdir');

    require Relianoid::File;

    opendir(my $directory, $logdir);
    my @files = readdir($directory);
    closedir($directory);

    for my $line (@files) {
        # not list if it is a directory
        next if -d "$logdir/$line";

        my $filepath = "$logdir/$line";
        chomp($filepath);

        push @logs, { 'file' => $line, 'date' => &getFileDateGmt($filepath) };
    }

    return \@logs;
}

=pod

=head1 getLogLines

Show a number of the last lines of a log file

Parameters:

    logFile - log file name in /var/log
    lines - number of lines to show

Returns:

    array - last lines of log file

=cut

sub getLogLines ($logFile, $lines_number) {
    my @lines;
    my $path = &getGlobalConfiguration('logdir');
    my $tail = &getGlobalConfiguration('tail');

    if ($logFile =~ /\.gz$/) {
        my $zcat = &getGlobalConfiguration('zcat');
        @lines = @{ &logAndGet("$zcat ${path}/$logFile | $tail -n $lines_number", "array") };
    }
    else {
        @lines = @{ &logAndGet("$tail -n $lines_number ${path}/$logFile", "array") };
    }

    return \@lines;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/System/Packages.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);
require Relianoid::Log;
use Relianoid::SystemInfo;
use autodie;

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::System::Packages

=cut

=pod

=head1 setSystemPackagesRepo

It configures the system to connect with the APT.

Parameters:

    none

Returns:

    Integer - Error code, 0 on success or another value on failure

=cut

sub setSystemPackagesRepo () {
    if ($eload) {
        return &eload(
            module => 'Relianoid::EE::Apt',
            func   => 'setAPTRepo',
        );
    }

    require Relianoid::File;

    my $host         = &getGlobalConfiguration('repo_url_relianoid');
    my $file         = &getGlobalConfiguration('apt_source_relianoid');
    my $aptget_bin   = &getGlobalConfiguration('aptget_bin');
    my $distribution = "bookworm";
    my $repo_version = "v7";
    my $content      = "deb http://$host/ce/$repo_version/ $distribution main\n";

    &log_info("Configuring the APT repository", "SYSTEM");

    my $success    = 1;
    my $error_code = (setFile($file, $content) == $success) ? 0 : 1;

    return $error_code;
}

=pod

=head1 getSystemPackagesUpdatesList

It returns information about the status of the system regarding updates.
This information is parsed from a file

Parameters:

    none

Returns:

    Hash reference

    'message'    : message with the instructions to update the system
    'last_check' : date of the last time that nod-updater (or apt-get) was executed
    'status'     : information about if there is pending updates.
    'number'     : number of packages pending of updating
    'packages'   : list of packages pending of updating

=cut

sub getSystemPackagesUpdatesList () {
    require Relianoid::Lock;
    my $package_list = &getGlobalConfiguration('apt_outdated_list');
    my $message_file = &getGlobalConfiguration('apt_msg');

    my @pkg_list = ();
    my $msg;
    my $date        = "";
    my $status      = "unknown";
    my $install_msg = "To upgrade the system, please, execute in a shell the following command:\n    'noid-updater -i'";

    my $fh = &openlock($package_list, 'r');
    if ($fh) {
        @pkg_list = split(' ', <$fh>);
        close $fh;

        # remove the first item
        shift @pkg_list
          if ((exists $pkg_list[0]) and ($pkg_list[0] eq 'Listing...'));
    }

    $fh = &openlock($message_file, 'r');
    if (defined $fh) {
        $msg = <$fh>;
        close $fh;

        if ($msg =~ /last check at (.+) -/) {
            $date   = $1;
            $status = "Updates available";
        }
        elsif ($msg =~ /Relianoid Packages are up-to-date/) {
            $status = "Updated";
        }
    }

    return {
        'message'    => $install_msg,
        'last_check' => $date,
        'status'     => $status,
        'number'     => scalar @pkg_list,
        'packages'   => \@pkg_list
    };
}

1;

=== ./background/relianoid/usr/share/perl5/Relianoid/System/Proxy.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

=pod

=head1 Module

Relianoid::System::Proxy

=cut

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 getProxy

Get a reference to a hash with the proxy configuration

Parameters: None

Returns: hash reference

    {
        "http_proxy" => "https://10.10.21.13:8080",
        "https_proxy" => "https://10.10.21.12:8080",
    }

=cut

sub getProxy () {
    my $http_proxy  = &getGlobalConfiguration('http_proxy')  // '';
    my $https_proxy = &getGlobalConfiguration('https_proxy') // '';

    return {
        'http_proxy'  => $http_proxy,
        'https_proxy' => $https_proxy,
    };
}

=pod

=head1 setProxy

Configure a system proxy

Parameters: hash reference

proxy structure

    {
        "http_proxy" => "https://10.10.21.13:8080",
        "https_proxy" => "https://10.10.21.12:8080",
    }

Returns: integer

    0 - succes
    1 - error

=cut

sub setProxy ($proxy_conf) {
    my $error = 0;

    for my $key ('http_proxy', 'https_proxy') {
        next if not exists $proxy_conf->{$key};

        if ($error = &setGlobalConfiguration($key, $proxy_conf->{$key})) {
            &log_error("Error setting '$key' with the value '$proxy_conf->{ $key }'", "System");
        }
    }

    if (not $error) {
        require Relianoid::Apt;
        &setAPTProxy();
    }

    return $error;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/SystemInfo.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures state);

=pod

=head1 Module

Relianoid::SystemInfo

=cut

=pod

=head1 getDate

Get date string

Parameters:

    none

Returns:

    string - Date string. Example: "Mon May 22 10:42:39 2017"

=cut

sub getDate() {
    return scalar CORE::localtime();
}

=pod

=head1 getHostname

Get system hostname, and it is saved all the process life time

Parameters:

    none - .

Returns:

    string - Hostname.

=cut

sub getHostname() {
    require Sys::Hostname;
    state $hostname = Sys::Hostname::hostname();
    return Sys::Hostname::hostname();
}

=pod

=head1 getApplianceVersion

Returns a string with the description of the appliance.

NOTE: This function uses Tie::File, this module should be used only for writing files.

Parameters:

    none - .

Returns:

    string - Version string.

=cut

sub getApplianceVersion() {
    my $version;
    my $hyperv;
    my $applianceFile = &getGlobalConfiguration('applianceVersionFile');
    my $lsmod         = &getGlobalConfiguration('lsmod');
    my @packages      = @{ &logAndGet("$lsmod", "array") };
    my @hypervisor    = grep { /(xen|vm|hv|kvm)_/ } @packages;

    # look for appliance vesion
    if (-f $applianceFile) {
        require Tie::File;
        Tie::File->import;

        tie my @filelines, 'Tie::File', $applianceFile;
        $version = $filelines[0];
        untie @filelines;
    }

    # generate appliance version
    if (!$version) {
        my $kernel = &getKernelVersion();

        my $awk      = &getGlobalConfiguration('awk');
        my $ifconfig = &getGlobalConfiguration('ifconfig');

        # look for mgmt interface
        my @ifaces = @{ &logAndGet("$ifconfig -s | $awk '{print $1}'", "array") };

        # Network appliance
        if (grep { /mgmt/ } @ifaces) {
            $version = "ZNA 3300";
        }
        else {
            # select appliance verison
            if    ($kernel =~ /3\.2\.0\-4/)      { $version = "3110"; }
            elsif ($kernel =~ /3\.16\.0\-4/)     { $version = "4000"; }
            elsif ($kernel =~ /3\.16\.7\-ckt20/) { $version = "4100"; }
            else                                 { $version = "System version not detected"; }

            # virtual appliance
            if ($hypervisor[0] =~ /(xen|vm|hv|kvm)_/) {
                $version = "ZVA $version";
            }

            # baremetal appliance
            else {
                $version = "ZBA $version";
            }
        }

        # save version for future request
        require Tie::File;
        Tie::File->import;

        tie my @filelines, 'Tie::File', $applianceFile;
        $filelines[0] = $version;
        untie @filelines;
    }

    # virtual appliance
    if (@hypervisor && $hypervisor[0] =~ /(xen|vm|hv|kvm)_/) {
        $hyperv = $1;
        $hyperv = 'HyperV' if ($hyperv eq 'hv');
        $hyperv = 'Vmware' if ($hyperv eq 'vm');
        $hyperv = 'Xen'    if ($hyperv eq 'xen');
        $hyperv = 'KVM'    if ($hyperv eq 'kvm');
    }

    # before relianoid versions had hypervisor in appliance version file, so not inclue it in the chain
    if ($hyperv && $version !~ /hypervisor/) {
        $version = "$version, hypervisor: $hyperv";
    }

    return $version;
}

=pod

=head1 getCpuCores

Get the number of CPU cores in the system.

Parameters:

    none

Returns:

    integer - Number of CPU cores.

=cut

sub getCpuCores() {
    my $cpuinfo_filename = '/proc/stat';
    my $cores            = 1;

    open my $stat_file, '<', $cpuinfo_filename;

    while (my $line = <$stat_file>) {
        next unless $line =~ /^cpu(\d+) /;
        $cores = $1 + 1;
    }

    close $stat_file;

    return $cores;
}

=head1 setEnv

Set envorioment variables. Get variables from global.conf

Parameters:

    none

Returns:

    none

=cut

sub setEnv() {
    use Relianoid::Config;

    local $ENV{http_proxy}  = &getGlobalConfiguration('http_proxy')  // "";
    local $ENV{https_proxy} = &getGlobalConfiguration('https_proxy') // "";

    my $provider = &getGlobalConfiguration('cloud_provider');

    if ($provider && $provider eq 'aws') {
        local $ENV{AWS_SHARED_CREDENTIALS_FILE} = &getGlobalConfiguration('aws_credentials') // "";
        local $ENV{AWS_CONFIG_FILE}             = &getGlobalConfiguration('aws_config')      // "";
    }

    return;
}

=pod

=head1 getKernelVersion

Returns the kernel version

Parameters:

    none

Returns:

    string - kernel version

=cut

sub getKernelVersion() {
    require Relianoid::Config;
    my $uname   = &getGlobalConfiguration('uname');
    my $version = &logAndGet("$uname -r");
    return $version;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/User.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::User

=cut

=pod

=head1 getUser

Get the user that is executing the API or WEBGUI

Parameters:

    None

Returns:

    String - User name

=cut

sub getUser () {
    return $ENV{REQ_USER} // '';
}

=pod

=head1 setUser

Save the user that is executing the API or WEBGUI

Parameters:

    None - .

Returns:

    String - User name

=cut

sub setUser ($user) {
    $ENV{REQ_USER} = $user;    ## no critic (Variables::RequireLocalizedPunctuationVars)

    return;
}

=pod

=head1 getSysGroupList

List all Operating System groups

Parameters:

    None

Returns:

    Array - List of groups

=cut

sub getSysGroupList () {
    require Relianoid::Lock;
    my @groupSet   = ();
    my $group_file = &openlock("/etc/group", "r");
    while (my $group = <$group_file>) {
        push(@groupSet, $1) if ($group =~ m/(\w+):x:.*/g);
    }
    close $group_file;

    return @groupSet;
}

=pod

=head1 getSysUserList

List all Operating System users

Parameters:

    None

Returns:

    Array - List of users

=cut

sub getSysUserList () {
    require Relianoid::Lock;
    my @userSet   = ();
    my $user_file = &openlock("/etc/passwd", "r");
    while (my $user = <$user_file>) {
        push(@userSet, $1) if ($user =~ m/(\w+):x:.*/g);
    }
    close $user_file;

    return @userSet;
}

=pod

=head1 getSysUserExists

    Check if a user exists in the Operting System

Parameters:

    User - User name

Returns:

    Integer - 1 if the user exists or 0 if it doesn't exist

=cut

sub getSysUserExists ($user) {
    my $out = 0;
    $out = 1 if (grep { $user eq $_ } &getSysUserList());

    return $out;
}

=pod

=head1 getSysGroupExists

    Check if a group exists in the Operting System

Parameters:

    Group - group name

Returns:

    Integer - 1 if the group exists or 0 if it doesn't exist

=cut

sub getSysGroupExists ($group) {
    my $out = 0;
    $out = 1 if (grep { $group eq $_ } &getSysGroupList());

    return $out;
}

1;


=== ./background/relianoid/usr/share/perl5/Relianoid/Validate.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use Regexp::IPv6 qw($IPv6_re);
use Relianoid::Net::Validate;

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Validate

=cut

# Notes about regular expressions:
#
# \w matches the 63 characters [a-zA-Z0-9_] (most of the time)
#

my $UNSIGNED8BITS = qr/(?:25[0-5]|2[0-4]\d|(?!0)[1]?\d\d?|0)/;                         # (0-255)
my $UNSIGNED7BITS = qr/(?:[0-9]{1,2}|10[0-9]|11[0-9]|12[0-8])/;                        # (0-128)
my $HEXCHAR       = qr/(?:[A-Fa-f0-9])/;
my $ipv6_word     = qr/(?:$HEXCHAR+){1,4}/;
my $ipv4_addr     = qr/(?:$UNSIGNED8BITS\.){3}$UNSIGNED8BITS/;
my $ipv6_addr     = $IPv6_re;
my $mac_addr      = qr/(?:$HEXCHAR$HEXCHAR\:){5}$HEXCHAR$HEXCHAR/;
my $ipv4v6        = qr/(?:$ipv4_addr|$ipv6_addr)/;
my $boolean       = qr/(?:true|false)/;
my $enable        = qr/(?:enable|disable)/;
my $integer       = qr/\d+/;
my $natural       = qr/[1-9]\d*/;                                                      # natural number = {1, 2, 3, ...}
my $weekdays      = qr/(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)/;
my $minutes       = qr/(?:\d|[0-5]\d)/;
my $hours         = qr/(?:\d|[0-1]\d|2[0-3])/;
my $months        = qr/(?:[1-9]|1[0-2])/;
my $dayofmonth    = qr/(?:[1-9]|[1-2]\d|3[01])/;                                       # day of month
my $rrdTime       = qr/\d\d-\d\d-(?:\d\d)?\d\d-\d\d:\d\d/;    # MM-DD-[YY]YY-hh:mm ; example: "11-09-2020-14:05";

my $hostname = qr/[a-z][a-z0-9\-]{0,253}[a-z0-9]/;
my $service  = qr/[a-zA-Z0-9][a-zA-Z0-9_\-\.]*/;
my $zone     = qr/(?:$hostname\.)+[a-z]{2,}/;

my $cert_name = qr/(?:\*[_|\.])?\w[\w\.\(\)\@ \-]*/;

my $vlan_tag        = qr/\d{1,4}/;
my $virtual_tag     = qr/[a-zA-Z0-9\-]{1,13}/;
my $nic_if          = qr/[a-zA-Z0-9\-]{1,15}/;
my $bond_if         = qr/[a-zA-Z0-9\-]{1,15}/;
my $vlan_if         = qr/[a-zA-Z0-9\-]{1,13}\.$vlan_tag/;
my $interface       = qr/$nic_if(?:\.$vlan_tag)?(?:\:$virtual_tag)?/;
my $port_range      = qr/(?:[1-9]\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])/;
my $graphsFrequency = qr/(?:daily|weekly|monthly|yearly)/;

my $blacklists_source = qr{(?:\d{1,3}\.){3}\d{1,3}(?:\/\d{1,2})?};
my $dos_global        = qr/(?:sshbruteforce)/;
my $dos_all           = qr/(?:limitconns|limitsec)/;
my $dos_tcp           = qr/(?:bogustcpflags|limitrst)/;

my $run_actions = qr/^(?:stop|start|restart)$/;

my $name  = qr/^(?:[a-zA-Z0-9][\w]{5,31})$/;
my $email = qr/(?:[a-zA-Z][\w\_\.]+)\@(?:[a-zA-Z0-9.-]+)\.(?:[a-zA-Z]{2,4})/;

my %format_re = (

    # generic types
    'integer'     => $integer,
    'natural_num' => $natural,
    'boolean'     => $boolean,
    'ipv4v6'      => $ipv4v6,
    'rrd_time'    => $rrdTime,

    # hostname
    'hostname' => $hostname,

    # license
    'license_format' => qr/(?:txt|html)/,

    # log
    'log' => qr/[\.\-\w]+/,

    # api
    'zapi_key'      => qr/[a-zA-Z0-9]+/,
    'zapi_status'   => $enable,
    'zapi_password' => qr/.+/,

    # common
    'port'      => $port_range,
    'multiport' => qr/(?:\*|(?:$port_range|$port_range\:$port_range)(?:,$port_range|,$port_range\:$port_range)*)/,

    'user'     => qr/[\w]+/,
    'password' => qr/.+/,

    # system
    'dns_nameserver' => $ipv4v6,
    'dns'            => qr/(?:primary|secondary)/,
    'ssh_port'       => $port_range,
    'ssh_listen'     => qr/(?:$ipv4v6|\*)/,
    'snmp_status'    => $boolean,
    'snmp_ip'        => qr/(?:$ipv4v6|\*)/,
    'snmp_community' => qr{.+},
    'snmp_port'      => $port_range,
    'snmp_scope'     => qr{(?:\d{1,3}\.){3}\d{1,3}\/\d{1,2}},    # ip/mask
    'ntp'            => qr{[\w\.\-]+},
    'http_proxy'     => qr{\S*},                                 # use any character except the spaces

    # farms
    'farm_name'             => qr/[a-zA-Z0-9\-]+/,
    'farm_profile'          => qr/HTTP|GSLB|L4XNAT|DATALINK/,
    'backend'               => qr/\d+/,
    'service'               => $service,
    'http_service'          => qr/[a-zA-Z0-9\-]+/,
    'gslb_service'          => qr/[a-zA-Z0-9][\w\-]*/,
    'farm_modules'          => qr/(?:gslb|dslb|lslb)/,
    'service_position'      => qr/\d+/,
    'l4_session'            => qr/[ \._\:\w]+/,
    'l7_session'            => qr/[ \._\:\w]+/,
    'farm_maintenance_mode' => qr/(?:drain|cut)/,               # not used from API 4

    # cipher
    'ciphers' => qr/(?:all|highsecurity|customsecurity|ssloffloading)/,    # not used from API 4

    # backup
    'backup'        => qr/[\w-]+/,
    'backup_action' => qr/apply/,

    # graphs
    'graphs_frequency' => $graphsFrequency,
    'graphs_system_id' => qr/(?:cpu|load|ram|swap)/,
    'mount_point'      => qr/root[\w\-\.\/]*/,

    # http
    'redirect_code'    => qr/(?:301|302|307)/,                             # not used from API 4
    'http_sts_status'  => qr/(?:true|false)/,                              # not used from API 4
    'http_sts_timeout' => qr/(?:\d+)/,

    # GSLB
    'zone'                => qr/(?:$hostname\.)+[a-z]{2,}/,
    'resource_id'         => qr/\d+/,
    'resource_name'       => qr/(?:[\w\-\.]+|\@)/,
    'resource_ttl'        => qr/$natural/,                                            # except zero
    'resource_type'       => qr/(?:NS|A|AAAA|CNAME|DYNA|MX|SRV|TXT|PTR|NAPTR)/,       # not used from API 4
    'resource_data'       => qr/.+/,                                                  # allow anything (TXT type needs it)
    'resource_data_A'     => $ipv4_addr,
    'resource_data_AAAA'  => $ipv6_addr,
    'resource_data_DYNA'  => $service,
    'resource_data_NS'    => qr/[a-zA-Z0-9\-]+/,
    'resource_data_CNAME' => qr/[a-z\.]+/,
    'resource_data_MX'    => qr/[a-z\.\ 0-9]+/,
    'resource_data_TXT'   => qr/.+/,                                                  # all characters allow
    'resource_data_SRV'   => qr/[0-9]+ [0-9]+ [0-9]+ .+/,                             # https://www.ietf.org/rfc/rfc2782
    'resource_data_PTR'   => qr/[a-z\.]+/,
    'resource_data_NAPTR' => qr/[0-9]+ [0-9]+\|[a-zA-Z]?\|[a-zA-Z0-9\+]*\|.*\|.+/,    # https://www.ietf.org/rfc/rfc2915

    # interfaces ( WARNING: length in characters < 16  )
    'mac_addr'         => $mac_addr,
    'interface'        => $interface,
    'nic_interface'    => $nic_if,
    'bond_interface'   => $bond_if,
    'vlan_interface'   => $vlan_if,
    'virt_interface'   => qr/(?:$bond_if|$nic_if)(?:\.$vlan_tag)?:$virtual_tag/,
    'routed_interface' => qr/(?:$nic_if|$bond_if|$vlan_if)/,
    'interface_type'   => qr/(?:nic|vlan|virtual|bond)/,
    'vlan_tag'         => qr/$vlan_tag/,
    'virtual_tag'      => qr/$virtual_tag/,
    'bond_mode_num'    => qr/[0-6]/,
    'bond_mode_short'  =>
      qr/(?:balance-rr|active-backup|balance-xor|broadcast|802.3ad|balance-tlb|balance-alb)/,    # not used from API 4

    # notifications
    'notif_alert'  => qr/(?:backends|cluster|license|interface|package|certificate)/,
    'notif_method' => qr/(?:email)/,
    'notif_tls'    => $boolean,
    'notif_action' => $enable,
    'notif_time'   => $natural,                                                                  # this value can't be 0

    # IPDS
    # blacklists
    'day_of_month'         => qr{$dayofmonth},
    'weekdays'             => qr{$weekdays},
    'blacklists_name'      => qr{\w+},
    'blacklists_source'    => qr{$blacklists_source},
    'blacklists_source_id' => qr{(?:\d+|$blacklists_source(?:,$blacklists_source)*)},

    'blacklists_url'            => qr{.+},
    'blacklists_hour'           => $hours,
    'blacklists_minutes'        => $minutes,
    'blacklists_period'         => $natural,
    'blacklists_day'            => qr{(:?$dayofmonth|$weekdays)},
    'blacklists_policy'         => qr{(:?allow|deny)},              # not used from API 4
    'blacklists_type'           => qr{(:?local|remote)},            # not used from API 4
    'blacklists_unit'           => qr{(:?hours|minutes)},           # not used from API 4
    'blacklists_frequency'      => qr{(:?daily|weekly|monthly)},    # not used from API 4
    'blacklists_frequency_type' => qr{(:?period|exact)},            # not used from API 4

    # DoS
    'dos_name'        => qr/[\w]+/,
    'dos_rule'        => qr/(?:$dos_global|$dos_all|$dos_tcp)/,
    'dos_rule_farm'   => qr/(?:$dos_all|$dos_tcp)/,
    'dos_rule_global' => $dos_global,
    'dos_rule_all'    => $dos_all,
    'dos_rule_tcp'    => $dos_tcp,
    'dos_time'        => $natural,
    'dos_limit_conns' => $natural,
    'dos_limit'       => $natural,
    'dos_limit_burst' => $natural,
    'dos_port'        => $port_range,
    'dos_hits'        => $natural,

    # RBL
    'rbl_name'          => qr/[\w]+/,
    'rbl_domain'        => qr/[\w\.\-]+/,
    'rbl_log_level'     => qr/[0-7]/,
    'rbl_only_logging'  => $boolean,
    'rbl_cache_size'    => $natural,
    'rbl_cache_time'    => $natural,
    'rbl_queue_size'    => $natural,
    'rbl_thread_max'    => $natural,
    'rbl_local_traffic' => $boolean,
    'rbl_actions'       => $run_actions,    # not used from API 4

    # WAF
    'http_code'      => qr/[0-9]{3}/,
    'waf_set_name'   => qr/[\.\w-]+/,
    'waf_rule_id'    => qr/\d+/,
    'waf_chain_id'   => qr/\d+/,
    'waf_severity'   => qr/[0-9]/,
    'waf_phase'      => qr/(?:[1-5]|request|response|logging)/,
    'waf_log'        => qr/(?:$boolean|)/,
    'waf_audit_log'  => qr/(?:$boolean|)/,
    'waf_skip'       => qr/[0-9]+/,
    'waf_skip_after' => qr/\w+/,
    'waf_set_status' => qr/(?:$boolean|detection)/,
    'waf_file'       => qr/(?:[\s+\w-]+)/,

    # certificates filenames
    'certificate_name'    => $cert_name,
    'certificate'         => qr/$cert_name\.(?:pem|csr)/,
    'cert_pem'            => qr/$cert_name\.pem/,
    'cert_name'           => qr/[a-zA-Z0-9\-]+/,
    'cert_csr'            => qr/\w[\w\.\-]*\.csr/,
    'cert_dh2048'         => qr/\w[\w\.\-]*_dh2048\.pem/,
    'le_certificate_name' => $cert_name,
    'le_mail'             => $email,

    # IPS
    'IPv4_addr' => qr/$ipv4_addr/,
    'IPv4_mask' => qr/(?:$ipv4_addr|3[0-2]|[1-2][0-9]|[0-9])/,

    'IPv6_addr' => qr/$ipv6_addr/,
    'IPv6_mask' => $UNSIGNED7BITS,

    'ip_addr'       => $ipv4v6,
    'ip_mask'       => qr/(?:$ipv4_addr|$UNSIGNED7BITS)/,
    'ip_addr_range' => qr/$ipv4_addr-$ipv4_addr/,

    # farm guardian
    'fg_name'    => qr/[\w-]+/,
    'fg_type'    => qr/(?:http|https|l4xnat|gslb)/,    # not used from API 4
    'fg_enabled' => $boolean,
    'fg_log'     => $boolean,
    'fg_time'    => qr/$natural/,                      # this value can't be 0

    # RBAC
    'user_name'     => qr/[a-z0-9][-a-z0-9_.]+/,
    'rbac_password' => qr/(?=.*[0-9])(?=.*[a-zA-Z]).{8,512}/,
    'group_name'    => qr/[\w-]+/,
    'role_name'     => qr/[\w-]+/,

    # alias
    'alias_id'        => qr/(?:$ipv4v6|$interface)/,
    'alias_backend'   => qr/$ipv4v6/,
    'alias_interface' => qr/$interface/,
    'alias_name'      => qr/(?:$zone|[\w-]+)/,
    'alias_type'      => qr/(?:backend|interface)/,

    # routing
    'route_rule_id'  => qr/$natural/,
    'route_table_id' => qr/[\w\.\-]+/,
    'route_entry_id' => qr/$natural/,

    # vpn
    'vpn_name' => qr/[a-zA-Z][a-zA-Z0-9\-]*/,
    'vpn_user' => qr/[a-zA-Z][a-zA-Z0-9\-]*/,

);

sub getAPIModel ($file_name) {
    require JSON;
    require Relianoid::API;
    require Relianoid::File;

    my $api_version = &getApiVersion();
    my $dir_name    = &getGlobalConfiguration("api_model_path") . "/v${api_version}/json";
    my $content     = getFile("${dir_name}/${file_name}");

    if ($content) {
        return JSON::decode_json($content)->{params};
    }
    else {
        return $content;
    }
}

=pod

=head1 getValidFormat

Validates a data format matching a value with a regular expression.
If no value is passed as an argument the regular expression is returned.

Usage:

    # validate exact data
    if ( ! &getValidFormat( "farm_name", $input_farmname ) ) {
        print "error";
    }

    # use the regular expression as a component for another regular expression
    my $file_regex = &getValidFormat( "certificate" );
    if ( $file_path =~ /$configdir\/$file_regex/ ) { ... }

Parameters:

    format_name	- type of format
    value		- value to be validated (optional)
    new_format_re	- structure with the formats to use. (optional)

Returns:

    false	- If value failed to be validated
    true	- If value was successfuly validated
    regex	- If no value was passed to be matched

See also:

    Mainly but not exclusively used in API v3.

=cut

sub getValidFormat ($format_name, $value = undef, %new_format_re) {
    # Checks if it should use the formats passed by parameters.
    %format_re = %new_format_re if (%new_format_re);

    #~ print "getValidFormat type:$format_name value:$value\n"; # DEBUG
    if (exists $format_re{$format_name}) {
        if (defined $value) {
            #~ print "$format_re{ $format_name }\n"; # DEBUG
            if (ref($value) eq "ARRAY") {
                return !grep { !/^$format_re{ $format_name }$/ } @{$value} > 0;
            }
            else {
                return $value =~ /^$format_re{ $format_name }$/;
            }
        }
        else {
            #~ print "$format_re{ $format_name }\n"; # DEBUG
            return $format_re{$format_name};
        }
    }
    else {
        my $message = "getValidFormat: format $format_name not found.";
        &log_info($message);
        die($message);
    }
}

=pod

=head1 getValidPort

Validate if the port is valid for a type of farm.

Parameters:

    port - Port number.
    profile - Farm profile (HTTP, L4XNAT, GSLB or DATALINK). Optional.

Returns:

    Boolean - TRUE for a valid port number, FALSE otherwise.

=cut

sub getValidPort ($port, $profile = undef) {
    if ($profile =~ /^(?:HTTP|GSLB|eproxy)$/i) {
        return &getValidFormat('port', $port);
    }
    elsif ($profile =~ /^(?:L4XNAT)$/i) {
        return &getValidFormat('multiport', $port);
    }
    elsif ($profile =~ /^(?:DATALINK)$/i) {
        return !defined $port;
    }
    elsif (!defined $profile) {
        return &getValidFormat('port', $port);
    }
    else    # profile not supported
    {
        return 0;
    }
}

=pod

=head1 checkApiParams

Function to check parameters of a PUT or POST call.
It check a list of parameters, and apply it some checks:

    - Almost 1 parameter
    - All required parameters must exist
    - All required parameters are correct

Also, it checks: getValidFormat funcion, if black is allowed, intervals, aditionals regex, excepts regex and a list with the possbile values

It is possible add a error message with the correct format. 

For example: $parameter . "must have letters and digits"

Parameters:

    Json_obj - Parameters sent in a POST or PUT call
    Parameters - Hash of parameter objects

    parameter object:

    {
        parameter :

        {		# parameter is the key or parameter name
            "required" 	: "true",		# or not defined
            "non_blank" : "true",		# or not defined
            "interval" 	: "1,65535",	# it is possible define strings matchs ( non implement). For example: "ports" = "1-65535", "log_level":"1-3", ...
                                        # ",10" indicates that the value has to be less than 10 but without low limit
                                        # "10," indicates that the value has to be more than 10 but without high limit
                                        # The values of the interval has to be integer numbers
            "exceptions"	: [ "api", "webgui", "root" ],	# The parameter can't have got any of the listed values
            "values" : ["priority", "weight"],		# list of possible values for a parameter
            "length" : 32,				# it is the maximum string size for the value
            "regex"	: "/\w+,\d+/",		# regex format
            "ref"	: "array|hash",		# the expected input must be an array or hash ref. To allow ref inputs and non ref for a parameter use the word 'none'. Example:  'ref' => 'array|none'
            "valid_format"	: "farmname",		# regex stored in Validate.pm file, it checks with the function getValidFormat
            "function" : \&func,		# function of validating, the input parameter is the value of the argument. The function has to return 0 or 'false' when a error exists
            "format_msg"	: "must have letters and digits",	# used message when a value is not correct
        }
        param2 :

        {
            ...
        }
        ....
    }

Returns:

    String - Return a error message with the first error found or undef on success

=cut

sub checkApiParams ($json_obj, $param_obj, $description) {
    my $err_msg;

    ## Remove parameters do not according to the edition
    for my $p (keys %$param_obj) {
        if (
            exists $param_obj->{$p}{edition}
            && (   ($param_obj->{$p}{edition} eq 'ee' && !$eload)
                || ($param_obj->{$p}{edition} eq 'ce' && $eload))
          )
        {
            delete $param_obj->{$p};
        }
    }

    my @rec_keys = keys %{$json_obj};

    # Returns a help with the expected input parameters
    if (!@rec_keys) {
        &httpResponseHelp($param_obj, $description);
    }

    # All required parameters must exist
    my @expect_params = keys %{$param_obj};

    $err_msg = &checkParamsRequired(\@rec_keys, \@expect_params, $param_obj);
    return $err_msg if ($err_msg);

    # All sent parameters are correct
    $err_msg = &checkParamsInvalid(\@rec_keys, \@expect_params);
    return $err_msg if ($err_msg);

    # check for each parameter
    for my $param (@rec_keys) {
        my $custom_msg = "The parameter '$param' has not a valid value.";

        # Store the input value to keep the data type,
        # and to be restored at the end of the loop.
        # This is because numeric type are converted to string
        # when used in a string context, like in a regex.
        my $current_param_value = $json_obj->{$param};

        if (exists $param_obj->{$param}{format_msg}) {
            $custom_msg = "$param $param_obj->{$param}{format_msg}";
        }

        if (
               not defined $json_obj->{$param}
            or not length $json_obj->{$param}
            or (    ref $json_obj->{$param}
                and ref $json_obj->{$param} eq 'ARRAY'
                and @{ $json_obj->{$param} } == 0)
          )
        {
            # if blank value is allowed
            if (    $param_obj->{$param}{non_blank}
                and $param_obj->{$param}{non_blank} eq 'true')
            {
                return "The parameter '$param' can't be in blank.";
            }

            next;
        }

        # the input has to be a ref
        my $r = ref $json_obj->{$param} // '';
        if (exists $param_obj->{$param}{ref}) {
            if ($r eq '') {
                if ('none' !~ /$param_obj->{ $param }{ 'ref' }/) {
                    return "The parameter '$param' expects a '$param_obj->{ $param }{ref}' reference as input";
                }
            }
            elsif ($r !~ /^$param_obj->{ $param }{ 'ref' }$/i) {
                return "The parameter '$param' expects a '$param_obj->{ $param }{ref}' reference as input";
            }
        }
        elsif ($r eq 'ARRAY' or $r eq 'HASH') {
            return "The parameter '$param' does not expect a $r as input";
        }

        if ((exists $param_obj->{$param}{values})) {
            if ($r eq 'ARRAY') {
                for my $value (@{ $json_obj->{$param} }) {
                    if (!grep { $value eq $_ } @{ $param_obj->{$param}{values} }) {
                        return
                          "The parameter '$param' expects some of the following values: '"
                          . join("', '", @{ $param_obj->{$param}{values} }) . "'";
                    }
                }
            }
            else {
                if (!grep { $json_obj->{$param} eq $_ } @{ $param_obj->{$param}{values} }) {
                    return
                      "The parameter '$param' expects one of the following values: '"
                      . join("', '", @{ $param_obj->{$param}{values} }) . "'";
                }
            }
        }

        # getValidFormat funcion:
        if (    (exists $param_obj->{$param}{valid_format})
            and (!&getValidFormat($param_obj->{$param}{valid_format}, $json_obj->{$param})))
        {
            return $custom_msg;
        }

        # length
        if (exists $param_obj->{$param}{length}) {
            my $data_length = length($json_obj->{$param});
            if ($data_length > $param_obj->{$param}{length}) {
                return "The maximum length for '$param' is '$param_obj->{ $param }{ 'length' }'";
            }
        }

        # intervals
        if (exists $param_obj->{$param}{interval}) {
            $err_msg =
              &checkParamsInterval($param_obj->{$param}{interval}, $param, $json_obj->{$param});
            return $err_msg if $err_msg;
        }

        # exceptions
        if (    (exists $param_obj->{$param}{exceptions})
            and (grep { /^$json_obj->{ $param }$/ } @{ $param_obj->{$param}{exceptions} }))
        {
            return "The value '$json_obj->{ $param }' is a reserved word of the parameter '$param'.";
        }

        # regex
        if ((exists $param_obj->{$param}{regex})) {
            if (defined $json_obj->{$param}) {
                # If ARRAY, evaluate all in values.
                if (ref($json_obj->{$param}) eq "ARRAY") {
                    for my $value (@{ $json_obj->{$param} }) {
                        return "The value '$value' is not valid for the parameter '$param'."
                          if (grep { !/^$param_obj->{ $param }{ 'regex' }$/ } $value);
                    }
                }
                else {
                    return "The value '$json_obj->{ $param }' is not valid for the parameter '$param'."
                      if ($json_obj->{$param} !~ /^$param_obj->{ $param }{ 'regex' }$/);
                }
            }
        }

        # negated_regex
        if ((exists $param_obj->{$param}{negated_regex})) {
            if (defined $json_obj->{$param}) {
                # If ARRAY, evaluate all in values.
                if (ref($json_obj->{$param}) eq "ARRAY") {
                    for my $value (@{ $json_obj->{$param} }) {
                        return "The value '$value' is not valid for the parameter '$param'."
                          if (grep { /^$param_obj->{ $param }{ 'regex' }$/ } $value);
                    }
                }
                else {
                    return "The value '$json_obj->{ $param }' is not valid for the parameter '$param'."
                      if ($json_obj->{$param} =~ /$param_obj->{ $param }{ 'negated_regex' }/);
                }
            }
        }

        # is_regex
        if (defined $param_obj->{$param}{is_regex}
            and $param_obj->{$param}{is_regex} eq 'true')
        {
            if (defined $json_obj->{$param}) {
                my $regex = eval { qr/$json_obj->{ $param }/ };
                return "The value of field $param is an invalid regex" if $@;
            }
        }

        if (exists $param_obj->{$param}{function}) {
            my $result =
              &{ $param_obj->{$param}{function} }($json_obj->{$param});

            return $custom_msg if (!$result || $result eq 'false');
        }

        # Restore the data type that was received as input
        # from the beginning of the loop
        $json_obj->{$param} = $current_param_value;
    }

    return;
}

=pod

=head1 checkParamsInterval

Check parameters when there are required params. The value has to be a integer number

Parameters:

    Interval - String with the expected interval. The low and high limits must be splitted with a comma character ','
    Parameter - Parameter name
    Value - Parameter value

Returns:

    String - It returns a string with the error message or undef on success

=cut

sub checkParamsInterval ($interval, $param, $value) {
    my $err_msg;

    if ($interval =~ /,/) {
        my ($low_limit, $high_limit) = split(',', $interval);

        my $msg = "";
        if (defined $low_limit and defined $high_limit and length $high_limit) {
            $msg = "'$param' has to be an integer number between '$low_limit' and '$high_limit'";
        }
        elsif (defined $low_limit) {
            $msg = "'$param' has to be an integer number greater than or equal to '$low_limit'";
        }
        elsif (defined $high_limit) {
            $msg = "'$param' has to be an integer number lower than or equal to '$high_limit'";
        }

        $err_msg = $msg
          if ( ($value !~ /^\d*$/)
            || ($high_limit and $value > $high_limit)
            || ($low_limit  and $value < $low_limit));
    }
    else {
        die "Expected a interval string, got: $interval";
    }

    return $err_msg;
}

=pod

=head1 checkParamsInvalid

Check if some of the sent parameters is invalid for the current API call

Parameters:

    Receive Parameters - It is the list of sent parameters in the API call
    Expected parameters - It is the list of expected parameters for a API call

Returns:

    String - It returns a string with the error message or undef on success

=cut

sub checkParamsInvalid ($rec_keys, $expect_params) {
    my $err_msg;
    my @non_valid;

    for my $param (@{$rec_keys}) {
        push @non_valid, "'$param'" if (!grep { /^$param$/ } @{$expect_params});
    }

    if (@non_valid) {
        $err_msg = &putArrayAsText(\@non_valid,
                "The parameter<sp>s</sp> <pl> <bs>is<|>are</bp> not correct for this call. Please, try with: '"
              . join("', '", @{$expect_params})
              . "'");
    }

    return $err_msg;
}

=pod

=head1 checkParamsRequired

Check if all the mandatory parameters has been sent in the current API call

Parameters:

    Receive Parameters - It is the list of sent parameters in the API call
    Expected parameters - It is the list of expected parameters for a API call
    Model - It is the struct with all allowed parameters and its possible values and options

Returns:

    String - It returns a string with the error message or undef on success

=cut

sub checkParamsRequired ($rec_keys, $expect_params, $param_obj) {
    my @miss_params;
    my $err_msg;

    for my $param (@{$expect_params}) {
        next if (!exists $param_obj->{$param}{required});

        if ($param_obj->{$param}{required} eq 'true') {
            push @miss_params, "'$param'"
              if (!grep { /^$param$/ } @{$rec_keys});
        }
    }

    if (@miss_params) {
        $err_msg = &putArrayAsText(\@miss_params, "The required parameter<sp>s</sp> <pl> <bs>is<|>are</bp> missing.");
    }
    return $err_msg;
}

=pod

=head1 httpResponseHelp

This function sends a response to client with the expected input parameters model.

This function returns a 400 HTTP error code

Parameters:

    Model - It is the struct with all allowed parameters and its possible values and options
    Description - Descriptive message about the API call

Returns:

    None

=cut

sub httpResponseHelp ($param_obj, $desc) {
    my $resp_param = [];

    # build the output
    for my $p (keys %{$param_obj}) {
        my $param->{name} = $p;
        if (exists $param_obj->{$p}{valid_format}) {
            $param->{format} = $param_obj->{$p}{valid_format};
        }
        if (exists $param_obj->{$p}{values}) {
            $param->{possible_values} = $param_obj->{$p}{values};
        }
        if (exists $param_obj->{$p}{interval}) {
            my ($ll, $hl) = split(',', $param_obj->{$p}{interval});
            $ll                = '-' if (!defined $ll);
            $hl                = '-' if (!defined $hl);
            $param->{interval} = "Expects a value between '$ll' and '$hl'.";
        }
        if (exists $param_obj->{$p}{non_blank}
            and $param_obj->{$p}{non_blank} eq 'true')
        {
            push @{ $param->{options} }, "non_blank";
        }
        if (exists $param_obj->{$p}{required}
            and $param_obj->{$p}{required} eq 'true')
        {
            push @{ $param->{options} }, "required";
        }
        if (exists $param_obj->{$p}{format_msg}) {
            $param->{description} = $param_obj->{$p}{format_msg};
        }
        if (exists $param_obj->{$p}{ref}) {
            $param->{ref} = $param_obj->{$p}{ref};
        }

        push @{$resp_param}, $param;
    }

    my $msg  = "No parameter has been sent. Please, try with:";
    my $body = {
        message => $msg,
        params  => $resp_param,
    };
    $body->{description} = $desc if (defined $desc);

    return &httpResponse({ code => 400, body => $body });
}

=pod

=head1 putArrayAsText

This funcion receives a text string and a list of values and it generates a
text with the values.

It uses a delimited to modify the text string passed as argument:

    put list - <pl>
    select plural - <sp>text</sp>
    select single - <ss>text</ss>
    select between single or plural - <bs>text_single<|>text_plural</bp>

Examples:

    putArrayAsText ( ["password", "user", "key"], "The possible value<sp>s</sp> <sp>are</sp>: <pl>")
        return: ""
    putArrayAsText ( ["", "", ""], "The values are")
        return: ""

Parameters:

    Parameters - List of parameters to add to the string message
    Text string - Text

Returns:

    String - Return a message adjust to the number of parameters passed

=cut

sub putArrayAsText ($array_ref, $msg) {
    my @array = @{$array_ref};

    # one element
    if (scalar @array == 1) {
        # save single tags
        $msg =~ s/<\/?ss>//g;

        # remove plural text
        #~ $msg =~ s/<sp>.+<\/?sp>// while ( $msg =~ /<sp>/ );
        $msg =~ s/<sp>.+<\/?sp>//g;

        # select between plural and single text
        #~ $msg =~ s/<bs>(.+)<|>.+<\/bp>/$1/ while ( $msg =~ /<|>/ );
        $msg =~ s/<bs>(.+)<\|>.+<\/bp>/$1/g;

        # put list
        $msg =~ s/<pl>/$array[0]/;
    }

    # more than one element
    else {
        # save plual tags
        $msg =~ s/<\/?sp>//g;

        # remove single text
        #~ $msg =~ s/<ss>.+<\/?ss>// while ( $msg =~ /<ss>/ );
        $msg =~ s/<ss>.+<\/?ss>//g;

        # select between plural and single text
        #~ $msg =~ s/<bs>.+<|>(.+)<\/bp>/$1/ while ( $msg =~ /<|>/ );
        $msg =~ s/<bs>.+<\|>(.+)<\/bp>/$1/g;

        my $lastItem = pop @array;
        my $list     = join(", ", @array);
        $list .= " and $lastItem";

        # put list
        $msg =~ s/<pl>/$list/;
    }

    return $msg;
}

1;

=== ./background/relianoid_adc/source_tree/build-deb.sh ===

#!/bin/bash
# Dependencies: rsync, fakeroot, dpkg-deb
set -Eeu

cd "$(dirname "${BASH_SOURCE[0]}")"

WORK_DIR="workdir"
rm -rf "$WORK_DIR"
mkdir "$WORK_DIR"

rsync --archive DEBIAN "$WORK_DIR/"
rsync --archive etc "$WORK_DIR/"
rsync --archive usr "$WORK_DIR/"

version=$(grep '^Version:' DEBIAN/control | awk '{print $2}')
package_name="relianoid_${version}_amd64.deb"

global_conf_template='usr/local/relianoid/share/global.conf.template'
sed -i "s/_VERSION_/$version/" "${WORK_DIR}/${global_conf_template}"

find "$WORK_DIR" -name .keep -exec rm {} \;

fakeroot dpkg-deb --build workdir "$package_name"

=== ./background/relianoid_adc/source_tree/etc/profile.d/relianoid.sh ===

#!/bin/bash

export PATH="${PATH}:/usr/local/relianoid/bin"

# If not using bash, it's most likely the load balancer is running a command 
# with environment variables
[ -z "$BASH_VERSION" ] && return

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

CLUSTER_STATUS=/etc/relianoid-ce-cluster.status

function cluster_node {
    [ -f $CLUSTER_STATUS ] && echo -n "[$(cat $CLUSTER_STATUS 2>/dev/null)] "
}

# set a fancy prompt (non-color, overwrite the one in /etc/profile)
# but only if not SUDOing and have SUDO_PS1 set; then assume smart user.
if ! [ -n "${SUDO_USER}" -a -n "${SUDO_PS1}" ]; then
    PS1='${debian_chroot:+($debian_chroot)}$(cluster_node)\u@\h:\w\$ '
fi

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
   PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD}\007"'
   ;;
*)
   ;;
esac


=== ./background/relianoid_adc/source_tree/usr/local/relianoid/bin/noid-cluster-notify.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use warnings;

use Linux::Inotify2;
use Sys::Hostname;

# Load configuration
require "/usr/local/relianoid/app/ucarp/etc/cluster.conf";

my $hostname = hostname();
my $sync     = "firstime";
my @alert    = "";
push(@alert, $configdir);
push(@alert, $rttables);

#log file
open STDERR, '>>', "$zeninolog" or die "Error creating log file";
open STDOUT, '>>', "$zeninolog" or die "Error creating log file";

print "Running the first replication...\n";
if ($exclude ne "") {
    my @commands = (
        "$rsync $rsync_args $exclude $configdir\/ root\@$remote_ip:$configdir\/",
        "$rsync $rsync_args $rttables root\@$remote_ip:$rttables",
    );

    for my $cmd (@commands) {
        print "$cmd\n";
        my @output = `$cmd`;
        print @output;
    }
}
print "First replication finished.\n";

my $inotify = Linux::Inotify2->new();

for (@alert) {
    $inotify->watch($_, IN_MODIFY | IN_CREATE | IN_DELETE);
}

while (1) {
    # By default this will block until some event is received
    my @events = $inotify->read();
    if (scalar(@events) == 0) {
        print "read error: $!";
        last;
    }

    for (@events) {
        unless ($_->name !~ /^\..*/ && $_->name !~ /.*\~$/) {
            next;
        }

        $action = sprintf("%d", $_->mask);
        $name   = sprintf($_->fullname);
        $file   = sprintf($_->name);

        if ($action eq 512) {
            $action = "DELETED";
        }
        if ($action eq 2) {
            $action = "MODIFIED";
        }
        if ($action eq 256) {
            $action = "CREATED";
        }

        printf "File: $file; Action: $action Fullname: $name\n";

        if ($name =~ /config/) {
            print "Exclude files: $exclude\n";
            my $cmd = "$rsync $rsync_args $exclude $configdir\/ root\@$remote_ip:$configdir\/";
            my @eject = `$cmd`;
            print @eject;
            print "ran replication process: $cmd\n";
        }

        if ($name =~ /iproute2/) {
            my $cmd = "$rsync $rsync_args $rttables root\@$remote_ip:$rttables";
            my @eject = `$cmd`;
            print @eject;
            print "ran replication process: $cmd\n";
        }
    }
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/bin/noid-collector-cpu-rrd.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use RRDs;
use Relianoid::Config;
use Relianoid::Stats;

my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
my $db_cpu            = "cpu.rrd";
my $rrd_filename      = "${collector_rrd_dir}/${db_cpu}";

my @cpu = &getCPU();

my %cpu = ();
for my $array_ref (@cpu) {
    my ($key, $value) = @{$array_ref};
    $cpu{$key} = $value;
}

my $cpu_user    = $cpu{"CPUuser"};
my $cpu_nice    = $cpu{"CPUnice"};
my $cpu_sys     = $cpu{"CPUsys"};
my $cpu_iowait  = $cpu{"CPUiowait"};
my $cpu_irq     = $cpu{"CPUirq"};
my $cpu_softirq = $cpu{"CPUsoftirq"};
my $cpu_idle    = $cpu{"CPUidle"};
my $cpu_usage   = $cpu{"CPUusage"};

if (!$cpu_user || !$cpu_nice || !$cpu_sys || !$cpu_iowait || !$cpu_irq || !$cpu_softirq || !$cpu_idle || !$cpu_usage) {
    print STDERR "$0: Error: Unable to get the data\n";
    exit;
}

if (!-f $rrd_filename) {
    print "$0: Info: Creating the rrd database ${rrd_filename} ...\n";

    RRDs::create $rrd_filename,
      "--step", "300",
      "DS:user:GAUGE:600:0.00:100.00",
      "DS:nice:GAUGE:600:0.00:100.00",
      "DS:sys:GAUGE:600:0.00:100.00",
      "DS:iowait:GAUGE:600:0.00:100.00",
      "DS:irq:GAUGE:600:0.00:100.00",
      "DS:softirq:GAUGE:600:0.00:100.00",
      "DS:idle:GAUGE:600:0.00:100.00",
      "DS:tused:GAUGE:600:0.00:100.00", "RRA:LAST:0.5:1:288",    # daily - every 5 min - 288 reg
      "RRA:MIN:0.5:1:288",                                       # daily - every 5 min - 288 reg
      "RRA:AVERAGE:0.5:1:288",                                   # daily - every 5 min - 288 reg
      "RRA:MAX:0.5:1:288",                                       # daily - every 5 min - 288 reg
      "RRA:LAST:0.5:12:168",                                     # weekly - every 1 hour - 168 reg
      "RRA:MIN:0.5:12:168",                                      # weekly - every 1 hour - 168 reg
      "RRA:AVERAGE:0.5:12:168",                                  # weekly - every 1 hour - 168 reg
      "RRA:MAX:0.5:12:168",                                      # weekly - every 1 hour - 168 reg
      "RRA:LAST:0.5:96:93",                                      # monthly - every 8 hours - 93 reg
      "RRA:MIN:0.5:96:93",                                       # monthly - every 8 hours - 93 reg
      "RRA:AVERAGE:0.5:96:93",                                   # monthly - every 8 hours - 93 reg
      "RRA:MAX:0.5:96:93",                                       # monthly - every 8 hours - 93 reg
      "RRA:LAST:0.5:288:372",                                    # yearly - every 1 day - 372 reg
      "RRA:MIN:0.5:288:372",                                     # yearly - every 1 day - 372 reg
      "RRA:AVERAGE:0.5:288:372",                                 # yearly - every 1 day - 372 reg
      "RRA:MAX:0.5:288:372";                                     # yearly - every 1 day - 372 reg

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to generate the rrd database: ${error}\n";
    }
}

print "$0: Info: CPU Stats ...\n";
print "$0: Info:	user: ${cpu_user} %\n";
print "$0: Info:	nice: ${cpu_nice} %\n";
print "$0: Info:	sys: ${cpu_sys} %\n";
print "$0: Info:	iowait: ${cpu_iowait} %\n";
print "$0: Info:	irq: ${cpu_irq} %\n";
print "$0: Info:	softirq: ${cpu_softirq} %\n";
print "$0: Info:	idle: ${cpu_idle} %\n";
print "$0: Info:	total used: ${cpu_usage} %\n";
print "$0: Info: Updating data in ${rrd_filename} ...\n";

RRDs::update $rrd_filename,
  "-t", "user:nice:sys:iowait:irq:softirq:idle:tused",
  "N:${cpu_user}:${cpu_nice}:${cpu_sys}:${cpu_iowait}:${cpu_irq}:${cpu_softirq}:${cpu_idle}:${cpu_usage}";

if (my $error = RRDs::error) {
    print STDERR "$0: Error: Unable to update the rrd database: ${error}\n";
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/bin/noid-collector-disk-rrd.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use RRDs;
use Relianoid::Config;
use Relianoid::Stats;

my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
my $db_hd             = "hd.rrd";

my @disks = getDiskSpace();

while (@disks) {
    my @total_ref = @{ shift @disks };
    my @used_ref  = @{ shift @disks };
    my @free_ref  = @{ shift @disks };

    my ($partition) = split("\ ", $total_ref[0]);
    my $rrd_filename = "${collector_rrd_dir}/${partition}${db_hd}";

    my $tot  = $total_ref[1];
    my $used = $used_ref[1];
    my $free = $free_ref[1];

    if ($tot =~ /^$/ || $used =~ /^$/ || $free =~ /^$/) {
        print STDERR "$0: Error: Unable to get the data for partition ${partition}\n";
        print STDERR "$0: tot:${tot} used:${used} free:${free}\n";
        next;
    }

    if (!-f $rrd_filename) {
        print "$0: Info: Creating the rrd database ${rrd_filename} ...\n";

        RRDs::create $rrd_filename,     #
          "--step", "300",              # data-point interval in seconds
          "DS:tot:GAUGE:600:0:U",       # total
          "DS:used:GAUGE:600:0:U",      # used
          "DS:free:GAUGE:600:0:U",      # free
          "RRA:LAST:0.5:1:288",         # daily - every 5 min - 288 reg
          "RRA:MIN:0.5:1:288",          # daily - every 5 min - 288 reg
          "RRA:AVERAGE:0.5:1:288",      # daily - every 5 min - 288 reg
          "RRA:MAX:0.5:1:288",          # daily - every 5 min - 288 reg
          "RRA:LAST:0.5:12:168",        # weekly - every 1 hour - 168 reg
          "RRA:MIN:0.5:12:168",         # weekly - every 1 hour - 168 reg
          "RRA:AVERAGE:0.5:12:168",     # weekly - every 1 hour - 168 reg
          "RRA:MAX:0.5:12:168",         # weekly - every 1 hour - 168 reg
          "RRA:LAST:0.5:96:93",         # monthly - every 8 hours - 93 reg
          "RRA:MIN:0.5:96:93",          # monthly - every 8 hours - 93 reg
          "RRA:AVERAGE:0.5:96:93",      # monthly - every 8 hours - 93 reg
          "RRA:MAX:0.5:96:93",          # monthly - every 8 hours - 93 reg
          "RRA:LAST:0.5:288:372",       # yearly - every 1 day - 372 reg
          "RRA:MIN:0.5:288:372",        # yearly - every 1 day - 372 reg
          "RRA:AVERAGE:0.5:288:372",    # yearly - every 1 day - 372 reg
          "RRA:MAX:0.5:288:372";        # yearly - every 1 day - 372 reg

        if (my $error = RRDs::error) {
            print STDERR "$0: Error: Unable to generate the rrd database for partition ${partition}: ${error}\n";
        }
    }

    print "$0: Info: Disk Stats for partition ${partition} ...\n";
    print "$0: Info:	Total: ${tot} Bytes\n";
    print "$0: Info:	Used: ${used} Bytes\n";
    print "$0: Info:	Free: ${free} Bytes\n";
    print "$0: Info: Updating data in ${rrd_filename} ...\n";

    RRDs::update $rrd_filename, "-t", "tot:used:free", "N:${tot}:${used}:${free}";

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to update the rrd database for partition ${partition}: ${error}\n";
    }
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/bin/noid-collector-farm-rrd.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use RRDs;
use Relianoid::Farm::Base;
use Relianoid::Farm::Stats;
use Relianoid::Net::ConnStats;

my $eload = eval { require Relianoid::ELoad; };

my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');

foreach my $farmfile (&getFarmList()) {
    my $farm_name   = &getFarmName($farmfile);
    my $farm_type   = &getFarmType($farm_name);
    my $farm_status = &getFarmStatus($farm_name);

    if ($farm_type eq "datalink" || $farm_status ne "up") {
        next;
    }

    my $db_farm      = "${farm_name}-farm.rrd";
    my $rrd_filename = "${collector_rrd_dir}/${db_farm}";

    my $synconns;
    my $globalconns;

    if ($farm_type eq 'gslb' && $eload) {
        my $stats = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Stats',
            func   => 'getGSLBFarmStats',
            args   => [$farm_name],
        );

        $synconns    = $stats->{syn};
        $globalconns = $stats->{est};
    }
    elsif ($farm_type eq 'eproxy' && $eload) {
        my $stats = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Stats',
            func   => 'getEproxyFarmStats',
            args   => [ { 'farm_name' => $farm_name }],
        );

        $synconns    = $stats->{pending};
        $globalconns = $stats->{established};
    }
    else {
        my $vip = &getFarmVip("vip", $farm_name);
        my $netstat;

        if ($farm_type eq 'l4xnat') {
            $netstat = &getConntrack("", $vip, "", "", "");
        }

        $synconns    = &getFarmSYNConns($farm_name, $netstat);    # SYN_RECV connections
        $globalconns = &getFarmEstConns($farm_name, $netstat);    # ESTABLISHED connections
    }

    if ($globalconns eq '' || $synconns eq '') {
        print STDERR "$0: Error: Unable to get the data for farm ${farm_name}\n";
        exit;
    }

    if (!-f $rrd_filename) {
        print "$0: Info: Creating the rrd database ${rrd_filename} ...\n";

        RRDs::create $rrd_filename,                               #
          "--step", "300",                                        #
          "DS:pending:GAUGE:600:0:12500000",                      #
          "DS:established:GAUGE:600:0:12500000",                  #
          "RRA:LAST:0.5:1:288",                                   # daily - every 5 min - 288 reg
          "RRA:MIN:0.5:1:288",                                    # daily - every 5 min - 288 reg
          "RRA:AVERAGE:0.5:1:288",                                # daily - every 5 min - 288 reg
          "RRA:MAX:0.5:1:288",                                    # daily - every 5 min - 288 reg
          "RRA:LAST:0.5:12:168",                                  # weekly - every 1 hour - 168 reg
          "RRA:MIN:0.5:12:168",                                   # weekly - every 1 hour - 168 reg
          "RRA:AVERAGE:0.5:12:168",                               # weekly - every 1 hour - 168 reg
          "RRA:MAX:0.5:12:168",                                   # weekly - every 1 hour - 168 reg
          "RRA:LAST:0.5:96:93",                                   # monthly - every 8 hours - 93 reg
          "RRA:MIN:0.5:96:93",                                    # monthly - every 8 hours - 93 reg
          "RRA:AVERAGE:0.5:96:93",                                # monthly - every 8 hours - 93 reg
          "RRA:MAX:0.5:96:93",                                    # monthly - every 8 hours - 93 reg
          "RRA:LAST:0.5:288:372",                                 # yearly - every 1 day - 372 reg
          "RRA:MIN:0.5:288:372",                                  # yearly - every 1 day - 372 reg
          "RRA:AVERAGE:0.5:288:372",                              # yearly - every 1 day - 372 reg
          "RRA:MAX:0.5:288:372";                                  # yearly - every 1 day - 372 reg

        if (my $error = RRDs::error) {
            print STDERR "$0: Error: Unable to generate the swap rrd database: ${error}\n";
        }
    }

    print "$0: Info: ${farm_name} Farm Connections Stats ...\n";
    print "$0: Info:	Pending: ${synconns}\n";
    print "$0: Info:	Established: ${globalconns}\n";
    print "$0: Info: Updating data in ${rrd_filename} ...\n";

    RRDs::update($rrd_filename, "-t", "pending:established", "N:${synconns}:${globalconns}");

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to update the rrd database: ${error}\n";
    }
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/bin/noid-collector-iface-rrd.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use RRDs;
use Relianoid::Config;
use Relianoid::Stats;

my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
my $db_if             = "iface.rrd";

my @net      = &getNetworkStats("hash");
my $net_size = scalar @net;

for (my $it = 0 ; $it < $net_size ; $it++) {
    my $row = shift @net;

    my $if_name = $row->{interface};

    if ($if_name eq 'lo' || $if_name =~ /:/) {
        next;
    }

    my $rrd_filename = "${collector_rrd_dir}/${if_name}${db_if}";
    my $in           = $row->{in} * 1000;
    my $out          = $row->{out} * 1000;

    if (! defined $in || ! defined $out) {
        print STDERR "$0: Error: Unable to get the data\n";
        next;
    }

    if (!-f $rrd_filename) {
        print "$0: Info: Creating the rrd database ${if_name} ${rrd_filename} ...\n";

        RRDs::create $rrd_filename,          #
          "--step",                          #
          "300",                             #
          "DS:in:DERIVE:600:0:12500000",     #
          "DS:out:DERIVE:600:0:12500000",    #
          "RRA:LAST:0.5:1:288",              # daily - every 5 min - 288 reg
          "RRA:MIN:0.5:1:288",               # daily - every 5 min - 288 reg
          "RRA:AVERAGE:0.5:1:288",           # daily - every 5 min - 288 reg
          "RRA:MAX:0.5:1:288",               # daily - every 5 min - 288 reg
          "RRA:LAST:0.5:12:168",             # weekly - every 1 hour - 168 reg
          "RRA:MIN:0.5:12:168",              # weekly - every 1 hour - 168 reg
          "RRA:AVERAGE:0.5:12:168",          # weekly - every 1 hour - 168 reg
          "RRA:MAX:0.5:12:168",              # weekly - every 1 hour - 168 reg
          "RRA:LAST:0.5:96:93",              # monthly - every 8 hours - 93 reg
          "RRA:MIN:0.5:96:93",               # monthly - every 8 hours - 93 reg
          "RRA:AVERAGE:0.5:96:93",           # monthly - every 8 hours - 93 reg
          "RRA:MAX:0.5:96:93",               # monthly - every 8 hours - 93 reg
          "RRA:LAST:0.5:288:372",            # yearly - every 1 day - 372 reg
          "RRA:MIN:0.5:288:372",             # yearly - every 1 day - 372 reg
          "RRA:AVERAGE:0.5:288:372",         # yearly - every 1 day - 372 reg
          "RRA:MAX:0.5:288:372";             # yearly - every 1 day - 372 reg

        if (my $error = RRDs::error) {
            print STDERR "$0: Error: Unable to generate the rrd database for interface ${if_name}: ${error}\n";
        }
    }

    print "$0: Info: Network Stats for interface ${if_name} ...\n";
    print "$0: Info:	in: ${in}\n";
    print "$0: Info:	out: ${out}\n";
    print "$0: Info: Updating data in ${rrd_filename} ...\n";

    RRDs::update $rrd_filename, "-t", "in:out", "N:${in}:${out}";

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to update the rrd database for interface ${if_name}: ${error}\n";
    }
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/bin/noid-collector-load-rrd.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use RRDs;
use Relianoid::Config;
use Relianoid::Stats;

my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
my $db_load           = "load.rrd";
my $rrd_filename      = "${collector_rrd_dir}/${db_load}";

my @load = &getLoadStats();

my %load = ();
for my $array_ref (@load) {
    my ($key, $value) = @{$array_ref};
    $load{$key} = $value;
}

my $last   = $load{"Last"};
my $last5  = $load{"Last 5"};
my $last15 = $load{"Last 15"};

if (!$last || !$last5 || !$last15) {
    print STDERR "$0: Error: Unable to get the data\n";
    exit;
}

if (!-f $rrd_filename) {
    print "$0: Info: Creating the rrd database ${rrd_filename} ...\n";

    RRDs::create $rrd_filename,             #
      "--step",                             #
      "300",                                #
      "DS:load:GAUGE:600:0.00:100.00",      #
      "DS:load5:GAUGE:600:0.00:100.00",     #
      "DS:load15:GAUGE:600:0.00:100.00",    #
      "RRA:LAST:0.5:1:288",                 # daily - every 5 min - 288 reg
      "RRA:MIN:0.5:1:288",                  # daily - every 5 min - 288 reg
      "RRA:AVERAGE:0.5:1:288",              # daily - every 5 min - 288 reg
      "RRA:MAX:0.5:1:288",                  # daily - every 5 min - 288 reg
      "RRA:LAST:0.5:12:168",                # weekly - every 1 hour - 168 reg
      "RRA:MIN:0.5:12:168",                 # weekly - every 1 hour - 168 reg
      "RRA:AVERAGE:0.5:12:168",             # weekly - every 1 hour - 168 reg
      "RRA:MAX:0.5:12:168",                 # weekly - every 1 hour - 168 reg
      "RRA:LAST:0.5:96:93",                 # monthly - every 8 hours - 93 reg
      "RRA:MIN:0.5:96:93",                  # monthly - every 8 hours - 93 reg
      "RRA:AVERAGE:0.5:96:93",              # monthly - every 8 hours - 93 reg
      "RRA:MAX:0.5:96:93",                  # monthly - every 8 hours - 93 reg
      "RRA:LAST:0.5:288:372",               # yearly - every 1 day - 372 reg
      "RRA:MIN:0.5:288:372",                # yearly - every 1 day - 372 reg
      "RRA:AVERAGE:0.5:288:372",            # yearly - every 1 day - 372 reg
      "RRA:MAX:0.5:288:372";                # yearly - every 1 day - 372 reg

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to generate the rrd database: ${error}\n";
    }
}

print "$0: Info: Load Stats ...\n";
print "$0: Info:	Last minute: ${last}\n";
print "$0: Info:	Last 5 minutes: ${last5}\n";
print "$0: Info:	Last 15 minutes: ${last15}\n";
print "$0: Info: Updating data in ${rrd_filename} ...\n";

RRDs::update $rrd_filename, "-t", "load:load5:load15", "N:${last}:${last5}:${last15}";

if (my $error = RRDs::error) {
    print STDERR "$0: Error: Unable to update the rrd database: ${error}\n";
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/bin/noid-collector-memory-rrd.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID SL, Sevilla (Spain)
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use RRDs;
use Relianoid::Config;
use Relianoid::Stats;

my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');

my $db_mem   = "mem.rrd";
my $db_memsw = "memsw.rrd";

my $ram_rrd_filename  = "${collector_rrd_dir}/${db_mem}";
my $swap_rrd_filename = "${collector_rrd_dir}/${db_memsw}";

my @mem = &getMemStats("b");

my %mem = ();
for my $array_ref (@mem) {
    my ($key, $value) = @{$array_ref};
    $mem{$key} = $value;
}

my $mvalue  = $mem{"MemTotal"};
my $mused   = $mem{"MemUsed"};
my $mfvalue = $mem{"MemFree"};
my $mbvalue = $mem{"Buffers"};
my $mcvalue = $mem{"Cached"};

my $swtvalue = $mem{"SwapTotal"};
my $swfvalue = $mem{"SwapFree"};
my $swused   = $mem{"SwapUsed"};
my $swcvalue = $mem{"SwapCached"};

if (!$mvalue || !$mused || !$mfvalue || !$mcvalue || !$swtvalue || !$swfvalue || !$swused || !$swcvalue) {
    print STDERR "$0: Error: Unable to get the data\n";
    exit;
}

if (!-f $ram_rrd_filename) {
    print "$0: Info: Creating the rrd database ${ram_rrd_filename} ...\n";

    RRDs::create $ram_rrd_filename,    #
      "--step", "300",                 # data-point interval in seconds
      "DS:memt:GAUGE:600:0:U",         # total
      "DS:memu:GAUGE:600:0:U",         # used
      "DS:memf:GAUGE:600:0:U",         # free
      "DS:memc:GAUGE:600:0:U",         # cache
      "RRA:LAST:0.5:1:288",            # daily - every 5 min - 288 reg
      "RRA:MIN:0.5:1:288",             # daily - every 5 min - 288 reg
      "RRA:AVERAGE:0.5:1:288",         # daily - every 5 min - 288 reg
      "RRA:MAX:0.5:1:288",             # daily - every 5 min - 288 reg
      "RRA:LAST:0.5:12:168",           # weekly - every 1 hour - 168 reg
      "RRA:MIN:0.5:12:168",            # weekly - every 1 hour - 168 reg
      "RRA:AVERAGE:0.5:12:168",        # weekly - every 1 hour - 168 reg
      "RRA:MAX:0.5:12:168",            # weekly - every 1 hour - 168 reg
      "RRA:LAST:0.5:96:93",            # monthly - every 8 hours - 93 reg
      "RRA:MIN:0.5:96:93",             # monthly - every 8 hours - 93 reg
      "RRA:AVERAGE:0.5:96:93",         # monthly - every 8 hours - 93 reg
      "RRA:MAX:0.5:96:93",             # monthly - every 8 hours - 93 reg
      "RRA:LAST:0.5:288:372",          # yearly - every 1 day - 372 reg
      "RRA:MIN:0.5:288:372",           # yearly - every 1 day - 372 reg
      "RRA:AVERAGE:0.5:288:372",       # yearly - every 1 day - 372 reg
      "RRA:MAX:0.5:288:372";           # yearly - every 1 day - 372 reg

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to generate the memory rrd database: ${error}\n";
    }
}

if (!-f $swap_rrd_filename) {
    print "$0: Info: Creating the rrd database ${swap_rrd_filename} ...\n";

    RRDs::create $swap_rrd_filename,    #
      "--step", "300",                  # data-point interval in seconds
      "DS:swt:GAUGE:600:0:U",           # total
      "DS:swu:GAUGE:600:0:U",           # used
      "DS:swf:GAUGE:600:0:U",           # free
      "DS:swc:GAUGE:600:0:U",           # cache
      "RRA:LAST:0.5:1:288",             # daily - every 5 min - 288 reg
      "RRA:MIN:0.5:1:288",              # daily - every 5 min - 288 reg
      "RRA:AVERAGE:0.5:1:288",          # daily - every 5 min - 288 reg
      "RRA:MAX:0.5:1:288",              # daily - every 5 min - 288 reg
      "RRA:LAST:0.5:12:168",            # weekly - every 1 hour - 168 reg
      "RRA:MIN:0.5:12:168",             # weekly - every 1 hour - 168 reg
      "RRA:AVERAGE:0.5:12:168",         # weekly - every 1 hour - 168 reg
      "RRA:MAX:0.5:12:168",             # weekly - every 1 hour - 168 reg
      "RRA:LAST:0.5:96:93",             # monthly - every 8 hours - 93 reg
      "RRA:MIN:0.5:96:93",              # monthly - every 8 hours - 93 reg
      "RRA:AVERAGE:0.5:96:93",          # monthly - every 8 hours - 93 reg
      "RRA:MAX:0.5:96:93",              # monthly - every 8 hours - 93 reg
      "RRA:LAST:0.5:288:372",           # yearly - every 1 day - 372 reg
      "RRA:MIN:0.5:288:372",            # yearly - every 1 day - 372 reg
      "RRA:AVERAGE:0.5:288:372",        # yearly - every 1 day - 372 reg
      "RRA:MAX:0.5:288:372";            # yearly - every 1 day - 372 reg

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to generate the swap rrd database: ${error}\n";
    }
}

print "$0: Info: Memory Stats ...\n";
print "$0: Info:	Total Memory: ${mvalue} Bytes\n";
print "$0: Info:	Used Memory: ${mused} Bytes\n";
print "$0: Info:	Free Memory: ${mfvalue} Bytes\n";
print "$0: Info:	Cached Memory: ${mcvalue} Bytes\n";
print "$0: Info:	Buffered Memory: ${mbvalue} Bytes\n";
print "$0: Info: Updating data in ${ram_rrd_filename} ...\n";

RRDs::update $ram_rrd_filename, "-t", "memt:memu:memf:memc", "N:${mvalue}:${mused}:${mfvalue}:" . ($mcvalue + $mbvalue);

if (my $error = RRDs::error) {
    print STDERR "$0: Error: Unable to update the rrd database: ${error}\n";
}

print "$0: Info: Swap Stats ...\n";
print "$0: Info:	Total Memory Swap: ${swtvalue} Bytes\n";
print "$0: Info:	Used Memory Swap: ${swused} Bytes\n";
print "$0: Info:	Free Memory Swap: ${swfvalue} Bytes\n";
print "$0: Info:	Cached Memory Swap: ${swcvalue} Bytes\n";
print "$0: Info: Updating data in $swap_rrd_filename ...\n";

RRDs::update $swap_rrd_filename, "-t", "swt:swu:swf:swc", "N:${swtvalue}:${swused}:${swfvalue}:${swcvalue}";

if (my $error = RRDs::error) {
    print STDERR "$0: Error: Unable to update the rrd database: ${error}\n";
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/bin/noid-collector-temperature-rrd.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use RRDs;
use Relianoid::Config;
use Relianoid::SystemInfo;
use Relianoid::Stats;

my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
my $db_temp           = "temp.rrd";
my $rrd_filename      = "${collector_rrd_dir}/${db_temp}";

# this script is only for ZNA
if (&getApplianceVersion() !~ /ZNA/) {
    exit;
}

my $temp = &getCPUTemp();

if ($temp eq '') {
    print STDERR "$0: Error: Unable to get the data\n";
    exit;
}

if (!-f $rrd_filename) {
    print "$0: Info: Creating the rrd database ${rrd_filename} ...\n";

    RRDs::create $rrd_filename,     #
      "--step", "300",              # data-point interval in seconds
      "DS:temp:GAUGE:600:0:100",    # temperature
      "RRA:LAST:0.5:1:288",         # daily - every 5 min - 288 reg
      "RRA:MIN:0.5:1:288",          # daily - every 5 min - 288 reg
      "RRA:AVERAGE:0.5:1:288",      # daily - every 5 min - 288 reg
      "RRA:MAX:0.5:1:288",          # daily - every 5 min - 288 reg
      "RRA:LAST:0.5:12:168",        # weekly - every 1 hour - 168 reg
      "RRA:MIN:0.5:12:168",         # weekly - every 1 hour - 168 reg
      "RRA:AVERAGE:0.5:12:168",     # weekly - every 1 hour - 168 reg
      "RRA:MAX:0.5:12:168",         # weekly - every 1 hour - 168 reg
      "RRA:LAST:0.5:96:93",         # monthly - every 8 hours - 93 reg
      "RRA:MIN:0.5:96:93",          # monthly - every 8 hours - 93 reg
      "RRA:AVERAGE:0.5:96:93",      # monthly - every 8 hours - 93 reg
      "RRA:MAX:0.5:96:93",          # monthly - every 8 hours - 93 reg
      "RRA:LAST:0.5:288:372",       # yearly - every 1 day - 372 reg
      "RRA:MIN:0.5:288:372",        # yearly - every 1 day - 372 reg
      "RRA:AVERAGE:0.5:288:372",    # yearly - every 1 day - 372 reg
      "RRA:MAX:0.5:288:372";        # yearly - every 1 day - 372 reg

    if (my $error = RRDs::error) {
        print STDERR "$0: Error: Unable to generate the rrd database: ${error}\n";
    }
}

print "$0: Info: Temperature Stats ...\n";
print "$0: Info:	Temp: ${temp}\n";
print "$0: Info: Updating data in ${rrd_filename} ...\n";

RRDs::update $rrd_filename, "-t", "temp", "N:${temp}";

if (my $error = RRDs::error) {
    print STDERR "$0: Error: Unable to update the rrd database: ${error}\n";
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/migrations/000-interfaces.pl ===

#!/usr/bin/perl

use strict;
use warnings;
use feature qw(signatures say);

use Config::Tiny;
use Relianoid::Config;
use Relianoid::Net::Interface;
use Relianoid::Validate;
use Relianoid::Log;

my $iface_files_dir = "/usr/local/relianoid/config";

opendir(my $dir, $iface_files_dir);
my @iface_files = grep { /^if_.*_conf/ && -f "$iface_files_dir/$_" } readdir($dir);
closedir $dir;

for my $file (@iface_files) {
    #Parse filename to obtain file
    $file =~ /if_(?<iface>.*)_conf/;
    my $iface = $+{iface};

    #Trying to read, set the errstr error if in tiny format
    my $iface_file = Config::Tiny->read("$iface_files_dir/$file");

    #Don't migrate if is in tiny format ( there is no error when reading and the section is defined )
    next
      if (!(Config::Tiny->errstr =~ /$iface/)
        && defined $iface_file->{$iface});

    &log_info("Migrating $iface configuration files", "NETWORK");

    #Is not in Tiny format, if unset, delete file, if set, parse the file
    say "File $file not in tiny format";
    my $if_ref = &_getInterfaceConfig($iface);

    unlink "$iface_files_dir/$file";

    #Setted
    require Relianoid::Net::Interface;
    &setInterfaceConfig($if_ref) if (defined $if_ref);
}
&log_info("Interfaces configuration migration finished", "NETWORK");

sub _getInterfaceConfig    # \%iface ($if_name, $ip_version)
{
    my ($if_name) = @_;

    unless (defined $if_name) {
        &log_debug2('getInterfaceConfig got undefined interface name', 'network');
    }

    #~ &log_info( "[CALL] getInterfaceConfig( $if_name )" );

    my $ip_version;
    my $if_line;
    my $if_status;
    my $configdir       = &getGlobalConfiguration('configdir');
    my $config_filename = "$configdir/if_${if_name}_conf";

    if (open my $file, '<', "$config_filename") {
        my @lines = grep { !/^(\s*#|$)/ } <$file>;

        for my $line (@lines) {
            my (undef, $ip) = split ';', $line;

            if (defined $ip) {
                $ip_version =
                    ($ip =~ /:/)  ? 6
                  : ($ip =~ /\./) ? 4
                  :                 undef;
            }

            if (defined $ip_version && !$if_line) {
                $if_line = $line;
            }
            elsif ($line =~ /^status=/) {
                $if_status = $line;
                $if_status =~ s/^status=//;
                chomp $if_status;
            }
        }
        close $file;
    }

    # includes !$if_status to avoid warning
    if (!$if_line && (!$if_status || $if_status !~ /up/)) {
        return;
    }

    chomp($if_line);
    my @if_params = split(';', $if_line);

    # Example: eth0;10.0.0.5;255.255.255.0;up;10.0.0.1;

    require IO::Socket;
    my $socket = IO::Socket::INET->new(Proto => 'udp');

    my %iface;

    $iface{name}    = shift @if_params // $if_name;
    $iface{addr}    = shift @if_params;
    $iface{mask}    = shift @if_params;
    $iface{gateway} = shift @if_params;                        # optional
    $iface{status}  = $if_status;
    $iface{dev}     = $if_name;
    $iface{vini}    = undef;
    $iface{vlan}    = undef;
    $iface{mac}     = undef;
    $iface{type}    = &getInterfaceType($if_name);
    $iface{parent}  = &getParentInterfaceName($iface{name});
    $iface{ip_v} =
      ($iface{addr} =~ /:/) ? '6' : ($iface{addr} =~ /\./) ? '4' : 0;
    $iface{net} =
      &getAddressNetwork($iface{addr}, $iface{mask}, $iface{ip_v});

    if ($iface{dev} =~ /:/) {
        ($iface{dev}, $iface{vini}) = split ':', $iface{dev};
    }

    if (!$iface{name}) {
        $iface{name} = $if_name;
    }

    if ($iface{dev} =~ /./) {
        # dot must be escaped
        ($iface{dev}, $iface{vlan}) = split '\.', $iface{dev};
    }

    $iface{mac} = $socket->if_hwaddr($iface{dev});

    # Interfaces without ip do not get HW addr via socket,
    # in those cases get the MAC from the OS.
    unless ($iface{mac}) {
        open my $fh, '<', "/sys/class/net/$if_name/address";
        chomp($iface{mac} = <$fh>);
        close $fh;
    }

    # complex check to avoid warnings
    if ((!exists($iface{vini}) || !defined($iface{vini}) || $iface{vini} eq '')
        && $iface{addr})
    {
        require Config::Tiny;
        my $float = Config::Tiny->read(&getGlobalConfiguration('floatfile'));

        $iface{float} = $float->{_}{ $iface{name} } // '';
    }

    # for virtual interface, overwrite mask and gw with parent values
    if ($iface{type} eq 'vini') {
        my $if_parent = &getInterfaceConfig($iface{parent});
        $iface{mask}    = $if_parent->{mask};
        $iface{gateway} = $if_parent->{gateway};
    }

    return \%iface;
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/migrations/001-zproxyng_2_pound.sh ===

#!/usr/bin/bash

source /usr/local/relianoid/bin/load_global_conf
load_global_conf

name="Name"
nfmark="NfMark"

for i in $(find /usr/local/relianoid/config/ -name "*_proxy.cfg" -or -name "*_pound.cfg");
do
	echo "Checking Name and NfMark directive in farm config file: $i"
	grep "^\s*Name\s*\"" $i &>/dev/null
	if [[ $? == 0 ]];then
		echo "Remove directive 'Name' to farm config file: $i"
		fname=`echo $i | cut -d"_" -f1 | cut -d"/" -f6`
		sed -i "/^\s*Name\s*\"/d" "$i"
	fi

	grep "^\s*NfMark\s*" $i &>/dev/null
	if [[ $? == 0 ]];then
		echo "Remove directive 'NfMark' to farm config file: $i"
		fname=`echo $i | cut -d"_" -f1 | cut -d"/" -f6`
		sed -i "/^\s*NfMark\s*/d" "$i"
	fi

	sed -i "s/usr.local.zevenet/usr\/local\/relianoid/g" "$i"
done

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/migrations/002-certificates.sh ===

#!/usr/bin/bash
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

# Migrate certificates files to new directory
mv /usr/local/relianoid/config/{*.pem,*.csr,*.key} /usr/local/relianoid/config/certificates/ 2>/dev/null

# Migrate certificate of farm config file
for i in $(find /usr/local/relianoid/config/ -name "*_proxy.cfg" -o -name "*_pound.cfg");
do
	if grep 'Cert \"\/usr\/local\/relianoid\/config\/\w.*\.pem' $i | grep -qv certificates; then
		echo "Migrating certificate directory of config file"
		sed -i -e 's/Cert \"\/usr\/local\/relianoid\/config/Cert \"\/usr\/local\/relianoid\/config\/certificates/' $i
	fi
done

# Migrate http server certificate
http_conf="/usr/local/relianoid/app/cherokee/etc/cherokee/cherokee.conf"

grep -E "/usr/local/relianoid/config/[^\/]+.pem" $http_conf
if [ $? -eq 0 ]; then
	echo "Migrating certificate of http server"
	perl -E '
use strict;
use Tie::File;
tie my @fh, "Tie::File", "/usr/local/relianoid/app/cherokee/etc/cherokee/cherokee.conf";
for my $line (@fh)
{
	if ($line =~ m"/usr/local/relianoid/config/[^/]+\.(pem|csr|key)" )
	{

		unless( $line =~ s"/usr/local/relianoid/config"/usr/local/relianoid/config/certificates"m)
		{
			say "Error modifying: >$line<";
		}
		say "migrated $line";
	}
}
close @fh;
	'
fi


=== ./background/relianoid_adc/source_tree/usr/local/relianoid/migrations/003-dh2048_cherokee.sh ===

#!/usr/bin/bash
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

#Add DH param to 2048 in cherokee conf

cherokee_conf="/usr/local/relianoid/app/cherokee/etc/cherokee/cherokee.conf"

if [[ ! `grep "^vserver\!1\!ssl_dh_length.*" $cherokee_conf` ]]; then
	echo "DH param not found in cherokee conf, adding"
	sed -i '/server!user = root/a vserver!1!ssl_dh_length = 2048' $cherokee_conf
fi



=== ./background/relianoid_adc/source_tree/usr/local/relianoid/migrations/003-migrate-noid-default-cert.sh ===

#!/usr/bin/bash
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

if [ ! -f "/usr/local/relianoid/share/noid_ssl_cert.pem" ]; then
	echo "Default SSL certificate does not exist _/usr/local/relianoid/share/noid_ssl_cert.pem_"
	exit 1
fi

if [ ! -f "/usr/local/relianoid/config/certificates/noid_ssl_cert.key" ]; then
	cp /usr/local/relianoid/share/noid_ssl_cert.key /usr/local/relianoid/config/certificates/
fi
if [ ! -f "/usr/local/relianoid/config/certificates/noid_ssl_cert.pem" ]; then
	cp /usr/local/relianoid/share/noid_ssl_cert.pem /usr/local/relianoid/config/certificates/
fi

# Migrate cherokee default certificate
if [ -f "/usr/local/relianoid/app/cherokee/etc/cherokee/cherokee.conf" ] && [ "`grep zencert /usr/local/relianoid/app/cherokee/etc/cherokee/cherokee.conf`" != "" ]; then
	sed -i -e 's/zencert-c/noid_ssl_cert/g' /usr/local/relianoid/app/cherokee/etc/cherokee/cherokee.conf
	sed -i -e 's/zencert/noid_ssl_cert/g' /usr/local/relianoid/app/cherokee/etc/cherokee/cherokee.conf
fi

# Migrate HTTP/S farms default certificate
for i in $(find /usr/local/relianoid/config/ -name "*proxy.cfg");
do
	if [ "`grep zencert $i`" != "" ]; then
		sed -i -e 's/zencert.pem/noid_ssl_cert.pem/g' "$i"
	fi
done

# Finally, remove obsolete zencert
rm -rf /usr/local/zevenet/config/certificates/zencert-c.key /usr/local/zevenet/config/certificates/zencert.pem

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/migrations/004-farmguardian.pl ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

# Description:
# Migrate from old Farmguardian configuration file to new Farmguardian configuration format

use strict;
use warnings;

use Relianoid::Log;
use Relianoid::Config;

my $conf_dir = &getGlobalConfiguration('configdir');
my $fg_conf  = "$conf_dir/farmguardian.conf";

use Relianoid::File;
use Relianoid::FarmGuardian;

opendir(my $dir, $conf_dir) or return;
my $index = 0;
while (my $file = readdir($dir)) {
    if ($file =~ /_guardian\.conf$/) {
        print " + Migrating Farmguardian file $conf_dir/$file ...\n";
        my $file_content = &getFile("$conf_dir/$file");
        chomp $file_content;

        my $file_name;
        my $service;
        $file_name = $1 if $file =~ /^(.+)_guardian\.conf$/;
        my ($farm, $interval, $command, $cut, $log) =
          split(/:{3}/, $file_content);
        ($farm, $service) = split(/_/, $file_name);

        my @check_command     = split(/ /, $command);
        my $farmguardian_name = "migrated" . $index++ . "_" . $check_command[0];
        my $farmguardian_ref  = {
            "description" => "check migrated from community backup",
            "interval"    => $interval,
            "command"     => "$command",
            "cut_conns"   => "$cut",
            "log"         => "$log"
        };

        print "      Create Farmguardian $farmguardian_name ... ";
        my $error = &createFGBlank($farmguardian_name);
        if ($error) {
            print "ERROR\n";
            next;
        }
        print "OK\n";
        print "      Update Farmguardian $farmguardian_name ... ";
        $error = &setFGObject($farmguardian_name, $farmguardian_ref);

        #$error = &setTinyObj( $fg_conf, $farmguardian_name, $farmguardian_ref );
        if ($error) {
            print "ERROR\n";
            next;
        }
        print "OK\n";
        print "      Link farm : $farm ";
        print " service : $service " if $service;
        print " to Farmguardian : $farmguardian_name ...";
        $error = &linkFGFarm($farmguardian_name, $farm, $service);
        if ($error) {
            print "ERROR\n";
            next;
        }
        print "OK\n";
        print "      Delete old configuration file : $file ... ";
        unlink "$conf_dir/$file";
        if (-f "$conf_dir/$file") {
            print "ERROR\n";
        }
        else {
            print "OK\n";
        }
    }
}

closedir($dir);

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/migrations/006-http_name.sh ===

#!/usr/bin/bash
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

source /usr/local/relianoid/bin/load_global_conf
load_global_conf

for i in $(find /usr/local/relianoid/config/ -name "*_proxy.cfg" -or -name "*_pound.cfg");
do
	fname=`echo $i | cut -d"_" -f1 | cut -d"/" -f6`

	echo "Checking User directive in farm config file: $i"
	grep "^User.*" $i &>/dev/null
	if [[ $? != 0 ]];then
		echo "Adding directive 'User' to farm config file: $i"
		sed -i "/^##GLOBAL OPTIONS/ aUser\t\t\"root\"" $i
	fi

	echo "Checking Group directive in farm config file: $i"
	grep "^Group.*" $i &>/dev/null
	if [[ $? != 0 ]];then
		echo "Adding directive 'Group' to farm config file: $i"
		sed -i "/^User/ aGroup\t\t\"root\"" $i
	fi

	echo "Checking Name directive in farm config file: $i"
	grep "^Name.*" $i &>/dev/null
	if [[ $? != 0 ]];then
		echo "Adding directive 'Name' to farm config file: $i"
		sed -i "/^Group/ aName\t\t${fname}" $i
	fi

	echo "Checking Control directive in farm config file: $i"
	grep "^Control.*" $i &>/dev/null
	if [[ $? != 0 ]];then
		echo "Adding directive 'Control' to farm config file: $i"
		sed -i "/^ThreadModel/ aControl\t\t\"/tmp/${fname}_proxy.socket\"" $i
	fi

done

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/migrations/014-snmpd.sh ===

#!/usr/bin/bash

###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

perl -MRelianoid::SNMP -E "&setSnmpdDefaultConfig();"

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Core;
use Relianoid::Log;
use Relianoid::Config;
use Relianoid::Validate;
use Relianoid::Debug;
use Relianoid::Netfilter;
use Relianoid::Net::Interface;
use Relianoid::FarmGuardian;
use Relianoid::Backup;
use Relianoid::RRD;
use Relianoid::SNMP;
use Relianoid::Stats;
use Relianoid::SystemInfo;
use Relianoid::System;
use Relianoid::API;

require Relianoid::CGI if defined $ENV{GATEWAY_INTERFACE};

=pod

=head1 Module

Relianoid

=cut

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/API.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures state);

my $eload = eval { require Relianoid::ELoad; };

=pod

=head1 Module

Relianoid::API

=cut

=pod

=head1 getAPI

Get API status

Parameters:

    name - 'status' to get if the user 'api' is enabled, or 'api_key' to get the 'api_key'.

Returns:

    For 'status': Boolean. 'true' if the API user is enabled, or 'false' if it is disabled.

    For 'api_key': Returns the current api_key.

=cut

sub getAPI ($name) {
    require Relianoid::File;

    my $result = "false";

    if ($name eq "status") {
        if (grep { /^api:/ } readFileAsArray(&getGlobalConfiguration('htpass'))) {
            $result = "true";
        }
    }
    elsif ($name eq "api_key") {
        $result = &getGlobalConfiguration('api_key');
    }

    return $result;
}

=pod

=head1 setAPI

Set API values

Parameters:

    name - Actions to be taken: 'enable', 'disable', 'randomkey' to set a random key, or 'key' to set the key specified in value.

        enable    - Enables the user 'api'.
        disable   - Disables the user 'api'.
        randomkey - Generates a random key.
        key       - Sets $value a the api_key.

    value - New key to be used. Only apply when the action 'key' is used.

Returns:

    none

=cut

sub setAPI ($action, $value = undef) {
    if ($action eq "enable") {
        my $cmd = "adduser --system --shell /bin/false --no-create-home api";

        return &logAndRun($cmd);
    }
    elsif ($action eq "disable") {
        setGlobalConfiguration('api_key', "");

        # Update api_key global configuration
        &getGlobalConfiguration('api_key', 1);

        my $deluser_bin = &getGlobalConfiguration('deluser_bin');
        my $cmd         = "$deluser_bin api";

        return &logAndRun($cmd);
    }
    elsif ($action eq "randomkey") {
        my $random = &getAPIRandomKey(64);

        setGlobalConfiguration('api_key', $random);
    }
    elsif ($action eq "key") {
        if ($eload) {
            $value = &eload(
                module => 'Relianoid::EE::Code',
                func   => 'setCryptString',
                args   => [$value],
            );
        }

        setGlobalConfiguration('api_key', $value);

        # Update api_key global configuration
        &getGlobalConfiguration('api_key', 1);
    }

    return;
}

=pod

=head1 getAPIRandomKey

Generate random key for API user.

Parameters:

    length - Number of characters in the new key.

Returns: string - Random key.

=cut

sub getAPIRandomKey ($length) {
    my @alphanumeric = ('a' .. 'z', 'A' .. 'Z', 0 .. 9);
    my $randpassword = join '', map { $alphanumeric[ rand @alphanumeric ] } 0 .. $length;

    return $randpassword;
}

=pod

=head1 isApiKeyValid

Validates the API key received with the HTTP header API_KEY

Parameters: None

Returns: integer - integer used as boolean

=cut

sub isApiKeyValid () {
    require Relianoid::User;

    my $is_valid = 0;
    my $key      = get_http_api_key();

    if ($key) {
        if (&getAPI("status") eq "true" && &getAPI("api_key") eq $key) {
            &setUser('root');
            $is_valid = 1;
        }
        elsif ($eload) {
            my $user = &eload(
                module => 'Relianoid::EE::RBAC::User::Core',
                func   => 'validateRBACUserAPIKey',
                args   => [$key],
            );
            if ($user) {
                &setUser($user);
                $is_valid = 1;
            }
        }
    }

    return $is_valid;
}

=pod

=head1 getApiVersionsList

Parameters: None

Returns: string array - list of API versions (as strings)

=cut

sub getApiVersionsList () {
    return (sort split ' ', &getGlobalConfiguration("api_versions"));
}

=pod

=head1 getApiVersion

Parameters:

    none

Returns:

    string - API version or empty string.

=cut

sub getApiVersion () {
    return $ENV{API_VERSION} // "";
}

sub get_http_api_key () {
    return $ENV{HTTP_API_KEY} if $ENV{HTTP_API_KEY};

    state $warned_deprecation = 0;

    if (exists $ENV{HTTP_ZAPI_KEY}) {
        if (not $warned_deprecation) {
            log_warn("The HTTP header 'ZAPI_KEY' is deprecated and its use will be removed, use 'API_KEY' instead.");
            $warned_deprecation = 1;
        }

        return $ENV{HTTP_ZAPI_KEY};
    }

    return;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/API40/Routes.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::HTTP;

=pod

=head1 Module

Relianoid::API40::Routes

=cut

my $PATH_INFO      = $ENV{PATH_INFO};
my $REQUEST_METHOD = $ENV{REQUEST_METHOD};

if ($PATH_INFO =~ qr{^/ids$}) {
    require Relianoid::HTTP::Controllers::API::Ids;

    GET qr{^/ids$} => \&list_ids_controller;
}

require Relianoid::Validate;

if ($PATH_INFO =~ qr{^/certificates/letsencryptz?}) {
    require Relianoid::HTTP::Controllers::API::Letsencrypt;

    my $le_cert_re = &getValidFormat('le_certificate_name');

    GET qr{^/certificates/letsencryptz?/config$} => \&get_le_conf_controller;    #  GET config
    PUT qr{^/certificates/letsencryptz?/config$} => \&set_le_conf_controller;    #  Modify config

    GET qr{^/certificates/letsencryptz?$} => \&list_le_cert_controller;          #  List certificates
    POST qr{^/certificates/letsencryptz?$} => \&add_le_cert_controller;          #  Create certificate

    GET qr{^/certificates/letsencryptz?/($le_cert_re)$} => \&get_le_cert_controller;          #  GET certificate
    DELETE qr{^/certificates/letsencryptz?/($le_cert_re)$} => \&delete_le_cert_controller;    #  DELETE certificate
    PUT qr{^/certificates/letsencryptz?/($le_cert_re)$} => \&set_le_cert_controller;          #  Modify certificate

    POST qr{^/certificates/letsencryptz?/($le_cert_re)/actions$} => \&actions_le_cert_controller;  #  LE certificate actions
}

# SSL certificates
if ($PATH_INFO =~ qr{^/certificates}) {
    require Relianoid::HTTP::Controllers::API::Certificate;

    my $cert_name_re = &getValidFormat('certificate_name');

    GET qr{^/certificates$}                      => \&list_certificates_controller;       #  GET List SSL certificates
    GET qr{^/certificates/($cert_name_re)/info$} => \&get_certificate_info_controller;    #  GET SSL certificate information
    GET qr{^/certificates/($cert_name_re)$}      => \&download_certificate_controller;    #  Download SSL certificate
    POST qr{^/certificates$}     => \&create_csr_controller;                              #  Create CSR certificates
    POST qr{^/certificates/pem$} => \&create_certificate_controller;                      #  POST certificates

    if ($PATH_INFO !~ qr{^/certificates/letsencryptz?-wildcard$}) {
        POST qr{^/certificates/($cert_name_re)$} => \&upload_certificate_controller;      #  POST certificates
    }

    DELETE qr{^/certificates/($cert_name_re)$} => \&delete_certificate_controller;        #  DELETE certificate
}

my $farm_re    = &getValidFormat('farm_name');
my $service_re = &getValidFormat('service');
my $be_re      = &getValidFormat('backend');

if ($PATH_INFO =~ qr{^/farms/$farm_re/certificates}) {
    require Relianoid::HTTP::Controllers::API::Certificate;

    my $cert_pem_re = &getValidFormat('cert_pem');

    POST qr{^/farms/($farm_re)/certificates$} => \&add_farm_certificate_controller;
    DELETE qr{^/farms/($farm_re)/certificates/($cert_pem_re)$} => \&delete_farm_certificate_controller;
}

if (   $PATH_INFO =~ qr{^/monitoring/fg}
    or $PATH_INFO =~ qr{^/farms/$farm_re(?:/services/$service_re)?/fg})
{
    require Relianoid::HTTP::Controllers::API::Farm::Guardian;

    my $fg_name_re = &getValidFormat('fg_name');

    POST qr{^/farms/($farm_re)/services/($service_re)/fg$} => \&add_fg_to_farm_controller;
    POST qr{^/farms/($farm_re)/fg$}                        => \&add_fg_to_farm_controller;
    DELETE qr{^/farms/($farm_re)/services/($service_re)/fg/($fg_name_re)$} => \&delete_fg_from_farm_controller;
    DELETE qr{^/farms/($farm_re)/fg/($fg_name_re)$}                        => \&delete_fg_from_farm_controller;

    GET qr{^/monitoring/fg$} => \&list_farmguardian_controller;
    POST qr{^/monitoring/fg$} => \&create_farmguardian_controller;
    GET qr{^/monitoring/fg/($fg_name_re)$} => \&get_farmguardian_controller;
    PUT qr{^/monitoring/fg/($fg_name_re)$} => \&modify_farmguardian_controller;
    DELETE qr{^/monitoring/fg/($fg_name_re)$} => \&delete_farmguardian_controller;
}

if ($PATH_INFO =~ qr{^/farms/$farm_re/actions}) {
    require Relianoid::HTTP::Controllers::API::Farm::Action;

    PUT qr{^/farms/($farm_re)/actions$} => \&actions_farm_controller;
}

if ($PATH_INFO =~ qr{^/farms/$farm_re.*/backends/$be_re/maintenance}) {
    require Relianoid::HTTP::Controllers::API::Farm::Action;

    PUT qr{^/farms/($farm_re)/services/($service_re)/backends/($be_re)/maintenance$} =>
      \&set_service_backend_maintenance_controller;    #  (HTTP only)

    PUT qr{^/farms/($farm_re)/backends/($be_re)/maintenance$} => \&set_backend_maintenance_controller;    #  (L4xNAT only)
}

if ($PATH_INFO =~ qr{^/farms/$farm_re(?:/services/$service_re)?/backends}) {
    require Relianoid::HTTP::Controllers::API::Farm::Backend;

    GET qr{^/farms/($farm_re)/backends$} => \&list_farm_backends_controller;
    POST qr{^/farms/($farm_re)/backends$} => \&add_farm_backend_controller;
    PUT qr{^/farms/($farm_re)/backends/($be_re)$} => \&modify_farm_backend_controller;
    DELETE qr{^/farms/($farm_re)/backends/($be_re)$} => \&delete_farm_backend_controller;

    GET qr{^/farms/($farm_re)/services/($service_re)/backends$} => \&list_service_backends_controller;
    POST qr{^/farms/($farm_re)/services/($service_re)/backends$} => \&add_service_backend_controller;
    PUT qr{^/farms/($farm_re)/services/($service_re)/backends/($be_re)$} => \&modify_service_backends_controller;
    DELETE qr{^/farms/($farm_re)/services/($service_re)/backends/($be_re)$} => \&delete_service_backend_controller;
}

if ($PATH_INFO =~ qr{^/farms/$farm_re/services}) {
    require Relianoid::HTTP::Controllers::API::Farm::Service;

    POST qr{^/farms/($farm_re)/services$} => \&add_farm_service_controller;
    GET qr{^/farms/($farm_re)/services/($service_re)$} => \&get_farm_service_controller;
    PUT qr{^/farms/($farm_re)/services/($service_re)$} => \&modify_farm_service_controller;
    DELETE qr{^/farms/($farm_re)/services/($service_re)$} => \&delete_farm_service_controller;
}

if ($PATH_INFO =~ qr{^/farms}) {
    if ($REQUEST_METHOD eq 'GET') {
        require Relianoid::HTTP::Controllers::API::Farm::Get;

        GET qr{^/farms$} => \&list_farms_controller;

        GET qr{^/farms/modules/summary$} => \&get_farm_modules_controller;
        GET qr{^/farms/modules/lslb$}    => \&list_lslb_controller;
        GET qr{^/farms/modules/dslb$}    => \&list_dslb_controller;

        GET qr{^/farms/($farm_re)$}         => \&get_farm_controller;
        GET qr{^/farms/($farm_re)/status$}  => \&get_farm_status_controller;
        GET qr{^/farms/($farm_re)/summary$} => \&get_farm_summary_controller;
    }

    if ($REQUEST_METHOD eq 'POST') {
        require Relianoid::HTTP::Controllers::API::Farm::Post;
        POST qr{^/farms$} => \&add_farm_controller;
    }

    if ($REQUEST_METHOD eq 'PUT') {
        require Relianoid::HTTP::Controllers::API::Farm::Put;
        PUT qr{^/farms/($farm_re)$} => \&modify_farm_controller;
    }

    if ($REQUEST_METHOD eq 'DELETE') {
        require Relianoid::HTTP::Controllers::API::Farm::Delete;
        DELETE qr{^/farms/($farm_re)$} => \&delete_farm_controller;
    }
}

# Network Interfaces
my $nic_re  = &getValidFormat('nic_interface');
my $bond_re = &getValidFormat('bond_interface');
my $vlan_re = &getValidFormat('vlan_interface');

if ($PATH_INFO =~ qr{^/interfaces/nic}) {
    require Relianoid::HTTP::Controllers::API::Interface::NIC;

    GET qr{^/interfaces/nic$}           => \&list_nic_controller;
    GET qr{^/interfaces/nic/($nic_re)$} => \&get_nic_controller;
    PUT qr{^/interfaces/nic/($nic_re)$} => \&modify_nic_controller;
    DELETE qr{^/interfaces/nic/($nic_re)$} => \&delete_nic_controller;
    POST qr{^/interfaces/nic/($nic_re)/actions$} => \&actions_nic_controller;
}

if ($PATH_INFO =~ qr{^/interfaces/vlan}) {
    require Relianoid::HTTP::Controllers::API::Interface::VLAN;

    GET qr{^/interfaces/vlan$} => \&list_vlan_controller;
    POST qr{^/interfaces/vlan$} => \&add_vlan_controller;
    GET qr{^/interfaces/vlan/($vlan_re)$} => \&get_vlan_controller;
    PUT qr{^/interfaces/vlan/($vlan_re)$} => \&modify_vlan_controller;
    DELETE qr{^/interfaces/vlan/($vlan_re)$} => \&delete_vlan_controller;
    POST qr{^/interfaces/vlan/($vlan_re)/actions$} => \&actions_vlan_controller;
}

if ($PATH_INFO =~ qr{^/interfaces/virtual}) {
    require Relianoid::HTTP::Controllers::API::Interface::Virtual;

    GET qr{^/interfaces/virtual$} => \&list_virtual_controller;
    POST qr{^/interfaces/virtual$} => \&add_virtual_controller;

    my $virtual_re = &getValidFormat('virt_interface');

    GET qr{^/interfaces/virtual/($virtual_re)$} => \&get_virtual_controller;
    PUT qr{^/interfaces/virtual/($virtual_re)$} => \&modify_virtual_controller;
    DELETE qr{^/interfaces/virtual/($virtual_re)$} => \&delete_virtual_controller;
    POST qr{^/interfaces/virtual/($virtual_re)/actions$} => \&actions_virtual_controller;
}

if ($PATH_INFO =~ qr{^/interfaces/gateway/ipv(?:[46])$}) {
    require Relianoid::HTTP::Controllers::API::Interface::Gateway;

    GET qr{^/interfaces/gateway/ipv([46])$} => \&get_gateway_controller;
    PUT qr{^/interfaces/gateway/ipv([46])$} => \&modify_gateway_controller;
    DELETE qr{^/interfaces/gateway/ipv([46])$} => \&delete_gateway_controller;
}

if ($PATH_INFO =~ qr{^/interfaces$}) {
    require Relianoid::HTTP::Controllers::API::Interface::Generic;

    GET qr{^/interfaces$} => \&list_interfaces_controller;
}

# Statistics
if ($PATH_INFO =~ qr{^/stats}) {
    require Relianoid::HTTP::Controllers::API::Stats;

    GET qr{^/stats$}                => \&get_stats_controller;
    GET qr{^/stats/system/network$} => \&get_stats_network_controller;

    GET qr{^/stats/farms$}                     => \&list_farms_stats_controller;
    GET qr{^/stats/farms/($farm_re)$}          => \&get_farm_stats_controller;
    GET qr{^/stats/farms/($farm_re)/backends$} => \&get_farm_stats_controller;

    # Fixed: make 'service' or 'services' valid requests for compatibility with previous bug.
    GET qr{^/stats/farms/($farm_re)/services?/($service_re)/backends$} => \&get_farm_stats_controller;
}

# Graphs
if ($PATH_INFO =~ qr{^/graphs}) {
    require Relianoid::HTTP::Controllers::API::Graph;

    my $frequency_re = &getValidFormat('graphs_frequency');
    my $rrd_re       = &getValidFormat('rrd_time');

    GET qr{^/graphs$} => \&list_graphs_controller;

    GET qr{^/graphs/system$} => \&list_sys_graphs_controller;

    GET qr{^/graphs/system/(cpu)$}  => \&get_sys_graphs_controller;
    GET qr{^/graphs/system/(load)$} => \&get_sys_graphs_controller;
    GET qr{^/graphs/system/(ram)$}  => \&get_sys_graphs_controller;
    GET qr{^/graphs/system/(swap)$} => \&get_sys_graphs_controller;

    GET qr{^/graphs/system/(cpu)/($frequency_re)$}  => \&get_sys_graphs_freq_controller;
    GET qr{^/graphs/system/(load)/($frequency_re)$} => \&get_sys_graphs_freq_controller;
    GET qr{^/graphs/system/(ram)/($frequency_re)$}  => \&get_sys_graphs_freq_controller;
    GET qr{^/graphs/system/(swap)/($frequency_re)$} => \&get_sys_graphs_freq_controller;

    GET qr{^/graphs/system/(cpu)/custom/start/($rrd_re)/end/($rrd_re)$}  => \&get_sys_graphs_interval_controller;
    GET qr{^/graphs/system/(load)/custom/start/($rrd_re)/end/($rrd_re)$} => \&get_sys_graphs_interval_controller;
    GET qr{^/graphs/system/(ram)/custom/start/($rrd_re)/end/($rrd_re)$}  => \&get_sys_graphs_interval_controller;
    GET qr{^/graphs/system/(swap)/custom/start/($rrd_re)/end/($rrd_re)$} => \&get_sys_graphs_interval_controller;

    # $disk_re includes 'root' at the beginning
    my $disk_re = &getValidFormat('mount_point');

    GET qr{^/graphs/system/disk$}                                                 => \&list_disks_graphs_controller;
    GET qr{^/graphs/system/disk/($disk_re)/custom/start/($rrd_re)/end/($rrd_re)$} => \&get_disk_graphs_interval_controller;
    GET qr{^/graphs/system/disk/($disk_re)/($frequency_re)$}                      => \&get_disk_graphs_freq_controller;
    GET qr{^/graphs/system/disk/($disk_re)$}                                      => \&get_disk_graphs_controller;

    GET qr{^/graphs/interfaces$}                                    => \&list_iface_graphs_controller;
    GET qr{^/graphs/interfaces/($nic_re|$vlan_re)$}                 => \&get_iface_graphs_controller;
    GET qr{^/graphs/interfaces/($nic_re|$vlan_re)/($frequency_re)$} => \&get_iface_graphs_frec_controller;
    GET qr{^/graphs/interfaces/($nic_re|$vlan_re)/custom/start/($rrd_re)/end/($rrd_re)$} =>
      \&get_iface_graphs_interval_controller;

    GET qr{^/graphs/farms$}                                                 => \&list_farm_graphs_controller;
    GET qr{^/graphs/farms/($farm_re)$}                                      => \&get_farm_graphs_controller;
    GET qr{^/graphs/farms/($farm_re)/($frequency_re)$}                      => \&get_farm_graphs_frec_controller;
    GET qr{^/graphs/farms/($farm_re)/custom/start/($rrd_re)/end/($rrd_re)$} => \&get_farm_graphs_interval_controller;
}

# System
if ($PATH_INFO =~ qr{^/system/dns}) {
    require Relianoid::HTTP::Controllers::API::System::Service::DNS;

    GET qr{^/system/dns$} => \&get_dns_controller;
    POST qr{^/system/dns$} => \&set_dns_controller;
}

if ($ENV{PATH_INFO} =~ qr{^/system/proxy}) {
    require Relianoid::HTTP::Controllers::API::System::Service::Proxy;

    GET qr{^/system/proxy$} => \&get_proxy_controller;
    POST qr{^/system/proxy$} => \&set_proxy_controller;
}

if ($PATH_INFO =~ qr{^/system/snmp}) {
    require Relianoid::HTTP::Controllers::API::System::Service::SNMP;

    GET qr{^/system/snmp$} => \&get_snmp_controller;
    POST qr{^/system/snmp$} => \&set_snmp_controller;
}

if ($PATH_INFO =~ qr{^/system/ntp}) {
    require Relianoid::HTTP::Controllers::API::System::Service::NTP;

    GET qr{^/system/ntp$} => \&get_ntp_controller;
    POST qr{^/system/ntp$} => \&set_ntp_controller;
}

if ($PATH_INFO =~ qr{^/system/users}) {
    require Relianoid::HTTP::Controllers::API::System::User;

    GET qr{^/system/users$} => \&get_system_user_controller;     #  GET users
    POST qr{^/system/users$} => \&set_system_user_controller;    #  POST users
}

if ($PATH_INFO =~ qr{^/system/log}) {
    require Relianoid::HTTP::Controllers::API::System::Log;

    GET qr{^/system/logs$} => \&list_logs_controller;

    my $logs_re = &getValidFormat('log');
    GET qr{^/system/logs/($logs_re)$} => \&download_logs_controller;

    GET qr{^/system/logs/($logs_re)/lines/(\d+)$} => \&show_logs_controller;
}

if ($PATH_INFO =~ qr{^/system/backup}) {
    require Relianoid::HTTP::Controllers::API::System::Backup;

    GET qr{^/system/backup$} => \&list_backups_controller;      #  GET list backups
    POST qr{^/system/backup$} => \&create_backup_controller;    #  POST create backups

    my $backup_re = &getValidFormat('backup');
    GET qr{^/system/backup/($backup_re)$} => \&download_backup_controller;          #  GET download backups
    PUT qr{^/system/backup/($backup_re)$} => \&upload_backup_controller;            #  PUT  upload backups
    DELETE qr{^/system/backup/($backup_re)$} => \&delete_backup_controller;         #  DELETE  backups
    POST qr{^/system/backup/($backup_re)/actions$} => \&restore_backup_controller;    #  POST  restore backups
}

if ($PATH_INFO =~ qr{^/system/(?:version|info|license|supportsave|language|packages)}) {
    require Relianoid::HTTP::Controllers::API::System::Info;

    GET qr{^/system/version$}     => \&get_version_controller;
    GET qr{^/system/info$}        => \&get_system_info_controller;
    GET qr{^/system/supportsave$} => \&get_supportsave_controller;

    my $license_re = &getValidFormat('license_format');
    GET qr{^/system/license/($license_re)$} => \&get_license_controller;

    GET qr{^/system/language$} => \&get_language_controller;
    POST qr{^/system/language$} => \&set_language_controller;

    GET qr{^/system/packages$} => \&get_packages_info_controller;
}

if ($PATH_INFO =~ qr{/ciphers$}) {
    require Relianoid::HTTP::Controllers::API::Certificate;

    GET qr{^/ciphers$} => \&get_ciphers_controller;
}

if ($PATH_INFO =~ qr{^/farms/$farm_re/(?:addheader|headremove|addresponseheader|removeresponseheader)(:?/\d+)?$}) {
    require Relianoid::HTTP::Controllers::API::Farm::HTTP;

    POST qr{^/farms/($farm_re)/addheader$} => \&add_addheader_controller;
    PUT qr{^/farms/($farm_re)/addheader/(\d+)$} => \&modify_addheader_controller;
    DELETE qr{^/farms/($farm_re)/addheader/(\d+)$} => \&del_addheader_controller;

    POST qr{^/farms/($farm_re)/headremove$} => \&add_headremove_controller;
    PUT qr{^/farms/($farm_re)/headremove/(\d+)$} => \&modify_headremove_controller;
    DELETE qr{^/farms/($farm_re)/headremove/(\d+)$} => \&del_headremove_controller;

    POST qr{^/farms/($farm_re)/addresponseheader$} => \&add_addResHeader_controller;
    PUT qr{^/farms/($farm_re)/addresponseheader/(\d+)$} => \&modify_addResHeader_controller;
    DELETE qr{^/farms/($farm_re)/addresponseheader/(\d+)$} => \&del_addResHeader_controller;
    POST qr{^/farms/($farm_re)/removeresponseheader$} => \&add_delResHeader_controller;
    PUT qr{^/farms/($farm_re)/removeresponseheader/(\d+)$} => \&modify_delResHeader_controller;
    DELETE qr{^/farms/($farm_re)/removeresponseheader/(\d+)$} => \&del_delResHeader_controller;
}

##### Load modules dynamically #######################################
my $routes_path = &getGlobalConfiguration('lib_dir') . '/API40/Routes';
opendir(my $dir, $routes_path);

for my $file (readdir $dir) {
    next if $file !~ /\w\.pm$/;

    my $module = "$routes_path/$file";

    unless (eval { require $module; }) {
        &log_debug2("Error loading module: $module", "SYSTEM");
        &log_error($@, "SYSTEM");
        die $@;
    }
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Arrays.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::Arrays

=cut

=pod

=head1 moveByIndex

This function moves an element of an list to another position using its index.
This funcion uses the original array to apply the changes, so it does not return anything.

Parameters:

    list - Array reference with the list to modify.
    ori_index - Index of the element will be moved.
    dst_index - Position in the list that the element will have.

Returns:

    None

=cut

sub moveByIndex ($list, $ori_index, $dst_index) {
    my $elem = $list->[$ori_index];

    # delete item
    splice(@{$list}, $ori_index, 1);

    # add item
    splice(@{$list}, $dst_index, 0, $elem);

    return;
}

=pod

=head1 getArrayIndex

Retuns the first index matching the value given, evaluated as a string.

Parameters:

    haystack - Array reference with the list to look for.
    needle   - Value to get its index

Returns:

    undef   - When the needle was not found
    integer - index of array with the first match found

=cut

sub getArrayIndex ($haystack, $needle) {
    my $found_index;
    my $current_index = 0;

    for my $element (@{$haystack}) {
        if ($element eq $needle) {
            $found_index = $current_index;
            last;
        }
        $current_index++;
    }

    return $found_index;
}

=pod

=head1 uniqueArray

It gets an array for reference and it removes the items that are repeated.
The original input array is modified. This function does not return anything

Parameters:

    Array ref - It is the array is going to be managed

Returns:

    None

=cut

sub uniqueArray ($arr) {
    my %hold = ();
    my @hold;

    for my $v (@{$arr}) {
        unless (exists $hold{$v}) {
            $hold{$v} = 1;
            push @hold, $v;
        }
    }

    @{$arr} = @hold;

    return;
}

=pod

=head1 getArrayCollision

It checks if two arrays have some value repeted.
The arrays have to contain scalar values.

Parameters:

    Array ref 1 - List of values 1
    Array ref 2 - List of values 2

Returns:

    scalar - It returns the first value which is contained in both arrays

=cut

sub getArrayCollision ($arr1, $arr2) {
    for my $it (sort @{$arr1}) {
        if (grep { $it eq $_ } @{$arr2}) {
            return $it;
        }
    }

    return;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Backup.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use File::stat;
use File::Basename;

=pod

=head1 Module

Relianoid::Backup

=cut

=pod

=head1 getBackup

List the backups in the system.

Parameters:

    none

Returns:

    scalar - Array reference.

=cut

sub getBackup () {
    my @backups;
    my $backupdir = &getGlobalConfiguration('backupdir');
    my $backup_re = &getValidFormat('backup');

    opendir(my $directory, $backupdir);
    my @files = grep { /^backup.*/ } readdir($directory);
    closedir($directory);

    for my $line (@files) {
        my $filepath = "$backupdir/$line";
        chomp($filepath);

        $line =~ s/backup-($backup_re).tar.gz/$1/;

        use Time::localtime qw(ctime);

        my $datetime_string = ctime(stat($filepath)->mtime);
        $datetime_string = &logAndGet("date -d \"${datetime_string}\" +%F\"  \"%T\" \"%Z -u");
        chomp($datetime_string);
        push @backups,
          {
            'name'    => $line,
            'date'    => $datetime_string,
            'version' => &getBackupVersion($line)
          };
    }

    return \@backups;
}

=pod

=head1 getExistsBackup

Check if there is a backup with the given name.

Parameters:

    name - Backup name.

Returns:

    1     - if the backup exists.
    undef - if the backup does not exist.

=cut

sub getExistsBackup ($name) {
    my $find;

    for my $backup (@{ &getBackup() }) {
        if ($backup->{name} =~ /^$name/,) {
            $find = 1;
            last;
        }
    }
    return $find;
}

=pod

=head1 createBackup

Creates a backup with the given name

Parameters:

    name - Backup name.

Returns:

    integer - ERRNO or return code of backup creation process.

=cut

sub createBackup ($name) {
    my $backup_cmd = &getGlobalConfiguration('backup_cmd');
    return &logAndRun("$backup_cmd $name -c");
}

=pod

=head1 getBackupFilename

Get a backup file name, not includin the directory.

Parameters:

    backup - Backup name.

Returns: string - Backup's absolute path.

=cut

sub getBackupFilename ($backup) {
    return "backup-${backup}.tar.gz";
}

=pod

=head1 uploadBackup 

Store an uploaded backup.

Parameters:

    filename          - Uploaded backup file name.
    upload_filehandle - File handle or file content.

Returns:

    2 - The file is not a .tar.gz
    1 - on failure.
    0 - on success.

=cut

sub uploadBackup ($filename, $upload_filehandle) {
    my $error;
    my $backupdir = &getGlobalConfiguration('backupdir');
    my $tar       = &getGlobalConfiguration('tar');

    $filename = "backup-$filename.tar.gz";
    my $filepath = "$backupdir/$filename";

    if (!-f $filepath) {
        open(my $disk_fh, '>', $filepath) or die "$!";

        binmode $disk_fh;

        use MIME::Base64 qw( decode_base64 );
        print $disk_fh decode_base64($upload_filehandle);

        close $disk_fh;
    }
    else {
        return 1;
    }

    # check the file, looking for the global.conf config file
    my $config_path = &getGlobalConfiguration('globalcfg');

    # remove the first slash
    $config_path =~ s/^\///;

    $error = &logAndRun("$tar -tf $filepath $config_path");
    if (! $error) {
        return $error;
    }

    $error = &logAndRun("$tar -tf $filepath usr/local/zevenet/config/global.conf");
    if (! $error) {
        &log_info("Enable backup migration to RELIANOID", 'backup');
        &logAndRun("ln -sf /usr/local/relianoid /usr/local/zevenet");
        return $error;
    }

    &log_error("$filename looks being a not valid backup", 'backup');
    unlink $filepath;
    return 2;
}

=pod

=head1 deleteBackup

Delete a backup.

Parameters:

    file - Backup name.

Returns:

    1     - on failure.
    undef - on success.

=cut

sub deleteBackup ($file) {
    $file = "backup-$file.tar.gz";
    my $backupdir = &getGlobalConfiguration("backupdir");
    my $filepath  = "$backupdir/$file";
    my $error;

    if (-e $filepath) {
        unlink($filepath);
        &log_info("Deleted backup file $file", "SYSTEM");
    }
    else {
        &log_warn("File $file not found", "SYSTEM");
        $error = 1;
    }

    return $error;
}

=pod

=head1 restoreBackup

Restore files from a backup.

Parameters:

    backup - Backup name.

Returns:

    integer - 0 on success or another value on failure.

=cut

sub restoreBackup ($backup) {
    my $error;
    my $tar               = &getGlobalConfiguration('tar');
    my $file              = &getGlobalConfiguration('backupdir') . "/backup-$backup.tar.gz";
    my $relianoid_service = &getGlobalConfiguration('relianoid_service');
    my $systemctl         = &getGlobalConfiguration('systemctl');

    # get current version
    my $pre_restore_version = &getGlobalConfiguration('version');

    &log_info("Stopping Relianoid service", "SYSTEM");
    $error = &logAndRun("$systemctl stop $relianoid_service");
    if ($error) {
        &log_error("Problem stopping Relianoid Load Balancer service", "SYSTEM");
        return $error;
    }

    &log_info("Restoring backup $file", "SYSTEM");
    my $cmd   = "$tar -xvzf $file -C /";
    my $eject = &logAndGet($cmd, 'array');

    if (not @{$eject}) {
        &log_error("The backup $file could not be extracted", "SYSTEM");
        return $error;
    }

    &log_info("unpacked files: @{$eject}", "SYSTEM");

    my $backup_version = &getGlobalConfiguration('version');

    # Reference: https://pmhahn.github.io/dpkg-compare-versions/
    # From lower to greater version: 1.0~rc1 < 1.0 < 1.0-noid1 < 1.0+noid1

    system("dpkg --compare-versions $backup_version lt $pre_restore_version");
    my $backup_is_previous = $?;

    # Flag migration if the backup version is previous to the current version
    if ($backup_is_previous) {
        my $migration_flag = &getGlobalConfiguration('migration_flag');

        if (open(my $fh, '>', $migration_flag)) {
            close($fh);

            if (-e $migration_flag) {
                &log_info("Migration Flag enabled");
            }
        }
        else {
            log_error("Failed to open file $migration_flag: $!");
        }
    }

    system("dpkg --compare-versions $backup_version ne $pre_restore_version");
    my $version_changed = $?;

    if ($version_changed) {
        &setGlobalConfiguration('version', $pre_restore_version);
    }

    unlink '/relianoid_version';

    $error = &logAndRun("$systemctl start $relianoid_service");

    if (!$error) {
        &log_info("Backup applied and Relianoid Load Balancer restarted...", "SYSTEM");
    }
    else {
        &log_error("Problem restarting Relianoid Load Balancer service", "SYSTEM");
    }

    return $error;
}

=pod

=head1 getBackupVersion

It gets the version of relianoid from which the backup was created

Parameters:

    backup - Backup name.

Returns:

    String - Relianoid version

=cut

sub getBackupVersion ($backup) {
    my $tar         = &getGlobalConfiguration('tar');
    my $file        = &getGlobalConfiguration('backupdir') . "/backup-$backup.tar.gz";
    my $config_path = &getGlobalConfiguration('globalcfg');

    # remove the first slash
    $config_path =~ s/^\///;

    my $cmd = "${tar} -xOf ${file} ${config_path}";
    log_debug("Running: $cmd");
    my @lines = `$cmd`;
    if ($?) {
        log_error("errno: $?");
        $cmd = "${tar} -xOf ${file} usr/local/zevenet/config/global.conf";
        log_debug("Running: $cmd");
        @lines = `$cmd`;
        if ($?) {
            log_error("errno: $?");
        }
    }

    my $version = "";

    for my $line (@lines) {
        if ($line =~ /^\s*\$version\s*=\s*(?:"(.*)"|\'(.*)\');(?:\s*#update)?\s*$/) {
            $version = $1;
            last;
        }
    }

    &log_debug3("Backup: $backup, version: $version", "system");

    return $version;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/CGI.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

=pod

=head1 Module

Relianoid::CGI

=cut

use strict;
use warnings;
use feature qw(signatures state);
use CGI::Simple;

$CGI::Simple::DISABLE_UPLOADS = 0;                # enable uploads
$CGI::Simple::POST_MAX        = 1_048_576_000;    # allow 1000MB uploads

=pod

=head1 getCGI

Get a L<CGI::Simple> object. The object is reused if called more than once in the request.

Parameters: None

Returns: L<CGI::Simple> object

=cut

sub getCGI () {
    state $cgi = CGI::Simple->new();
    return $cgi;
}

=pod

=head1 getCgiParam

Get CGI variables. This functions can be used in two diferent ways:

1. When a variable name is passed as an argument, the variable value is returned:

    &getCgiParam(variableName);

2. When no arguments are passed, a hash reference with all the variables is returned:

    $hash_ref = &getCgiParam();
    $hash_ref->{variableName};

Parameters:

    param - string - Optional. CGI variable name.

Returns:

- When a variable name has been passed as an argument:

    &getCgiParam( 'variableName' );

  - If the variable is found: string - Variable value.
  - If the variable is not found: undefined

- When the function is run without arguments:

    &getCgiParam();

    hash reference - With all the CGI variables.

=cut

sub getCgiParam ($param = undef) {
    my $cgi = getCGI();

    return eval { $cgi->param($param) } if $param;
    return $cgi->Vars;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Certificate.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use File::stat;

use Relianoid::Core;
use Relianoid::Config;

my $openssl = &getGlobalConfiguration('openssl');

=pod

=head1 Module

Relianoid::Certificate

- Privacy-Enhanced Mail (PEM)
- Certificate Signing Request (CSR)

=cut

=pod

=head1 getCertFiles

Returns a list of all .pem and .csr certificate files in the config directory.

Parameters:

    none

Returns:

    list - certificate files in config/ directory.

=cut

sub getCertFiles () {
    my $configdir = &getGlobalConfiguration('certdir');
    my $dir;

    opendir($dir, $configdir);
    my @files = grep { /.*\.pem$/ } readdir($dir);
    @files = grep { !/_dh\d+\.pem$/ } @files;
    closedir($dir);

    opendir($dir, $configdir);
    push(@files, grep { /.*\.csr$/ } readdir($dir));
    closedir($dir);

    return @files;
}

=pod

=head1 getPemCertFiles

Returns a list of only .pem certificate files in the config directory.

Parameters:

    none

Returns:

    list - certificate files in config/ directory.

=cut

sub getPemCertFiles () {
    my $configdir = &getGlobalConfiguration('certdir');

    opendir(my $dir, $configdir);
    my @files = grep { /.*\.pem$/ } readdir($dir);
    @files = grep { !/_dh\d+\.pem$/ } @files;
    closedir($dir);

    return @files;
}

=pod

=head1 getCertType

Return the type of a certificate filename.

The certificate types are:

    Certificate - For .pem or .crt certificates
    CSR         - For .csr certificates
    none        - for any other file or certificate

Parameters:

    String - Certificate filename.

Returns:

    String - Certificate type.

=cut

sub getCertType ($certfile) {
    my $certtype = "none";

    if ($certfile =~ /\.pem/ || $certfile =~ /\.crt/) {
        $certtype = "Certificate";
    }
    elsif ($certfile =~ /\.csr/) {
        $certtype = "CSR";
    }

    return $certtype;
}

=pod

=head1 getCertExpiration

Return the expiration date of a certificate file

Parameters:

    String - Certificate filename.

Returns:

    String - Expiration date.

=cut

sub getCertExpiration ($certfile) {
    my $expiration_date = "";

    if (&getCertType($certfile) eq "Certificate") {
        my @eject  = `$openssl x509 -noout -in $certfile -dates`;
        my @dateto = split(/=/, $eject[1]);
        $expiration_date = $dateto[1];
    }
    else {
        $expiration_date = "NA";
    }

    return $expiration_date;
}

=pod

=head1 getFarmCertUsed

Get if a certificate file is being used by an HTTP farm

Parameters:

    String - Certificate filename.

Returns:

    Integer - 0 if the certificate is being used, or -1 if it is not.

=cut

sub getFarmCertUsed ($cfile) {
    require Relianoid::File;
    require Relianoid::Farm::Core;

    my $certdir   = &getGlobalConfiguration('certdir');
    my $configdir = &getGlobalConfiguration('configdir');
    my @farms     = &getFarmsByType("https");
    my $output    = -1;

    for my $fname (@farms) {
        my $farm_filename = &getFarmFile($fname);

        if (grep { /Cert \"$certdir\/\Q$cfile\E\"/ } readFileAsArray("$configdir/$farm_filename")) {
            $output = 0;
        }
    }

    return $output;
}

=pod

=head1 getCertFarmsUsed

Get HTTPS Farms list using the certificate file. 

Parameters:

    String - Certificate filename.

Returns:

    Array ref - Farm list using the certificate.

=cut

sub getCertFarmsUsed ($cfile) {
    require Relianoid::File;
    require Relianoid::Farm::Core;

    my $certdir   = &getGlobalConfiguration('certdir');
    my $configdir = &getGlobalConfiguration('configdir');
    my @farms     = &getFarmsByType("https");
    my $farms_ref = [];

    for my $farm_name (@farms) {
        my $farm_filename = &getFarmFile($farm_name);

        if (grep { /Cert \"$certdir\/\Q$cfile\E\"/ } readFileAsArray("$configdir/$farm_filename")) {
            push @{$farms_ref}, $farm_name;
        }
    }

    return $farms_ref;
}

=pod

=head1 checkFQDN

Check if a FQDN is valid

Parameters:

    certfqdn - FQDN.

Returns:

    String - Boolean 'true' or 'false'.

=cut

sub checkFQDN ($certfqdn) {
    my $valid = "true";

    if ($certfqdn =~ /^http:/) {
        $valid = "false";
    }
    if ($certfqdn =~ /^\./) {
        $valid = "false";
    }
    if ($certfqdn =~ /\.$/) {
        $valid = "false";
    }
    if ($certfqdn =~ /\//) {
        $valid = "false";
    }

    return $valid;
}

=pod

=head1 delCert

Removes a certificate file

Parameters:

    String - Certificate filename.

Returns:

    Integer - Number of files removed.

Bugs:

    Removes the _first_ file found _starting_ with the given certificate name.

=cut

sub delCert ($certname) {
    my $certdir = &getGlobalConfiguration('certdir');

    # escaping special caracters
    $certname =~ s/ /\ /g;

    my $files_removed;

    # verify existance in config directory for security reasons
    if (-f "$certdir/$certname") {
        $files_removed = unlink("$certdir/$certname");

        my $key_file = $certname;
        $key_file =~ s/\.pem$/\.key/;

        if (-f "$certdir/$key_file") {
            unlink("$certdir/$key_file");
        }

        # remove key file for CSR
        if ($certname =~ /.csr$/) {
            my $key_file = $certname;
            $key_file =~ s/\.csr$/\.key/;

            if (-f "$certdir/$key_file") {
                unlink "$certdir/$key_file";
            }
            else {
                &log_error("Key file was not found '$certdir/$key_file'", "LSLB");
            }
        }
    }

    &log_error("Error removing certificate '$certdir/$certname'", "LSLB")
      if !$files_removed;

    return $files_removed;
}

=pod

=head1 createCSR

Create a CSR file.

If the function run correctly two files will appear in the config/ directory:

certname.key and certname.csr.

Parameters:

    certname     - Certificate name, part of the certificate filename without the extension.
    certfqdn     - FQDN.
    certcountry  - Country.
    certstate    - State.
    certlocality - Locality.
    certorganization - Organization.
    certdivision - Division.
    certmail     - E-Mail.
    certkey      - Key. ?
    certpassword - Password. Optional.

Returns:

    Integer - Return code of openssl generating the CSR file..

=cut

sub createCSR ($name, $fqdn, $country, $state, $locality, $organization, $division, $mail, $key, $password) {
    my $configdir = &getGlobalConfiguration('certdir');
    my $output;

    my $subdomains = '';

    my @alternatives = split(/,/, $fqdn);
    my $cn_found     = 0;

    for my $dns (@alternatives) {
        next if $dns =~ /^\s*$/;
        if (not $cn_found) {
            $fqdn     = $dns;
            $cn_found = 1;
        }
        $subdomains .= "DNS:$dns,";
    }

    chop($subdomains);
    $subdomains = "-addext \"subjectAltName = $subdomains\"";

    return 1 if not $cn_found;

    ##sustituir los espacios por guiones bajos en el nombre de archivo###
    if ($password eq "") {
        $output =
          &logAndRun(
            "$openssl req -nodes -newkey rsa:$key -keyout $configdir/$name.key $subdomains -out $configdir/$name.csr -batch -subj \"/C=$country\/ST=$state/L=$locality/O=$organization/OU=$division/CN=$fqdn/emailAddress=$mail\"  2> /dev/null"
          );
        &log_info(
            "Creating CSR: $openssl req -nodes -newkey rsa:$key -keyout $configdir/$name.key $subdomains -out $configdir/$name.csr -batch -subj \"/C=$country\/ST=$state/L=$locality/O=$organization/OU=$division/CN=$fqdn/emailAddress=$mail\"",
            "LSLB"
        ) if (not $output);
    }
    else {
        $output =
          &logAndRun(
            "$openssl req -passout pass:$password -newkey rsa:$key -keyout $configdir/$name.key $subdomains -out $configdir/$name.csr $configdir/openssl.cnf -batch -subj \"/C=$country/ST=$state/L=$locality/O=$organization/OU=$division/CN=$fqdn/emailAddress=$mail\""
          );
        &log_info(
            "Creating CSR: $openssl req -passout pass:$password -newkey rsa:$key -keyout $configdir/$name.key $subdomains -out $configdir/$name.csr $configdir/openssl.cnf -batch -subj \"/C=$country\/ST=$state/L=$locality/O=$organization/OU=$division/CN=$fqdn/emailAddress=$mail\"",
            "LSLB"
        ) if (not $output);
    }
    return $output;
}

=pod

=head1 getCertData

Returns the information stored in a certificate.

Parameters:

    String - Certificate path.
    String - "true" for checking the Certificate.

Returns:

    string - It returns a string with the certificate content. It contains new line characters.

=cut

sub getCertData ($filepath, $check = undef) {
    my $cmd;
    my $filepath_orig = $filepath;
    $filepath = quotemeta($filepath);

    if (&getCertType($filepath) eq "Certificate") {
        $cmd = "$openssl x509 -in $filepath -text";
    }
    else {
        $cmd = "$openssl req -in $filepath -text";

        # request Certs do not need to be checked
        $check = 0;
    }

    my $cert = &logAndGet($cmd);
    $cert = $cert eq "" ? "This certificate is not valid." : $cert;
    if ($check) {
        my $status = checkCertPEMValid($filepath_orig);
        if ($status and $status->{code}) {
            $cert = $status->{desc};
        }
    }

    return $cert;
}

=pod

=head1 getCertInfo

It returns an object with the certificate information parsed

Parameters:

    certificate path - path to the certificate

Returns:

    hash ref - The hash contains the following keys:

    file:       name of the certificate with extension and without path. "zert.pem"
    type:       type of file. CSR or Certificate
    CN:         common name
    issuer:     name of the certificate authority
    creation:   date of certificate creation. "019-08-13 09:31:33 UTC"
    expiration: date of certificate expiration. "2020-07-11 09:31:33 UTC"
    status:     status of the certificate. 'unknown' if the file is not recognized as a certificate, 'expired' if the certificate is expired, 'about to expire' if the expiration date is in less than 15 days, 'valid' the expiration date is greater than 15 days, 'invalid' if the file is a not valid certificate

=cut

sub getCertInfo ($filepath) {
    my %response;

    my $certfile = "";
    if ($filepath =~ /([^\/]+)$/) {
        $certfile = $1;
    }

    # PEM
    if ($certfile =~ /\.pem$/) {
        require Crypt::OpenSSL::X509;
        my $status = "unknown";
        my $CN     = "no CN";
        my $ISSUER = "no issuer";
        my $x509;
        eval {
            $x509 = Crypt::OpenSSL::X509->new_from_file($filepath);

            my $time_offset = 60 * 60 * 24 * 15;    # 15 days
            if ($x509->checkend(0)) { $status = 'expired' }
            else {
                $status = ($x509->checkend($time_offset)) ? 'about to expire' : 'valid';
            }

            if (defined $x509->subject_name()->get_entry_by_type('CN')) {
                $CN = $x509->subject_name()->get_entry_by_type('CN')->value;
            }
            if (defined $x509->issuer_name()->get_entry_by_type('CN')) {
                $ISSUER = $x509->issuer_name()->get_entry_by_type('CN')->value;
            }
        };
        if ($@) {
            %response = (
                file       => $certfile,
                type       => 'Certificate',
                CN         => '-',
                issuer     => '-',
                creation   => '-',
                expiration => '-',
                status     => $status,
            );
        }
        else {
            $status   = "invalid" if (&checkCertPEMValid($filepath)->{code});
            %response = (
                file       => $certfile,
                type       => 'Certificate',
                CN         => $CN,
                issuer     => $ISSUER,
                creation   => $x509->notBefore(),
                expiration => $x509->notAfter(),
                status     => $status,
            );
        }
    }

    # CSR
    else {
        require Relianoid::File;

        my @cert_data = @{ &logAndGet("$openssl req -in $filepath -text -noout", "array") };

        my $cn = "";
        my ($string) = grep { /\sSubject: / } @cert_data;
        if ($string =~ /CN ?= ?([^,]+)/) {
            $cn = $1;
        }

        %response = (
            file       => $certfile,
            type       => 'CSR',
            CN         => $cn,
            issuer     => "NA",
            creation   => &getFileDateGmt($filepath),
            expiration => "NA",
            status     => 'valid',
        );
    }

    return \%response;
}

=pod

=head1 getDateEpoc

It converts a human date (2018-05-17 15:04:52 UTC) in a epoc date (1594459893)

Parameters:

    date - string with the date. The string has to be as "2018-05-17 15:04:52"

Returns:

    Integer - Time in epoc time. "1594459893"

=cut

sub getDateEpoc ($date_string) {
    # my @months      = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);

    my ($year, $month, $day, $hours, $min, $sec) = split /[ :-]+/, $date_string;

    return 0 if (! defined $year || ! defined $month || ! defined $day || ! defined $hours || ! defined $min || !defined $sec);

    # the range of the month is from 0 to 11
    $month-- if ($month > 0);

    require Time::Local;
    return Time::Local::timegm($sec, $min, $hours, $day, $month, $year);
}

=pod

=head1 getCertDaysToExpire

It calculates the number of days to expire the certificate.

Parameters:

    ending date - String with the ending date with the following format "2018-05-17 15:04:52 UTC"

Returns:

    Integer - Number of days to expire the certificate

=cut

sub getCertDaysToExpire ($cert_ends) {
    my $end       = &getDateEpoc($cert_ends);
    return 0 if ($end == 0);
    my $days_left = ($end - time()) / 86400;

    # leave only two decimals
    if ($days_left < 1) {
        $days_left *= 100;
        $days_left =~ s/\..*//g;
        $days_left /= 100;
    }
    else {
        $days_left =~ s/\..*//g;
    }

    return $days_left;
}

=pod

=head1 getCertPEM

It returns an object with all certificates: key, fullchain

Parameters:

    cert_path - path to the certificate

Returns:

    hash ref - List of certificates : key, fullchain

=cut

sub getCertPEM ($cert_path) {
    my $pem_config;

    if (-T $cert_path) {
        require Tie::File;
        use Fcntl 'O_RDONLY';

        tie my @cert_file, 'Tie::File', "$cert_path", mode => O_RDONLY;

        my $key_boundary         = 0;
        my $certificate_boundary = 0;
        my $cert;

        for (@cert_file) {
            if ($_ =~ /^-+BEGIN.*KEY-+/) {
                $key_boundary = 1;
            }
            if ($_ =~ /^-+BEGIN.*CERTIFICATE-+/) {
                $certificate_boundary = 1;
            }
            if ($key_boundary) {
                push @{ $pem_config->{key} }, $_;
            }
            if ($certificate_boundary) {
                push @{$cert}, $_;
            }
            if (($_ =~ /^-+END.*KEY-+/) and ($key_boundary)) {
                $key_boundary = 0;
                next;
            }
            if (($_ =~ /^-+END.*CERTIFICATE-+/) and ($certificate_boundary)) {
                push @{ $pem_config->{fullchain} }, $cert;
                $certificate_boundary = 0;
                $cert                 = undef;
                next;
            }
        }
    }

    return $pem_config;
}

=pod

=head1 checkCertPEMKeyEncrypted

Checks if a certificate private key in PEM format is encrypted.

Parameters:

    cert_path - path to the certificate

Returns:

    Integer - 0 if it is not encrypted, 1 if encrypted, -1 on error.

=cut

sub checkCertPEMKeyEncrypted ($cert_path) {
    my $rc         = -1;
    my $pem_config = &getCertPEM($cert_path);

    if (($pem_config) and ($pem_config->{key})) {
        use Net::SSLeay;
        $Net::SSLeay::trace = 1;

        $rc = 0;
        my $bio_key = Net::SSLeay::BIO_new_file($cert_path, 'r');

        # Loads PEM formatted private key via given BIO structure using empty password
        unless (Net::SSLeay::PEM_read_bio_PrivateKey($bio_key, undef, "")) {
            my $error     = Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
            my @strerr    = split(/:/, $error);
            my $error_str = $strerr[4];
            if ($error_str eq "bad decrypt") {
                &log_debug("Private Key Encrypted was found in '$cert_path': " . $strerr[4], "LSLB");
                $rc = 1;
            }
            else {
                &log_debug("Error checking Private Key Encrypted in '$cert_path': " . $strerr[4], "LSLB");
                $rc = -1;
            }
        }
        Net::SSLeay::BIO_free($bio_key);
    }

    return $rc;
}

=pod

=head1 checkCertPEMValid

Checks if a certificate is in PEM format and has a valid structure.
The certificates must be in PEM format and must be sorted starting with the subject's certificate (actual client or server certificate), followed by intermediate CA certificates if applicable, and ending at the highest level (root) CA. The Private key has to be unencrypted.

Parameters:

    cert_path - path to the certificate

Returns: hash reference

Error object.

    code - integer - Error code. 0 if the PEM file is valid.
    desc - string - Description of the error.

=cut

sub checkCertPEMValid ($cert_path) {
    use Net::SSLeay;
    $Net::SSLeay::trace = 1;

    my $error_ref->{code} = 0;
    my $ctx = Net::SSLeay::CTX_new_with_method(Net::SSLeay::SSLv23_method());

    if (!$ctx) {
        my $error_msg = "Error check PEM certificate";
        $error_ref->{code} = -1;
        $error_ref->{desc} = $error_msg;
        my $error     = Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
        my @strerr    = split(/:/, $error);
        my $error_str = $strerr[4];
        &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
        return $error_ref;
    }

    if (&checkCertPEMKeyEncrypted($cert_path) == 1) {
        Net::SSLeay::CTX_free($ctx);
        my $error_msg = "PEM file private key is encrypted";
        $error_ref->{code} = 1;
        $error_ref->{desc} = $error_msg;
        &log_debug("$error_msg in '$cert_path'", "LSLB");
        return $error_ref;
    }

    unless (Net::SSLeay::CTX_use_certificate_chain_file($ctx, "$cert_path")) {
        my $error  = Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
        my @strerr = split(/:/, $error);
        Net::SSLeay::CTX_free($ctx);
        my $error_str = $strerr[4];
        if ($error_str eq "no start line") {
            my $error_msg = "No Certificate found";
            $error_ref->{code} = 2;
            $error_ref->{desc} = $error_msg;
            &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
            return $error_ref;
        }
        elsif ($error_str eq "ca md too weak") {
            my $error_msg = "Cipher weak found";
            $error_ref->{code} = 3;
            $error_ref->{desc} = $error_msg;
            &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
            return $error_ref;
        }
        else {
            my $error_msg = "Error using Certificate";
            $error_ref->{code} = 4;
            $error_ref->{desc} = $error_msg;
            &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
            return $error_ref;
        }
    }

    unless (Net::SSLeay::CTX_use_PrivateKey_file($ctx, "$cert_path", Net::SSLeay::FILETYPE_PEM())) {
        my $error  = Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
        my @strerr = split(/:/, $error);
        Net::SSLeay::CTX_free($ctx);
        my $error_str = $strerr[4];
        if ($error_str eq "no start line") {
            my $error_msg = "No Private Key found";
            $error_ref->{code} = 5;
            $error_ref->{desc} = $error_msg;
            &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
            return $error_ref;
        }
        elsif ($error_str eq "key values mismatch") {
            my $error_msg = "Private Key is not valid for the first Certificate found";
            $error_ref->{code} = 6;
            $error_ref->{desc} = $error_msg;
            &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
            return $error_ref;
        }
        else {
            my $error_msg = "Error using Private Key";
            $error_ref->{code} = 7;
            $error_ref->{desc} = $error_msg;
            &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
            return $error_ref;
        }
    }

    unless (Net::SSLeay::CTX_check_private_key($ctx)) {
        my $error = Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
        Net::SSLeay::CTX_free($ctx);
        my @strerr    = split(/:/, $error);
        my $error_str = $strerr[4];
        my $error_msg = "Error checking Private Key";
        $error_ref->{code} = 8;
        $error_ref->{desc} = $error_msg;
        &log_debug("$error_msg in '$cert_path': " . $error_str, "LSLB");
        return $error_ref;
    }

    Net::SSLeay::CTX_free($ctx);
    return $error_ref;
}

=pod

=head1 createPEM

Create a valid PEM file.

Parameters:

    certname - Certificate name, part of the certificate filename without the extension.
    key      - String. Private Key.
    ca       - String. CA Certificate or fullchain certificates.
    intermediates - CA Intermediates Certificates.

Returns: hash reference

Error object.

    code - integer - Error code. 0 if the PEM file is created.
    desc - string - Description of the error.

=cut

sub createPEM ($cert_name, $cert_key, $cert_ca, $cert_intermediates) {
    my $error_ref->{code} = 0;

    if (not $cert_name or not $cert_key or not $cert_ca) {
        my $error_msg = "A required parameter is missing";
        $error_ref->{code} = 1;
        $error_ref->{desc} = $error_msg;
        return $error_ref;
    }

    # check certificate exists
    my $configdir = &getGlobalConfiguration('certdir');
    my $cert_file = $configdir . "/" . $cert_name . ".pem";

    if (-T $cert_file) {
        my $error_msg = "Certificate already exists";
        $error_ref->{code} = 2;
        $error_ref->{desc} = $error_msg;
        return $error_ref;
    }

    # create temp certificate
    my $tmp_cert  = "/tmp/cert_$cert_name.tmp";
    my $lock_file = &getLockFile($tmp_cert);
    my $lock_fh   = &openlock($lock_file, 'w');
    my $fh        = &openlock($tmp_cert,  'w');
    print $fh $cert_key . "\n";
    print $fh $cert_ca . "\n";
    print $fh $cert_intermediates . "\n" if (defined $cert_intermediates);
    close $fh;

    unless (-T $tmp_cert) {
        close $lock_fh;
        my $error_msg = "Error creating Temp Certificate File";
        $error_ref->{code} = 3;
        $error_ref->{desc} = $error_msg;
        return $error_ref;
    }

    # check temp certificate
    my $cert_conf = &getCertPEM($tmp_cert);
    if (!$cert_conf->{key}) {
        unlink $tmp_cert;
        close $lock_fh;
        my $error_msg = "No Private Key in PEM format found";
        $error_ref->{code} = 4;
        $error_ref->{desc} = $error_msg;
        return $error_ref;
    }
    if (!$cert_conf->{fullchain}) {
        unlink $tmp_cert;
        close $lock_fh;
        my $error_msg = "No Certificate in PEM format found";
        $error_ref->{code} = 4;
        $error_ref->{desc} = $error_msg;
        return $error_ref;
    }

    my $error = &checkCertPEMValid($tmp_cert);
    if ($error->{code}) {
        unlink $tmp_cert;
        close $lock_fh;
        $error_ref->{code} = 5;
        $error_ref->{desc} = $error->{desc} . " in generated PEM";
        return $error_ref;
    }

    # copy temp certificate
    if (&copyLock($tmp_cert, $cert_file)) {
        unlink $tmp_cert;
        close $lock_fh;
        my $error_msg = "Error creating Certificate File";
        $error_ref->{code} = 5;
        $error_ref->{desc} = $error_msg;
        return $error_ref;
    }

    unlink $tmp_cert;
    close $lock_fh;
    return $error_ref;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Config.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(say signatures state);

use Relianoid::Log;

=pod

=head1 Module

Relianoid::Config

=cut

=pod

=head1 getGlobalConfiguration

Get the value of a configuration variable. The global.conf is parsed only the first time

Parameters:

    parameter - Name of the global configuration variable. Optional.
    Force_relad - This parameter is a flag that force a reload of the global.conf structure, useful to reload the struct when it has been modified. Optional

Returns:

    scalar - Value of the configuration variable when a variable name is passed as an argument.
    scalar - Hash reference to all global configuration variables when no argument is passed.

See Also:

    Widely used.

=cut

sub getGlobalConfiguration ($parameter, $force_reload = 0) {
    state $global_conf = &parseGlobalConfiguration();

    if ($force_reload) {
        $global_conf = &parseGlobalConfiguration();
    }

    if ($parameter) {
        if (defined $global_conf->{$parameter}) {
            return $global_conf->{$parameter};
        }
        elsif ($parameter eq 'debug') {
            # workaround: no message is logged when the 'debug' parameter is not defined in global.conf.
            return;
        }
        else {
            &log_warn("The global configuration parameter '$parameter' has not been found", 'Configuration');

            return;
        }
    }

    return $global_conf;
}

=pod

=head1 parseGlobalConfiguration

Parse the global.conf file. It expands the variables too.

Parameters:

    none

Returns:

    scalar - Hash reference to all global configuration variables when no argument is passed.

See Also:

    Widely used.

=cut

sub parseGlobalConfiguration () {
    my $global_conf_filepath = "/usr/local/relianoid/config/global.conf";
    my $global_conf;

    if (open(my $global_conf_file, '<', $global_conf_filepath)) {
        my @lines = <$global_conf_file>;
        close $global_conf_file;

        # build globalconf struct
        for my $conf_line (@lines) {
            # extract variable name and value
            if ($conf_line =~ /^\s*\$(\w+)\s*=\s*(?:"(.*)"|\'(.*)\');(?:\s*#update)?\s*$/) {
                $global_conf->{$1} = $2;
            }
        }
    }
    else {
        my $msg = "Could not open $global_conf_filepath: $!";
        &log_error($msg, "SYSTEM");
        die $msg;
    }

    # expand the variables, by replacing every variable used in the $var_value by its content
    for my $param (keys %{$global_conf}) {
        while ($global_conf->{$param} =~ /\$(\w+)/) {
            my $var   = $1;
            my $value = $global_conf->{$var} // '';
            $global_conf->{$param} =~ s/\$$var/$value/;
        }
    }

    return $global_conf;
}

=pod

=head1 setGlobalConfiguration

Set a value to a configuration variable

Parameters:

    param - Configuration variable name.
    value - New value to be set on the configuration variable.

Returns:

    scalar - 0 on success, or -1 if the variable was not found.

FIXME:

- Receive a hash, to be able to set a list of settings
- Control file handling errors.

See Also:

    API v4: <set_ntp>

=cut

sub setGlobalConfiguration ($param, $value) {
    my $global_conf_file = &getGlobalConfiguration('globalcfg');
    my $output           = -1;

    use Fcntl qw(:flock);

    if (open(my $fh, '+<', $global_conf_file)) {    ## no critic (InputOutput::RequireBriefOpen)
        flock($fh, LOCK_EX) or die "Cannot lock file ${global_conf_file}: $!\n";
        my @lines = <$fh>;

        for my $line (@lines) {
            if ($line =~ /^\$$param\s*=/) {
                $line   = "\$${param}=\"${value}\";\n";
                $output = 0;
                last;
            }
        }

        seek $fh, 0, 0;
        truncate $fh, 0;    # reduce file size to 0
        print {$fh} join("", @lines);
        close $fh;
    }
    else {
        log_error("Could not open file ${global_conf_file}: $!");
    }

    # reload global.conf struct
    &getGlobalConfiguration(undef, 1);

    return $output;
}

=pod

=head1 setConfigStr2Arr

Put a list of string parameters as array references

Parameters:

    object - reference to a hash
    parameters - list of parameters to change from string to array

Returns:

    hash ref - Object updated

=cut

sub setConfigStr2Arr ($obj, $param_list) {
    for my $param_name (@{$param_list}) {
        my @list = ();

        # split parameter if it is not a blank string
        @list = sort split(' ', $obj->{$param_name})
          if ($obj->{$param_name});
        $obj->{$param_name} = \@list;
    }

    return $obj;
}

=pod

=head1 getTinyObj

Get a Config::Tiny object from a file name.
This function has 3 behaviors:

it can returns all parameters from all groups
or it can returns all parameters from a group
or it can returns only selected parameters.
selected parameters can be ignored,undef or error if they do not exists

Parameters:

    file_path - Path to file.
    section - Group to get. Empty means all groups.
    key_ref - Array of parameters to get. Empty means all parameters
    key_action - string define the action. Possible values are "ignored|undef|error".Empty means error.

Returns:

    hash ref - a reference to Config::Tiny object when success, undef on failure.

=cut

sub getTinyObj ($filepath, $section = undef, $key_ref = undef, $key_action = "error") {
    if (!-f "$filepath") {
        return;
    }
    require Config::Tiny;
    my $conf = Config::Tiny->read($filepath);
    if (not defined $conf) {
        return;
    }

    if (not defined $section) {
        return $conf;
    }

    if (not exists $conf->{$section}) {
        return;
    }

    if (not defined $key_ref) {
        return $conf->{$section};
    }

    if (ref $key_ref ne 'ARRAY') {
        return;
    }

    my $filtered_conf = {};
    $conf = $conf->{$section};
    for my $param (@{$key_ref}) {
        if (defined $conf->{$param}) {
            $filtered_conf->{$param} = $conf->{$param};
        }
        else {
            if ($key_action eq "error") {
                return;
            }

            if ($key_action eq "undef") {
                $filtered_conf->{$param} = undef;
            }
        }
    }

    return $filtered_conf;
}

=pod

=head1 setTinyObj

Save a change in a config file. The file is locker before than applying the changes
This function has 2 behaviors:

it can receives a hash ref to save a struct
or it can receive a key and parameter to replace a value

Parameters:

    path   - Tiny conguration file where to apply the change
    object - Group to apply the change
    key    - parameter to change or struct ref to overwrite.
    value  - new value for the parameter or action for struct ref. The possible action values are: "update" to update only existing params , "new" to delete old params and set news ones or empty to add all new params. 
    action - This is a optional parameter. The possible values are: "add" to add
             a item to a list, or "del" to delete a item from a list, or "remove" to delete the key

Returns:

    Integer - Error code: 0 on success or other value on failure

=cut

sub setTinyObj ($path, $object = undef, $key = undef, $value = undef, $action = undef) {
    unless ($object) {
        &log_info("Object not defined trying to save it in file $path");
        return;
    }

    &log_debug2("Modify $object from $path");

    require Relianoid::Lock;
    require Config::Tiny;
    require Relianoid::File;

    my $lock_file = &getLockFile($path);
    my $lock_fd   = &openlock($lock_file, 'w');

    my $fileHandle;
    if (!-f "$path") {
        createFile($path);
        $fileHandle = Config::Tiny->new;
    }
    else {
        $fileHandle = Config::Tiny->read($path);
    }

    unless ($fileHandle) {
        &log_info("Could not open file $path: " . Config::Tiny::errstr());
        return -1;
    }

    # save all struct
    if (ref $key) {
        if ((defined $value) and ($value eq "new")) {
            $fileHandle->{$object} = {};
        }
        for my $param (keys %{$key}) {
            if (ref $key->{$param} eq 'ARRAY') {
                $key->{$param} = join(' ', @{ $key->{$param} });
            }
            next
              if (  (!exists $fileHandle->{$object}{$param})
                and ((defined $value) and ($value eq "update")));

            $fileHandle->{$object}{$param} = $key->{$param};
        }
    }

    # save a parameter
    else {
        if ($action and 'add' eq $action) {
            $fileHandle->{$object}{$key} .= " $value";
        }
        elsif ($action and 'del' eq $action) {
            $fileHandle->{$object}{$key} =~ s/(^| )$value( |$)/ /;
        }
        elsif ($action and 'remove' eq $action) {
            delete $fileHandle->{$object}{$key};
        }
        else {
            $fileHandle->{$object}{$key} = $value;
        }
    }

    my $success = $fileHandle->write($path);
    close $lock_fd;
    unlink $lock_file;

    return ($success) ? 0 : 1;
}

=pod

=head1 delTinyObj

It deletes a object of a tiny file. The tiny file is locked before than set the configuration

Parameters:

    object - Group name
    path   - Tiny file where the object will be deleted

Returns:

    Integer -  Error code: 0 on success or other value on failure

=cut

sub delTinyObj ($path, $object) {
    &log_debug2("Delete $object from $path");

    require Relianoid::Lock;

    my $lock_file = &getLockFile($path);
    my $lock_fd   = &openlock($lock_file, 'w');

    my $fileHandle = Config::Tiny->read($path);
    delete $fileHandle->{$object};
    my $error = $fileHandle->write($path);

    close $lock_fd;
    unlink $lock_file;

    return $error;
}

=pod

=head1 migrateConfigFiles

Apply all migrating scripts to relianoid

Parameters:

    none

Returns:

    none

=cut

sub migrateConfigFiles () {
    my $mig_dir = &getGlobalConfiguration('mig_dir');

    opendir(my $dh, $mig_dir);
    my @files = grep { -f "${mig_dir}/$_" } sort readdir($dh);
    closedir $dh;

    for my $file (@files) {
        my $errno = system("${mig_dir}/${file} >/dev/null");
        my $msg = "";

        if ($errno == 0) {
            $msg = "[ OK ]  ${file} ($errno)";
            log_info($msg);
        } else {
            $msg = "[ERROR] ${file} ($errno)";
            log_error($msg);
        }
    }

    return;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Core.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures state);

use Relianoid::Log;
use Relianoid::Config;
use Relianoid::Debug;

=pod

=head1 Module

Relianoid::Core

=cut

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Debug.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures state);

=pod

=head1 Module

Relianoid::Debug

=cut

=pod

=head1 debug

Get debugging level.

Parameters: None

Returns: integer - Debug level, a value from 0 to 5.

Bugs:

The debugging level should be stored as a variable.

=cut

sub debug () {
    state $debug;

    if (not defined $debug) {
        use Relianoid::Config;
        $debug = &getGlobalConfiguration('debug') // 0;
        $debug += 0;
    }

    return $debug;
}

=pod

=head1 getMemoryUsage

Get the resident memory usage of the current perl process.

Parameters: None

Returns: string - String with the memory usage.

=cut

sub getMemoryUsage () {
    my $mem_string;
    my $proc_pid_status_file = "/proc/$$/status";

    if (open(my $fh, "<", $proc_pid_status_file)) {
        my @lines = <$fh>;
        close $fh;

        ($mem_string) = grep { /RSS/ } @lines;
        chomp($mem_string);
        $mem_string =~ s/\s+/ /;
    }
    else {
        warn "Could not open file ${proc_pid_status_file}: $!";
    }

    return $mem_string;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/Action.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Config;

my $eload = eval { require Relianoid::ELoad };

my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::Action

=cut

=pod

=head1 _runFarmStart

Run a farm

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success, 2 if the ip:port is busy for another farm or another value on another failure

=cut

sub _runFarmStart ($farm_name, $writeconf = 0) {
    # The parameter expect "undef" to not write it
    $writeconf = 0 if ($writeconf eq 'false');

    require Relianoid::Farm::Base;
    require Relianoid::Farm::Config;

    my $status = -1;

    # finish the function if the farm is already up
    if (&getFarmStatus($farm_name) eq "up") {
        log_info("Farm $farm_name already up", "FARMS");
        return 0;
    }

    # check if the ip exists in any interface
    my $ip = &getFarmVip("vip", $farm_name);

    require Relianoid::Net::Interface;

    if (!&getIpAddressExists($ip)) {
        &log_info("The virtual interface $ip is not defined in any interface.");
        return $status;
    }

    require Relianoid::Net::Interface;

    my $farm_type = &getFarmType($farm_name);

    if ($farm_type ne "datalink") {
        my $port = &getFarmVip("vipp", $farm_name);
        if (!&validatePort($ip, $port, undef, $farm_name)) {
            &log_info("The networking '$ip:$port' is being used.");
            return 2;
        }
    }

    &log_info("Starting farm $farm_name with type $farm_type", "FARMS");

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Action;
        $status = &_runHTTPFarmStart($farm_name, $writeconf);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Action;
        $status = &startL4Farm($farm_name, $writeconf);
    }
    elsif ($farm_type eq "datalink") {
        $status = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Action',
            func   => '_runDatalinkFarmStart',
            args   => [ $farm_name, $writeconf ],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $status = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Action',
            func   => '_runGSLBFarmStart',
            args   => [ $farm_name, $writeconf ],
        );
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        $status = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Action',
            func   => '_runEproxyFarmStart',
            args   => [ { 'farm_name' => $farm_name, 'write' => $writeconf } ],
        );
    }

    &setFarmNoRestart($farm_name);

    return $status;
}

=pod

=head1 runFarmStart

Run a farm completely a farm. Run farm, its farmguardian, ipds rules and ssyncd

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success, 2 if the ip:port is busy for another farm or another value on another failure

NOTE:

    Generic function

=cut

sub runFarmStart ($farm_name, $writeconf = 0) {
    my $status = &_runFarmStart($farm_name, $writeconf);
    &log_info("Farm start status: $status");

    return $status if ($status != 0);

    require Relianoid::FarmGuardian;
    my $fg_status = &runFarmGuardianStart($farm_name, "");
    &log_info("Farm guardian start status: $fg_status");

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::IPDS::Base',
            func   => 'runIPDSStartByFarm',
            args   => [$farm_name],
        );

        require Relianoid::Farm::Config;
        if (&getPersistence($farm_name) == 0) {
            &eload(
                module => 'Relianoid::EE::Ssyncd',
                func   => 'setSsyncdFarmUp',
                args   => [$farm_name],
            );
        }
    }
    return $status;
}

=pod

=head1 runFarmStop

Stop a farm completely a farm. Stop the farm, its farmguardian, ipds rules and ssyncd

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success or different of 0 on failure

NOTE:

    Generic function

=cut

sub runFarmStop ($farm_name, $writeconf = 0) {
    if ($eload) {
        &eload(
            module => 'Relianoid::EE::IPDS::Base',
            func   => 'runIPDSStopByFarm',
            args   => [$farm_name],
        );
        &eload(
            module => 'Relianoid::EE::Ssyncd',
            func   => 'setSsyncdFarmDown',
            args   => [$farm_name],
        );
    }

    require Relianoid::FarmGuardian;
    &runFGFarmStop($farm_name);

    my $status = &_runFarmStop($farm_name, $writeconf);

    return $status;
}

=pod

=head1 _runFarmStop

Stop a farm

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success or different of 0 on failure

=cut

sub _runFarmStop ($farm_name, $writeconf = 0) {
    $writeconf = 0 if ($writeconf eq 'false');

    require Relianoid::Farm::Base;

    my $farm_filename = &getFarmFile($farm_name);
    if ($farm_filename eq '-1') {
        return -1;
    }

    my $farm_type = &getFarmType($farm_name);
    my $status    = $farm_type;

    &log_info("Stopping farm $farm_name with type $farm_type", "FARMS");

    if ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Action;
        $status = &_runHTTPFarmStop($farm_name, $writeconf);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Action;
        $status = &stopL4Farm($farm_name, $writeconf);
    }
    elsif ($farm_type eq "datalink") {
        $status = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Action',
            func   => '_runDatalinkFarmStop',
            args   => [ $farm_name, $writeconf ],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $status = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Action',
            func   => '_runGSLBFarmStop',
            args   => [ $farm_name, $writeconf ],
        );
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        $status = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Action',
            func   => '_runEproxyFarmStop',
            args   => [ { 'farm_name' => $farm_name, 'write' => $writeconf } ],
        );
    }

    &setFarmNoRestart($farm_name);

    return $status;
}

=pod

=head1 runFarmDelete

Delete a farm

Parameters:

    farmname - Farm name

Returns:

    String - farm name

NOTE:

    Generic function

=cut

sub runFarmDelete ($farm_name) {
    require Relianoid::Netfilter;

    my $configdir = &getGlobalConfiguration('configdir');

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::IPDS::Base',
            func   => 'runIPDSDeleteByFarm',
            args   => [$farm_name],
        );

        &eload(
            module => 'Relianoid::EE::RBAC::Group::Config',
            func   => 'delRBACResource',
            args   => [ $farm_name, 'farms' ],
        );
    }

    # stop and unlink farmguardian
    require Relianoid::FarmGuardian;
    &delFGFarm($farm_name);

    my $farm_type = &getFarmType($farm_name);
    my $status    = 1;

    &log_info("running 'Delete' for $farm_name", "FARMS");

    if ($farm_type eq "gslb") {
        require File::Path;
        File::Path->import('rmtree');

        $status = 0
          if rmtree(["$configdir/$farm_name\_gslb.cfg"]);
    }
    elsif ($farm_type eq "http" || $farm_type eq "https") {
        unlink glob("$configdir/$farm_name\_*\.html");

        # For HTTPS farms only
        my $dhfile = "$configdir\/$farm_name\_dh2048.pem";
        unlink("$dhfile") if -e "$dhfile";
        &delMarks($farm_name, "");

        # Check if local farm exists and delete it
        require Relianoid::Nft;
        my $output = &httpNlbRequest({
            method => "GET",
            uri    => "/farms/" . $farm_name,
            check  => 1,
        });

        if (!$output) {
            $output = &httpNlbRequest({
                farm   => $farm_name,
                method => "DELETE",
                uri    => "/farms/" . $farm_name,
            });
        }
    }
    elsif ($farm_type eq "datalink") {
        # delete cron task to check backends
        require Tie::File;
        tie my @filelines, 'Tie::File', "/etc/cron.d/relianoid";
        @filelines = grep { !/\# \_\_$farm_name\_\_/ } @filelines;
        untie @filelines;
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Factory;
        &runL4FarmDelete($farm_name);
    }

    if ($farm_type eq "eproxy" && $eload) {
        $status = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Factory',
            func   => 'runEproxyFarmDelete',
            args   => [{ farm_name => $farm_name }],
        );
    } else {
        unlink glob("$configdir/$farm_name\_*\.cfg");

        if (!-f "$configdir/$farm_name\_*\.cfg") {
            $status = 0;
        }
    }

    require Relianoid::RRD;

    &delGraph($farm_name, "farm");

    return $status;
}

=pod

=head1 runFarmReload

Reload a farm

Parameters:

    farm_name - Farm name

Returns:

    Integer - return 0 on success, another value on another failure

=cut

sub runFarmReload ($farm_name) {
    require Relianoid::Farm::Action;

    my $farm_type = &getFarmType($farm_name);
    my $status = 0;

    if ($farm_type eq "http" || $farm_type eq "https") {
        if (&getFarmRestartStatus($farm_name)) {
            &log_info("'Reload' on $farm_name is not executed. 'Restart' is needed.", "FARMS");
            return 2;
        }

        &log_info("running 'Reload' for $farm_name", "FARMS");

        $status = &_runFarmReload($farm_name);

        # Reload Farm status from its cfg file
        require Relianoid::Farm::HTTP::Backend;
        &setHTTPFarmBackendStatusFromFile($farm_name);
    }
    elsif ($farm_type eq "eproxy") {
        &log_info("running 'Reload' for $farm_name", "FARMS");
        $status = &_runFarmReload($farm_name);
    }

    return $status;
}

=pod

=head1 _runFarmReload

It reloads a farm to update the configuration.

Parameters:

    Farm - It is the farm name

Returns:

    Integer - It returns 0 on success or another value on failure.

=cut

sub _runFarmReload ($farm) {
    my $err = 0;

    require Relianoid::Farm::Base;
    return 0 if (&getFarmStatus($farm) ne 'up');

    my $farm_type = &getFarmType($farm);

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;
        my $poundctl = &getGlobalConfiguration('poundctl');
        my $socket    = &getHTTPFarmSocket($farm);

        $err = &logAndRun("$poundctl -c $socket -R 0");
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        $err = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Action',
            func   => 'runEproxyFarmReload',
            args   => [{ farm_name => $farm }],
        );
        require Relianoid::EE::Cluster;
        &runClusterRemoteManager('farm', 'reload', $farm);
    }

    return $err;
}

=pod

=head1 getFarmRestartFile

This function returns a file name that indicates that a farm is waiting to be restarted

Parameters:

    farmname - Farm name

Returns:

    sting - path to flag file

NOTE:

    Generic function

=cut

sub getFarmRestartFile ($farm_name) {
    return "/tmp/_farm_need_restart_$farm_name";
}

=pod

=head1 getFarmRestartStatus

This function responses if a farm has pending changes waiting for restarting

Parameters:

    farmname - Farm name

Returns:

    Integer - 1 if the farm has to be restarted or 0 if it is not

NOTE:

    Generic function

=cut

sub getFarmRestartStatus ($fname) {
    require Relianoid::Farm::Action;
    my $lfile = &getFarmRestartFile($fname);

    return 1 if (-e $lfile);
    return 0;
}

=pod

=head1 setFarmRestart

This function creates a file to tell that the farm needs to be restarted to apply changes

Parameters:

    farmname - Farm name

Returns:

    undef

NOTE:

    Generic function

=cut

sub setFarmRestart ($farm_name) {
    # do nothing if the farm is not running
    require Relianoid::Farm::Base;
    return if &getFarmStatus($farm_name) ne 'up';

    require Relianoid::Lock;
    my $lf = &getFarmRestartFile($farm_name);
    my $fh = &openlock($lf, 'w');
    close $fh;

    return;
}

=pod

=head1 setFarmNoRestart

This function deletes the file marking the farm to be restarted to apply changes

Parameters:

    farmname - Farm name

Returns:

    none

NOTE:

    Generic function

=cut

sub setFarmNoRestart ($farm_name) {
    my $lf = &getFarmRestartFile($farm_name);
    unlink($lf) if -e $lf;

    return;
}

=pod

=head1 setNewFarmName

Function that renames a farm. Before call this function, stop the farm.

Parameters:

    farmname    - Farm name
    newfarmname - New farm name

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub setNewFarmName ($farm_name, $new_farm_name) {
    my $collector_rrd_dir   = &getGlobalConfiguration('collector_rrd_dir');

    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    # farmguardian renaming
    require Relianoid::FarmGuardian;
    require File::Copy;

    &runFGFarmStop($farm_name);
    &setFGFarmRename($farm_name, $new_farm_name);

    # end of farmguardian renaming

    &log_info("setting 'NewFarmName $new_farm_name' for $farm_name farm $farm_type", "FARMS");

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Action;
        $output = &copyHTTPFarm($farm_name, $new_farm_name, 'del');
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Action;
        $output = &setL4NewFarmName($farm_name, $new_farm_name);
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Action',
            func   => 'copyDatalinkFarm',
            args   => [ $farm_name, $new_farm_name, 'del' ],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Action',
            func   => 'copyGSLBFarm',
            args   => [ $farm_name, $new_farm_name, 'del' ],
        );
    }

    # farmguardian renaming
    if ($output == 0) {
        &log_info("restarting farmguardian", 'FG') if &debug();
        &runFGFarmStart($farm_name);
    }

    # end of farmguardian renaming

    # rename rrd
    File::Copy::move("$collector_rrd_dir/$farm_name-farm.rrd", "$collector_rrd_dir/$new_farm_name-farm.rrd");

    # delete old graphs
    unlink("img/graphs/bar$farm_name.png");

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::IPDS::Base',
            func   => 'runIPDSRenameByFarm',
            args   => [ $farm_name, $new_farm_name ],
        );

        &eload(
            module => 'Relianoid::EE::RBAC::Group::Config',
            func   => 'setRBACRenameByFarm',
            args   => [ $farm_name, $new_farm_name ],
        );
    }

    # FIXME: logfiles
    return $output;
}

=pod

=head1 copyFarm

Function that copies the configuration file of a farm to create a new one.

Parameters:

    farmname - Farm name
    newfarmname - New farm name

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub copyFarm ($farm_name, $new_farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    &log_info("copying the farm '$farm_name' to '$new_farm_name'", "FARMS");

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Action;
        $output = &copyHTTPFarm($farm_name, $new_farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Action;
        $output = &copyL4Farm($farm_name, $new_farm_name);
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Action',
            func   => 'copyDatalinkFarm',
            args   => [ $farm_name, $new_farm_name ],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Action',
            func   => 'copyGSLBFarm',
            args   => [ $farm_name, $new_farm_name ],
        );
    }

    return $output;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/Backend.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use Relianoid::Farm::Backend::Maintenance;

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::Backend

=cut

=pod

=head1 getFarmServerIds

It returns a list with the backend servers for a farm and service.
The backends are read from the config file.
This function is to not use the getFarmservers that does stats checks.

Parameters:

    farm_name - Farm name
    service - service backends related (optional)

Returns:

    array ref - list of backends IDs

=cut

sub getFarmServerIds ($farm_name, $service) {
    my @servers   = ();
    my $farm_type = &getFarmType($farm_name);

    if ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Service;
        my $backendsvs = &getHTTPFarmVS($farm_name, $service, "backends");
        @servers = split("\n", $backendsvs);
        @servers = 0 .. $#servers if (@servers);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Backend;
        @servers = @{ &getL4FarmServers($farm_name) };
        @servers = 0 .. $#servers if (@servers);
    }
    elsif ($farm_type eq "datalink") {
        my $configdir     = &getGlobalConfiguration('configdir');
        my $farm_filename = &getFarmFile($farm_name);
        open my $fh, '<', "$configdir/$farm_filename";
        {
            while (my $line = <$fh>) {
                push @servers, $line if ($line =~ /^;server;/);
            }
            close $fh;
        }
        @servers = 0 .. $#servers if (@servers);
    }
    elsif ($farm_type eq "gslb" && $eload) {
        my $backendsvs = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Service',
            func   => 'getGSLBFarmVS',
            args   => [ $farm_name, $service, "backends" ],
        );
        my @be = split("\n", $backendsvs);
        my $id;
        for my $b (@be) {
            $b =~ s/^\s+//;
            next if ($b =~ /^$/);

            # ID and IP
            my @subbe = split(" => ", $b);
            $id = $subbe[0];
            $id =~ s/^primary$/1/;
            $id =~ s/^secondary$/2/;
            $id += 0;
            push @servers, $id;
        }
    }

    return \@servers;
}

=pod

=head1 getFarmServers

List all farm backends and theirs configuration

Parameters:

    farm_name - Farm name
    service - service backends related (optional)

Returns:

    array ref - list of backends

FIXME:

    changes output to hash format

=cut

sub getFarmServers ($farm_name, $service = undef) {
    my $farm_type = &getFarmType($farm_name);
    my $servers;

    if ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Backend;
        $servers = &getHTTPFarmBackends($farm_name, $service);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Backend;
        $servers = &getL4FarmServers($farm_name);
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $servers = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Backend',
            func   => 'getDatalinkFarmBackends',
            args   => [$farm_name],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $servers = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Backend',
            func   => 'getGSLBFarmBackends',
            args   => [ $farm_name, $service ],
        );
    }

    return $servers;
}

=pod

=head1 getFarmServer

Return the backend with the specified value on the specified parameter.

Parameters:

    backends_ref - Array ref of backends hashes.
    value - Parameter value to match
    param - Parameter to match. Default value "id"

Returns:

    hash ref - bachend hash reference or undef if there aren't backends

=cut

sub getFarmServer ($bcks_ref, $value, $param = "id") {
    for my $server (@{$bcks_ref}) {
        # preserve type param number
        if ($param eq "id") {
            return $server if ($server->{$param} == $value);
        }
        else {
            return $server if ($server->{$param} eq "$value");
        }
    }

    # Error, not found so return undef
    return;
}

=pod

=head1 setFarmServer

Add a new Backend

Parameters:

    farm_name -  Farm name
    service   -  Optional. service name. For HTTP farms
    ids       -  Backend id, if this id doesn't exist, it will create a new backend
    bk        -  hash with backend configuration. 
                 Depend on the type of farms, the backend can have the following keys:
                 ip, port, weight, priority, timeout, max_conns or interface

Returns:

    Scalar - Error code: undef on success or -1 on error

=cut

sub setFarmServer ($farm_name, $service, $ids, $bk) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    my $attrs_msg = sprintf(
        'Server %s ip:%s port:%u max:%u weight:%u prio:%u timeout:%u',
        $ids             // '', $bk->{ip},
        $bk->{port}      // 0,
        $bk->{max_conns} // 0,
        $bk->{weight}    // 0,
        $bk->{priority}  // 0,
        $bk->{timeout}   // 0
    );
    my $msg = sprintf("setting '$attrs_msg' for %s farm, %s service of type %s", $farm_name, $service // 'no', $farm_type);
    &log_info($msg, "FARMS");

    if ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Backend',
            func   => 'setDatalinkFarmServer',
            args   => [ $ids, $bk->{ip}, $bk->{interface}, $bk->{weight}, $bk->{priority}, $farm_name ],
        );
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Backend;
        $output = &setL4FarmServer(
            $farm_name, $ids, $bk->{ip},
            $bk->{port}      // "",
            $bk->{weight}    // 1,
            $bk->{priority}  // 1,
            $bk->{max_conns} // 0
        );
    }
    elsif ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Backend;
        $output = &setHTTPFarmServer(
            $ids,           $bk->{ip},  $bk->{port}, $bk->{weight},    #
            $bk->{timeout}, $farm_name, $service,    $bk->{priority}
        );
    }

    # FIXME: include setGSLBFarmNewBackend
    return $output;
}

=pod

=head1 runFarmServerDelete

Delete a Backend

Parameters:

    ids       - Backend id, if this id doesn't exist, it will create a new backend
    farm_name - Farm name
    service   - service name. For HTTP farms

Returns:

    Scalar - Error code: undef on success or -1 on error

=cut

sub runFarmServerDelete ($ids, $farm_name, $service = undef) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    &log_info("running 'ServerDelete $ids' for $farm_name farm $farm_type", "FARMS");

    if ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Backend;
        $output = &runL4FarmServerDelete($ids, $farm_name);
    }
    elsif ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Backend;
        $output = &runHTTPFarmServerDelete($ids, $farm_name, $service);
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Backend',
            func   => 'runDatalinkFarmServerDelete',
            args   => [ $ids, $farm_name ],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Backend',
            func   => 'runGSLBFarmServerDelete',
            args   => [ $ids, $farm_name, $service ],
        );
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Backend',
            func   => 'delEproxyFarmBackend',
            args   => [ { farm_name => $farm_name, service_name => $service, backend_id => $ids } ],
        );
    }

    return $output;
}

=pod

=head1 getFarmBackendAvailableID

Get next available backend ID

Parameters:

    farmname - farm name

Returns:

    integer

=cut

sub getFarmBackendAvailableID ($farmname) {
    my $nbackends;

    if (&getFarmType($farmname) eq 'l4xnat') {
        require Relianoid::Farm::L4xNAT::Backend;
        $nbackends = &getL4FarmBackendAvailableID($farmname);
    }
    else {
        my $backends = &getFarmServers($farmname);
        $nbackends = $#{$backends} + 1;
    }

    return $nbackends;
}

=pod

=head1 setBackendRule

Add or delete the route rule according to the backend mark.

Parameters:

    action    - "add" to create the mark or "del" to remove it.
    farm_ref  - farm reference.
    mark      - backend mark to apply in the rule.
    farm_type - type of farm (l4xnat, http, https).

Returns:

    integer - 0 if successful, otherwise error.

=cut

sub setBackendRule ($action, $farm_ref, $mark, $farm_type = undef) {
    $farm_type //= getFarmType($farm_ref->{name});

    unless ($action eq "add" or $action eq "del") {
        croak("Rule action must be 'add' or 'del'");
    }

    unless (defined $farm_ref) {
        croak("A farm configuration is required");
    }

    unless (length $mark and hex $mark) {
        croak("Invalid mark received");
    }

    require Relianoid::Net::Util;
    require Relianoid::Net::Route;

    my $vip_if_name = &getInterfaceOfIp($farm_ref->{vip});
    my $vip_if      = &getInterfaceConfig($vip_if_name);
    my $table_if =
      ($vip_if->{type} eq 'virtual') ? $vip_if->{parent} : $vip_if->{name};

    my $rule = {
        table  => "table_$table_if",
        type   => $farm_type,
        from   => 'all',
        fwmark => "$mark/0x7fffffff",
    };
    return &setRule($action, $rule);
}

=pod

=head1 getPriorityAlgorithmStatus

Calculates the Priroty algorithm status of the backend list

Parameters:

    $backends_ref - list of backend_ref
    $bk_index     - backend index if defined, only returns this index values. Optional. 

    $backend_ref->{status}   - Status of the backend. Possibles values:"up","down".
    $backend_ref->{priority} - Priority of the backend

Returns:

    $availability_ref - Hash of algorithm values.

Variable:

    $availability_ref->{priority} - algorithm priority.
    $availability_ref->{status}   - Array - list of backend availability.

    If defined parameter $backend_ref->{status}:
    - "true" if the backend is used.
    - "false" if is available to be used.

    If not defined parameter $backend_ref->{status}:
    - "true" if the backend is used or available to be used.
    - "false" if the backend will never be used.

=cut

sub getPriorityAlgorithmStatus ($backends_ref, $bk_index = undef) {
    my $alg_status_ref;
    my $sum_prio_ref;

    for my $bk (@{$backends_ref}) {
        #determine number of backends down for each level of priority
        if (not defined $bk->{status} or $bk->{status} eq "down") {
            $sum_prio_ref->{ $bk->{priority} }++;
        }
    }

    #determine the lowest priority level where backends are being used
    my $current_alg_prio = 1;
    my $alg_prio         = 1;

    while ($current_alg_prio <= $alg_prio) {
        #when the level of priority matches the number of down backends, loop stops
        #and $alg_prio indicates the lowest level of prio being used.
        #else, keep increasing the level of priority checked in the next iteration.
        if (defined $sum_prio_ref->{$current_alg_prio}) {
            $alg_prio += $sum_prio_ref->{$current_alg_prio};
        }
        last if $alg_prio == $current_alg_prio;
        $current_alg_prio++;
    }

    $alg_status_ref->{priority} = $alg_prio;
    $alg_status_ref->{status}   = [];

    if (defined $bk_index) {
        if (@{$backends_ref}[$bk_index]->{priority} <= $alg_prio) {
            push @{ $alg_status_ref->{status} }, "true";
        }
        else {
            push @{ $alg_status_ref->{status} }, "false";
        }
    }
    else {
        for my $bk (@{$backends_ref}) {
            if ($bk->{priority} <= $alg_prio) {
                push @{ $alg_status_ref->{status} }, "true";
            }
            else {
                push @{ $alg_status_ref->{status} }, "false";
            }
        }
    }

    return $alg_status_ref;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/Backend/Maintenance.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::Farm::Backend::Maintenance

=cut

=pod

=head1 setFarmBackendMaintenance

Function that enable the maintenance mode for backend

Parameters:

    farm_name -  Farm name
    backend   -  Backend id
    mode      -  Maintenance mode, the options are:
                 - drain: the backend continues working with the established connections
                 - cut:   the backend cuts all the established connections
    service   -  Service name, required for http only

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub setFarmBackendMaintenance ($farm_name, $backend, $mode, $service = undef) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Backend;
        $output = &setHTTPFarmBackendMaintenance($farm_name, $backend, $mode, $service);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Backend;
        $output = &setL4FarmBackendStatus($farm_name, $backend, 'maintenance', $mode);
    }

    return $output;
}

=pod

=head1 setFarmBackendNoMaintenance

Function that disable the maintenance mode for backend

Parameters:

    farm_name - Farm name
    backend   - Backend id
    service   - Service name

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub setFarmBackendNoMaintenance ($farm_name, $backend, $service = undef) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Backend;
        $output = &setHTTPFarmBackendNoMaintenance($farm_name, $backend, $service);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Backend;
        $output = &setL4FarmBackendStatus($farm_name, $backend, 'up', "");
    }

    return $output;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/Base.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Config;
use Relianoid::Farm::Core;

my $configdir = &getGlobalConfiguration('configdir');
my $eload     = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::Base

=cut

=pod

=head1 getFarmVip

Returns farm vip or farm port

Parameters:

    tag - requested parameter. The options are 
          - "vip" for virtual ip
          - "vipp" for virtual port

    farmname - Farm name

Returns:

    Scalar - return vip or port of farm or -1 on failure

See Also:

    setFarmVirtualConf

=cut

sub getFarmVip ($info, $farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;
        $output = &getHTTPFarmVip($info, $farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $output = &getL4FarmParam($info, $farm_name);
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Config',
            func   => 'getDatalinkFarmVip',
            args   => [ $info, $farm_name ],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Config',
            func   => 'getGSLBFarmVip',
            args   => [ $info, $farm_name ],
        );
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        my $farm = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Config',
            func   => 'getEproxyFarmStruct',
            args   => [{ farm_name => $farm_name }],
        );
        $output = $farm->{vip} if ($info eq "vip");
        $output = $farm->{vport} if ($info eq "vipp");
    }

    return $output;
}

=pod

=head1 getFarmStatus

Return farm status checking if pid file exists

Parameters:

    farmname - Farm name

Returns:

    String - "down", "up" or -1 on failure

NOTE:

    Generic function

=cut

sub getFarmStatus ($farm_name) {
    my $output = -1;
    return $output if !defined($farm_name);

    my $farm_type = &getFarmType($farm_name);

    if ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        return &getL4FarmStatus($farm_name);
    }
    elsif ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Config;
        return &getHTTPFarmStatus($farm_name);
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Config',
            func   => 'getDatalinkFarmStatus',
            args   => [$farm_name],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Config',
            func   => 'getGSLBFarmStatus',
            args   => [$farm_name],
        );
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Action',
            func   => 'getEproxyFarmStatus',
            args   => [{ farm_name => $farm_name }],
        );
    }

    return $output;
}

=pod

=head1 getFarmVipStatus

Return a vip status

Parameters:

    farmname - Farm name

Returns:

    String - "needed restart", "critical", "problem", "maintenance", "up", "down" or -1 on failure

    up

        The farm is up and all the backends are working success.

    down

        The farm is not running

    needed restart

        The farm is up but it is pending of a restart action

    critical

        The farm is up and all backends are unreachable or maintenance

    problem

        The farm is up and there are some backend unreachable, 
        but almost a backend is in up status

    maintenance

        The farm is up and there are backends in up status, 
        but almost a backend is in maintenance mode.

NOTE:

    Generic function

=cut

sub getFarmVipStatus ($farm_name) {
    my $output     = -1;
    my $farmStatus = &getFarmStatus($farm_name);
    return $output if !defined($farm_name);

    $output = "problem";

    require Relianoid::Farm::Action;

    if ($farmStatus eq "down") {
        return "down";
    }
    elsif (&getFarmRestartStatus($farm_name)) {
        return "needed restart";
    }
    elsif ($farmStatus ne "up") {
        return -1;
    }

    # types: "http", "https", "datalink", "l4xnat", "gslb", "eproxy" or 1
    my $type = &getFarmType($farm_name);

    my $backends;
    my $up_flag = 0;
    my $down_flag = 0;
    my $maintenance_flag = 0;

    require Relianoid::Farm::Backend;

    # HTTP, optimized for many services
    if ($type =~ /http/) {
        require Relianoid::Farm::HTTP::Backend;
        my $status = &getHTTPFarmBackendsStatusInfo($farm_name);

        for my $service (keys %{$status}) {
            next unless defined $status->{$service}{backends};

            for my $backend (@{ $status->{$service}{backends} }) {
                push @{$backends}, $backend;
            }
        }
    }

    elsif ($type eq "gslb" && $eload) {
        my $stats = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Stats',
            func   => 'getGSLBFarmBackendsStats',
            args   => [$farm_name],
        );
        $backends = $stats->{backends};
    }

    elsif ($type eq "eproxy" && $eload) {
        $backends = &eload(
           module => 'Relianoid::EE::Farm::Eproxy::Backend',
           func   => 'getEproxyFarmBackends',
           args   => [ { farm_name => $farm_name } ],
        );
    }

    else {
        $backends = &getFarmServers($farm_name);
    }

    # checking status
    for my $be (@{$backends}) {
        $up_flag          = 1 if grep { $be->{status} eq $_ } qw(up undefined);
        $maintenance_flag = 1 if grep { $be->{status} eq $_ } qw(maintenance);
        $down_flag        = 1 if grep { $be->{status} eq $_ } qw(down fgDOWN);

        # if there is a backend up and another down, the status is 'problem'
        last if ($down_flag and $up_flag);
    }

    # check if redirect exists when there are not backends
    if ($type =~ /http/) {
        require Relianoid::Farm::HTTP::Service;
        for my $srv (&getHTTPFarmServices($farm_name)) {
            if (&getHTTPFarmVS($farm_name, $srv, 'redirect')) {
                $up_flag = 1;
                last;
            }
        }
    }

    if (!$up_flag) {
        $output = "critical";
    }
    elsif ($down_flag) {
        $output = "problem";
    }
    elsif ($maintenance_flag) {
        $output = "maintenance";
    }
    else {
        $output = "up";
    }

    return $output;
}

=pod

=head1 getFarmPid

Returns farm PID

Parameters:

    farmname - Farm name

Returns:

    Integer - return a list of daemon pids. It can contains more than one value

=cut

sub getFarmPid ($farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my @output    = ();

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;

        @output = &getHTTPFarmPidPound($farm_name);
    }
    elsif ($farm_type eq "gslb" && $eload) {
        my $pid = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Config',
            func   => 'getGSLBFarmPid',
            args   => [$farm_name],
        );
        push(@output, $pid) if $pid;
    }

    return @output;
}

=pod

=head1 getFarmBootStatus

Return the farm status at boot relianoid

Parameters:

    farmname - Farm name

Returns:

    scalar - return "down" if the farm not run at boot or "up" if the farm run at boot

=cut

sub getFarmBootStatus ($farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = "down";

    if ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Config;
        $output = &getHTTPFarmBootStatus($farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $output = &getL4FarmParam('bootstatus', $farm_name);
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Config',
            func   => 'getDatalinkFarmBootStatus',
            args   => [$farm_name],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Config',
            func   => 'getGSLBFarmBootStatus',
            args   => [$farm_name],
        );
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Config',
            func   => 'getEproxyFarmBootStatus',
            args   => [{ farm_name => $farm_name }],
        );
    }

    return $output;
}

=pod

=head1 getFarmProto

Return basic transport protocol used by the farm protocol

Parameters:

    farmname - Farm name

Returns:

    String - "udp" or "tcp"

BUG:

    Gslb works with tcp protocol too

FIXME:

    Use getL4ProtocolTransportLayer to get l4xnat protocol

=cut

sub getFarmProto ($farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    if ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $output = &getL4FarmParam('proto', $farm_name);
    }
    elsif ($farm_type =~ /http/i) {
        $output = "tcp";
    }
    elsif ($farm_type eq "gslb") {
        $output = "all";
    }

    return $output;
}

=pod

=head1 getNumberOfFarmTypeRunning

    Counter how many farms exists in a farm profile.

Parameters:

    type - Farm profile: "http", "l4xnat", "gslb" or "datalink"

Returns:

    integer- Number of farms

=cut

sub getNumberOfFarmTypeRunning ($type) {
    my $counter = 0;

    for my $farm_name (&getFarmNameList()) {
        # count if requested farm type and running
        my $current_type = &getFarmType($farm_name);

        if ($current_type eq $type) {
            my $current_status = &getFarmStatus($farm_name);

            if ($current_status eq 'up') {
                $counter++;
            }
        }
    }

    return $counter;
}

=pod

=head1 getFarmListByVip

Returns a list of farms that have the same IP address.

Parameters:

    ip   - ip address
    port - virtual port. This parameter is optional

Returns:

    Array - List of farm names

=cut

sub getFarmListByVip ($ip, $port = undef) {
    require Relianoid::Net::Validate;

    my @out = ();

    for my $farm (&getFarmNameList()) {
        if (&getFarmVip('vip', $farm) eq $ip) {
            next if defined $port && !grep { $port eq $_ } @{ &getMultiporExpanded(&getFarmVip('vipp', $farm)) };
            push @out, $farm;
        }
    }

    return @out;
}

=pod

=head1 getFarmRunning

Returns the farms are currently running in the system.

Parameters:

    none

Returns:

    Array - List of farm names

=cut

sub getFarmRunning() {
    my @out = ();

    for my $farm (&getFarmNameList()) {
        if (&getFarmStatus($farm) eq 'up') {
            push @out, $farm;
        }
    }
    return @out;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/Config.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::Config

=cut

=pod

=head1 setFarmBlacklistTime

Configure check time for resurected back-end. It is a farm paramter.

Parameters:

    blacklist_time - time for resurrected checks
    farm_name - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setFarmBlacklistTime ($blacklist_time, $farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;
        $output = &setHTTPFarmBlacklistTime($blacklist_time, $farm_name);
    }

    return $output;
}

=pod

=head1 setFarmSessionType

Configure type of persistence

Parameters:

    session  - type of session: nothing, HEADER, URL, COOKIE, PARAM, BASIC or IP, for HTTP farms; none or ip, for l4xnat farms
    farm_name - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setFarmSessionType ($session, $farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;
        $output = &setHTTPFarmSessionType($session, $farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $output = &setL4FarmParam('persist', $session, $farm_name);
    }

    #if persistence is enabled
    require Relianoid::Farm::Config;
    if (&getPersistence($farm_name) == 0) {
        #register farm in ssyncd
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Ssyncd',
                func   => 'setSsyncdFarmUp',
                args   => [$farm_name],
            );
        }
    }
    else {
        #unregister farm in ssyncd
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Ssyncd',
                func   => 'setSsyncdFarmDown',
                args   => [$farm_name],
            );
        }
    }
    return $output;
}

=pod

=head1 setFarmTimeout

Asign a timeout value to a farm

Parameters:

    timeout  - Time out in seconds
    farm_name - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setFarmTimeout ($timeout, $farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    &log_info("setting 'Timeout $timeout' for $farm_name farm $farm_type", "LSLB");

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;
        $output = &setHTTPFarmTimeout($timeout, $farm_name);
    }

    return $output;
}

=pod

=head1 setFarmAlgorithm

Set the load balancing algorithm to a farm.

Supports farm types: TCP, Datalink, L4xNAT.

Parameters:

    algorithm - Type of balancing mode
    farm_name - Farm name

Returns:

    none

FIXME:

    set a return value, and do error control

=cut

sub setFarmAlgorithm ($algorithm, $farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    &log_info("setting 'Algorithm $algorithm' for $farm_name farm $farm_type", "FARMS");

    if ($farm_type eq "datalink" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Config',
            func   => 'setDatalinkFarmAlgorithm',
            args   => [ $algorithm, $farm_name ],
        );
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $output = &setL4FarmParam('alg', $algorithm, $farm_name);
    }

    return $output;
}

=pod

=head1 getFarmAlgorithm

Get type of balancing algorithm.

Supports farm types: Datalink, L4xNAT.

Parameters:

    farm_name - Farm name

Returns:

    scalar - return a string with type of balancing algorithm or -1 on failure

=cut

sub getFarmAlgorithm ($farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $algorithm = -1;

    if ($farm_type eq "datalink" && $eload) {
        $algorithm = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Config',
            func   => 'getDatalinkFarmAlgorithm',
            args   => [$farm_name],
        );
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $algorithm = &getL4FarmParam('alg', $farm_name);
    }

    return $algorithm;
}

=pod

=head1 setFarmMaxClientTime

Set the maximum time for a client

Parameters:

    maximumTO - Maximum client time
    farm_name - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setFarmMaxClientTime ($max_client_time, $track, $farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $output    = -1;

    &log_info("setting 'MaxClientTime $max_client_time $track' for $farm_name farm $farm_type", "LSLB");

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;
        $output = &setHTTPFarmMaxClientTime($track, $farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $output = &setL4FarmParam('persisttm', $track, $farm_name);
    }

    return $output;
}

=pod

=head1 setFarmVirtualConf

Set farm virtual IP and virtual PORT

Parameters:

    vip - virtual ip

    vip_port - virtual port (interface in datalink farms).
               If the port is not sent, the port will not be changed

    farm_name - Farm name

Returns:

    Integer - return 0 on success or other value on failure

See Also:

    To get values use getFarmVip.

=cut

sub setFarmVirtualConf ($vip, $vip_port, $farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my $stat      = -1;
    $vip_port //= '';

    &log_info("setting 'VirtualConf $vip $vip_port' for $farm_name farm $farm_type", "FARMS");

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Config;
        $stat = &setHTTPFarmVirtualConf($vip, $vip_port, $farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Config;
        $stat = 0;

        if ($vip ne "") {
            $stat = &setL4FarmParam('vip', $vip, $farm_name);
        }

        return $stat if $stat;

        if ($vip_port ne "") {
            $stat = &setL4FarmParam('vipp', $vip_port, $farm_name);
        }
    }
    elsif ($farm_type eq "datalink" && $eload) {
        $stat = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Config',
            func   => 'setDatalinkFarmVirtualConf',
            args   => [ $vip, $vip_port, $farm_name ],
        );
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $stat = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Config',
            func   => 'setGSLBFarmVirtualConf',
            args   => [ $vip, $vip_port, $farm_name ],
        );
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        $stat = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Config',
            func   => 'setEproxyFarmStruct',
            args   => [ { 'farm_name' => $farm_name, 'vip' => $vip, 'vport' => $vip_port }],
        );
    }

    return $stat;
}

=pod

=head1 setAllFarmByVip

This function change the virtual interface for a set of farms. If some farm
is up, this function will restart it.

Parameters:

    IP        - New virtual interface for the farms
    farm list - List of farms to update. This list will send as reference

Returns:

    None

=cut

sub setAllFarmByVip ($vip, $farmList) {
    require Relianoid::Farm::Action;

    for my $farm (@{$farmList}) {
        # get status
        my $status = &getFarmStatus($farm);

        # stop farm
        if ($status eq 'up') { &runFarmStop($farm); }

        # change vip
        &setFarmVirtualConf($vip, undef, $farm);

        # start farm
        if ($status eq 'up') { &runFarmStart($farm); }
    }

    return;
}

=pod

=head1 getFarmVS

Return virtual server parameter

Parameters:

    farm_name - Farm name
    service  - Service name
    tag      - Indicate which field will be returned

Returns:

    Integer - The requested parameter value

=cut

sub getFarmVS ($farm_name, $service, $tag) {
    my $output = "";
    require Relianoid::Farm::Core;
    my $farm_type = &getFarmType($farm_name);

    if ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Service;
        $output = &getHTTPFarmVS($farm_name, $service, $tag);
    }
    elsif ($farm_type eq "gslb" && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Service',
            func   => 'getGSLBFarmVS',
            args   => [ $farm_name, $service, $tag ],
        );
    }

    return $output;
}

=pod

=head1 setFarmVS

Set values for service parameters

Parameters:

    farm_name - Farm name
    service  - Service name
    tag      - Indicate which parameter modify
    string   - value for the field "tag"

Returns:

    Integer - Error code: 0 on success or -1 on failure

=cut

sub setFarmVS ($farm_name, $service, $tag, $string) {
    my $output    = "";
    my $farm_type = &getFarmType($farm_name);

    if ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Service;
        $output = &setHTTPFarmVS($farm_name, $service, $tag, $string);
    }
    elsif ($farm_type eq "gslb") {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Service',
            func   => 'setGSLBFarmVS',
            args   => [ $farm_name, $service, $tag, $string ],
        ) if $eload;
    }

    return $output;
}

=pod

=head1 getFarmStruct

    Generic subroutine for the struct retrieval

Parameters:

    farmname - Farm name

Returns:

    farm - reference of the farm hash

=cut

sub getFarmStruct ($farmName) {
    require Relianoid::Farm::Core;
    my $farm;    # declare output hash
    my $farmType = &getFarmType($farmName);
    return if ($farmType eq 1);

    if ($farmType =~ /http|https/) {
        require Relianoid::Farm::HTTP::Config;
        $farm = &getHTTPFarmStruct($farmName, $farmType);
    }
    elsif ($farmType =~ /l4xnat/) {
        require Relianoid::Farm::L4xNAT::Config;
        $farm = &getL4FarmStruct($farmName);
    }
    elsif ($farmType =~ /gslb/ && $eload) {
        $farm = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Config',
            func   => 'getGSLBFarmStruct',
            args   => [$farmName],
        );
    }
    elsif ($farmType =~ /eproxy/ && $eload) {
        $farm = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Config',
            func   => 'getEproxyFarmStruct',
            args   => [{ farm_name => $farmName}],
        );
    }

    # elsif ( $farmType =~ /datalink/ && $eload)
    # {
    #     $farm = &eload(
    #         module => 'Relianoid::EE::Farm::Datalink::Config',
    #         func   => 'getDatalinkFarmStruct',
    #         args   => [$farmName],
    #     );
    # }
    return $farm;    # return a hash reference
}

=pod

=head1 getFarmPlainInfo

Return the L4 farm text configuration

Parameters:

    farm_name - farm name to get the status

Returns:

    Scalar - Reference of the file content in plain text

=cut

sub getFarmPlainInfo ($farm_name, $file = undef) {
    my @content;

    my $configdir = &getGlobalConfiguration('configdir');

    my $farm_filename = &getFarmFile($farm_name);

    if ($farm_filename =~ /(?:gslb)\.cfg$/ && defined $file) {
        open my $fd, '<', "$configdir/$farm_filename/$file" or return;
        chomp(@content = <$fd>);
        close $fd;
    }
    else {
        open my $fd, '<', "$configdir/$farm_filename" or return;
        chomp(@content = <$fd>);
        close $fd;
    }

    return \@content;
}

=pod

=head1 reloadFarmsSourceAddress

Reload source address rules of farms

Parameters:

    none

Returns:

    none


FIXME:

    one source address per farm, not for backend

=cut

sub reloadFarmsSourceAddress () {
    require Relianoid::Farm::Core;

    for my $farm_name (&getFarmNameList()) {
        &reloadFarmsSourceAddressByFarm($farm_name);
    }

    return;
}

=pod

=head1 reloadL7FarmsSourceAddress

Reload source address rules of HTTP/HTTPS farms

Parameters:

    none

Returns:

    none

=cut

sub reloadL7FarmsSourceAddress () {
    require Relianoid::Farm::Core;

    my @farms = &getFarmsByType('http');
    push @farms, &getFarmsByType('https');

    for my $farm_name (@farms) {
        &reloadFarmsSourceAddressByFarm($farm_name);
    }

    return;
}

=pod

=head1 reloadFarmsSourceAddressbyFarm

Reload source address rules of a certain farm (l4 in NAT mode and HTTP)

HTTP:

    Add backend only if use a different sourceaddr

Parameters:

    farm_name - name of the farm to apply the source address

Returns:

    none

FIXME:

    one source address per farm, not per backend

=cut

sub reloadFarmsSourceAddressByFarm ($farm_name) {
    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    return if &getFarmStatus($farm_name) ne 'up';

    my $farm_type = &getFarmType($farm_name);

    if ($farm_type eq 'l4xnat') {
        my $farm_ref = &getL4FarmStruct($farm_name);

        return if $farm_ref->{nattype} ne 'nat';

        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Net::Floating',
                func   => 'setFloatingSourceAddr',
                args   => [ $farm_ref, undef ],
            );

            # reload the backend source address
            for my $bk (@{ $farm_ref->{servers} }) {
                &eload(
                    module => 'Relianoid::EE::Net::Floating',
                    func   => 'setFloatingSourceAddr',
                    args   => [ $farm_ref, $bk ],
                );
            }
        }
    }

    return;
}

=pod

=head1 checkLocalFarmSourceAddress

Check if an HTTP farm should exist as a local farm in nftlb in order to do snat in any of its backends.
The function will return 1 in case the farm's vip contains floating ip or any of the farm's backends 
are on a network with floating ip or is on an unknown network or custom routes.

Parameters:

    farm_name    - name of the farm to check
    floating_ref - Hash ref with floating system information

Returns:

    Scalar - Integer : 0 if the source address is not needed.

    1 - if farm must be configured for snat.
    2 - if some backend must be configured for snat.
    3 - if farm and some backend must be configured for snat.
    -1 - if there is an error.

=cut

sub checkLocalFarmSourceAddress ($farm_name, $floating_ref) {
    my $farm_srcaddr_ref;

    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    my $farm_type = &getFarmType($farm_name);

    if ($farm_type eq 'http' || $farm_type eq 'https') {
        my $floating = 0;

        if ($eload && &getGlobalConfiguration('floating_L7') eq 'true') {
            $floating = 1;
        }
        return $farm_srcaddr_ref if not $floating;

        # check system floating
        my $floating_config = &eload(
            module => 'Relianoid::EE::Net::Floating',
            func   => 'getFloatingConfig',
        );

        if (not $floating_config) {
            return $farm_srcaddr_ref;
        }

        # check farm vip has floating
        require Relianoid::Farm::HTTP::Config;
        my $farm_vip = &getHTTPFarmVip("vip", $farm_name);
        my $floating_system_ref;

        if ($floating_ref) {
            $floating_system_ref = $floating_ref;
        }
        else {
            $floating_system_ref = &eload(
                module => 'Relianoid::EE::Net::Floating',
                func   => 'get_floating_struct',
            );
        }

        require Relianoid::Net::Interface;
        my $if_system_status = &getInterfaceSystemStatusAll();

        my $farm_floating = &eload(
            module => 'Relianoid::EE::Net::Floating',
            func   => 'getFloatingSourceAddr',
            args   => [ $farm_vip, undef, $floating_system_ref, $if_system_status ]
        );

        # if iface with floating, needs snat
        if ($farm_floating->{out}{floating_ip}) {
            $farm_srcaddr_ref->{farm} = $farm_floating;
        }

        # check backends for every service
        require Relianoid::Farm::HTTP::Service;
        my @services = &getHTTPFarmServices($farm_name);

        require Relianoid::Farm::HTTP::Backend;
        my $ip_floating_ref;
        my $bk_floating;
        my $exists_floating_backend = 0;

        for my $serv_name (@services) {
            my $backends_ref = &getHTTPFarmBackends($farm_name, $serv_name, "false");

            for my $bk (@{$backends_ref}) {
                if (not $ip_floating_ref->{ $bk->{ip} }) {
                    # get sourceaddress
                    my $mark = sprintf("0x%x", $bk->{tag});
                    $bk_floating = &eload(
                        module => 'Relianoid::EE::Net::Floating',
                        func   => 'getFloatingSourceAddr',
                        args   => [ $bk->{ip}, $mark, $floating_system_ref, $if_system_status ]
                    );

                    $ip_floating_ref->{ $bk->{ip} } = $bk_floating;
                }
                else {
                    %{ $bk_floating->{in} }  = %{ $ip_floating_ref->{ $bk->{ip} }{in} };
                    %{ $bk_floating->{out} } = %{ $ip_floating_ref->{ $bk->{ip} }{out} };
                }

                $bk_floating->{in}{mark} = $bk->{tag};

                # check if backend uses floating
                if ($bk_floating->{out}{floating_ip}) {
                    $exists_floating_backend = 1;
                }

                push @{ $farm_srcaddr_ref->{backends} }, $bk_floating;
                $bk_floating = undef;
            }
        }

        if (not $exists_floating_backend) {
            delete $farm_srcaddr_ref->{backends};
        }
    }

    return $farm_srcaddr_ref;
}

=pod

=head1 reloadBackendsSourceAddressByIface

Reload source address rules of a certain farm (l4 in NAT mode and HTTP) by Iface

Parameters:

    iface_name - Interface which the the route is appplied in

Returns:

    none

=cut

sub reloadBackendsSourceAddressByIface ($iface_name) {
    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    for my $farm_name (&getFarmNameList()) {
        my $farm_type = &getFarmType($farm_name);

        next if &getFarmStatus($farm_name) ne 'up';

        if ($farm_type eq 'l4xnat') {
            my $farm_ref = &getL4FarmStruct($farm_name);
            next if $farm_ref->{nattype} ne 'nat';
            &reloadFarmsSourceAddressByFarm($farm_name);
        }
    }

    return;
}

=pod

=head1 getPersistence

Checks if persistence is enabled in the farm through config file

Parameters:

    farm_name - name of the farm where check persistence

Returns: integer

    0 - true
    1 - false

=cut

sub getPersistence ($farm_name) {
    my $farm_type  = &getFarmType($farm_name);
    my $nodestatus = "";

    return 1 if $farm_type !~ /l4xnat|http/;

    if ($eload) {
        $nodestatus = &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'getClusterNodeStatus',
            args   => [],
        );
    }

    if ($nodestatus ne "master") {
        return 1;
    }

    if ($farm_type eq 'l4xnat') {
        require Relianoid::Farm::L4xNAT::Config;

        my $persist = &getL4FarmParam('persist', $farm_name);

        if ($persist !~ /^$/) {
            &log_info("Persistence enabled to $persist for farm $farm_name", "farm");
            return 0;
        }
    }

    if ($farm_type =~ /http/) {
        require Relianoid::Farm::HTTP::Service;
        require Relianoid::Config;
        require Relianoid::Lock;

        my $farm_file = &getFarmFile($farm_name);
        my $pathconf  = &getGlobalConfiguration('configdir');
        my $lock_fh   = &openlock("$pathconf/$farm_file", 'r');

        while (<$lock_fh>) {
            if ($_ =~ /[^#]Session/) {
                &log_info("Persistence enabled for farm $farm_name", "farm");
                return 0;
            }
        }
        close $lock_fh;
    }

    return 1;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/Core.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Config;

my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::Core

=cut

=pod

=head1 getFarmType

Get the farm type for a farm

Parameters:

    farmname - Farm name

Returns:

    String - "http", "https", "datalink", "l4xnat", "gslb" or 1 on failure

FIXME: Return undefined, or "", or throw an exception on failure.

=cut

sub getFarmType ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);

    if ($farm_filename =~ /^$farm_name\_proxy.cfg/) {
        require Relianoid::File;

        if (grep { /ListenHTTPS/ } readFileAsArray("$configdir/$farm_filename")) {
            return "https";
        }
        else {
            return "http";
        }
    }
    elsif ($farm_filename =~ /^$farm_name\_datalink.cfg/) {
        return "datalink";
    }
    elsif ($farm_filename =~ /^$farm_name\_l4xnat.cfg/) {
        return "l4xnat";
    }
    elsif ($farm_filename =~ /^$farm_name\_gslb.cfg/) {
        return "gslb";
    }
    elsif ($farm_filename =~ /^$farm_name\_eproxy.yaml/) {
        return "eproxy";
    }

    return 1;
}

=pod

=head1 getFarmFile

Returns farm file name

Parameters:

    farmname - Farm name

Returns:

    String - file name or -1 on failure

=cut

sub getFarmFile ($farm_name) {
    opendir(my $dir, "$configdir") || return -1;

    my @farm_files =
      grep {
             /^$farm_name\_(?:gslb|proxy|datalink|l4xnat)\.cfg$|^$farm_name\_eproxy\.yaml$/
          && !/^$farm_name\_.*guardian\.conf$/
          && !/^$farm_name\_status.cfg$/
      } readdir($dir);

    closedir $dir;

    if (@farm_files) {
        return $farm_files[0];
    }
    else {
        return -1;
    }
}

=pod

=head1 getFarmName

Returns farms configuration filename list

Parameters:

    file - Farm file

Returns:

    String - farm name

=cut

sub getFarmName ($farm_filename) {
    my @filename_split = split("_", $farm_filename);
    return $filename_split[0];
}

=pod

=head1 getFarmList

Returns farms configuration filename list

Parameters: None

Returns:

    Array - List of configuration files

=cut

sub getFarmList() {
    opendir(my $directory, $configdir);
    my @cfgFiles = sort (grep { /\.cfg$|\.yaml$/ } readdir($directory));
    closedir($directory);

    my @files1 = grep { /_proxy\.cfg$/ } @cfgFiles;
    my @files2 = grep { /_datalink\.cfg$/ } @cfgFiles;
    my @files3 = grep { /_l4xnat\.cfg$/ } @cfgFiles;
    my @files4 = grep { /_gslb\.cfg$/ } @cfgFiles;
    my @files5 = grep { /_eproxy\.yaml$/ } @cfgFiles;
    my @files  = (@files1, @files2, @files3, @files4, @files5);

    return @files;
}

=pod

=head1 getFarmsByType

Get all farms of a type

Parameters:

    type - Farm type. The available options are "http", "https", "datalink", "l4xnat" or "gslb"

Returns:

    Array - List of farm name of a type

=cut

sub getFarmsByType ($farm_type) {
    my @farm_names = ();

    opendir(my $dir, "$configdir") || return -1;

    # gslb uses a directory, not a file
    # my @farm_files = grep { /^.*\_.*\.cfg/ && -f "$configdir/$_" } readdir ( $dir );
    my @farm_files = grep { /^.*\_.*\.cfg$/ } readdir($dir);
    closedir $dir;

    for my $farm_filename (@farm_files) {
        next if $farm_filename =~ /.*status.cfg/;
        next if $farm_filename =~ /.*sessions.cfg/;
        my $farm_name = &getFarmName($farm_filename);

        if (&getFarmType($farm_name) eq $farm_type) {
            push(@farm_names, $farm_name);
        }
    }

    return @farm_names;
}

=pod

=head1 getFarmNameList

Returns a list with the farm names.

Parameters: None

Returns:

    array - list of farm names.

=cut

sub getFarmNameList () {
    my @farm_names = ();

    for my $farm_filename (&getFarmList()) {
        push(@farm_names, &getFarmName($farm_filename));
    }

    return @farm_names;
}

=pod

=head1 getFarmExists

Check if a farm exists

Parameters:

    Farm - Farm name

Returns:

    Integer - 1 if the farm exists or 0 if it is not

=cut

sub getFarmExists ($farmname) {
    my $out = 0;
    $out = 1 if (grep { $farmname eq $_ } &getFarmNameList());
    return $out;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/Factory.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::Factory

=cut

=pod

=head1 runFarmCreate

Create a farm

Parameters:

    farm_type - Farm type. The available options are: "http", "https", "datalink", "l4xnat" or "gslb"
    vip       - Virtual IP where the virtual service is listening
    vip_port  - Virtual port where the virtual service is listening
    farm_name - Farm name
    fdev      - Inteface wich uses the VIP. This parameter is only used in datalink farms

Returns:

    Integer - return 0 on success or different of 0 on failure

FIXME:

    Use hash to pass the parameters

=cut

sub runFarmCreate ($farm_type, $vip, $vip_port, $farm_name, $fdev) {
    my $output        = -1;

    my $farm_filename = &getFarmFile($farm_name);

    if ($farm_filename != -1) {
        # the farm name already exists
        $output = -2;
        return $output;
    }

    my $status = 'up';
    if ($farm_type ne 'datalink') {
        require Relianoid::Net::Interface;

        if (!&validatePort($vip, $vip_port, $farm_type, $farm_name)) {
            $status = 'down';
        }
    }

    &log_info("running 'Create' for $farm_name farm $farm_type", "LSLB");

    if ($farm_type =~ /^HTTPS?$/i) {
        require Relianoid::Farm::HTTP::Factory;
        $output = &runHTTPFarmCreate($vip, $vip_port, $farm_name, $farm_type, $status);
    }
    elsif ($farm_type =~ /^eproxy$/) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Factory',
            func   => 'runEproxyFarmCreate',
            args   => [ {vip => $vip, vport => $vip_port, farm_name => $farm_name, farm_type => $farm_type, status => $status} ],
        );
    }
    elsif ($farm_type =~ /^L4xNAT$/i) {
        require Relianoid::Farm::L4xNAT::Factory;
        $output = &runL4FarmCreate($vip, $farm_name, $vip_port, $status);
    }
    elsif ($farm_type =~ /^DATALINK$/i && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Factory',
            func   => 'runDatalinkFarmCreate',
            args   => [ $farm_name, $vip, $fdev ],
        );
    }
    elsif ($farm_type =~ /^GSLB$/i && $eload) {
        $output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Factory',
            func   => 'runGSLBFarmCreate',
            args   => [ $vip, $vip_port, $farm_name, $status ],
        );
    }

    &eload(
        module => 'Relianoid::EE::RBAC::Group::Config',
        func   => 'addRBACUserResource',
        args   => [ $farm_name, 'farms' ],
    ) if $eload;

    return $output;
}

=pod

=head1 runFarmCreateFrom

Function that does a copy of a farm and set the new virtual ip and virtual port.
Apply the same farguardians to the services and the same ipds rules.

Parameters:

    params - hash reference. The hash has to contain the following keys:

    profile:   is the type of profile is going to be copied
    farmname:  the name of the new farm
    copy_from: it is the name of the farm from is copying
    vip:       the new virtual ip for the new farm
    vport:     the new virtual port for the new farm. This parameters is skipped in datalink farms
    interface: it is the interface for the new farm. This parameter is for datalink farms

Returns:

    Integer - Error code: return 0 on success or another value on failure

=cut

sub runFarmCreateFrom ($params) {
    my $err = 0;

    require Relianoid::Lock;

    # lock farm
    my $lock_file = &getLockFile($params->{farmname});
    my $lock_fh   = &openlock($lock_file, 'w');

    # add ipds rules
    my $ipds;
    if ($eload) {
        $ipds = &eload(
            module => 'Relianoid::EE::IPDS::Core',
            func   => 'getIPDSfarmsRules',
            args   => [ $params->{copy_from} ],
        );

        # they doesn't have to be applied, they already are in the config file
        delete $ipds->{waf};
    }

    # create file
    require Relianoid::Farm::Action;
    $err = &copyFarm($params->{copy_from}, $params->{farmname});

    # add fg
    require Relianoid::FarmGuardian;
    if ($params->{profile} eq 'l4xnat') {
        if (my $fg = &getFGFarm($params->{copy_from})) {
            &linkFGFarm($fg, $params->{farmname});
        }
    }
    elsif ($params->{profile} ne 'datalink') {
        my $fg;
        require Relianoid::Farm::Service;
        for my $s (&getFarmServices($params->{farmname})) {
            if (my $fg = &getFGFarm($params->{copy_from}, $s)) {
                &linkFGFarm($fg, $params->{farmname}, $s);
            }
        }
    }

    # unlock farm
    close $lock_fh;

    # modify vport, vip, interface
    if ($params->{profile} ne 'datalink') {
        require Relianoid::Farm::Config;
        $err = &setFarmVirtualConf($params->{vip}, $params->{vport}, $params->{farmname});
    }
    else {
        $err = &eload(
            module => 'Relianoid::EE::Farm::Datalink::Config',
            func   => 'setDatalinkFarmVirtualConf',
            args   => [ $params->{vip}, $params->{interface}, $params->{farmname} ],
        ) if $eload;
    }

    if ($eload and not $err) {
        $err = &eload(
            module => 'Relianoid::EE::IPDS::Core',
            func   => 'addIPDSFarms',
            args   => [ $params->{farmname}, $ipds ],
        );
    }

    if (($params->{profile} eq 'l4xnat') and (!$err)) {
        require Relianoid::Net::Interface;
        if (&validatePort($params->{vip}, $params->{vport}, 'l4xnat', $params->{farmname})) {
            $err = &startL4Farm($params->{farmname});
        }
    }

    return $err;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/HTTP/Action.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::HTTP::Action

=cut

=pod

=head1 _runHTTPFarmStart

Run a HTTP farm

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success or different of 0 on failure

=cut

sub _runHTTPFarmStart ($farm_name, $writeconf = undef) {
    require Relianoid::System;
    require Relianoid::Farm::HTTP::Backend;
    require Relianoid::Farm::Config;

    my $status        = -1;
    my $farm_filename = &getFarmFile($farm_name);
    my $pound         = &getGlobalConfiguration('pound');
    my $piddir        = &getGlobalConfiguration('piddir');

    require Relianoid::Lock;
    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    close $lock_fh;

    &log_info("Checking $farm_name farm configuration", "LSLB");
    return -1 if (&getHTTPFarmConfigIsOK($farm_name));

    my $args = '';
    if ($eload) {
        my $ssyncd_enabled = &getGlobalConfiguration('ssyncd_enabled');
        $args = '-s' if ($ssyncd_enabled eq 'true');
    }

    my $cmd = "$pound $args -f $configdir\/$farm_filename -p $piddir\/$farm_name\_proxy.pid";
    $status = &run_with_env("$cmd");

    if ($status) {
        &log_error("failed: $cmd", "LSLB");
        return $status;
    }

    # set backend at status before that the farm stopped
    &setHTTPFarmBackendStatusFromFile($farm_name);
    &setHTTPFarmBootStatus($farm_name, "up") if ($writeconf);

    return $status;
}

=pod

=head1 _runHTTPFarmStop

Stop a HTTP farm

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success or different of 0 on failure

=cut

sub _runHTTPFarmStop ($farm_name, $writeconf = undef) {
    require Relianoid::FarmGuardian;
    my $time = &getGlobalConfiguration("http_farm_stop_grace_time");

    &runFarmGuardianStop($farm_name, "");

    require Relianoid::Farm::HTTP::Config;
    &setHTTPFarmBootStatus($farm_name, "down") if ($writeconf);

    require Relianoid::Farm::HTTP::Config;
    return 0 if &getHTTPFarmStatus($farm_name) eq "down";

    my $piddir = &getGlobalConfiguration('piddir');

    if (&getHTTPFarmConfigIsOK($farm_name) == 0) {
        my @pids = &getFarmPid($farm_name);

        if (!@pids) {
            &log_warn("Not found pid", "LSLB");
        }
        else {
            my $pid = join(', ', @pids);
            &log_info("Stopping HTTP farm $farm_name with PID $pid", "LSLB");
            kill 9, @pids;
            sleep($time);
        }

        unlink("${piddir}/${farm_name}_proxy.pid") if -e "${piddir}/${farm_name}_proxy.pid";
        unlink("/tmp/${farm_name}_proxy.socket")   if -e "/tmp/${farm_name}_proxy.socket";

        require Relianoid::Lock;
        my $lf = &getLockFile($farm_name);
        unlink $lf if -e $lf;
    }
    else {
        &log_info("Farm $farm_name can't be stopped, check the logs and modify the configuration", "LSLB");
        return 1;
    }

    return 0;
}

=pod

=head1 copyHTTPFarm

Function that does a copy of a farm configuration.
If the flag has the value 'del', the old farm will be deleted.

Parameters:

    farm_name   - Farm name
    newfarmname - New farm name
    del         - It expects a 'del' string to delete the old farm.
                  It is used to copy or rename the farm.

Returns:

    Integer - Error code: return 0 on success or -1 on failure

=cut

sub copyHTTPFarm ($farm_name, $new_farm_name, $del = "") {
    use File::Copy qw(copy);
    require Relianoid::File;

    my $output           = 0;
    my @farm_configfiles = (
        "${configdir}/${farm_name}_status.cfg",  "${configdir}/${farm_name}_proxy.cfg",
        "${configdir}/${farm_name}_Err414.html", "${configdir}/${farm_name}_Err500.html",
        "${configdir}/${farm_name}_Err501.html", "${configdir}/${farm_name}_Err503.html",
        "${configdir}/${farm_name}_sessions.cfg",
    );
    my @new_farm_configfiles = (
        "${configdir}/${new_farm_name}_status.cfg",  "${configdir}/${new_farm_name}_proxy.cfg",
        "${configdir}/${new_farm_name}_Err414.html", "${configdir}/${new_farm_name}_Err500.html",
        "${configdir}/${new_farm_name}_Err501.html", "${configdir}/${new_farm_name}_Err503.html",
        "${configdir}/${new_farm_name}_sessions.cfg",
    );

    my $cfg = $configdir;
    my $oFN = $farm_name;        # old farm name
    my $nFN = $new_farm_name;    # new farm name

    for my $farm_file (@farm_configfiles) {
        my $new_farm_filename = shift @new_farm_configfiles;

        next unless (-e $farm_file);

        copy($farm_file, $new_farm_filename) or $output = -1;
        unlink($farm_file) if ($del eq 'del');

        next unless ($farm_file eq "${configdir}/${farm_name}_proxy.cfg");

        my @lines = readFileAsArray($new_farm_filename);

        # Lines to change:
        #Name		BasekitHTTP
        #Control 	"/tmp/BasekitHTTP_proxy.socket"
        #\tErr414 "/usr/local/relianoid/config/BasekitHTTP_Err414.html"
        #\tErr500 "/usr/local/relianoid/config/BasekitHTTP_Err500.html"
        #\tErr501 "/usr/local/relianoid/config/BasekitHTTP_Err501.html"
        #\tErr503 "/usr/local/relianoid/config/BasekitHTTP_Err503.html"
        #\t#Service "BasekitHTTP"
        #NfMarks (for each backend)

        for my $l (@lines) {
            $l =~ s/^(\s*Name\s+"?)${oFN}/$1${nFN}/;
            $l =~ s/\tErr414 "$cfg\/${oFN}_Err414.html"/\tErr414 "$cfg\/${nFN}_Err414.html"/;
            $l =~ s/\tErr500 "$cfg\/${oFN}_Err500.html"/\tErr500 "$cfg\/${nFN}_Err500.html"/;
            $l =~ s/\tErr501 "$cfg\/${oFN}_Err501.html"/\tErr501 "$cfg\/${nFN}_Err501.html"/;
            $l =~ s/\tErr503 "$cfg\/${oFN}_Err503.html"/\tErr503 "$cfg\/${nFN}_Err503.html"/;
            $l =~ s/\t#Service "${oFN}"/\t#Service "${nFN}"/;
        }

        my $match   = qq(Control \t"\/tmp\/${oFN}_proxy.socket");
        my $replace = qq(Control \t"\/tmp\/${nFN}_proxy.socket");

        for my $l (@lines) {
            $l =~ s/${match}/${replace}/;
        }

        writeFileFromArray($new_farm_filename, \@lines);

        &log_info("Configuration saved in $new_farm_filename file", "LSLB");
    }

    if (-e "\/tmp\/$farm_name\_pound.socket" and $del eq 'del') {
        unlink("\/tmp\/$farm_name\_pound.socket");
    }

    return $output;
}

=pod

=head1 checkFarmHTTPSystemStatus

Checks the process and PID file on the system and fixes the inconsistency.

Parameters:

    farm_name - farm that is going to be modified
    status    - Status to check. Only "down" status.
    fix       - True, do the necessary changes to get the inconsistency fixed. 

Returns:

    None

=cut

sub checkFarmHTTPSystemStatus ($farm_name, $status, $fix = undef) {
    if ($status eq "down") {
        my $pid_file = getHTTPFarmPidFile($farm_name);
        if (-e $pid_file) {
            unlink $pid_file if (defined $fix and $fix eq "true");
        }
        my $pgrep = &getGlobalConfiguration("pgrep");
        require Relianoid::Farm::Core;
        my $farm_file    = &getFarmFile($farm_name);
        my $config_dir   = &getGlobalConfiguration("configdir");
        my $pound        = &getGlobalConfiguration("pound");
        my @pids_running = @{ &logAndGet("$pgrep -f \"$pound (-s )?-f $config_dir/$farm_file -p $pid_file\"", "array") };

        if (@pids_running) {
            kill 9, @pids_running if (defined $fix and $fix eq "true");
        }
    }
    return;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/HTTP/Backend.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

require Relianoid::Netfilter;
require Relianoid::Farm::Config;

my $configdir = &getGlobalConfiguration('configdir');

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::HTTP::Backend

=cut

=pod

=head1 setHTTPFarmServer

Add a new backend to a HTTP service or modify if it exists

Parameters:

    ids       - integer - backend id
    rip       - string  - backend ip
    port      - integer - backend port
    weight    - integer - The weight of this backend (between 1 and 9). Higher weight backends will be used more often than lower weight ones.
    timeout   - integer - Override the global time out for this backend
    farm_name - string  - Farm name
    service   - string  - service name
    priority  - integer - Optional. The priority of this backend (greater than 1). Lower value indicates higher priority

Returns: integer - Error code - non-zero when there is an error.

=cut

sub setHTTPFarmServer ($ids, $rip, $port, $weight, $timeout, $farm_name, $service, $priority = 1) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    $priority = 1 if (not defined $priority) or $priority eq '';
    $priority = 1 unless ($priority == 1 || $priority == 2);

    require Relianoid::Lock;
    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @contents, 'Tie::File', "${configdir}/${farm_filename}";

    if ($ids ne "") {
        my $index_count = -1;
        my $i           = -1;
        my $sw          = 0;

        for my $line (@contents) {
            $i++;

            #search the service to modify
            if ($line =~ /^\s*Service "$service"/) {
                $sw = 1;
            }

            if ($line =~ /^\s*(BackEnd|Emergency)/ && $sw) {
                $index_count++;

                if ($index_count == $ids) {
                    #server for modify $ids;
                    #HTTPS
                    if ($line =~ /^\s*BackEnd/ && $priority == 2) {
                        $contents[$i] = "\t\tEmergency";
                    }
                    elsif ($line =~ /^\s*Emergency/ && $priority == 1) {
                        $contents[$i] = "\t\tBackEnd";
                    }

                    my $httpsbe = &getHTTPFarmVS($farm_name, $service, "httpsbackend");

                    if ($httpsbe eq "true") {
                        #add item
                        $i++;
                    }

                    $output             = 0;
                    $contents[ $i + 1 ] = "\t\t\tAddress $rip";
                    $contents[ $i + 2 ] = "\t\t\tPort $port";

                    my $p_m = 0;

                    if ($contents[ $i + 3 ] =~ /^\s*TimeOut/) {
                        $contents[ $i + 3 ] = "\t\t\tTimeOut $timeout";
                        &log_info("Modified current timeout", "LSLB");
                    }

                    if ($contents[ $i + 4 ] =~ /^\s*Priority/) {
                        $contents[ $i + 4 ] = "\t\t\tPriority $weight";
                        splice @contents, $i + 4, 1, if ($priority == 2);
                        &log_info("Modified current priority", "LSLB");
                        $p_m = 1;
                    }

                    if ($contents[ $i + 3 ] =~ /^\s*Priority/) {
                        $contents[ $i + 3 ] = "\t\t\tPriority $weight";
                        splice @contents, $i + 3, 1, if ($priority == 2);
                        $p_m = 1;
                    }

                    #delete item
                    if (!defined $timeout || $timeout =~ /^$/) {
                        if ($contents[ $i + 3 ] =~ /^\s*TimeOut/) {
                            splice @contents, $i + 3, 1,;
                        }
                    }

                    if (!defined $weight || $weight =~ /^$/) {
                        if ($contents[ $i + 3 ] =~ /^\s*Priority/) {
                            splice @contents, $i + 3, 1,;
                        }
                        if ($contents[ $i + 4 ] =~ /^\s*Priority/) {
                            splice @contents, $i + 4, 1,;
                        }
                    }

                    #new item
                    if (   defined $timeout
                        && $timeout !~ /^$/
                        && ($contents[ $i + 3 ] =~ /^\s*End/ || $contents[ $i + 3 ] =~ /^\s*Priority/))
                    {
                        splice @contents, $i + 3, 0, "\t\t\tTimeOut $timeout";
                    }

                    if (   defined $weight
                        && $p_m eq 0
                        && $weight !~ /^$/
                        && ($contents[ $i + 3 ] =~ /^\s*End/ || $contents[ $i + 4 ] =~ /^\s*End/))
                    {
                        if ($contents[ $i + 3 ] =~ /^\s*TimeOut/) {
                            splice @contents, $i + 4, 0, "\t\t\tPriority $weight" if ($priority == 1);
                        }
                        else {
                            splice @contents, $i + 3, 0, "\t\t\tPriority $weight" if ($priority == 1);
                        }
                    }
                }
            }
        }
    }
    else {
        #add new server
        my $nsflag     = "true";
        my $index      = -1;
        my $backend    = 0;
        my $be_section = -1;

        for my $line (@contents) {
            $index++;

            if ($be_section == 1 && $line =~ /^\s*Address/) {
                $backend++;
            }

            if ($line =~ /^\s*Service \"$service\"/ && $be_section == -1) {
                $be_section++;
            }

            if ($line =~ /^\s*#BackEnd/ && $be_section == 0) {
                $be_section++;
            }

            if ($be_section == 1 && $line =~ /^\s*#End/) {
                if ($priority == 1) {
                    splice @contents, $index, 0, "\t\tBackEnd";
                }
                else {
                    splice @contents, $index, 0, "\t\tEmergency";
                }

                $output = 0;
                $index++;

                splice @contents, $index, 0, "\t\t\tAddress $rip";
                my $httpsbe = &getHTTPFarmVS($farm_name, $service, "httpsbackend");

                if ($httpsbe eq "true") {
                    #add item
                    splice @contents, $index, 0, "\t\t\tHTTPS";
                    $index++;
                }

                $index++;
                splice @contents, $index, 0, "\t\t\tPort $port";
                $index++;

                #Timeout?
                if ($timeout) {
                    splice @contents, $index, 0, "\t\t\tTimeOut $timeout";
                    $index++;
                }

                #Priority?
                if ($weight && ($priority == 1)) {
                    splice @contents, $index, 0, "\t\t\tPriority $weight";
                    $index++;
                }

                splice @contents, $index, 0, "\t\tEnd";
                $be_section++;    # Backend Added
            }

            # if backend added then go out of form
        }

        if ($nsflag eq "true") {
            my $idservice = &getFarmVSI($farm_name, $service);

            if ($idservice ne "") {
                &setHTTPFarmBackendStatusFile($farm_name, $backend, "active", $idservice);
            }
        }
    }

    untie @contents;
    close $lock_fh;

    return $output;
}

=pod

=head1 runHTTPFarmServerDelete

Delete a backend in a HTTP service

Parameters:

    ids       - backend id to delete it
    farm_name - Farm name
    service   - service name where is the backend

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub runHTTPFarmServerDelete ($ids, $farm_name, $service) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;
    my $i             = -1;
    my $j             = -1;
    my $sw            = 0;
    my $dec_mark;
    my $farm_ref = getFarmStruct($farm_name);

    require Relianoid::Lock;
    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @contents, 'Tie::File', "$configdir\/$farm_filename";

    for my $line (@contents) {
        $i++;

        if ($line =~ /^\s*Service \"$service\"/) {
            $sw = 1;
        }

        if ($line =~ /^\s*(BackEnd|Emergency)/ && $sw) {
            $j++;

            if ($j == $ids) {
                splice @contents, $i, 1,;
                $output = 0;

                while ($contents[$i] !~ /^\s*End/) {
                    splice @contents, $i, 1,;
                }

                splice @contents, $i, 1,;
            }
        }
    }
    untie @contents;

    close $lock_fh;

    if ($output != -1) {
        &runRemoveHTTPBackendStatus($farm_name, $ids, $service);
    }

    return $output;
}

=pod

=head1 getHTTPFarmBackendStatusCtl

Get status of a HTTP farm and its backends, sessions can be not included

Parameters:

    farm_name - Farm name
    sessions  - "true" show sessions info. "false" sessions are not shown.

Returns:

    array - return the output of poundctl command for a farm

=cut

sub getHTTPFarmBackendStatusCtl ($farm_name, $sessions = undef) {
    my $poundctl = &getGlobalConfiguration('poundctl');

    my $sessions_option = "-C";
    if (defined $sessions and $sessions = "true") {
        $sessions_option = "";
    }
    return @{ &logAndGet("$poundctl $sessions_option -c /tmp/$farm_name\_proxy.socket", "array") };
}

=pod

=head1 getHTTPFarmBackends

Return a list with all backends in a service and theirs configuration

Parameters:

    farmname     - Farm name
    service      - Service name
    param_status - "true" or "false" to indicate to get backend status.

Returns:

    array ref - Each element in the array it is a hash ref to a backend.
                the array index is the backend id

=cut

sub getHTTPFarmBackends ($farmname, $service, $param_status = undef) {
    require Relianoid::Farm::HTTP::Service;

    my $backendsvs = &getHTTPFarmVS($farmname, $service, "backends");

    my @be = split("\n", $backendsvs);
    my @be_status;
    my @out_ba;
    my $backend_ref;

    if (not $param_status or $param_status eq "true") {
        @be_status = @{ &getHTTPFarmBackendsStatus($farmname, $service) };
    }

    for my $subl (@be) {
        my @subbe = split(' ', $subl);
        my $id    = $subbe[1] + 0;

        my $ip   = $subbe[3];
        my $port = $subbe[5] + 0;
        my $tout = $subbe[7];
        my $prio = $subbe[9];
        my $weig = $subbe[11];

        $tout = $tout eq '-' ? undef : $tout + 0;
        $prio = $prio eq '-' ? undef : $prio + 0;
        $weig = $weig eq '-' ? undef : $weig + 0;

        my $status = "undefined";
        if (not $param_status or $param_status eq "true") {
            $status = $be_status[$id] if $be_status[$id];
        }

        $backend_ref = {
            id       => $id,
            ip       => $ip,
            port     => $port + 0,
            timeout  => $tout,
            weight   => $prio,
            priority => $weig,
        };

        if (not $param_status or $param_status eq "true") {
            $backend_ref->{status} = $status;
        }

        push @out_ba, $backend_ref;
        $backend_ref = undef;
    }

    return \@out_ba;
}

=pod

=head1 getHTTPFarmBackendsStatus

Get the status of all backends in a service. The possible values are:

    up         - The farm is in up status and the backend is OK.
    down       - The farm is in up status and the backend is unreachable
    maintenace - The backend is in maintenance mode.
    undefined  - The farm is in down status and backend is not in maintenance mode.

Parameters:

    farm_name - Farm name
    service - Service name

Returns:

    Array ref - the index is backend index, the value is the backend status

=cut

#ecm possible bug here returns 2 values instead of 1 (1 backend only)
sub getHTTPFarmBackendsStatus ($farm_name, $service) {
    require Relianoid::Farm::Base;

    my @status;
    my $farmStatus = &getFarmStatus($farm_name);
    my $stats;

    if ($farmStatus eq "up") {
        require Relianoid::Farm::HTTP::Backend;
        $stats = &getHTTPFarmBackendsStatusInfo($farm_name);
    }

    require Relianoid::Farm::HTTP::Service;

    my $backendsvs = &getHTTPFarmVS($farm_name, $service, "backends");
    my @be         = split("\n", $backendsvs);
    my $id         = 0;

    # @be is used to get size of backend array
    for (@be) {
        my $backendstatus = &getHTTPBackendStatusFromFile($farm_name, $id, $service);
        if ($backendstatus ne "maintenance") {
            if ($farmStatus eq "up") {
                $backendstatus = $stats->{$service}{backends}[$id]->{status};
            }
            else {
                $backendstatus = "undefined";
            }
        }
        push @status, $backendstatus;
        $id = $id + 1;
    }

    return \@status;
}

=pod

=head1 setHTTPFarmBackendStatus

Set backend status for an http farm and stops traffic to that backend when needed.

Parameters:

    farm_name          - Farm name
    service            - Service name
    backend_index      - Backend index
    status             - Backend status. The possible values are: "up", "maintenance" or "fgDOWN".
    cutmode            - "cut" to remove sessions for such backend
    backends_info_ref  - array ref including status and prio of all backends of the service.

Returns:

    hash reference

    $error_ref->{code}

        0 on success
        1 on failure changing status,
        2 on failure removing sessions.

    $error_ref->{desc} - error message.

=cut

sub setHTTPFarmBackendStatus ($farm_name, $service, $backend_index, $status, $cutmode, $backends_info_ref = undef) {
    require Relianoid::Farm::HTTP::Service;
    require Relianoid::Farm::HTTP::Config;

    my $socket_file       = &getHTTPFarmSocket($farm_name);
    my $service_id        = &getFarmVSI($farm_name, $service);
    my $error_ref->{code} = -1;
    my $output;

    $cutmode = "" if &getHTTPFarmVS($farm_name, $service, "sesstype") eq "";

    my $poundctl = &getGlobalConfiguration('poundctl');
    if ($status eq 'maintenance' or $status eq 'fgDOWN') {
        $output = &logAndRun("$poundctl -c $socket_file -b 0 $service_id $backend_index");
        if ($output) {
            my $msg = "Backend '$backend_index' in service '$service' of farm '$farm_name' cannot be disabled";
            $error_ref->{code} = 1;
            $error_ref->{desc} = $msg;
            return $error_ref;
        }
        else {
            $error_ref->{code} = 0;
        }
        &setHTTPFarmBackendStatusFile($farm_name, $backend_index, $status, $service_id);
        if ($cutmode eq 'cut') {
            $output = &setHTTPFarmBackendsSessionsRemove($farm_name, $service, $backend_index);
            if ($output) {
                my $msg = "Sessions for backend '$backend_index' in service '$service' of farm '$farm_name' were not deleted.";
                &log_error($msg, "LSLB");
                $error_ref->{code} = 2;
                $error_ref->{desc} = $msg;
                return $error_ref;
            }
        }
    }
    elsif ($status eq 'up') {
        $output = &logAndRun("$poundctl -c $socket_file -B 0 $service_id $backend_index");
        if ($output) {
            my $msg = "Backend '$backend_index' in service '$service' of farm '$farm_name' cannot be enabled";
            $error_ref->{code} = 1;
            $error_ref->{desc} = $msg;
            return $error_ref;
        }
        else {
            $error_ref->{code} = 0;
        }
        &setHTTPFarmBackendStatusFile($farm_name, $backend_index, 'active', $service_id);
    }

    return $error_ref;
}

=pod

=head1 getHTTPBackendStatusFromFile

Function that return if a l7 proxy backend is active, down by farmguardian or it's in maintenance mode

Parameters:

    farm_name - Farm name
    backend  - backend id
    service  - service name

Returns:

    scalar - return backend status: "maintentance", "fgDOWN", "active" or -1 on failure

=cut

sub getHTTPBackendStatusFromFile ($farm_name, $backend, $service) {
    require Relianoid::Farm::HTTP::Service;

    my $index;
    my $stfile = "$configdir\/$farm_name\_status.cfg";

    # if the status file does not exist the backend is ok
    my $output = "active";

    if (!-e $stfile) {
        return $output;
    }

    $index = &getFarmVSI($farm_name, $service);

    if (open(my $fh, '<', $stfile)) {
        my @lines = <$fh>;
        close $fh;

        for my $line (@lines) {
            #service index
            if ($line =~ /\ 0\ ${index}\ ${backend}/) {
                if ($line =~ /maintenance/) {
                    $output = "maintenance";
                }
                elsif ($line =~ /fgDOWN/) {
                    $output = "fgDOWN";
                }
                else {
                    $output = "active";
                }
            }
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmBackendStatusFile

Function that save in a file the backend status (maintenance or not)

Parameters:

    farm_name   - Farm name
    backend     - Backend id
    status      - backend status to save in the status file
    idsv        - Service id

Returns: Nothing

FIXME:

    Not return anything, do error control

=cut

sub setHTTPFarmBackendStatusFile ($farm_name, $backend, $status, $idsv) {
    require Tie::File;

    my $statusfile = "${configdir}/${farm_name}_status.cfg";
    my $changed    = "false";

    unless (-e $statusfile) {
        my $poundctl = &getGlobalConfiguration('poundctl');
        my @run      = @{ &logAndGet("${poundctl} -C -c /tmp/${farm_name}_proxy.socket", "array") };
        my @sw;
        my @bw;
        my @statusfile_ln;

        for my $line (@run) {
            if ($line =~ /\.\ Service\ /) {
                @sw = split("\ ", $line);
                $sw[0] =~ s/\.//g;
                chomp $sw[0];
            }
            if ($line =~ /\.\ Backend\ /) {
                @bw = split("\ ", $line);
                $bw[0] =~ s/\.//g;
                chomp $bw[0];
                if ($bw[3] eq "active") {
                    #~ print FW "-B 0 $sw[0] $bw[0] active\n";
                }
                else {
                    push(@statusfile_ln, "-b 0 $sw[0] $bw[0] fgDOWN\n");
                }
            }
        }

        open my $fh, '>', $statusfile;
        print $fh join("\n", @statusfile_ln);
        close $fh;
    }

    tie my @filelines, 'Tie::File', "$statusfile";
    my $i = 0;

    for my $linea (@filelines) {
        if ($linea =~ / 0 ${idsv} ${backend}/) {
            if ($status =~ /maintenance/ || $status =~ /fgDOWN/) {
                $linea   = "-b 0 ${idsv} $backend $status";
                $changed = "true";
            }
            else {
                splice(@filelines, $i, 1);
                $changed = "true";
            }
        }
        $i++;
    }

    untie @filelines;

    if ($changed eq "false") {
        open(my $fh, '>>', $statusfile);

        if ($status =~ /maintenance/ || $status =~ /fgDOWN/) {
            print {$fh} "-b 0 ${idsv} $backend $status\n";
        }

        close $fh;
    }

    return;
}

=pod

=head1 setHTTPFarmBackendMaintenance

Function that enable the maintenance mode for backend

Parameters:

    farm_name - Farm name
    backend   - Backend id
    mode      - Maintenance mode, the options are:
                - drain, the backend continues working with the established connections
                - cut, the backend cuts all the established connections
    service   - Service name

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub setHTTPFarmBackendMaintenance ($farm_name, $backend, $mode, $service) {
    my $output = 0;

    &log_info("setting Maintenance mode for $farm_name service $service backend $backend", "LSLB");

    if (&getFarmStatus($farm_name) eq 'up') {
        $output = &setHTTPFarmBackendStatus($farm_name, $service, $backend, 'maintenance', $mode);
    }

    return $output;
}

=pod

=head1 setHTTPFarmBackendNoMaintenance

Function that disable the maintenance mode for backend

Parameters:

    farm_name - Farm name
    backend   - Backend id
    service   - Service name

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub setHTTPFarmBackendNoMaintenance ($farm_name, $backend, $service) {
    my $output = 0;

    &log_info("setting Disabled maintenance mode for $farm_name service $service backend $backend", "LSLB");

    if (&getFarmStatus($farm_name) eq 'up') {
        $output = &setHTTPFarmBackendStatus($farm_name, $service, $backend, 'up', 'cut');
    }

    return $output;
}

=pod

=head1 runRemoveHTTPBackendStatus

Function that removes a backend from the status file

Parameters:

    farm_name - Farm name
    backend   - Backend id
    service   - Service name

Returns:

    none

FIXME:

    This function returns nothing, do error control

=cut

sub runRemoveHTTPBackendStatus ($farm_name, $backend, $service) {
    require Tie::File;

    my $i          = -1;
    my $serv_index = &getFarmVSI($farm_name, $service);

    tie my @contents, 'Tie::File', "$configdir\/$farm_name\_status.cfg";

    for my $line (@contents) {
        $i++;
        if ($line =~ /0\ ${serv_index}\ ${backend}/) {
            splice @contents, $i, 1,;
            last;
        }
    }
    untie @contents;

    # decrease backend index in greater backend ids
    tie my @filelines, 'Tie::File', "$configdir\/$farm_name\_status.cfg";

    for my $line (@filelines) {
        if ($line =~ /0\ ${serv_index}\ (\d+) (\w+)/) {
            my $backend_index = $1;
            my $status        = $2;
            if ($backend_index > $backend) {
                $backend_index = $backend_index - 1;
                $line          = "-b 0 $serv_index $backend_index $status";
            }
        }
    }
    untie @filelines;

    return;
}

=pod

=head1 setHTTPFarmBackendStatusFromFile

For a HTTP farm, it gets each backend status from status file and set it in ly proxy daemon

Parameters:

    farmname - Farm name

Returns:

    none

FIXME:

    This function returns nothing, do error control

=cut

sub setHTTPFarmBackendStatusFromFile ($farm_name) {
    &log_info("Setting backends status in farm $farm_name", "LSLB");

    my $be_status_filename = "$configdir\/$farm_name\_status.cfg";
    my $poundctl           = &getGlobalConfiguration('poundctl');

    unless (-f $be_status_filename) {
        open my $fh, ">", $be_status_filename;
        close $fh;
        return;
    }

    if (open(my $fh, "<", $be_status_filename)) {
        my @lines = <$fh>;
        close $fh;

        for my $line_aux (@lines) {
            my @line = split("\ ", $line_aux);
            &logAndRun("$poundctl -c /tmp/$farm_name\_proxy.socket $line[0] $line[1] $line[2] $line[3]");
        }
    }
    else {
        my $msg = "Error opening $be_status_filename: $!. Aborting execution.";
        &log_error($msg, "LSLB");
        die $msg;
    }

    return;
}

=pod

=head1 setHTTPFarmBackendsSessionsRemove

Remove all the active sessions enabled to a backend in a given service
Used by farmguardian

Parameters:

    farm_name - Farm name
    service   - Service name
    backendid - Backend id

Returns:

    Integer - Error code: It returns 0 on success or another value if it fails deleting some sessions

=cut

sub setHTTPFarmBackendsSessionsRemove ($farm_name, $service, $backendid) {
    my $serviceid;
    my $err = 0;

    &log_info("Deleting established sessions to a backend $backendid from farm $farm_name in service $service",
        "LSLB");

    $serviceid = &getFarmVSI($farm_name, $service);

    my $poundctl = &getGlobalConfiguration('poundctl');
    my $cmd      = "$poundctl -c /tmp/$farm_name\_proxy.socket -f 0 $serviceid $backendid";
    $err = &logAndRun($cmd);

    return $err;
}

sub getHTTPFarmBackendAvailableID ($farmname, $service) {
    require Relianoid::Farm::HTTP::Service;

    # get an ID for the new backend
    my $backendsvs = &getHTTPFarmVS($farmname, $service, "backends");
    my @be         = split("\n", $backendsvs);
    my $id         = 0;

    for my $subl (@be) {
        my @subbe = split(' ', $subl);
        $id = $subbe[1] + 1;
    }

    if (defined $id && $id eq '') {
        $id = 0;
    }

    return $id;
}

=pod

=head1 getHTTPFarmBackendsStatusInfo

This function take data from proxy and it gives hash format

Parameters:

    farm_name - Farm name

Returns:

    hash ref - hash with backends farm status

    services => [
        "id" => $service_id,            # index in the service array
        "name" => $service_name,
        "backends" => [
            {
                "id" = $backend_id      # index in the backend array
                "ip" = $backend_ip
                "port" = $backend_port
                "status" = $backend_status
                "service" = $service_name
            }
        ]
    ]

=cut

sub getHTTPFarmBackendsStatusInfo ($farm_name) {
    require Relianoid::Farm::Base;
    require Relianoid::Farm::HTTP::Backend;
    require Relianoid::Validate;
    my $status = {};

    my $serviceName;
    my $service_re = &getValidFormat('service');

    # Get l7 proxy info
    #i.e. of poundctl:

    #Requests in queue: 0
    #0. http Listener 185.76.64.223:80 a
    #0. Service "HTTP" active (4)
    #0. Backend 172.16.110.13:80 active (1 0.780 sec) alive (61)
    #1. Backend 172.16.110.14:80 active (1 0.878 sec) alive (90)
    #2. Backend 172.16.110.11:80 active (1 0.852 sec) alive (99)
    #3. Backend 172.16.110.12:80 active (1 0.826 sec) alive (75)
    my @poundctl = &getHTTPFarmBackendStatusCtl($farm_name);

    # Parse l7 proxy info
    for my $line (@poundctl) {
        # i.e.
        #     0. Service "HTTP" active (10)
        if ($line =~ /(\d+)\. Service "($service_re)"/) {
            $serviceName = $2;
        }

        # Parse backend connections
        # i.e.
        #      0. Backend 192.168.100.254:80 active (5 0.000 sec) alive (0)
        if ($line =~ /(\d+)\. Backend (\d+\.\d+\.\d+\.\d+|[a-fA-F0-9:]+):(\d+) (\w+) .+ (\w+)(?: \((\d+)\))?/) {
            my $backendHash = {
                id     => $1 + 0,
                ip     => $2,
                port   => $3 + 0,
                status => $5,
            };

            # Getting real status
            my $backend_disabled = $4;
            if ($backend_disabled eq "DISABLED") {
                require Relianoid::Farm::HTTP::Backend;

                #Checkstatusfile
                $backendHash->{status} = &getHTTPBackendStatusFromFile($farm_name, $backendHash->{id}, $serviceName);

                # not show fgDOWN status
                $backendHash->{status} = "down" if ($backendHash->{status} ne "maintenance");
            }
            elsif ($backendHash->{status} eq "alive") {
                $backendHash->{status} = "up";
            }
            elsif ($backendHash->{status} eq "DEAD") {
                $backendHash->{status} = "down";
            }

            push(@{ $status->{$serviceName}{backends} }, $backendHash);
        }
    }

    return $status;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/HTTP/Config.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

require Relianoid::Config;
require Relianoid::Lock;

my $configdir = &getGlobalConfiguration('configdir');

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::HTTP::Config

=cut

=pod

=head1 setHTTPFarmClientTimeout

Configure the client time parameter for a HTTP farm.

Parameters:

    client   - It is the time in seconds for the client time parameter
    farmname - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmClientTimeout ($client, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";

    my $i_f         = -1;
    my $array_count = @filefarmhttp;
    my $found       = "false";

    while ($i_f <= $array_count && $found eq "false") {
        $i_f++;

        if ($filefarmhttp[$i_f] =~ /^Client/) {
            &log_info("setting 'ClientTimeout $client' for $farm_name farm http", "LSLB");
            $filefarmhttp[$i_f] = "Client\t\t $client";
            $output             = 0;
            $found              = "true";
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return $output;
}

=pod

=head1 getHTTPFarmClientTimeout

Return the client time parameter for a HTTP farm.

Parameters:

    farmname - Farm name

Returns:

    Integer - Return the seconds for client request timeout or -1 on failure.

=cut

sub getHTTPFarmClientTimeout ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;
    close $fh;

    for my $line (@file) {
        if ($line =~ /^Client\s+.*\d+/) {
            my @line_aux = split("\ ", $line);
            $output = $line_aux[1];
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmSessionType

Configure type of persistence

Parameters:

    session  - type of session: nothing, HEADER, URL, COOKIE, PARAM, BASIC or IP
    farmname - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmSessionType ($session, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    &log_info("Setting 'Session type $session' for $farm_name farm http", "LSLB");
    tie my @contents, 'Tie::File', "$configdir\/$farm_filename";

    my $i     = -1;
    my $found = "false";

    for my $line (@contents) {
        $i++;

        if ($session ne "nothing") {
            if ($line =~ "Session") {
                $contents[$i] = "\t\tSession";
                $found = "true";
            }

            if ($found eq "true" && $line =~ "End") {
                $contents[$i] = "\t\tEnd";
                $found = "false";
            }

            if ($line =~ "Type") {
                $contents[$i] = "\t\t\tType $session";
                $output = 0;
                $contents[ $i + 1 ] =~ s/#//g;

                if (   $session eq "URL"
                    || $session eq "COOKIE"
                    || $session eq "HEADER")
                {
                    $contents[ $i + 2 ] =~ s/#//g;
                }
                else {
                    if ($contents[ $i + 2 ] !~ /#/) {
                        $contents[ $i + 2 ] =~ s/^/#/;
                    }
                }
            }
        }

        if ($session eq "nothing") {
            if ($line =~ "Session") {
                $contents[$i] = "\t\t#Session $session";
                $found = "true";
            }

            if ($found eq "true" && $line =~ "End") {
                $contents[$i] = "\t\t#End";
                $found = "false";
            }

            if ($line =~ "TTL") {
                $contents[$i] = "#$contents[$i]";
            }

            if ($line =~ "Type") {
                $contents[$i] = "#$contents[$i]";
                $output = 0;
            }

            if ($line =~ "ID") {
                $contents[$i] = "#$contents[$i]";
            }
        }
    }

    untie @contents;
    close $lock_fh;

    return $output;
}

=pod

=head1 setHTTPFarmBlacklistTime

Configure check time for resurected back-end. It is a HTTP farm paramter.

Parameters:

    checktime - time for resurrected checks
    farmname  - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmBlacklistTime ($blacklist_time, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";

    my $i_f         = -1;
    my $array_count = @filefarmhttp;
    my $found       = "false";

    while ($i_f <= $array_count && $found eq "false") {
        $i_f++;

        if ($filefarmhttp[$i_f] =~ /^Alive/) {
            &log_info("Setting 'Blacklist time $blacklist_time' for $farm_name farm http", "LSLB");

            $filefarmhttp[$i_f] = "Alive\t\t $blacklist_time";
            $output             = 0;
            $found              = "true";
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return $output;
}

=pod

=head1 getHTTPFarmBlacklistTime

Return time for resurrected checks for a HTTP farm.

Parameters:

    farmname - Farm name

Returns:

    integer - seconds for check or -1 on failure.

=cut

sub getHTTPFarmBlacklistTime ($farm_name) {
    my $blacklist_time = -1;
    my $conf_file      = &getFarmFile($farm_name);
    my $conf_path      = "$configdir/$conf_file";

    open(my $fh, '<', $conf_path) or die "Could not open $conf_path: $!";
    while (my $line = <$fh>) {
        next unless $line =~ /^Alive/i;

        my @line_aux = split("\ ", $line);
        $blacklist_time = $line_aux[1];
        last;
    }
    close $fh;

    return $blacklist_time;
}

=pod

=head1 setHTTPFarmHttpVerb

Configure the accepted HTTP verb for a HTTP farm.

The accepted verb sets are:

    0. standardHTTP, for the verbs GET, POST, HEAD.
    1. extendedHTTP, add the verbs PUT, DELETE.
    2. standardWebDAV, add the verbs LOCK, UNLOCK, PROPFIND, PROPPATCH, SEARCH, MKCOL, MOVE, COPY, OPTIONS, TRACE, MKACTIVITY, CHECKOUT, MERGE, REPORT.
    3. MSextWebDAV, add the verbs SUBSCRIBE, UNSUBSCRIBE, NOTIFY, BPROPFIND, BPROPPATCH, POLL, BMOVE, BCOPY, BDELETE, CONNECT.
    4. MSRPCext, add the verbs RPC_IN_DATA, RPC_OUT_DATA.
    5. OptionsHTTP, add the verb OPTIONS to the set extendedHTTP.

Parameters:

    verb     - accepted verbs: 0, 1, 2, 3 or 4
    farmname - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmHttpVerb ($verb, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";

    my $i_f         = -1;
    my $array_count = @filefarmhttp;
    my $found       = "false";

    while ($i_f <= $array_count && $found eq "false") {
        $i_f++;

        if ($filefarmhttp[$i_f] =~ /xHTTP/) {
            &log_info("Setting 'Http verb $verb' for $farm_name farm http", "LSLB");

            $filefarmhttp[$i_f] = "\txHTTP $verb";
            $output             = 0;
            $found              = "true";
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return $output;
}

=pod

=head1 getHTTPFarmHttpVerb

Return the available verb set for a HTTP farm.

The possible verb sets are:

    0. standardHTTP, for the verbs GET, POST, HEAD.
    1. extendedHTTP, add the verbs PUT, DELETE.
    2. standardWebDAV, add the verbs LOCK, UNLOCK, PROPFIND, PROPPATCH, SEARCH, MKCOL, MOVE, COPY, OPTIONS, TRACE, MKACTIVITY, CHECKOUT, MERGE, REPORT.
    3. MSextWebDAV, add the verbs SUBSCRIBE, UNSUBSCRIBE, NOTIFY, BPROPFIND, BPROPPATCH, POLL, BMOVE, BCOPY, BDELETE, CONNECT.
    4. MSRPCext, add the verbs RPC_IN_DATA, RPC_OUT_DATA.
    5. OptionsHTTP, add the verb OPTIONS to the set extendedHTTP.

Parameters:

    farmname - Farm name

Returns:

    integer - return the verb set identier or -1 on failure.

=cut

sub getHTTPFarmHttpVerb ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;
    close $fh;

    for my $line (@file) {
        if ($line =~ /xHTTP/) {
            my @line_aux = split("\ ", $line);
            $output = $line_aux[1];
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmListen

Change a HTTP farm between HTTP and HTTPS listener

Parameters:

    farmname - Farm name
    listener - type of listener: http or https

Returns:

    none

FIXME

    not return nothing, use $found variable to return success or error

=cut

sub setHTTPFarmListen ($farm_name, $listener) {
    my $farm_filename = &getFarmFile($farm_name);
    my $i_f           = -1;

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";
    my $array_count = @filefarmhttp;

    while ($i_f <= $array_count) {
        $i_f++;
        if ($filefarmhttp[$i_f] =~ /^ListenHTTP/ && $listener eq "http") {
            $filefarmhttp[$i_f] = "ListenHTTP";
        }
        if ($filefarmhttp[$i_f] =~ /^ListenHTTP/ && $listener eq "https") {
            $filefarmhttp[$i_f] = "ListenHTTPS";
        }

        if ($filefarmhttp[$i_f] =~ /.*Cert\ \"/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/Cert\ \"/#Cert\ \"/;
        }
        if ($filefarmhttp[$i_f] =~ /.*Cert\ \"/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }

        if ($filefarmhttp[$i_f] =~ /.*Ciphers\ \"/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/Ciphers\ \"/#Ciphers\ \"/;
        }
        if ($filefarmhttp[$i_f] =~ /.*Ciphers\ \"/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }

        # Enable 'Disable TLSv1, TLSv1_1 or TLSv1_2'
        if ($filefarmhttp[$i_f] =~ /.*Disable TLSv1/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/Disable TLSv1/#Disable TLSv1/;
        }
        if ($filefarmhttp[$i_f] =~ /.*Disable TLSv1/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }
        elsif ($filefarmhttp[$i_f] =~ /.*DisableTLSv1\d$/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }

        # Enable 'Disable SSLv3 or SSLv2'
        if ($filefarmhttp[$i_f] =~ /.*Disable SSLv\d$/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/Disable SSLv/#Disable SSLv/;
        }
        if ($filefarmhttp[$i_f] =~ /.*Disable SSLv\d$/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }
        elsif ($filefarmhttp[$i_f] =~ /.*DisableSSLv\d$/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }

        # Enable SSLHonorCipherOrder
        if ($filefarmhttp[$i_f] =~ /.*SSLHonorCipherOrder/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/SSLHonorCipherOrder/#SSLHonorCipherOrder/;
        }
        if ($filefarmhttp[$i_f] =~ /.*SSLHonorCipherOrder/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }

        # Enable StrictTransportSecurity
        if ($filefarmhttp[$i_f] =~ /.*StrictTransportSecurity/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/StrictTransportSecurity/#StrictTransportSecurity/;
        }
        if ($filefarmhttp[$i_f] =~ /.*StrictTransportSecurity/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#//g;
        }

        # Check for ECDHCurve cyphers
        if ($filefarmhttp[$i_f] =~ /ECDHCurve/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/ECDHCurve/\#ECDHCurve/;
        }
        if ($filefarmhttp[$i_f] =~ /ECDHCurve/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/#ECDHCurve/ECDHCurve/;
        }

        # Generate DH Keys if needed
        #my $dhfile = "$configdir\/$farm_name\_dh2048.pem";
        if ($filefarmhttp[$i_f] =~ /^\#*DHParams/ && $listener eq "http") {
            $filefarmhttp[$i_f] =~ s/.*DHParams/\#DHParams/;
        }
        if ($filefarmhttp[$i_f] =~ /^\#*DHParams/ && $listener eq "https") {
            $filefarmhttp[$i_f] =~ s/.*DHParams/DHParams/;
            #$filefarmhttp[$i_f] =~ s/.*DHParams.*/DHParams\t"$dhfile"/;
        }

        if ($filefarmhttp[$i_f] =~ /ZWACL-END/) {
            last;
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return;
}

=pod

=head1 setHTTPFarmRewriteL

Asign a RewriteLocation vaue to a farm HTTP or HTTPS

Parameters:

    farmname - Farm name

    rewritelocation - The options are: disabled, enabled or enabled-backends

Returns: Integer. Error code.

    0 - success
    1 - failure

=cut

sub setHTTPFarmRewriteL ($farm_name, $rewritelocation, $path = undef) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = 1;

    &log_info("setting 'Rewrite Location' for $farm_name to $rewritelocation", "LSLB");

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";
    my $i_f         = -1;
    my $array_count = @filefarmhttp;

    while ($i_f <= $array_count) {
        $i_f++;
        if ($filefarmhttp[$i_f] =~ /RewriteLocation\ .*/) {
            my $directive = "\tRewriteLocation $rewritelocation";
            $directive .= " path" if ($path);
            $filefarmhttp[$i_f] = $directive;
            $output = 0;
            last;
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return $output;
}

=pod

=head1 getHTTPFarmRewriteL

Return RewriteLocation Header configuration HTTP and HTTPS farms

Parameters:

    farmname - Farm name

Returns:

    string - The possible values are: 

    - disabled (default)
    - enabled
    - enabled-backends
    - enabled-path
    - enabled-backends-path

=cut

sub getHTTPFarmRewriteL ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = "disabled";

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;
    close $fh;

    for my $line (@file) {
        if ($line =~ /RewriteLocation\s+(\d)\s*(path)?/) {
            if    ($1 eq 0) { $output = "disabled"; last; }
            elsif ($1 eq 1) { $output = "enabled"; }
            elsif ($1 eq 2) { $output = "enabled-backends"; }

            if (defined $2 and $2 eq 'path') { $output .= "-path"; }
            last;
        }
    }
    return $output;
}

=pod

=head1 setHTTPFarmConnTO

Configure connection time out value to a farm HTTP or HTTPS

Parameters:

    connectionTO - Conection time out in seconds

    farmname - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmConnTO ($tout, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    &log_info("Setting 'ConnTo timeout $tout' for $farm_name farm http", "LSLB");

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";

    my $i_f         = -1;
    my $array_count = @filefarmhttp;
    my $found       = "false";

    while ($i_f <= $array_count && $found eq "false") {
        $i_f++;

        if ($filefarmhttp[$i_f] =~ /^ConnTO.*/) {
            $filefarmhttp[$i_f] = "ConnTO\t\t $tout";
            $output             = 0;
            $found              = "true";
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return $output;
}

=pod

=head1 getHTTPFarmConnTO

Return farm connecton time out value for http and https farms

Parameters:

    farmname - Farm name

Returns:

    integer - return the connection time out or -1 on failure

=cut

sub getHTTPFarmConnTO ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;
    close $fh;

    for my $line (@file) {
        if ($line =~ /^ConnTO/) {
            my @line_aux = split("\ ", $line);
            $output = $line_aux[1];
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmTimeout

Asign a timeout value to a farm

Parameters:

    timeout - Time out in seconds

    farmname - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmTimeout ($timeout, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";

    my $i_f         = -1;
    my $array_count = @filefarmhttp;
    my $found       = "false";

    while ($i_f <= $array_count && $found eq "false") {
        $i_f++;

        if ($filefarmhttp[$i_f] =~ /^Timeout/) {
            $filefarmhttp[$i_f] = "Timeout\t\t $timeout";
            $output             = 0;
            $found              = "true";
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return $output;
}

=pod

=head1 getHTTPFarmTimeout

Return the farm time out

Parameters:

    farmname - Farm name

Returns:

    Integer - Return time out, or -1 on failure.

=cut

sub getHTTPFarmTimeout ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;

    for my $line (@file) {
        if ($line =~ /^Timeout/) {
            my @line_aux = split("\ ", $line);
            $output = $line_aux[1];
        }
    }
    close $fh;

    return $output;
}

=pod

=head1 setHTTPFarmMaxClientTime

Set the maximum time for a client

Parameters:

    track     - Maximum client time
    farm_name - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmMaxClientTime ($track, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;
    my $i_f           = -1;
    my $found         = "false";

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";
    my $array_count = @filefarmhttp;

    while ($i_f <= $array_count && $found eq "false") {
        $i_f++;
        if ($filefarmhttp[$i_f] =~ /TTL/) {
            $filefarmhttp[$i_f] = "\t\t\tTTL $track";
            $output             = 0;
            $found              = "true";
        }
    }

    untie @filefarmhttp;
    close $lock_fh;

    return $output;
}

=pod

=head1 getHTTPFarmGlobalStatus

Get the status of a farm, sessions and its backends through l7 proxy command.

Parameters:

    farmname - Farm name

Returns:

    array - Return poundctl output

=cut

sub getHTTPFarmGlobalStatus ($farm_name) {
    my $poundctl = &getGlobalConfiguration('poundctl');

    return @{ &logAndGet("$poundctl -c \"/tmp/$farm_name\_proxy.socket\"", "array") };
}

=pod

=head1 setHTTPFarmErr

Configure a error message for http error: WAF, 414, 500, 501 or 503

Parameters:

    farm_name - Farm name
    message   - Message body for the error
    error     - Number of error to set, the options are WAF, 414, 500, 501 or 503

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

=cut

sub setHTTPFarmErr ($farm_name, $content, $error) {
    my $output = -1;

    if (not $error) {
        log_error("Setting undefined HTTP Err");
        return $output;
    }

    &log_info("Setting 'Err$error' for $farm_name farm http", "LSLB");

    my $file_path = "${configdir}/${farm_name}_Err${error}.html";

    if (-e $file_path) {
        $output = 0;
        # FIXME
        # $content =~ s/\r\n/\n/;
        # my $fd  = &openlock($file_path, 'w');
        # print $fd "$line\n";
        # close $fd;
        my @err = split("\n", $content);
        my $fd  = &openlock($file_path, 'w');

        for my $line (@err) {
            $line =~ s/\r$//;
            print $fd "$line\n";
        }

        close $fd;
    }

    return $output;
}

=pod

=head1 getHTTPFarmErr

Return the error message for a http error: WAF, 414, 500, 501 or 503

Parameters:

    farmname - Farm name

    error_number - Number of error to set, the options are WAF, 414, 500, 501 or 503

Returns:

    string - Message body for the error

=cut

# Only http function
sub getHTTPFarmErr ($farm_name, $nerr) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output;

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;
    close $fh;

    for my $line (@file) {
        if ($line =~ /Err$nerr/) {
            my @line_aux = split("\ ", $line);
            my $err      = $line_aux[1];
            $err =~ s/"//g;

            if (-e $err) {
                open my $fh, '<', $err;
                while (<$fh>) {
                    $output .= $_;
                }
                close $fh;
                chomp($output);
            }
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmConfErrFile

Comment or uncomment an error config file line from the proxy config file.

Parameters:

    enabled

        - true to uncomment the line ( or to add if it doesn't exist)
        - false to comment the line.

    farmname - Farm name

    err - error file: WAF, 414, 500 ...

Returns:

    None

=cut

sub setHTTPFarmConfErrFile ($enabled, $farm_name, $err) {
    require Relianoid::Farm::Core;
    require Tie::File;

    my $farm_filename = &getFarmFile($farm_name);
    my $i             = -1;
    my $found         = 0;

    tie my @filefarmhttp, 'Tie::File', "$configdir/$farm_filename";

    for my $line (@filefarmhttp) {
        $i++;
        if ($enabled eq "true") {
            if ($line =~ /^.*Err$err/) {
                $line =~ s/#//;
                splice @filefarmhttp, $i, 1, $line;
                $found = 1;
                last;
            }
        }
        else {
            if ($line =~ /^\s*Err$err/) {
                splice @filefarmhttp, $i, 1;
                last;
            }
        }
    }
    if (!$found && $enabled eq "true") {
        $i = -1;
        for my $line (@filefarmhttp) {
            $i++;
            if ($line =~ /^ListenHTTP/) {
                my $directive = "\tErr$err \"$configdir" . "/" . $farm_name . "_Err$err.html\"";
                splice @filefarmhttp, $i + 1, 0, $directive;
                last;
            }
        }
    }
    untie @filefarmhttp;

    return;
}

=pod

=head1 getHTTPFarmBootStatus

Return the farm status at boot relianoid

Parameters:

    farmname - Farm name

Returns:

    scalar - return "down" if the farm not run at boot or "up" if the farm run at boot

=cut

sub getHTTPFarmBootStatus ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = "down";
    my $lastline;

    open my $fh, '<', "${configdir}/${farm_filename}";

    while (my $line = <$fh>) {
        $lastline = $line;
    }
    close $fh;

    if ($lastline !~ /^#down/) {
        $output = "up";
    }

    return $output;
}

=pod

=head1 setHTTPFarmBootStatus

Set the farm status in the configuration file to boot relianoid process

Parameters:

    farm_name - Farm name
    value - Write the boot status "up" or "down"

Returns:

    scalar - return "down" if the farm not run at boot or "up" if the farm run at boot

=cut

sub setHTTPFarmBootStatus ($farm_name, $value) {
    my $farm_filename = &getFarmFile($farm_name);

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @configfile, 'Tie::File', "$configdir\/$farm_filename";
    @configfile = grep { !/^\#down/ } @configfile;

    push @configfile, '#down' if ($value eq "down");

    untie @configfile;
    close $lock_fh;

    return;
}

=pod

=head1 getHTTPFarmStatus

Return current farm process status

Parameters:

    farm_name - Farm name

Returns: string - Whether the process is running, with "up" or "down".

=cut

sub getHTTPFarmStatus ($farm_name) {
    my @pid         = &getHTTPFarmPid($farm_name);
    my $running_pid = @pid ? kill(0, @pid) : undef;

    return (@pid && $running_pid) ? "up" : "down";
}

=pod

=head1 getHTTPFarmSocket

Returns socket for HTTP farm.

This funcion is only used in farmguardian functions.

Parameters:

    farmname - Farm name

Returns:

    String - return socket file

=cut

sub getHTTPFarmSocket ($farm_name) {
    return "/tmp/" . $farm_name . "_proxy.socket";
}

=pod

=head1 getHTTPFarmPid

Returns farm PID

Parameters:

    farmname - Farm name

Returns:

    Integer - return a list with the PIDs of the farm

=cut

sub getHTTPFarmPid ($farm_name) {
    my $piddir  = &getGlobalConfiguration('piddir');
    my $pidfile = "$piddir\/$farm_name\_proxy.pid";

    my @pid = ();
    if (-e $pidfile) {
        open my $fh, '<', $pidfile;
        @pid = <$fh>;
        close $fh;
    }

    return @pid;
}

=pod

=head1 getHTTPFarmPidPound

This function returns all the pids of a process looking for in the ps table.

Parameters:

    farmname - Farm name

Returns:

    array - list of pids

=cut

sub getHTTPFarmPidPound ($farm_name) {
    my $ps        = &getGlobalConfiguration('ps');
    my $grep      = &getGlobalConfiguration('grep_bin');
    my @pid       = ();
    my $farm_file = "$configdir/" . &getFarmFile($farm_name);
    my $cmd       = "$ps aux | $grep '\\-f $farm_file' | $grep -v grep";

    my $out = &logAndGet($cmd, 'array');
    for my $l (@{$out}) {
        if ($l =~ /^\s*[^\s]+\s+([^\s]+)\s/) {
            push @pid, $1;
        }
    }

    return @pid;
}

=pod

=head1 getHTTPFarmPidFile

Returns farm PID File

Parameters:

    farmname - Farm name

Returns:

    String - Pid file path

=cut

sub getHTTPFarmPidFile ($farm_name) {
    my $piddir  = &getGlobalConfiguration('piddir');
    my $pidfile = "$piddir\/$farm_name\_proxy.pid";

    return $pidfile;
}

=pod

=head1 getHTTPFarmVip

Returns farm vip or farm port

Parameters:

    tag - requested parameter. The options are 
          - vip, for virtual ip
          - vipp, for virtual port

    farmname - Farm name

Returns:

    Scalar - return vip or port of farm or -1 on failure

=cut

sub getHTTPFarmVip ($info, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;
    my $i             = 0;
    my $lw            = 0;

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;
    close $fh;

    for my $line (@file) {
        if ($line =~ /^ListenHTTP/) {
            $lw = 1;
        }
        if ($lw) {
            if ($info eq "vip" && $line =~ /^\s+Address\s+(.*)/) {
                $output = $1;
            }

            if ($info eq "vipp" && $line =~ /^\s+Port\s+(.*)/) { $output = $1 }

            last if ($output ne '-1');
        }
        $i++;
    }

    return $output;
}

=pod

=head1 setHTTPFarmVirtualConf

Set farm virtual IP and virtual PORT

Parameters:

    vip - virtual ip
    vip_port - virtual port. If the port is not sent, the port will not be changed
    farm_name - Farm name

Returns:

    Integer - return 0 on success or different on failure

=cut

sub setHTTPFarmVirtualConf ($vip, $vip_port, $farm_name) {
    my $farm_filename = &getFarmFile($farm_name);
    my $stat          = 1;
    my $enter         = 2;
    $enter-- if !$vip_port;

    my $prev_config = getFarmStruct($farm_name);

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @array, 'Tie::File', "$configdir\/$farm_filename";
    my $size = @array;

    for (my $i = 0 ; $i < $size && $enter > 0 ; $i++) {
        if ($array[$i] =~ /Address/) {
            if ($array[$i] =~ s/.*Address\ .*/\tAddress\ $vip/) {
                $stat = 0;
            }
            $enter--;
        }
        if ($array[$i] =~ /Port/ and $vip_port) {
            if ($array[$i] =~ s/.*Port\ .*/\tPort\ $vip_port/) {
                $stat = 0;
            }
            $enter--;
        }
        last if (!$enter);
    }

    untie @array;
    close $lock_fh;

    return $stat;
}

=pod

=head1 getHTTPFarmConfigIsOK

Function that check if the config file is OK.

Parameters:

    farmname - Farm name

Returns:

    scalar - return 0 on success or different on failure

=cut

sub getHTTPFarmConfigIsOK ($farm_name) {
    my $pound         = &getGlobalConfiguration('pound');
    my $farm_filename = &getFarmFile($farm_name);
    my $farm_filepath = "${configdir}/${farm_filename}";
    my $proxy_command = "${pound} -f ${farm_filepath} -c";

    # do not use the function 'logAndGet' here is managing the error output and error code
    my $run = `$proxy_command 2>&1`;
    my $rc  = $?;

    if ($rc or &debug()) {
        if ($rc) {
            &log_error("failed: $proxy_command", "LSLB");
        }
        else {
            &log_debug("running: $proxy_command", "LSLB");
        }

        if ($run =~ / line (\d+)/) {
            my $line_number = $1;
            my $line        = `sed -n '$line_number p' ${farm_filepath}`;

            log_error("${farm_filepath} line $line_number: $line");
        }
    }

    return $rc;
}

=pod

=head1 getHTTPFarmConfigErrorMessage

This function return a message to know what parameter is not correct in a HTTP farm

Parameters:

    farm_name - Farm name

Returns:

    Scalar - If there is an error, it returns a message, else it returns a blank string

=cut

sub getHTTPFarmConfigErrorMessage ($farm_name) {
    my $pound         = &getGlobalConfiguration('pound');
    my $farm_filename = &getFarmFile($farm_name);
    my $farm_filepath = "${configdir}/${farm_filename}";
    my $proxy_command = "${pound} -f ${farm_filepath} -c";

    # do not use the function 'logAndGet' here is managing the error output and error code
    my @run = `$proxy_command 2>&1`;

    return "" if $? == 0;

    chomp @run;
    shift @run if ($run[0] =~ /starting\.\.\./);

    &log_error("Error checking ${farm_filepath}.", "LSLB");
    &log_error($run[0],                            "LSLB");

    $run[0] = $run[1] if ($run[0] =~ /waf/i);
    $run[0] =~ / line (\d+): /;
    my $error_line_number = $1;

    my $current_line_number = 1;
    my $line                = "";
    my $service             = "";

    if ($error_line_number && open my $fh, '<', $farm_filepath) {
        my @lines = <$fh>;
        close $fh;

        for my $current_line (@lines) {
            if ($line =~ /^\s+Service \"(.+)\"/) {
                $service = $1;
            }

            if ($current_line_number == $error_line_number) {
                $line = $current_line;
                last;
            }

            $current_line_number++;
        }
    }

    # examples of error msg
    #	AAAhttps, /usr/local/relianoid/config/AAAhttps_proxy.cfg line 36: unknown directive
    #	AAAhttps, /usr/local/relianoid/config/AAAhttps_proxy.cfg line 40: SSL_CTX_use_PrivateKey_file failed - aborted
    $line =~ /\s*([\w-]+)/;
    my $param = $1;
    my $msg   = "Error in the configuration file";

    # parse line
    if ($param eq "Cert") {
        # return pem name if the pem file is not correct
        $line =~ /([^\/]+)\"$/;
        $msg = "Error loading the certificate: $1" if $1;
    }
    elsif ($param eq "WafRules") {
        # return waf rule name  if the waf rule file is not correct
        $line =~ /([^\/]+)\"$/;
        $msg = "Error loading the WafRuleSet: $1" if $1;
    }
    elsif ($param) {
        $service = "in the service ${service}" if $service;
        $msg     = "Error in the parameter ${param} ${service}";
    }
    elsif (&debug()) {
        $msg = $run[0];
        log_error("${farm_filepath} line $error_line_number: $line");
    }

    &log_debug("Error checking config file: $msg");

    return $msg;
}

=pod

=head1 getHTTPFarmStruct

=cut

sub getHTTPFarmStruct ($farmname, $type = undef) {
    $type //= &getFarmType($farmname);

    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    # Output hash reference or undef if the farm does not exist.
    my $farm;

    return $farm unless $farmname;

    my $vip    = &getFarmVip("vip",  $farmname);
    my $vport  = &getFarmVip("vipp", $farmname) + 0;
    my $status = &getFarmVipStatus($farmname);

    my $connto              = 0 + &getHTTPFarmConnTO($farmname);
    my $alive               = 0 + &getHTTPFarmBlacklistTime($farmname);
    my $timeout             = 0 + &getHTTPFarmTimeout($farmname);
    my $client              = 0 + &getHTTPFarmClientTimeout($farmname);
    my $httpverb            = 0 + &getHTTPFarmHttpVerb($farmname);
    my $rewritelocation     = &getHTTPFarmRewriteL($farmname);
    my $logs                = &getHTTPFarmLogs($farmname);
    my $ignore_100_continue = &getHTTPFarm100Continue($farmname);

    # my $errWAF = &getHTTPFarmErr($farmname, "WAF");
    my $err414 = &getHTTPFarmErr($farmname, "414");
    my $err500 = &getHTTPFarmErr($farmname, "500");
    my $err501 = &getHTTPFarmErr($farmname, "501");
    my $err503 = &getHTTPFarmErr($farmname, "503");

    my @http_verbs = (
        "standardHTTP",      #0
        "extendedHTTP",      #1
        "standardWebDAV",    #2
        "MSextWebDAV",       #3
        "MSRPCext",          #4
        "optionsHTTP",       #5
    );

    $farm = {
        contimeout          => $connto,
        error414            => $err414,
        error500            => $err500,
        error501            => $err501,
        error503            => $err503,
        httpverb            => $http_verbs[$httpverb],
        ignore_100_continue => $ignore_100_continue,
        listener            => $type,
        logs                => $logs,
        name                => $farmname,
        reqtimeout          => $client,
        restimeout          => $timeout,
        resurrectime        => $alive,
        rewritelocation     => $rewritelocation,
        status              => $status,
        vip                 => $vip,
        vport               => $vport,
    };

    # HTTPS parameters
    if ($type eq "https") {
        require Relianoid::Farm::HTTP::HTTPS;

        ## Get farm certificate(s)
        my @cnames = ();

        if ($eload) {
            @cnames = &eload(
                module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext',
                func   => 'getFarmCertificatesSNI',
                args   => [$farmname],
            );
        }
        else {
            @cnames = (&getFarmCertificate($farmname));
        }

        # Make struct array
        my @cert_list;

        for (my $i = 0 ; $i < scalar @cnames ; $i++) {
            push @cert_list, { file => $cnames[$i], id => $i + 1 };
        }

        ## Get cipher set
        my $ciphers = &getFarmCipherSet($farmname);

        # adapt "ciphers" to required interface values
        if ($ciphers eq "cipherglobal") {
            $ciphers = "all";
        }
        elsif ($ciphers eq "cipherssloffloading") {
            $ciphers = "ssloffloading";
        }
        elsif ($ciphers eq "cipherpci") {
            $ciphers = "highsecurity";
        }
        else {
            $ciphers = "customsecurity";
        }

        ## All HTTPS parameters
        $farm->{certlist}        = \@cert_list;
        $farm->{ciphers}         = $ciphers;
        $farm->{cipherc}         = &getFarmCipherList($farmname);
        $farm->{disable_sslv2}   = (&getHTTPFarmDisableSSL($farmname, "SSLv2"))   ? "true" : "false";
        $farm->{disable_sslv3}   = (&getHTTPFarmDisableSSL($farmname, "SSLv3"))   ? "true" : "false";
        $farm->{disable_tlsv1}   = (&getHTTPFarmDisableSSL($farmname, "TLSv1"))   ? "true" : "false";
        $farm->{disable_tlsv1_1} = (&getHTTPFarmDisableSSL($farmname, "TLSv1_1")) ? "true" : "false";
        $farm->{disable_tlsv1_2} = (&getHTTPFarmDisableSSL($farmname, "TLSv1_2")) ? "true" : "false";
    }

    require Relianoid::Farm::Config;
    $farm = &getHTTPFarmHeadersStruct($farmname, $farm);

    return $farm;
}

=pod

=head1 getHTTPFarmVerbCode

=cut

sub getHTTPFarmVerbCode ($verbs_set) {
    # Default output value in case of missing verb set
    my $verb_code;

    my %http_verbs = (
        standardHTTP   => 0,
        extendedHTTP   => 1,
        standardWebDAV => 2,
        MSextWebDAV    => 3,
        MSRPCext       => 4,
        optionsHTTP    => 5,
    );

    if (exists $http_verbs{$verbs_set}) {
        $verb_code = $http_verbs{$verbs_set};
    }

    return $verb_code;
}

######### l7 proxy Config

# Writing

# add header

=pod

=head1 getHTTPAddReqHeader

Get a list with all the http headers are added by the farm

Parameters:

    farm_name - Farm name

Returns:

    Array ref - headers list

=cut

sub getHTTPAddReqHeader ($farm_name) {
    return &getHTTPFarmHeadersStruct($farm_name)->{addheader};
}

=pod

=head1 addHTTPAddheader

The HTTP farm will add the header to the http communication

Parameters:

    farm_name - Farm name
    header - Header to add

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub addHTTPAddheader ($farm_name, $header) {
    require Relianoid::Farm::Core;
    require Relianoid::Lock;

    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index        = 0;
    my $rewrite_flag = 0;    # it is used to add HeadRemove before than AddHeader

    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /[#\s]*RewriteLocation/) {
            $rewrite_flag = 1;
        }
        elsif ($rewrite_flag) {
            # put new headremove before than last one
            if (    $line !~ /^[#\s]*(?:AddHeader|HeadRemove|AddResponseHeader|RemoveResponseHead)\s+"/
                and $rewrite_flag)

            {
                # example: AddHeader "header: to add"
                splice @fileconf, $index, 0, "\tAddHeader \"$header\"";
                $errno = 0;
                last;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not add AddHeader") if $errno;

    return $errno;
}

=pod

=head1 modifyHTTPAddheader

Modify an AddHeader directive from the given farm

Parameters:

    farm_name   - Farm name
    header      - Header to add
    header_ind  - directive index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub modifyHTTPAddheader ($farm_name, $header, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*AddHeader\s+"/) {
            # put new headremove before than last one
            if ($header_ind == $ind) {
                splice @fileconf, $index, 1, "\tAddHeader \"$header\"";
                $errno = 0;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not modify AddHeader") if $errno;

    return $errno;
}

=pod

=head1 delHTTPAddheader

Delete a directive "AddHeader".

Parameters:

    farm_name  - Farm name
    header_ind - Header index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub delHTTPAddheader ($farm_name, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*AddHeader\s+"/) {
            if ($header_ind == $ind) {
                $errno = 0;
                splice @fileconf, $index, 1;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not remove HeadRemove") if $errno;

    return $errno;
}

# head remove

=pod

=head1 getHTTPRemReqHeader

Get a list with all the http headers are added by the farm

Parameters:

    farm_name - Farm name

Returns:

    Array ref - headers list

=cut

sub getHTTPRemReqHeader ($farm_name) {
    return &getHTTPFarmHeadersStruct($farm_name)->{headremove};
}

=pod

=head1 addHTTPHeadremove

Add a directive "HeadRemove". The HTTP farm will remove the header that match with the sentence

Parameters:

    farm_name - Farm name
    header   - Header to add

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub addHTTPHeadremove ($farm_name, $header) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index        = 0;
    my $rewrite_flag = 0;    # it is used to add HeadRemove before than AddHeader
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /[#\s]*RewriteLocation/) {
            $rewrite_flag = 1;
        }
        elsif ($rewrite_flag) {
            # put new headremove after than last one
            if (    $line !~ /^[#\s]*(?:AddHeader|HeadRemove|AddResponseHeader|RemoveResponseHead)\s+"/
                and $rewrite_flag)
            {
                # example: AddHeader "header: to add"
                splice @fileconf, $index, 0, "\tHeadRemove \"$header\"";
                $errno = 0;
                last;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not add HeadRemove") if $errno;

    return $errno;
}

=pod

=head1 modifyHTTPHeadremove

Modify an Headremove directive from the given farm

Parameters:

    farm_name    - Farm name
    header      - Header to add
    header_ind  - directive index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub modifyHTTPHeadremove ($farm_name, $header, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*HeadRemove\s+"/) {
            # put new headremove before than last one
            if ($header_ind == $ind) {
                splice @fileconf, $index, 1, "\tHeadRemove \"$header\"";
                $errno = 0;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not modify HeadRemove") if $errno;

    return $errno;
}

=pod

=head1 delHTTPHeadremove

Delete a directive "HeadRemove".

Parameters:

    farm_name - Farm name
    index    - Header index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub delHTTPHeadremove ($farm_name, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*HeadRemove\s+"/) {
            if ($header_ind == $ind) {
                $errno = 0;
                splice @fileconf, $index, 1;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not remove HeadRemove") if $errno;

    return $errno;
}

# add response header

=pod

=head1 getHTTPAddRespHeader

Get a list with all the http headers that load balancer will add to the backend repsonse

Parameters:

    farm_name - Farm name

Returns:

    Array ref - headers list

=cut

sub getHTTPAddRespHeader ($farm_name) {
    return &getHTTPFarmHeadersStruct($farm_name)->{addresponseheader};
}

=pod

=head1 addHTTPAddRespheader

The HTTP farm will add the header to the http response from the backend to the client

Parameters:

    farm_name - Farm name
    header   - Header to add

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub addHTTPAddRespheader ($farm_name, $header) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index        = 0;
    my $rewrite_flag = 0;    # it is used to add HeadRemove before than AddHeader
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /[#\s]*RewriteLocation/) {
            $rewrite_flag = 1;
        }
        elsif ($rewrite_flag) {
            # put new headremove before than last one
            if (    $line !~ /^[#\s]*(?:AddHeader|HeadRemove|AddResponseHeader|RemoveResponseHead)\s+"/
                and $rewrite_flag)
            {
                # example: AddHeader "header: to add"
                splice @fileconf, $index, 0, "\tAddResponseHeader \"$header\"";
                $errno = 0;
                last;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not add AddResponseHeader") if $errno;

    return $errno;
}

=pod

=head1 modifyHTTPAddRespheader

Modify an AddResponseHeader directive from the given farm

Parameters:

    farm_name   - Farm name
    header      - Header to add
    header_ind  - directive index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub modifyHTTPAddRespheader ($farm_name, $header, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*AddResponseHeader\s+"/) {
            # put new headremove before than last one
            if ($header_ind == $ind) {
                splice @fileconf, $index, 1, "\tAddResponseHeader \"$header\"";
                $errno = 0;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not modify AddResponseHeader") if $errno;

    return $errno;
}

=pod

=head1 delHTTPAddRespheader

Delete a directive "AddResponseHeader from the farm config file".

Parameters:

    farm_name  - Farm name
    header_ind - Header index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub delHTTPAddRespheader ($farm_name, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*AddResponseHeader\s+"/) {
            if ($header_ind == $ind) {
                $errno = 0;
                splice @fileconf, $index, 1;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not remove AddResponseHeader") if $errno;

    return $errno;
}

# remove response header

=pod

=head1 getHTTPRemRespHeader

Get a list with all the http headers that the load balancer will add to the response to the client

Parameters:

    farm_name - Farm name

Returns:

    Array ref - headers list

=cut

sub getHTTPRemRespHeader ($farm_name) {
    return &getHTTPFarmHeadersStruct($farm_name)->{removeresponseheader};
}

=pod

=head1 addHTTPRemRespHeader

Add a directive "HeadResponseRemove". The HTTP farm will remove a reponse
header from the backend that matches with this expression

Parameters:

    farm_name - Farm name
    header    - Header to add

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub addHTTPRemRespHeader ($farm_name, $header) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index        = 0;
    my $rewrite_flag = 0;    # it is used to add HeadRemove before than AddHeader
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /[#\s]*RewriteLocation/) {
            $rewrite_flag = 1;
        }
        elsif ($rewrite_flag) {
            # put new headremove after than last one
            if (    $line !~ /^[#\s]*(?:AddHeader|HeadRemove|AddResponseHeader|RemoveResponseHead)\s+"/
                and $rewrite_flag)
            {
                # example: AddHeader "header: to add"
                splice @fileconf, $index, 0, "\tRemoveResponseHead \"$header\"";
                $errno = 0;
                last;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not add RemoveResponseHead") if $errno;

    return $errno;
}

=pod

=head1 modifyHTTPRemRespHeader

Modify an RemoveResponseHead directive from the given farm

Parameters:

    farm_name     - Farm name
    header        - Header to add
    header_ind    - directive index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub modifyHTTPRemRespHeader ($farm_name, $header, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*RemoveResponseHead\s+"/) {
            # put new headremove before than last one
            if ($header_ind == $ind) {
                splice @fileconf, $index, 1, "\tRemoveResponseHead \"$header\"";
                $errno = 0;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not modify RemoveResponseHead") if $errno;

    return $errno;
}

=pod

=head1 delHTTPRemRespHeader

Delete a directive "HeadResponseRemove".

Parameters:

    farm_name  - Farm name
    header_ind - Header index

Returns:

    Integer - Error code: 0 on success or 1 on failure

=cut

sub delHTTPRemRespHeader ($farm_name, $header_ind) {
    require Relianoid::Farm::Core;
    my $ffile = &getFarmFile($farm_name);
    my $errno = 1;

    require Relianoid::Lock;
    &ztielock(\my @fileconf, "$configdir/$ffile");

    my $index = 0;
    my $ind   = 0;
    for my $line (@fileconf) {
        if ($line =~ /^[#\s]*Service \"/) { last; }
        if ($line =~ /^\s*RemoveResponseHead\s+"/) {
            if ($header_ind == $ind) {
                $errno = 0;
                splice @fileconf, $index, 1;
                last;
            }
            else {
                $ind++;
            }
        }
        $index++;
    }
    untie @fileconf;

    &log_info("Could not remove RemoveResponseHead") if $errno;

    return $errno;
}

=pod

=head1 getHTTPFarmHeadersStruct

It extends the farm struct with parameters exclusive to EE.
If no farm struct was passed to the function, the function will return
a new farm struct with the enterprise fields.

Parameters:

    farmname    - Farm name
    farm struct - Struct with the farm configuration parameters

Returns:

    Hash ref - Farm struct updated with EE parameters

=cut

sub getHTTPFarmHeadersStruct ($farmname, $farm_st = {}) {
    $farm_st->{addheader}            = [];
    $farm_st->{headremove}           = [];
    $farm_st->{addresponseheader}    = [];
    $farm_st->{removeresponseheader} = [];

    my $farm_filename = &getFarmFile($farmname);
    my @lines         = ();

    if (open my $fh, '<', "${configdir}/${farm_filename}") {
        @lines = <$fh>;
        close $fh;
    }

    my $add_req_header_index = 0;
    my $rem_req_header_index = 0;
    my $add_res_header_index = 0;
    my $rem_res_header_index = 0;

    for my $line (@lines) {
        if    ($line =~ /^[#\s]*Service \"/) { last; }
        elsif ($line =~ /^[#\s]*AddHeader\s+"(.+)"/) {
            push @{ $farm_st->{addheader} },
              {
                "id"     => $add_req_header_index++,
                "header" => $1
              };
        }
        elsif ($line =~ /^[#\s]*HeadRemove\s+"(.+)"/) {
            push @{ $farm_st->{headremove} },
              {
                "id"      => $rem_req_header_index++,
                "pattern" => $1
              };
        }
        elsif ($line =~ /^[#\s]*AddResponseHeader\s+"(.+)"/) {
            push @{ $farm_st->{addresponseheader} },
              {
                "id"     => $add_res_header_index++,
                "header" => $1
              };
        }
        elsif ($line =~ /^[#\s]*RemoveResponseHead\s+"(.+)"/) {
            push @{ $farm_st->{removeresponseheader} },
              {
                "id"      => $rem_res_header_index++,
                "pattern" => $1
              };
        }
        elsif ($line =~ /Ignore100Continue (\d).*/) {
            $farm_st->{ignore_100_continue} = ($1 eq '0') ? 'false' : 'true';
        }
        elsif ($line =~ /LogLevel\s+(\d).*/) {
            my $lvl = $1 + 0;
            $farm_st->{logs} = 'true' if ($lvl >= 5);
        }
    }

    return $farm_st;
}

=pod

=head1 moveHeader

Changes the position of a farm header directive.

NOTICE: This function is not currently being used.

Parameters:

    farmname - Farm name
    regex    - Regex to match the directive
    pos      - It is the required position for the rule.
    index    - It is index of the rule in the set

Returns:

    none

=cut

sub moveHeader ($farm_name, $regex, $pos, $index) {
    require Relianoid::Arrays;

    my $farm_filename = &getFarmFile($farm_name);

    require Tie::File;
    tie my @file, 'Tie::File', "$configdir/$farm_filename";

    my $file_index   = 0;
    my $header_index = 0;
    my @headers      = ();
    for my $l (@file) {
        if ($l =~ /^[#\s]*Service \"/) { last; }
        if ($l =~ /^$regex/) {
            $header_index = $file_index unless ($header_index != 0);
            push @headers, $l;
        }
        $file_index++;
    }

    &moveByIndex(\@headers, $index, $pos);

    my $size = scalar @headers;

    splice(@file, $header_index, $size, @headers);

    untie @file;

    return;
}

=pod

=head1 getHTTPFarmLogs

Return the log connection tracking status

Parameters:

    farm_name - Farm name

Returns:

    scalar - The possible values are: 0 on disabled, possitive value on enabled or -1 on failure

=cut

sub getHTTPFarmLogs ($farm_name) {
    my $output = 'false';

    my $farm_filename = &getFarmFile($farm_name);
    my @lines         = ();

    if (open my $fh, '<', "${configdir}/${farm_filename}") {
        @lines = <$fh>;
        close $fh;
    }

    for my $line (@lines) {
        if    ($line =~ /^[#\s]*Service \"/) { last; }
        elsif ($line =~ /LogLevel\s+(\d).*/) {
            my $lvl = $1 + 0;
            $output = 'true' if ($lvl >= 5);
            last;
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmLogs

Enable or disable the log connection tracking for a http farm

Parameters:

    farmname  - Farm name
    action    - The available actions are: "true" to enable or "false" to disable

Returns:

    scalar - The possible values are: 0 on success or -1 on failure

=cut

sub setHTTPFarmLogs ($farm_name, $action) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    my $loglvl;
    $loglvl = ($action eq "true") ? 5 : 0;

    require Relianoid::File;
    my @lines = readFileAsArray("$configdir/$farm_filename");

    my $match_found = 0;
    for my $line (@lines) {
        if ($line =~ s/^LogLevel\s+(\d).*$/LogLevel\t$loglvl/) {
            $match_found = 1;
            $output      = 0;
        }
    }

    if ($match_found) {
        writeFileFromArray("$configdir/$farm_filename", \@lines);
    }
    else {
        &log_error("Error modifying http logs", "LSLB");
    }

    return $output;
}

=pod

=head1 getHTTPFarm100Continue

Return 100 continue Header configuration HTTP and HTTPS farms

Parameters:

    farmname - Farm name

Returns:

    scalar - The possible values are: 0 on disabled, 1 on enabled

=cut

sub getHTTPFarm100Continue ($farm_name) {
    my $output = 'true';

    my $farm_filename = &getFarmFile($farm_name);
    my @lines;

    if (open my $fh, '<', "${configdir}/${farm_filename}") {
        @lines = <$fh>;
        close $fh;
    }

    for my $line (@lines) {
        if    ($line =~ /^[#\s]*Service \"/) { last; }
        elsif ($line =~ /Ignore100Continue (\d).*/) {
            $output = ($1 eq '0') ? 'false' : 'true';
            last;
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarm100Continue

Enable or disable the HTTP 100 continue header

Parameters:

    farm_name  - Farm name
    action    - The available actions are: 1 to enable or 0 to disable

Returns:

    scalar - The possible values are: 0 on success or -1 on failure

=cut

sub setHTTPFarm100Continue ($farm_name, $action) {
    my $farm_filename = &getFarmFile($farm_name);

    require Relianoid::File;
    my @lines = readFileAsArray("$configdir/$farm_filename");

    # check if 100 continue directive exists
    my $match_found = 0;
    for my $line (@lines) {
        if ($line =~ s/^Ignore100Continue\ .*/Ignore100Continue $action/) {
            $match_found = 1;
        }
    }

    if (not $match_found) {
        for my $line (@lines) {
            if ($line =~ /^Control\s/) {
                $line = "$line\nIgnore100Continue $action\n";
                last;
            }
        }
    }

    writeFileFromArray("$configdir/$farm_filename", \@lines);

    return 0;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/HTTP/Factory.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

require Relianoid::Core;

my $eload     = eval { require Relianoid::ELoad };
my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::HTTP::Factory

=cut

=pod

=head1 runHTTPFarmCreate

Create a HTTP farm

Parameters:

    vip - Virtual IP where the virtual service is listening
    vip_port - Virtual port where the virtual service is listening
    farm_name - Farm name
    farm_type - Specify if farm is HTTP or HTTPS
    status - Set the initial status of the farm. The possible values are: 'down' for creating the farm and do not run it or 'up' (default) for running the farm when it has been created

Returns:

    Integer - return 0 on success or different of 0 on failure

=cut

sub runHTTPFarmCreate ($vip, $vip_port, $farm_name, $farm_type, $status = 'up') {
    require Relianoid::Farm::HTTP::Config;
    require Tie::File;
    require File::Copy;
    File::Copy->import();

    my $output = -1;

    #copy template modyfing values
    my $poundtpl        = &getGlobalConfiguration('poundtpl');
    my $proxy_conf_file = "$configdir/${farm_name}_proxy.cfg";
    &log_info("Copying proxy template ($poundtpl) to $proxy_conf_file", "LSLB");
    copy($poundtpl, $proxy_conf_file);

    #modify strings with variables
    tie my @file, 'Tie::File', $proxy_conf_file;

    for my $line (@file) {
        $line =~ s/\[IP\]/$vip/;
        $line =~ s/\[PORT\]/$vip_port/;
        $line =~ s/\[DESC\]/$farm_name/;
        $line =~ s/\[CONFIGDIR\]/$configdir/;
        if ($farm_type eq "HTTPS") {
            $line =~ s/ListenHTTP/ListenHTTPS/;
            $line =~ s/#Cert/Cert/;
        }
    }
    untie @file;

    #create files with personalized errors
    my $f_err;

    open $f_err, '>', "${configdir}/${farm_name}_Err414.html";
    print $f_err "Request URI is too long.\n";
    close $f_err;

    open $f_err, '>', "${configdir}/${farm_name}_Err500.html";
    print $f_err "An internal server error occurred. Please try again later.\n";
    close $f_err;

    open $f_err, '>', "${configdir}/${farm_name}_Err501.html";
    print $f_err "This method may not be used.\n";
    close $f_err;

    open $f_err, '>', "${configdir}/${farm_name}_Err503.html";
    print $f_err "The service is not available. Please try again later.\n";
    close $f_err;

    #create session file
    open $f_err, '>', "${configdir}/${farm_name}_sessions.cfg";
    close $f_err;

    &setHTTPFarmLogs($farm_name, 'false');

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Farm::HTTP::Ext',
            func   => 'addHTTPFarmWafBodySize',
            args   => [$farm_name],
        );
    }

    $output = &getHTTPFarmConfigIsOK($farm_name);

    if ($output) {
        require Relianoid::Farm::Action;
        &runFarmDelete($farm_name);
        return 1;
    }

    #run farm
    require Relianoid::System;
    my $pound  = &getGlobalConfiguration('pound');
    my $piddir = &getGlobalConfiguration('piddir');

    if ($status eq 'up') {
        my $cmd = "${pound} -f ${configdir}/${farm_name}_proxy.cfg -p ${piddir}/${farm_name}_proxy.pid";
        &log_info("Running: ${cmd}", "LSLB");

        $output = &run_with_env($cmd);
    }
    else {
        $output = &setHTTPFarmBootStatus($farm_name, 'down');
    }

    return $output;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/HTTP/HTTPS.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload     = eval { require Relianoid::ELoad };
my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::HTTP::HTTPS

=cut

=pod

=head1 getFarmCertificate

Return the certificate applied to the farm

Parameters:

    farm_name - Farm name

Returns:

    scalar - Return the certificate file, or -1 on failure.

FIXME:

    If are there more than one certificate, only return the last one

=cut

sub getFarmCertificate ($farm_name) {
    my $output = -1;

    my $farm_filename = &getFarmFile($farm_name);
    open my $fh, '<', "${configdir}/${farm_filename}";
    my @content = <$fh>;
    close $fh;

    for my $line (@content) {
        if ($line =~ /Cert/ && $line !~ /\#.*Cert/) {
            my @partline = split('\"', $line);
            @partline = split("\/", $partline[1]);
            my $lfile = @partline;
            $output = $partline[ $lfile - 1 ];
        }
    }

    return $output;
}

=pod

=head1 setFarmCertificate

Configure a certificate for a HTTP farm

Parameters:

    cert_file - certificate file name
    farm_name - Farm name

Returns:

    Integer - Error code: 0 on success, or -1 on failure.

FIXME:

    There is other function for this action: setFarmCertificateSNI

=cut

sub setFarmCertificate ($cert_file, $farm_name) {
    require Tie::File;
    require Relianoid::Lock;
    require Relianoid::Farm::HTTP::Config;

    my $farm_filename = &getFarmFile($farm_name);
    my $lock_file     = &getLockFile($farm_name);
    my $lock_fh       = &openlock($lock_file, 'w');
    my $output        = -1;

    my $cert_dir  = &getGlobalConfiguration('certdir');
    my $cert_path = "${cert_dir}/${cert_file}";

    &log_info("Setting 'Certificate ${cert_file}' for ${farm_name} farm https", "LSLB");

    require Relianoid::Certificate;
    my $error = &checkCertPEMValid($cert_path);

    if ($error->{code}) {
        &log_error("'Certificate ${cert_file}' for ${farm_name} farm https is not valid", "LSLB");
        return $output;
    }

    tie my @array, 'Tie::File', "${configdir}/${farm_filename}";

    for my $line (@array) {
        if ($line =~ /Cert "/) {
            $line =~ s!.*Cert .*!\tCert "${cert_path}"!g;
            $output = 0;
        }
    }

    untie @array;
    close $lock_fh;

    return $output;
}

=pod

=head1 setFarmCipherList

Set Farm Ciphers value

Parameters:

    farmname - Farm name

    ciphers - The options are: cipherglobal, cipherpci, cipherssloffloading or ciphercustom

    cipherc - Cipher custom, this field is used when ciphers is ciphercustom

Returns:

    Integer - return 0 on success or -1 on failure

=cut

sub setFarmCipherList ($farm_name, $ciphers, $cipherc) {
    require Tie::File;
    require Relianoid::Lock;
    require Relianoid::Farm::HTTP::Config;

    my $farm_filename = &getFarmFile($farm_name);
    my $lock_file     = &getLockFile($farm_name);
    my $lock_fh       = &openlock($lock_file, 'w');
    my $output        = -1;

    tie my @array, 'Tie::File', "$configdir/$farm_filename";

    for my $line (@array) {
        # takes the first Ciphers line only
        next if ($line !~ /Ciphers/);

        if ($ciphers eq "cipherglobal") {
            $line =~ s/#//g;
            $line   = "\tCiphers \"ALL\"";
            $output = 0;
        }
        elsif ($ciphers eq "cipherpci") {
            my $cipher_pci = &getGlobalConfiguration('cipher_pci');
            $line =~ s/#//g;
            $line   = "\tCiphers \"$cipher_pci\"";
            $output = 0;
        }
        elsif ($ciphers eq "ciphercustom") {
            $cipherc = 'DEFAULT' if not defined $cipherc;
            $line =~ s/#//g;
            $line   = "\tCiphers \"$cipherc\"";
            $output = 0;
        }
        elsif ($ciphers eq "cipherssloffloading") {
            my $cipher = &getGlobalConfiguration('cipher_ssloffloading');
            $line   = "\tCiphers \"$cipher\"";
            $output = 0;
        }

        # default cipher
        else {
            $line =~ s/#//g;
            $line   = "\tCiphers \"ALL\"";
            $output = 0;
        }

        last;
    }

    untie @array;
    close $lock_fh;

    return $output;
}

=pod

=head1 getFarmCipherList

Get Cipher value defined in l7 proxy configuration file

Parameters:

    farmname - Farm name

Returns:

    scalar - return a string with cipher value or -1 on failure
=cut

sub getFarmCipherList ($farm_name) {
    my $output = -1;

    my $farm_filename = &getFarmFile($farm_name);

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @content = <$fh>;
    close $fh;

    for my $line (@content) {
        next if ($line !~ /Ciphers/);

        $output = (split('\"', $line))[1];

        last;
    }

    return $output;
}

=pod

=head1 getFarmCipherSet

Get Ciphers value defined in l7 proxy configuration file.

Parameters:

    farmname - Farm name

Returns:

    scalar - return a string with cipher set (ciphers) or -1 on failure

    Possible values are:

        cipherglobal
        cipherpci
        cipherssloffloading
        ciphercustom

=cut

sub getFarmCipherSet ($farm_name) {
    my $output = -1;

    my $cipher_list = &getFarmCipherList($farm_name);

    if ($cipher_list eq 'ALL') {
        $output = "cipherglobal";
    }
    elsif ($cipher_list eq &getGlobalConfiguration('cipher_pci')) {
        $output = "cipherpci";
    }
    elsif ($eload
        && $cipher_list eq &getGlobalConfiguration('cipher_ssloffloading'))
    {
        $output = "cipherssloffloading";
    }
    else {
        $output = "ciphercustom";
    }

    return $output;
}

=pod

=head1 getHTTPFarmDisableSSL

Get if a security protocol version is enabled or disabled in a HTTPS farm

Parameters:

    farm_name - Farm name
    protocol - SSL or TLS protocol get status (disabled or enabled)

Returns:

    Integer - 1 on disabled, 0 on enabled or -1 on failure

=cut

sub getHTTPFarmDisableSSL ($farm_name, $protocol) {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    open my $fh, '<', "${configdir}/${farm_filename}" or return $output;
    $output = 0;    # if the directive is not in config file, it is disabled
    my @file = <$fh>;
    close $fh;

    for my $line (@file) {
        if ($line =~ /^\tDisable $protocol$/) {
            $output = 1;
            last;
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmDisableSSL

Enable or disable a security protocol for a HTTPS farm

Parameters:

    farm_name - Farm name
    protocol - SSL or TLS protocol to disable/enable: SSLv2|SSLv3|TLSv1|TLSv1_1|TLSv1_2
    action   - The available actions are: 1 to disable or 0 to enable

Returns:

    Integer - Error code: 0 on success or -1 on failure

=cut

sub setHTTPFarmDisableSSL ($farm_name, $protocol, $action) {
    require Tie::File;
    require Relianoid::Lock;
    require Relianoid::Farm::HTTP::Config;

    my $farm_filename = &getFarmFile($farm_name);
    my $lock_file     = &getLockFile($farm_name);
    my $lock_fh       = &openlock($lock_file, 'w');
    my $output        = -1;

    tie my @file, 'Tie::File', "$configdir/$farm_filename";

    if ($action == 1) {
        for my $line (@file) {
            if ($line =~ /Ciphers\ .*/) {
                $line = "$line\n\tDisable $protocol";
                last;
            }
        }
        $output = 0;
    }
    else {
        my $it = -1;
        for my $line (@file) {
            $it = $it + 1;
            last if ($line =~ /Disable $protocol$/);
        }

        # Remove line only if it is found (we haven't arrive at last line).
        splice(@file, $it, 1) if (($it + 1) != scalar @file);
        $output = 0;
    }

    untie @file;
    close $lock_fh;

    return $output;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/HTTP/Service.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload     = eval { require Relianoid::ELoad };
my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::HTTP::Service

=cut

=pod

=head1 setFarmHTTPNewService

Create a new Service in a HTTP farm

Parameters:

    farm_name - Farm name

    service - Service name

Returns:

    Integer - Error code: 0 on success, other value on failure

FIXME:

    This function returns nothing, do error control

=cut

sub setFarmHTTPNewService ($farm_name, $service) {
    require Tie::File;
    require Relianoid::Lock;
    require Relianoid::File;
    require Relianoid::Farm::Config;

    my $output = -1;

    #first check if service name exist
    if ($service =~ /(?=)/ && $service =~ /^$/) {
        #error 2 eq $service is empty
        $output = 2;
        return $output;
    }

    if (!grep { /^\s*Service "$service"/ } readFileAsArray("$configdir/$farm_name\_proxy.cfg")) {
        #create service
        my @newservice;
        my $sw       = 0;
        my $count    = 0;
        my $poundtpl = &getGlobalConfiguration('poundtpl');

        tie my @poundtpl, 'Tie::File', "$poundtpl";

        for my $line (@poundtpl) {
            if ($line =~ /Service \"\[DESC\]\"/) {
                $sw = 1;
            }

            if ($sw eq "1") {
                push(@newservice, $line);
            }

            if ($line =~ /End/) {
                $count++;
            }

            if ($count eq "4") {
                last;
            }
        }

        untie @poundtpl;

        $newservice[0]  =~ s/#//g;
        $newservice[-1] =~ s/#//g;

        my $lock_file = &getLockFile($farm_name);
        my $lock_fh   = &openlock($lock_file, 'w');

        my @fileconf;
        if (!grep { /^\s*Service "$service"/ } readFileAsArray("$configdir/$farm_name\_proxy.cfg")) {
            tie @fileconf, 'Tie::File', "$configdir/$farm_name\_proxy.cfg";

            my $i         = 0;
            my $farm_type = &getFarmType($farm_name) // "";

            for my $line (@fileconf) {
                if ($line =~ /#ZWACL-END/) {
                    $output = 0;

                    for my $lline (@newservice) {
                        if ($lline =~ /\[DESC\]/) {
                            $lline =~ s/\[DESC\]/$service/;
                        }

                        if ($lline =~ /StrictTransportSecurity/ && $farm_type eq "https") {
                            $lline =~ s/#//;
                        }

                        splice @fileconf, $i, 0, "$lline";
                        $i++;
                    }
                    last;
                }
                $i++;
            }
        }

        untie @fileconf;
        close $lock_fh;
    }
    else {
        $output = 1;
    }

    return $output;
}

=pod

=head1 setFarmHTTPNewServiceFirst

Create a new Service in a HTTP farm on first position

Parameters:

    farm_name - Farm name

    service - Service name

Returns:

    Integer - Error code: 0 on success, other value on failure

=cut

sub setFarmHTTPNewServiceFirst ($farm_name, $service) {
    require Tie::File;
    require Relianoid::Lock;
    require Relianoid::File;
    require Relianoid::Farm::Config;

    my $output = -1;

    #first check if service name exist
    if ($service =~ /(?=)/ && $service =~ /^$/) {
        #error 2 eq $service is empty
        $output = 2;
        return $output;
    }

    if (!grep { /^\s*Service "$service"/ } readFileAsArray("$configdir/$farm_name\_proxy.cfg")) {
        #create service
        my @newservice;
        my $sw       = 0;
        my $count    = 0;
        my $poundtpl = &getGlobalConfiguration('poundtpl');

        tie my @poundtpl, 'Tie::File', "$poundtpl";

        for my $line (@poundtpl) {
            if ($line =~ /Service \"\[DESC\]\"/) {
                $sw = 1;
            }

            if ($sw eq "1") {
                push(@newservice, $line);
            }

            if ($line =~ /End/) {
                $count++;
            }

            if ($count eq "4") {
                last;
            }
        }

        untie @poundtpl;

        $newservice[0]  =~ s/#//g;
        $newservice[-1] =~ s/#//g;

        my $lock_file = &getLockFile($farm_name);
        my $lock_fh   = &openlock($lock_file, 'w');
        my @fileconf;

        if (!grep { /^\s*Service "$service"/ } readFileAsArray("${configdir}/${farm_name}_proxy.cfg")) {
            tie @fileconf, 'Tie::File', "$configdir/$farm_name\_proxy.cfg";

            my $i         = 0;
            my $farm_type = "";
            $farm_type = &getFarmType($farm_name);

            for my $line (@fileconf) {
                if ($line =~ /#ZWACL-INI/) {
                    $output = 0;

                    for my $lline (@newservice) {
                        if ($lline =~ /\[DESC\]/) {
                            $lline =~ s/\[DESC\]/$service/;
                        }

                        if ($lline =~ /StrictTransportSecurity/ && $farm_type eq "https") {
                            $lline =~ s/#//;
                        }

                        $i++;
                        splice @fileconf, $i, 0, "$lline";
                    }

                    last;
                }

                $i++;
            }
        }

        untie @fileconf;
        close $lock_fh;
    }
    else {
        $output = 1;
    }

    return $output;
}

=pod

=head1 delHTTPFarmService

Delete a service in a Farm

Parameters:

    farm_name - Farm name
    service - Service name

Returns:

    Integer - Error code: 0 on success, -1 on failure

=cut

sub delHTTPFarmService ($farm_name, $service) {
    require Tie::File;
    require Relianoid::Lock;
    require Relianoid::FarmGuardian;
    require Relianoid::Farm::HTTP::Service;
    require Relianoid::Farm::Config;

    my $farm_filename = &getFarmFile($farm_name);
    my $sw            = 0;
    my $output        = -1;
    my $farm_ref      = getFarmStruct($farm_name);

    # Counter the Service's backends
    my $sindex     = &getFarmVSI($farm_name, $service);
    my $backendsvs = &getHTTPFarmVS($farm_name, $service, "backends");
    my @be         = split("\n", $backendsvs);
    my $counter    = @be;

    # Stop FG service
    &delFGFarm($farm_name, $service);

    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    tie my @fileconf, 'Tie::File', "$configdir/$farm_filename";

    my $i = 0;
    for ($i = 0 ; $i < $#fileconf ; $i++) {
        my $line = $fileconf[$i];
        if ($sw eq "1" && ($line =~ /ZWACL-END/ || $line =~ /Service/)) {
            $output = 0;
            last;
        }

        if ($sw) {
            splice @fileconf, $i, 1,;
            $i--;
        }

        if ($line =~ /Service "$service"/) {
            $sw = 1;
            splice @fileconf, $i, 1,;
            $i--;
        }
    }

    if ($eload) {
        if (&getGlobalConfiguration('floating_L7') eq 'true') {
            &reloadFarmsSourceAddressByFarm($farm_name);
        }
    }

    untie @fileconf;
    close $lock_fh;

    # delete service's backends  in status file
    if ($counter > -1) {
        while ($counter > -1) {
            require Relianoid::Farm::HTTP::Backend;
            &runRemoveHTTPBackendStatus($farm_name, $counter, $service);
            $counter--;
        }
    }

    # change the ID value of services with an ID higher than the service deleted (value - 1)
    tie my @contents, 'Tie::File', "$configdir\/$farm_name\_status.cfg";
    for my $line (@contents) {
        my @params = split(" ", $line);
        my $newval = $params[2] - 1;

        if ($params[2] > $sindex) {
            my $old = join " ", @params;
            $params[2] = $newval;
            my $new = join " ", @params;
            $line =~ s/$old/$new/g;
        }
    }
    untie @contents;

    return $output;
}

=pod

=head1 getHTTPFarmServices

Get an array containing all service name configured in an HTTP farm.

If Service name is sent, get an array containing the service name foundand index.

Parameters:

    farm_name - Farm name
    service_name - Service name

Returns:

    Array - service names if service name param does not exist. 
    Hash ref  - Hash ref $service_ref if service name param exists.

Variable: $service_ref

    $service_ref->{ $service_name } - Service index

FIXME:

    &getHTTPFarmVS(farmname) does same but in a string

=cut

sub getHTTPFarmServices ($farm_name, $service_name = undef) {
    require Relianoid::Farm::Core;

    my $farm_filename = &getFarmFile($farm_name);
    my @output        = ();

    open my $fh, '<', "${configdir}/${farm_filename}";
    my @file = <$fh>;
    close $fh;

    my $index = 0;
    for my $line (@file) {
        if ($line =~ /^\s*Service\s+\"(.*)\"\s*$/) {
            my $service = $1;
            if ($service_name) {
                if ($service_name eq $service) {
                    return { $service => $index };
                }
                $index++;
            }
            else {
                push(@output, $service);
            }
        }
    }

    return @output;
}

=pod

=head1 getHTTPServiceStruct

Get a struct with all parameters of a HTTP service

Parameters:

    farm_name - Farm name
    service_name  - Service name

Returns:

    hash ref - hash with service configuration

    Example output:

    {
        "backends" : [
            {
                "id" : 0,
                "ip" : "48.5.25.5",
                "port" : 70,
                "status" : "up",
                "timeout" : null,
                "weight" : null
            }
        ],
        "fgenabled" : "false",
        "fglog" : "false",
        "fgscript" : "",
        "fgtimecheck" : 5,
        "httpsb" : "false",
        "id" : "srv3",
        "leastresp" : "false",
        "persistence" : "",
        "redirect" : "",
        "redirecttype" : "",
        "sessionid" : "",
        "ttl" : 0,
        "urlp" : "",
        "vhost" : ""
    };

    Enterprise Edition also includes:

    {
        ...
        "cookiedomain" : "",
        "cookieinsert" : "false",
        "cookiename" : "",
        "cookiepath" : "",
        "cookiettl" : 0,
        ...
    };

Notes:

    Similar to the function get_http_service_struct

=cut

sub getHTTPServiceStruct ($farm_name, $service_name) {
    require Relianoid::FarmGuardian;
    require Relianoid::Farm::HTTP::Backend;

    # http services
    my $services_str = &getHTTPFarmVS($farm_name, "", "");
    my @services     = split(' ', $services_str);

    # return error if service is not found
    return unless grep ({ $service_name eq $_ } @services);

    my $service = {
        id           => $service_name,
        vhost        => &getHTTPFarmVS($farm_name, $service_name, "vs"),
        urlp         => &getHTTPFarmVS($farm_name, $service_name, "urlp"),
        redirect     => &getHTTPFarmVS($farm_name, $service_name, "redirect"),
        redirecttype => &getHTTPFarmVS($farm_name, $service_name, "redirecttype"),
        persistence  => &getHTTPFarmVS($farm_name, $service_name, "sesstype"),
        ttl          => &getHTTPFarmVS($farm_name, $service_name, "ttl"),
        sessionid    => &getHTTPFarmVS($farm_name, $service_name, "sessionid"),
        leastresp    => &getHTTPFarmVS($farm_name, $service_name, "dynscale")     || "false",
        httpsb       => &getHTTPFarmVS($farm_name, $service_name, "httpsbackend") || "false",
        backends     => &getHTTPFarmBackends($farm_name, $service_name),
        farmguardian => &getFGFarm($farm_name, $service_name),
    };
    # Remove backend status 'undefined', it is for news api versions
    for my $be (@{ $service->{backends} }) {
        $be->{status} = 'up' if $be->{status} eq 'undefined';
    }

    if ($eload) {
        $service->{backends} = &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'addAliasBackendsStruct',
            args   => [ $service->{backends} ],
        );

        $service = &eload(
            module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
            func   => 'add_service_cookie_insertion',
            args   => [ $farm_name, $service ],
        );

        $service->{redirect_code} = &eload(
            module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
            func   => 'getHTTPServiceRedirectCode',
            args   => [ $farm_name, $service_name ],
        );
        $service->{sts_status} = &eload(
            module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
            func   => 'getHTTPServiceSTSStatus',
            args   => [ $farm_name, $service_name ],
        );

        $service->{sts_timeout} = &eload(
            module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
            func   => 'getHTTPServiceSTSTimeout',
            args   => [ $farm_name, $service_name ],
        );
    }

    return $service;
}

=pod

=head1 getHTTPServiceId

Returns the service id

Parameters:

    farmname - Farm name
    service_name - Service name

Returns:

    integer - id of service

    undefined - if the service was not found

=cut

sub getHTTPServiceId ($farmname, $service_name) {
    my $id       = undef;
    my @services = getHTTPFarmServices($farmname);
    my $index    = 0;
    my $exist    = 0;

    for my $service (@services) {
        if ($service eq $service_name) {
            $id    = $index;
            $exist = 1;
            last;
        }
        $index++;
    }
    return unless ($exist);
    return $id;
}

=pod

=head1 getHTTPFarmVS

Return virtual server parameter

Parameters:

    farm_name - Farm name
    service - Service name
    tag - Indicate which field will be returned. The options are: vs, urlp, redirect, redirecttype, dynscale, sesstype, ttl, sessionid, httpsbackend or backends

Returns:

    scalar - if service and tag is blank, return all services in a string: "service0 service1 ..." else return the parameter value

FIXME:

    return a hash with all parameters

=cut

sub getHTTPFarmVS ($farm_name, $service = "", $tag = "") {
    my $farm_filename = &getFarmFile($farm_name);
    my $output        = "";

    my $directive_index = 0;
    my @lines           = ();

    if (open my $fh, '<', "${configdir}/${farm_filename}") {
        @lines = <$fh>;
        close $fh;
    }

    my $sw         = 0;
    my $be_section = 0;
    my $se_section = 0;
    my $be_emerg   = 0;
    my $be         = -1;
    my $sw_ti      = 0;
    my $output_ti  = "";
    my $sw_pr      = 0;
    my $output_pr  = "";
    my $sw_w       = 0;
    my $output_w   = "";
    my $outputa;
    my $outputp;
    my @return;

    for my $line (@lines) {
        if ($line =~ /^\s*Service \"$service\"/) { $sw         = 1; }
        if ($line =~ /^\s*Session/ && $sw)       { $se_section = 1; }
        if ($line =~ /^\s*End\s*$/) {
            if    ($se_section)                { $se_section = 0; }
            elsif (!$be_section && !$be_emerg) { $sw         = 0; }
        }

        # returns all services for this farm
        if ($tag eq "" && $service eq "") {
            if ($line =~ /^\s*Service\ \"/) {
                @return = split("\ ", $line);
                $return[1] =~ s/\"//g;
                $return[1] =~ s/^\s+//;
                $return[1] =~ s/\s+$//;
                $output = "$output $return[1]";
            }
        }

        #vs tag
        if ($tag eq "vs") {
            if ($line =~ /^\s*HeadRequire/ && $sw) {
                @return = split("Host:", $line);
                $return[1] =~ s/\"//g;
                $return[1] =~ s/^\s+//;
                $return[1] =~ s/\s+$//;
                $output = $return[1];
                last;
            }
        }

        #url pattern
        if ($tag eq "urlp") {
            if ($line =~ /^\s*Url \"/ && $sw) {
                @return = split("Url", $line);
                $return[1] =~ s/\"//g;
                $return[1] =~ s/^\s+//;
                $return[1] =~ s/\s+$//;
                $output = $return[1];
                last;
            }
        }

        #redirect
        if ($tag eq "redirect") {
            # Redirect types: 301, 302 or 307.
            if ($line =~ /^\s*Redirect(?:Append)?\s/ && $sw) {
                @return = split(" ", $line);

                my $url = $return[-1];
                $url =~ s/\"//g;
                $url =~ s/^\s+//;
                $url =~ s/\s+$//;
                $output = $url;
                last;
            }
        }

        if ($tag eq "redirecttype") {
            if ($line =~ /^\s*Redirect(?:Append)?\s/ && $sw) {
                if    ($line =~ /Redirect /)       { $output = "default"; }
                elsif ($line =~ /RedirectAppend /) { $output = "append"; }
                last;
            }
        }

        # leastresp
        if ($tag eq "dynscale") {
            if ($line =~ /^\s*DynScale\ / && $sw) {
                $output = "true";
                last;
            }
        }

        #######################
        # Session has 3 fields:
        # - Type
        # - TTL
        # - ID

        # session type
        # only get the session type when it's not commented
        if ($tag eq "sesstype") {
            if ($line =~ /^\s*Type/ && $sw) {
                @return = split(" ", $line);
                $return[1] =~ s/\"//g;
                $return[1] =~ s/^\s+//;
                $return[1] =~ s/\s+$//;
                $output = $return[1];
                last;
            }
        }

        # session ttl
        # Get ttl value whether the line is commented or not
        if ($tag eq "ttl") {
            if ($line =~ /^[\s#]*TTL/ && $sw) {
                @return = split(" ", $line);
                $return[1] =~ s/\"//g;
                $return[1] =~ s/^\s+//;
                $return[1] =~ s/\s+$//;
                $output = $return[1] + 0;
                last;
            }
        }

        # session id
        # only get the session name when it's not commented
        # Format: sessionid "sessionname"
        if ($tag eq "sessionid") {
            if ($line =~ /^\s*ID/ && $sw) {
                @return = split(" ", $line);
                $return[1] =~ s/\"//g;
                $return[1] =~ s/^\s+//;
                $return[1] =~ s/\s+$//;
                $output = $return[1];
                last;
            }
        }

        # End of session section
        ########################

        #HTTPS tag
        if ($tag eq "httpsbackend") {
            if ($line =~ "##True##HTTPS-backend##" && $sw) {
                $output = "true";
                last;
            }
        }

        #backends
        if ($tag eq "backends") {
            if ($line =~ /^\s*BackEnd|^\s*Emergency/ && $sw) {
                $be_section = 1;
            }
            if ($line =~ /^\s*Emergency/ && $sw) {
                $be_emerg = 1;
            }
            if ($be_section) {
                if ($line =~ /^\s*End/ && $sw) {
                    if ($sw_ti == 0) {
                        $output_ti = "TimeOut -";
                    }
                    if ($sw_pr == 0) {
                        $output_pr = "Priority -";
                    }
                    if ($sw_w == 0) {
                        $output_w = "Weight 1";
                        $output_w = "Weight 2" if ($be_emerg == 1);
                        $be_emerg = 0;
                    }

                    my @line_parts = ($output, $outputa, $outputp, $output_ti, $output_pr, $output_w);
                    $output    = join(" ", @line_parts) . "\n";
                    $output_ti = "";
                    $output_pr = "";
                    $sw_ti     = 0;
                    $sw_pr     = 0;
                    $sw_w      = 0;
                }
                elsif ($line =~ /^\s*Address/) {
                    $be++;
                    chomp($line);
                    $outputa = "Server $be $line";
                }
                elsif ($line =~ /^\s*Port/) {
                    chomp($line);
                    $outputp = "$line";
                }
                elsif ($line =~ /^\s*TimeOut/) {
                    chomp($line);

                    #$output = $output . "$line";
                    $output_ti = $line;
                    $sw_ti     = 1;
                }
                elsif ($line =~ /^\s*Priority/) {
                    chomp($line);

                    #$output = $output . "$line";
                    $output_pr = $line;
                    $sw_pr     = 1;
                }
                elsif ($line =~ /^\s*Weight/) {
                    chomp($line);

                    #$output = $output . "$line";
                    $output_w = $line;
                    $sw_w     = 1;
                }
            }
            if ($sw && $be_section && $line =~ /#End/) {
                last;
            }
        }
    }

    return $output;
}

=pod

=head1 setHTTPFarmVS

Set values for service parameters. The parameters are: vs, urlp, redirect, redirectappend, dynscale, sesstype, ttl, sessionid, httpsbackend or backends

An empty string/value will comment the tag/attribute/field in config file.

Examples of service section:

	Service "newservice"
		##False##HTTPS-backend##
		#DynScale 1
		#BackendCookie "NOIDSESSIONID" "" "/" 3600
		#HeadRequire "Host: "
		#Url ""
		#Redirect ""
		#StrictTransportSecurity 21600000
		#Session
			#Type nothing
			#TTL 120
			#ID "sessionname"
		#End
		#BackEnd

		#End
	End

	Service "newservice"
		##False##HTTPS-backend##
		DynScale 1
		BackendCookie "TESTING" "domaintesting.com" "/a" 17
		HeadRequire "Host: www.mywebserver.com"
		Url "^/myapp1$"
		Redirect 302 "http://www.mysite.com"
		#StrictTransportSecurity 21600000
		Session
			Type URL
			TTL 120
			ID "sessionname"
		End
		#BackEnd

		#End
	End

Parameters:

    farm_name - Farm name
    service   - Service name
    tag       - Indicate which parameter modify
    string    - value for the field "tag"

Returns:

    Integer - Error code: 0 on success or -1 on failure

=cut

sub setHTTPFarmVS ($farm_name, $service, $tag, $string = '') {
    my $farm_filename  = &getFarmFile($farm_name);
    my $output         = 0;
    my $in_service     = 0;                          # Found service block
    my $be_section     = 0;
    my $se_section     = 0;
    my $clean_sessions = 0;
    my $line_index     = -1;

    $string =~ s/^\s+//;
    $string =~ s/\s+$//;

    require Relianoid::Lock;
    my $lock_file = &getLockFile($farm_name);
    my $lock_fh   = &openlock($lock_file, 'w');

    require Tie::File;
    tie my @fileconf, 'Tie::File', "$configdir/$farm_filename";

    for my $line (@fileconf) {
        $line_index++;
        if ($line =~ /^\s*Service "$service"/)                 { $in_service = 1; next; }
        if ($line =~ /^\s*Session/ && $in_service)             { $se_section = 1; }
        if ($line =~ /^\s*(BackEnd|Emergency)/ && $in_service) { $be_section = 1; }

        if ($line =~ /^\s*End\s*$/ && $in_service && !$se_section && !$be_section) { last; }
        if ($in_service && $line =~ /\s*Service "/ && $line !~ /\s*Service "$service"/) { last; }

        next if not $in_service;

        # vhost or vs tag
        if ($tag eq "vs") {
            if ($line =~ /^[\s#]*HeadRequire / && $string ne "") {
                $line = "\t\tHeadRequire \"Host: $string\"";
                last;
            }
            if ($line =~ /^[\s#]*HeadRequire / && $string eq "") {
                $line = "\t\t#HeadRequire \"Host:\"\n";
                last;
            }
        }

        # urlp or url pattern
        if ($tag eq "urlp") {
            if ($line =~ /^[\s#]*Url / && $string ne "") {
                $line = "\t\tUrl \"$string\"";
                last;
            }
            if ($line =~ /^[\s#]*Url / && $string eq "") {
                $line = "\t\t#Url \"\"";
                last;
            }
        }

        # leastresp or dynscale tag
        if ($tag eq "dynscale") {
            if ($line =~ /^[\s#]*DynScale / && $string ne "") {
                $line = "\t\tDynScale 1";
                last;
            }
            if ($line =~ /^[\s#]*DynScale / && $string eq "") {
                $line = "\t\t#DynScale 1";
                last;
            }
        }

        # client redirect default
        if ($tag eq "redirect") {
            if ($line =~ /^[\s#]*(Redirect(?:Append)?) (30[127] )?.*/) {
                my $policy        = $string ? $1 : "Redirect";
                my $redirect_code = $2 // '';
                my $comment       = $string ? '' : '#';
                $line = qq(\t\t${comment}${policy} ${redirect_code}"${string}");
                last;
            }
        }

        # redirecttype
        if ($tag eq "redirecttype") {
            if ($line =~ /^[\s#]*Redirect(?:Append)? (.*)/) {
                my $rest    = $1;
                my $policy  = $string eq 'append' ? 'RedirectAppend' : 'Redirect';
                my $comment = $string             ? ''               : '#';
                $line = "\t\t${comment}${policy} $rest";
                last;
            }
        }

        # ttl
        if ($tag eq "ttl") {
            if ($line =~ /^[\s#]*TTL / && $string ne "") {
                $line = "\t\t\tTTL $string";
                last;
            }
            if ($line =~ /^[\s#]*TTL / && $string eq "") {
                $line = "\t\t\t#TTL 120";
                last;
            }
        }

        # session id
        if ($tag eq "sessionid") {
            if ($line =~ /^[\s#]*ID / && $string ne "") {
                $line = "\t\t\tID \"$string\"";
                last;
            }
            if ($line =~ /^[\s#]*ID / && $string eq "") {
                $line = "\t\t\t#ID \"$string\"";
                last;
            }
        }

        # httpsb or HTTPS Backends tag
        if ($tag eq "httpsbackend") {
            if ($line =~ "##HTTPS-backend##" && $string ne "") {
                #turn on
                $line = "\t\t##True##HTTPS-backend##";
            }
            elsif ($line =~ "##HTTPS-backend##" && $string eq "") {
                #turn off
                $line = "\t\t##False##HTTPS-backend##";
            }

            #Delete HTTPS tag in a BackEnd
            if ($line =~ /^\s*HTTPS$/ && $string eq "") {
                #Delete HTTPS tag
                splice @fileconf, $line_index, 1,;
            }

            #Add HTTPS tag
            if ($line =~ /^\s*(BackEnd|Emergency)$/ && $string ne "") {
                $line .= "\n\t\t\tHTTPS";
            }
        }

        # session type
        if ($tag eq "session") {
            # Session section enabled
            if ($string ne "nothing") {
                if ($line =~ /^[\s#]*Session/) {
                    $line = "\t\tSession";
                }
                elsif ($line =~ /^[\s#]*End/) {
                    $line = "\t\tEnd";
                    last;
                }
                elsif ($line =~ /^[\s#]*Type\s+(.*)\s*/) {
                    $line           = "\t\t\tType $string";
                    $clean_sessions = 1 if $1 ne $string;
                }
                elsif ($line =~ /^[\s#]*TTL /) {
                    $line =~ s/#//g;
                }
                elsif ($line =~ /^[\s#]*ID /) {
                    if (grep { $string eq $_ } ("URL", "COOKIE", "HEADER")) {
                        $line =~ s/#//g;
                    }
                    else {
                        $line = "#$line";
                    }
                }
            }
            # Session section disabled
            else {
                if ($line =~ /^[\s#]*Session/) {
                    $line = "\t\t#Session";
                }
                elsif ($line =~ /^[\s#]*End/) {
                    $line = "\t\t#End";
                    last;
                }
                elsif ($line =~ /^[\s#]*TTL /) {
                    $line = "\t\t\t#TTL 120";
                }
                elsif ($line =~ /^[\s#]*Type /) {
                    $line           = "\t\t\t#Type nothing";
                    $clean_sessions = 1;
                }
                elsif ($line =~ /^[\s#]*ID /) {
                    $line = "\t\t\t#ID \"sessionname\"";
                }
            }
        }
    }

    untie @fileconf;
    close $lock_fh;

    return $output;
}

=pod

=head1 getFarmVSI

Get the index of a service in a http farm

Parameters:

    farmname - Farm name
    service - Service name

Returns:

    integer - Service index, it returns -1 if the service does not exist

FIXME:

    Rename with intuitive name, something like getHTTPFarmServiceIndex

=cut

sub getFarmVSI ($farm_name, $target_service) {
    my @services = &getHTTPFarmServices($farm_name);
    my $index    = 0;

    for my $service (@services) {
        if ($service eq $target_service) {
            return $index;
        }
        $index++;
    }

    return -1;
}

=pod

=head1 get_http_service_struct

FIXME:

    This function is only used in API 3.2. getHTTPServiceStruct should be used.

=cut

sub get_http_service_struct ($farmname, $service_name) {
    require Relianoid::FarmGuardian;
    require Relianoid::Farm::HTTP::Backend;

    my $service_ref = &getHTTPServiceStruct($farmname, $service_name);

    # Backends
    my $backends = &getHTTPFarmBackends($farmname, $service_name);

    # Remove backend status 'undefined', it is for news api versions
    for my $be (@{$backends}) {
        $be->{status} = 'up' if $be->{status} eq 'undefined';
    }

    # Add FarmGuardian
    $service_ref->{farmguardian} = &getFGFarm($farmname, $service_name);

    # Add STS
    if ($eload) {
        $service_ref->{sts_status} = &eload(
            module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
            func   => 'getHTTPServiceSTSStatus',
            args   => [ $farmname, $service_name ],
        );

        $service_ref->{sts_timeout} = &eload(
            module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
            func   => 'getHTTPServiceSTSTimeout',
            args   => [ $farmname, $service_name ],
        );
    }

    return $service_ref;
}

=pod

=head1 get_http_all_services_summary_struct

=cut

sub get_http_all_services_summary_struct ($farmname) {
    # Output
    my @services_list = ();

    for my $service (&getHTTPFarmServices($farmname)) {
        push @services_list, { 'id' => $service };
    }

    return \@services_list;
}

=pod

=head1 getHTTPFarmPriorities

Get the list of the backends priorities of the service in a http farm

Parameters:

    farmname - Farm name

    service - Service name

Returns:

    Array Ref - it returns an array ref of priority values

=cut

sub getHTTPFarmPriorities ($farmname, $service_name) {
    my @priorities;
    my $backends = &getHTTPFarmBackends($farmname, $service_name);

    for my $backend (@{$backends}) {
        if (defined $backend->{priority} and $backend->{priority} > 1) {
            push @priorities, $backend;
        }
    }

    return \@priorities;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/HTTP/Stats.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::HTTP::Stats

=cut

=pod

=head1 getHTTPFarmEstConns

Get all ESTABLISHED connections for a farm

Parameters:

    farm_name - Farm name

Returns:

    array - Return all ESTABLISHED conntrack lines for a farm

=cut

sub getHTTPFarmEstConns ($farm_name) {
    my $count = 0;

    my $vip      = &getFarmVip("vip",  $farm_name);
    my $vip_port = &getFarmVip("vipp", $farm_name);

    my $filter = {
        proto         => 'tcp',
        orig_dst      => $vip,
        orig_port_dst => $vip_port,
        state         => 'ESTABLISHED',
    };

    my $ct_params = &getConntrackParams($filter);
    $count = &getConntrackCount($ct_params);

    #~ &log_info( "getHTTPFarmEstConns: $farm_name farm -> $count connections." );

    return $count + 0;
}

=pod

=head1 getHTTPFarmSYNConns

Get all SYN connections for a farm

Parameters:

    farm_name - Farm name

Returns:

    array - Return all SYN conntrack lines for a farm

=cut

sub getHTTPFarmSYNConns ($farm_name) {
    my $vip      = &getFarmVip("vip",  $farm_name);
    my $vip_port = &getFarmVip("vipp", $farm_name);

    my $filter = {
        proto         => 'tcp',
        orig_dst      => $vip,
        orig_port_dst => $vip_port,
        state         => 'SYN_SENT',
    };

    my $ct_params = &getConntrackParams($filter);
    my $count     = &getConntrackCount($ct_params);

    $filter->{state} = 'SYN_RECV';

    $ct_params = &getConntrackParams($filter);
    $count += &getConntrackCount($ct_params);

    #~ &log_info( "getHTTPFarmSYNConns: $farm_name farm -> $count connections." );

    return $count + 0;
}

=pod

=head1 getHTTPBackendEstConns

Get all ESTABLISHED connections for a backend

Parameters:

    farm_name    - Farm name
    backend_ip   - IP backend
    backend_port - backend port
    mark

Returns:

    array - Return all ESTABLISHED conntrack lines for the backend

BUG:

    If a backend is used on more than one farm, here it appears all them

=cut

sub getHTTPBackendEstConns ($farm_name, $backend_ip, $backend_port, $mark = undef) {
    my $filter = {
        proto         => 'tcp',
        orig_dst      => $backend_ip,
        orig_port_dst => $backend_port,
        state         => 'ESTABLISHED',
    };

    if ($mark) {
        $filter->{mark} = $mark;
    }

    require Relianoid::Net::ConnStats;
    my $ct_params = &getConntrackParams($filter);
    my $count     = &getConntrackCount($ct_params);

    return $count + 0;
}

=pod

=head1 getHTTPBackendSYNConns

Get all SYN connections for a backend

Parameters:

    farm_name    - Farm name
    backend_ip   - IP backend
    backend_port - backend port
    mark

Returns:

    unsigned integer - connections count

BUG:

    If a backend is used on more than one farm, here it appears all them.

=cut

sub getHTTPBackendSYNConns ($farm_name, $backend_ip, $backend_port, $mark = undef) {
    my $filter = {
        proto         => 'tcp',
        orig_dst      => $backend_ip,
        orig_port_dst => $backend_port,
        state         => 'SYN_SENT',
    };

    if ($mark) {
        $filter->{mark} = $mark;
    }

    my $ct_params = &getConntrackParams($filter);
    my $count     = &getConntrackCount($ct_params);

    $filter->{state} = 'SYN_RECV';

    $ct_params = &getConntrackParams($filter);
    $count += &getConntrackCount($ct_params);

    return $count + 0;
}

=pod

=head1 getHTTPFarmBackendsStats

This function take data from pounctl and it gives hash format

Parameters:

    farm_name    - Farm name
    service_name - Service name

Returns:

    hash ref - hash with backend farm stats

    backends => [
        {
            "id" = $backend_id      # it is the index in the backend array too
            "ip" = $backend_ip
            "port" = $backend_port
            "status" = $backend_status
            "established" = $established_connections
        }
    ]

    sessions => [
        {
            "client"       = $client_id         # it is the index in the session array too
            "id"           = $session_id        # id associated to a backend, it can change depend of session type
            "backend_ip"   = $backend ip        # it is the backend ip
            "backend_port" = $backend port      # it is the backend port
            "service"      = $service name
            "session"      = $session identifier    # it depends on the persistence mode
        }
    ]

FIXME:

    Put output format same format than "GET /stats/farms/BasekitHTTP"

=cut

sub getHTTPFarmBackendsStats ($farm_name, $service_name = undef) {
    require Relianoid::Farm::Base;
    require Relianoid::Farm::HTTP::Config;
    require Relianoid::Validate;

    my $serviceName;
    my $service_re = &getValidFormat('service');
    my $stats      = {
        sessions => [],
        backends => []
    };

    unless ($eload) {
        require Relianoid::Net::ConnStats;
    }

    # Get L7 proxy info
    #i.e. of poundctl:

    #Requests in queue: 0
    #0. http Listener 185.76.64.223:80 a
    #0. Service "HTTP" active (4)
    #0. Backend 172.16.110.13:80 active (1 0.780 sec) alive (61)
    #1. Backend 172.16.110.14:80 active (1 0.878 sec) alive (90)
    #2. Backend 172.16.110.11:80 active (1 0.852 sec) alive (99)
    #3. Backend 172.16.110.12:80 active (1 0.826 sec) alive (75)
    my @poundctl = &getHTTPFarmGlobalStatus($farm_name);

    my $alias;
    $alias = &eload(
        module => 'Relianoid::EE::Alias',
        func   => 'getAlias',
        args   => ['backend']
    ) if $eload;

    my $backend_info;

    # Parse L7 proxy info
    for my $line (@poundctl) {
        # i.e.
        #     0. Service "HTTP" active (10)
        if ($line =~ /(\d+)\. Service "($service_re)"/) {
            $serviceName  = $2;
            $backend_info = undef;
        }

        next if (defined $service_name && $service_name ne $serviceName);

        # Parse backend connections
        # i.e.
        #      0. Backend 192.168.100.254:80 active (5 0.000 sec) alive (0)
        if ($line =~ /(\d+)\. Backend (\d+\.\d+\.\d+\.\d+|[a-fA-F0-9:]+):(\d+) (\w+) .+ (\w+)(?: \((\d+)\))?/) {
            my $backendHash = {
                id      => $1 + 0,
                ip      => $2,
                port    => $3 + 0,
                status  => $5,
                pending => 0,
                service => $serviceName,
            };

            $backendHash->{alias}                       = $alias->{$2} if $eload;
            $backend_info->{ $backendHash->{id} }{ip}   = $backendHash->{ip};
            $backend_info->{ $backendHash->{id} }{port} = $backendHash->{port};

            # The established connections should be always defined with >= 0
            # If there is any case where it is not defined, we can use the IP based filtering in conntrack
            # $backendHash->{established} = &getHTTPBackendEstConns($farm_name, $backendHash->{ip}, $backendHash->{port});
            $backendHash->{established} = $6 + 0;

            # Getting real status
            my $backend_disabled = $4;

            if ($backend_disabled eq "DISABLED") {
                require Relianoid::Farm::HTTP::Backend;

                #Checkstatusfile
                $backendHash->{status} =
                  &getHTTPBackendStatusFromFile($farm_name, $backendHash->{id}, $serviceName);

                # not show fgDOWN status
                $backendHash->{status} = "down"
                  if ($backendHash->{status} ne "maintenance");
            }
            elsif ($backendHash->{status} eq "alive") {
                $backendHash->{status} = "up";
            }
            elsif ($backendHash->{status} eq "DEAD") {
                $backendHash->{status} = "down";
            }

            # Getting pending connections
            require Relianoid::Net::ConnStats;
            require Relianoid::Farm::Stats;

            # The port passed to getBackendSYNConns will be converted to string,
            # port + 0 will pass a copy of the port, so the original port will not be converted
            $backendHash->{pending} = &getBackendSYNConns($farm_name, $backendHash->{ip}, $backendHash->{port} + 0);

            # Workaround: getBackendSYNConns changes the port to string
            $backendHash->{port} += 0;

            push(@{ $stats->{backends} }, $backendHash);
        }

        # Parse sessions
        # i.e.
        #      1. Session 107.178.194.117 -> 1
        if ($line =~ /(\d+)\. Session (.+) \-\> (\d+)/) {
            push @{ $stats->{sessions} },
              {
                client       => $1 + 0,
                session      => $2,
                id           => $3 + 0,
                backend_ip   => $backend_info->{$3}{ip},
                backend_port => $backend_info->{$3}{port},
                service      => $serviceName,
              };
        }
    }

    return $stats;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/L4xNAT.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::L4xNAT::Config;
use Relianoid::Farm::L4xNAT::Action;
use Relianoid::Farm::L4xNAT::Stats;
use Relianoid::Farm::L4xNAT::Factory;
use Relianoid::Farm::L4xNAT::Backend;
use Relianoid::Farm::L4xNAT::Service;

1;

=pod

=head1 Module

Relianoid::Farm::L4xNAT

=cut

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/L4xNAT/Action.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Config;
use Relianoid::Nft;

my $eload     = eval { require Relianoid::ELoad };
my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::L4xNAT::Action

=cut

=pod

=head1 startL4Farm

Run a l4xnat farm

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success or different of 0 on failure

=cut

sub startL4Farm ($farm_name, $writeconf = 0) {
    require Relianoid::Farm::L4xNAT::Config;

    &log_info("Starting L4xNAT farm $farm_name") if &debug();

    my $status = 0;
    my $farm   = &getL4FarmStruct($farm_name);

    &loadL4Modules($$farm{vproto});

    $status = &startL4FarmNlb($farm_name, $writeconf);
    if ($status != 0) {
        return $status;
    }

    &doL4FarmRules("start", $farm_name);

    &reloadFarmsSourceAddressByFarm($farm_name);

    # Enable IP forwarding
    require Relianoid::Net::Util;
    &setIpForward('true');

    if ($farm->{lbalg} eq 'leastconn') {
        require Relianoid::Farm::L4xNAT::L4sd;
        &sendL4sdSignal();
    }

    return $status;
}

=pod

=head1 stopL4Farm

Stop a l4xnat farm

Parameters:

    farm_name - Farm name
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - return 0 on success or other value on failure

=cut

sub stopL4Farm ($farm_name, $writeconf) {
    my $pidfile = &getL4FarmPidFile($farm_name);

    require Relianoid::Farm::Core;
    require Relianoid::Farm::L4xNAT::Config;

    &log_info("Stopping L4xNAT farm $farm_name") if &debug();

    my $farm = &getL4FarmStruct($farm_name);

    &doL4FarmRules("stop", $farm_name);

    my $pid = &getNlbPid();
    if ($pid <= 0) {
        return 0;
    }

    my $status = &stopL4FarmNlb($farm_name, $writeconf);

    # Flush conntrack
    &resetL4FarmConntrack($farm_name) unless ($status);

    unlink "$pidfile" if (-e "$pidfile");

    &unloadL4Modules($$farm{vproto});

    if ($farm->{lbalg} eq 'leastconn') {
        require Relianoid::Farm::L4xNAT::L4sd;
        &sendL4sdSignal();
    }

    return $status;
}

=pod

=head1 setL4NewFarmName

Function that renames a farm

Parameters:

    farmname - Farm name
    newfarmname - New farm name

Returns:

    Integer - return 0 on success or <> 0 on failure

=cut

sub setL4NewFarmName ($farm_name, $new_farm_name) {
    my $err = &setL4FarmParam('name', "$new_farm_name", $farm_name);

    unlink "$configdir\/${farm_name}_l4xnat.cfg";

    if (!$err) {
        $err = &setL4FarmParam('log-prefix', undef, $new_farm_name);
    }

    return $err;
}

=pod

=head1 copyL4Farm

Function that copies a l4xnat farm.
If the flag has the value 'del', the old farm will be deleted.

Parameters:

    farmname - Farm name

    newfarmname - New farm name

    flag - It expets a 'del' string to delete the old farm. It is used to copy or rename the farm.

Returns:

    Integer - return 0 on success or <> 0 on failure

=cut

sub copyL4Farm ($farm_name, $new_farm_name, $del = '') {
    my $output = 0;

    use File::Copy qw(copy);

    my $file_ori = "$configdir/" . &getFarmFile($farm_name);
    my $file_new = "$configdir/${new_farm_name}_l4xnat.cfg";

    copy($file_ori, $file_new);

    # replace the farm directive
    my @lines;
    &ztielock(\@lines, $file_new);
    require Relianoid::Netfilter;
    my $backend_block = 0;

    for my $line (@lines) {
        if ($line =~ /(^\s+"name": )"$farm_name(.*)",/) {
            $line = $1 . "\"$new_farm_name" . $2 . "\",";
        }
        if ((!$backend_block) and ($line =~ /^(\s+"state": )"\w+",/)) {
            $line = $1 . "\"down\",";
        }
        if ($line =~ /^\s+"backends": \[/) {
            $backend_block = 1;
        }
        if (($backend_block) and ($line =~ /(^\s+"mark": )"0x\w+",/)) {
            my $new_mark = &getNewMark($new_farm_name);
            $line = $1 . "\"$new_mark\",";
        }
        if ($line =~ /(^\s+"log-prefix":)(.*)$farm_name ",/) {
            $line = $1 . $2 . "$new_farm_name \",";
        }
    }

    untie @lines;

    unlink $file_ori if ($del eq 'del');

    return $output;
}

=pod

=head1 loadL4NlbFarm

Load farm configuration in nftlb

Parameters:

    farm_name - farm name configuration to be loaded

Returns:

    Integer - 0 on success or -1 on failure

=cut

sub loadL4FarmNlb ($farm_name) {
    require Relianoid::Farm::Core;

    my $farmfile = &getFarmFile($farm_name);

    return 0 if ($farmfile eq "-1" or (!-e "$configdir/$farmfile"));

    return &httpNlbRequest({
        farm   => $farm_name,
        method => "POST",
        uri    => "/farms",
        body   => qq(\@$configdir/$farmfile)
    });
}

=pod

=head1 startL4FarmNlb

Start a new farm in nftlb

Parameters:

    farm_name - farm name to be started
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - 0 on success or -1 on failure

=cut

sub startL4FarmNlb ($farm_name, $writeconf) {
    require Relianoid::Farm::L4xNAT::Config;

    my $output = &setL4FarmParam(($writeconf) ? 'bootstatus' : 'status', "up", $farm_name);

    my $pidfile = &getL4FarmPidFile($farm_name);

    if (!-e $pidfile) {
        open my $fh, '>', $pidfile;
        close $fh;
    }

    return $output;
}

=pod

=head1 stopL4FarmNlb

Stop an existing farm in nftlb

Parameters:

    farm_name - farm name to be started
    writeconf - write this change in configuration status "writeconf" for true or omit it for false

Returns:

    Integer - 0 on success or -1 on failure

=cut

sub stopL4FarmNlb ($farm_name, $writeconf) {
    require Relianoid::Farm::Core;

    my $out = &setL4FarmParam(($writeconf) ? 'bootstatus' : 'status', "down", $farm_name);

    return $out;
}

=pod

=head1 getL4FarmPidFile

Return the farm pid file

Parameters:

    farm_name - Name of the given farm

Returns:

    String - Pid file path or -1 on failure

=cut

sub getL4FarmPidFile ($farm_name) {
    my $piddir  = &getGlobalConfiguration('piddir');
    my $pidfile = "$piddir/$farm_name\_l4xnat.pid";

    return $pidfile;
}

=pod

=head1 sendL4NlbCmd

Send the param to Nlb for a L4 Farm

Parameters:

    self - hash that includes hash_keys:

    farm        - it is the farm that is going to be modified
    farm_new_name - this field is defined when the farm name is going to be modified.
    backend     - backend id to modify
    file        - file where the HTTP body response of the nftlb is saved
    method      - HTTP verb for nftlb request
    body        - body to use in POST and PUT requests

Returns:

    Integer - return code of the request command

=cut

sub sendL4NlbCmd ($self) {
    my $cfgfile = "";
    my $output  = -1;

    # load the configuration file first if the farm is down
    my $status = &getL4FarmStatus($self->{farm});
    if ($status ne "up") {
        my $out = &loadL4FarmNlb($self->{farm});
        return $out if ($out != 0);
    }

    # avoid farm configuration file destruction by asking nftlb only for modifications
    # or deletion of attributes of the farm
    if ($self->{method} =~ /PUT/
        || ($self->{method} =~ /DELETE/ && defined $self->{uri} && $self->{uri} =~ /farms\/.*\/.*/))
    {
        my $file  = "/tmp/get_farm_$$";
        my $match = 0;

        $output = &httpNlbRequest({
            method => "GET",
            uri    => "/farms/" . $self->{farm},
            file   => $file,
        });

        if (-e $file) {
            open my $fh, "<", $file;
            while (my $line = <$fh>) {
                if ($line =~ /\"name\"\: \"$$self{farm}\"/) {
                    $match = 1;
                    last;
                }
            }
            close $fh;
            unlink $file;
        }

        if (!$match) {
            &log_error("The farms was not loaded properly, trying it again");
            &loadL4FarmNlb($self->{farm});
        }
    }

    if ($self->{method} =~ /PUT|DELETE/) {
        $cfgfile = $self->{file};
        $self->{file} = "";
    }

    if (defined $self->{backend} && $self->{backend} ne "") {
        $self->{uri} = "/farms/$self->{farm}/backends/$self->{backend}";
    }
    elsif (!defined $self->{uri}) {
        $self->{uri} = "/farms";
        $self->{uri} = "/farms/$self->{farm}" if $self->{method} eq "DELETE";
    }

    # use the new name
    $self->{farm} = $self->{farm_new_name} if exists $self->{farm_new_name};

    $output = &httpNlbRequest($self);

    if ($self->{method} eq "GET" or not defined $self->{file}) {
        return $output;
    }

    # end if the farm was deleted
    if ($self->{method} eq "DELETE" and not exists $self->{backend}) {
        return $output;
    }

    # save the conf
    if ($self->{method} =~ /PUT|DELETE/) {
        $self->{file} = $cfgfile;
    }

    $self->{method} = "GET";
    $self->{uri}    = "/farms/" . $self->{farm};
    $self->{body}   = "";

    $output = &httpNlbRequest($self);

    return $output;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/L4xNAT/Backend.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Config;
use Relianoid::Nft;

my $configdir = &getGlobalConfiguration('configdir');
my $eload     = eval { require Relianoid::ELoad; };

=pod

=head1 Module

Relianoid::Farm::L4xNAT::Backend

=cut

=pod

=head1 setL4FarmServer

Edit a backend or add a new one if the id is not found

Parameters:

    farm_name - Farm name
    ids - Backend id
    ip - Backend IP
    port - Backend port
    weight - Backend weight. The backend with more weight will manage more connections
    priority - The priority of this backend (between 1 and 9). Higher priority backends will be used more often than lower priority ones
    max_conns - Maximum connections for the given backend

Returns:

    Integer - return 0 on success, -1 on NFTLB failure or -2 on IP duplicated.

Returns:

    Scalar - 0 on success or other value on failure
    FIXME: Stop returning -2 when IP duplicated, nftlb should do this

=cut

sub setL4FarmServer ($farm_name, $ids, $ip, $port = undef, $weight = undef, $priority = undef, $max_conns = undef) {
    require Relianoid::Farm::L4xNAT::Config;
    require Relianoid::Farm::L4xNAT::Action;
    require Relianoid::Farm::Backend;
    require Relianoid::Netfilter;

    my $farm_filename = &getFarmFile($farm_name);
    my $output        = 0;
    my $json          = qq();
    my $msg           = "setL4FarmServer << farm_name:$farm_name ids:$ids ";

    # load the configuration file first if the farm is down
    my $f_ref = &getL4FarmStruct($farm_name);
    if ($f_ref->{status} ne "up") {
        my $out = &loadL4FarmNlb($farm_name);
        return $out if ($out != 0);
    }

    my $exists = &getFarmServer($f_ref->{servers}, $ids);

    my $rip  = $ip;
    my $mark = "0x0";

    if (defined $port && $port ne "") {
        if (&ipversion($ip) == 4) {
            $rip = "$ip\:$port";
        }
        elsif (&ipversion($ip) == 6) {
            $rip = "[$ip]\:$port";
        }

        if (!defined $exists || (defined $exists && $exists->{port} ne $port)) {
            $json .= qq(, "port" : "$port");
            $msg  .= "port:$port ";
        }
    }
    elsif (defined $port && $port eq "") {
        $json .= qq(, "port" : "$port");
        $msg  .= "port:$port ";
    }

    if (   defined $ip
        && $ip ne ""
        && (!defined $exists || (defined $exists && $exists->{rip} ne $rip)))
    {
        my $existrip = &getFarmServer($f_ref->{servers}, $rip, "rip");
        return -2 if (defined $existrip && ($existrip->{id} ne $ids));
        $json = qq(, "ip-addr" : "$ip") . $json;
        $msg .= "ip:$ip ";

        if (!defined $exists) {
            $mark = &getNewMark($farm_name);
            return -1 if (!defined $mark || $mark eq "");
            $json .= qq(, "mark" : "$mark");
            $msg  .= "mark:$mark ";
        }
        else {
            $mark = $exists->{tag};
        }

        &setBackendRule("add", $f_ref, $mark) if ($f_ref->{status} eq "up");
    }

    if (
           defined $weight
        && $weight ne ""
        && (!defined $exists
            || (defined $exists && $exists->{weight} ne $weight))
      )
    {
        $weight = 1 if ($weight == 0);
        $json .= qq(, "weight" : "$weight");
        $msg  .= "weight:$weight ";
    }

    if (
           defined $priority
        && $priority ne ""
        && (!defined $exists
            || (defined $exists && $exists->{priority} ne $priority))
      )
    {
        $priority = 1 if ($priority == 0);
        $json .= qq(, "priority" : "$priority");
        $msg  .= "priority:$priority ";
    }

    if (
           defined $max_conns
        && $max_conns ne ""
        && (!defined $exists
            || (defined $exists && $exists->{max_conns} ne $max_conns))
      )
    {
        $max_conns = 0 if ($max_conns < 0);
        $json .= qq(, "est-connlimit" : "$max_conns");
        $msg  .= "maxconns:$max_conns ";
    }

    if (!defined $exists) {
        $json .= qq(, "state" : "up");
        $msg  .= "state:up ";
    }

    &log_info("$msg") if &debug();

    $output = &sendL4NlbCmd({
        farm   => $farm_name,
        file   => "$configdir/$farm_filename",
        method => "PUT",
        body   => qq({"farms" : [ { "name" : "$farm_name", "backends" : [ { "name" : "bck$ids"$json } ] } ] })
    });

    # take care of floating interfaces without masquerading
    if ($json =~ /ip-addr/ && $eload) {
        my $farm_ref = &getL4FarmStruct($farm_name);
        &eload(
            module => 'Relianoid::EE::Net::Floating',
            func   => 'setFloatingSourceAddr',
            args   => [ $farm_ref, { ip => $ip, id => $ids, tag => $mark } ],
        );
    }

    return $output;
}

=pod

=head1 runL4FarmServerDelete

Delete a backend from a l4 farm

Parameters:

    ids - Backend id
    farm_name - Farm name

Returns:

    Scalar - 0 on success or other value on failure

=cut

sub runL4FarmServerDelete ($ids, $farm_name) {
    require Relianoid::Farm::L4xNAT::Config;
    require Relianoid::Farm::L4xNAT::Action;
    require Relianoid::Netfilter;

    my $farm_filename = &getFarmFile($farm_name);
    my $output        = 0;
    my $mark          = "0x0";

    # load the configuration file first if the farm is down
    my $f_ref = &getL4FarmStruct($farm_name);

    $output = &sendL4NlbCmd({
        farm    => $farm_name,
        backend => "bck" . $ids,
        file    => "$configdir/$farm_filename",
        method  => "DELETE",
    });

    my $backend;
    for my $server (@{ $f_ref->{servers} }) {
        if ($server->{id} eq $ids) {
            $mark    = $server->{tag};
            $backend = $server;
            last;
        }
    }

    ### Flush conntrack
    &resetL4FarmBackendConntrackMark($backend);

    &setBackendRule("del", $f_ref, $mark);
    &delMarks("", $mark);

    return $output;
}

=pod

=head1 setL4FarmBackendsSessionsRemove

Remove all the active sessions enabled to a backend

Parameters:

    farm_name - Farm name
    backend_ref - Hash ref of Backend 
    farm_mode - Farm Mode

Returns:

    Integer - 0 on success , 1 on failure

=cut

sub setL4FarmBackendsSessionsRemove ($farm_name, $backend_ref = undef, $farm_mode = undef) {
    my $output = -1;
    if (not defined $backend_ref) {
        &log_warn("Warning removing sessions for backend id farm '$farm_name': Backend id not found", "lslb");
        return $output;
    }

    my $table;
    my $value_check;
    my $value_regex;
    if (defined $farm_mode and $farm_mode eq "dsr") {
        $table = "netdev";
        my $ip_bin    = &getGlobalConfiguration('ip_bin');
        my $mac       = &logAndRun("$ip_bin neigh show $backend_ref->{ip}");
        my @mac_split = split(' ', $mac);
        $value_check = $mac_split[4];
        $value_regex = qr/([a-fA-F0-9:]{1,})/;
    }
    else {
        $table = "ip";
        require Relianoid::Net::Validate;
        if (&ipversion($backend_ref->{ip}) == 6) {
            $table .= "6";
        }
        ($value_check = $backend_ref->{tag}) =~ s/0x//g;
        $value_regex = qr/0x0*(\d+)/;
    }

    my $nft_bin    = &getGlobalConfiguration('nft_bin');
    my $map_name   = "persist-$farm_name";
    my @persistmap = @{ &logAndGet("$nft_bin list map $table nftlb $map_name", "array") };
    my $data       = 0;

    my $sessions;
    my $n_sessions_deleted;
    for my $line (@persistmap) {
        $data = 1 if ($line =~ /elements = /);
        next      if (!$data);

        my ($key, $value) = ($line =~ /,?\s+([\w\.\s\:]+) expires \w+ : $value_regex[\s,]/);
        if ($value eq $value_check) {
            $sessions .= " $key,";
            $n_sessions_deleted++;
        }

        last if ($data and $line =~ /\}/);
    }

    if (defined $sessions) {
        chop $sessions;
        my $error = &logAndRun("$nft_bin delete element $table nftlb $map_name { $sessions }");
        if ($error) {
            &log_error("Error removing '$n_sessions_deleted' sessions for backend id '$backend_ref->{id}' in farm '$farm_name'",
                "lslb");
            $output = 1;
        }
        else {
            &log_info("Removing '$n_sessions_deleted' sessions for backend id '$backend_ref->{id}' in farm '$farm_name'", "lslb");
            $output = 0;
        }
    }
    else {
        # no sessions found
        $output = 0;
    }

    return $output;
}

=pod

=head1 setL4FarmBackendStatus

Set backend status for an l4 farm and stops traffic to that backend when needed.

Parameters:

    farm_name - Farm name
    backend - Backend id
    status - Backend status. The possible values are: "up", "down", "maintenance" or "fgDOWN".
    cutmode - "cut" to force the traffic stop for such backend

Returns:

    hash reference 

    $error_ref->{code}

        - 0 on success
        - 1 on failure changing status,
        - 2 on failure removing sessions
        - 3 on failure removing connections,
        - 4 on failure removing sessions and connections.

    $error_ref->{desc} - error message.

=cut

sub setL4FarmBackendStatus ($farm_name, $backend, $status, $cutmode = undef) {
    require Relianoid::Farm::L4xNAT::Config;
    require Relianoid::Farm::L4xNAT::Action;

    my $error_ref->{code} = -1;
    my $farm              = &getL4FarmStruct($farm_name);
    my $farm_filename     = $farm->{filename};
    my @backends;
    my @bks_prio_status;
    my @bks_updated_prio_status;
    my $output;
    my $msg;
    $status = 'off'  if ($status eq "maintenance");
    $status = 'down' if ($status eq "fgDOWN");

    #the following actions are only needed if a high priority backend turns up after being down/off and
    #a lower priority backend(s) turned active during the time the other backends was down/off
    if ($status eq 'up' and @{ $$farm{servers} } > 1) {
        my $i = 0;
        my $bk_index;
        for my $server (@{ $$farm{servers} }) {
            my $bk;
            $bk_index = $i if $backend == $server->{id};
            if ($server->{status} ne "up") {
                $bk->{status} = "down";
            }
            else {
                $bk->{status} = $server->{status};
            }
            $bk->{priority} = $server->{priority};
            push(@backends, $bk);
            $i++;
        }
        require Relianoid::Farm::Backend;
        @bks_prio_status =
          @{ &getPriorityAlgorithmStatus(\@backends)->{status} };
        $backends[$bk_index]->{status} = $status;
        @bks_updated_prio_status =
          @{ &getPriorityAlgorithmStatus(\@backends)->{status} };
    }

    $output = &sendL4NlbCmd({
        farm   => $farm_name,
        file   => "$configdir/$farm_filename",
        method => "PUT",
        body   =>
          qq({"farms" : [ { "name" : "$farm_name", "backends" : [ { "name" : "bck$backend", "state" : "$status" } ] } ] })
    });

    if ($output) {
        $msg = "Status of backend $backend in farm '$farm_name' was not changed to $status";
        &log_error($msg, "LSLB");
        $error_ref->{code} = 1;
        $error_ref->{desc} = $msg;
        return $error_ref;
    }
    else {
        $msg = "Status of backend $backend in farm '$farm_name' was changed to $status";
        &log_info($msg, "LSLB");
        $error_ref->{code} = 0;
        $error_ref->{desc} = $msg;
    }

    #compare priority status of all backends and delete sessions and connections of backends
    #that have had their priority status changed from true to false.
    my $i = 0;
    for my $bk (@bks_updated_prio_status) {
        if ($bk ne $bks_prio_status[$i]) {
            if (@{ $farm->{servers} }[$i]->{status} eq 'up') {
                if ($farm->{persist} ne '') {
                    # delete backend session
                    $output = &setL4FarmBackendsSessionsRemove($farm_name, @{ $farm->{servers} }[$i], $farm->{mode});
                    if ($output) {
                        $error_ref->{code} = 2;
                    }
                }

                # remove conntrack
                $output =
                  &resetL4FarmBackendConntrackMark(@{ $farm->{servers} }[$i]);
                if ($output) {
                    $msg               = "Connections for unused backends in farm '$farm_name' were not deleted";
                    $error_ref->{code} = 3;
                    $error_ref->{desc} = $msg;
                }

                if ($farm->{persist} ne '') {
                    # delete backend session again in case new connections are created
                    $output = &setL4FarmBackendsSessionsRemove($farm_name, @{ $farm->{servers} }[$i], $farm->{mode});
                    if ($output) {
                        if ($error_ref->{code} == 3) {
                            $msg               = "Connections and sessions of unused backends in farm '$farm_name' were not deleted";
                            $error_ref->{code} = 4;
                            $error_ref->{desc} = $msg;
                        }
                        else {
                            $msg               = "Sessions for unused backends in farm '$farm_name' were not deleted";
                            $error_ref->{code} = 2;
                            $error_ref->{desc} = $msg;
                        }
                    }
                    else {
                        $error_ref->{code} = 0 if $error_ref->{code} == 2;
                    }
                }
            }
        }
        $i++;
    }
    if ($status ne "up" and $cutmode eq "cut") {
        my $server;

        # get backend with id $backend
        for my $srv (@{ $$farm{servers} }) {
            if ($srv->{id} == $backend) {
                $server = $srv;
                last;
            }
        }

        if ($farm->{persist} ne '') {
            #delete backend session
            $output = &setL4FarmBackendsSessionsRemove($farm_name, $server, $farm->{mode});
            if ($output) {
                $error_ref->{code} = 2;
            }
        }

        # remove conntrack
        $output = &resetL4FarmBackendConntrackMark($server);
        if ($output) {
            $msg               = "Connections for backend $server->{ip}:$server->{port} in farm '$farm_name' were not deleted";
            $error_ref->{code} = 3;
            $error_ref->{desc} = $msg;
        }

        if ($farm->{persist} ne '') {
            # delete backend session again in case new connections are created
            $output = &setL4FarmBackendsSessionsRemove($farm_name, $server, $farm->{mode});
            if ($output) {
                if ($error_ref->{code} == 3) {
                    $msg = "Error deleting connections and sessions on backend $server->{ip}:$server->{port} in farm '$farm_name'";
                    $error_ref->{code} = 4;
                    $error_ref->{desc} = $msg;
                }
                else {
                    $msg               = "Sessions for backend $server->{ip}:$server->{port} in farm '$farm_name' were not deleted";
                    $error_ref->{code} = 2;
                    $error_ref->{desc} = $msg;
                }
            }
            else {
                $error_ref->{code} = 0 if $error_ref->{code} == 2;
            }
        }
    }
    if ($farm->{lbalg} eq 'leastconn') {
        require Relianoid::Farm::L4xNAT::L4sd;
        &sendL4sdSignal();
    }

    #~ TODO
    #~ my $stopping_fg = ( $caller =~ /runFarmGuardianStop/ );
    #~ if ( $fg_enabled eq 'true' && !$stopping_fg )
    #~ {
    #~ if ( $0 !~ /farmguardian/ && $fg_pid > 0 )
    #~ {
    #~ kill 'CONT' => $fg_pid;
    #~ }
    #~ }

    return $error_ref;
}

=pod

=head1 getL4FarmServers

Get all backends and their configuration

Parameters:

    farmname - Farm name

Returns:

    Array - array of hash refs of backend struct

=cut

sub getL4FarmServers ($farm_name) {
    my $farm_filename = &getFarmFile($farm_name);

    open my $fh, '<', "${configdir}/${farm_filename}";
    chomp(my @content = <$fh>);
    close $fh;

    return &_getL4FarmParseServers(\@content);
}

=pod

=head1 _getL4FarmParseServers

Return the list of backends with all data about a backend in a l4 farm

Parameters:

    config - plain text server list

Returns:

    array reference - reference to a list of backend hashes

    [
        {
            $id, 
            $alias, 
            $family, 
            $ip, 
            $port, 
            $tag, 
            $weight, 
            $priority, 
            $status, 
            $rip = $ip, 
            $max_conns
        },
        ...
    ]

=cut

sub _getL4FarmParseServers ($config) {
    my $stage = 0;
    my $server;
    my @servers;

    require Relianoid::Farm::L4xNAT::Config;
    my $fproto = &_getL4ParseFarmConfig('proto', undef, $config);

    for my $line (@{$config}) {
        if ($line =~ /\"farms\"/) {
            $stage = 1;
        }

        # do not go to the next level if empty
        if ($line =~ /\"backends\"/ && $line !~ /\[\],/) {
            $stage = 2;
        }

        if ($stage == 2 && $line =~ /\{/) {
            $stage = 3;
            undef $server;
        }

        if ($stage == 3 && $line =~ /\}/) {
            $stage = 2;
            push(@servers, $server);
        }

        if ($stage == 2 && $line =~ /\]/) {
            last;
        }

        if ($stage == 3 && $line =~ /\"name\"/) {
            my @l     = split(/"/, $line);
            my $index = $l[3];
            $index =~ s/bck//;
            $server->{id}        = $index + 0;
            $server->{port}      = undef;
            $server->{tag}       = "0x0";
            $server->{max_conns} = 0;
        }

        if ($stage == 3 && $line =~ /\"ip-addr\"/) {
            my @l = split(/"/, $line);
            $server->{ip}  = $l[3];
            $server->{rip} = $l[3];
        }

        if ($stage == 3 && $line =~ /\"source-addr\"/) {
            my @l = split(/"/, $line);
            $server->{sourceip} = $l[3];
        }

        if ($stage == 3 && $line =~ /\"port\"/) {
            my @l = split(/"/, $line);
            $server->{port} = $l[3];

            require Relianoid::Net::Validate;
            if ($server->{port} ne '' && $fproto ne 'all') {
                if (&ipversion($server->{rip}) == 4) {
                    $server->{rip} = "$server->{ip}\:$server->{port}";
                }
                elsif (&ipversion($server->{rip}) == 6) {
                    $server->{rip} = "[$server->{ip}]\:$server->{port}";
                }
            }

            # Convert to number after being used as string.
            if (defined $server->{port} and length $server->{port}) {
                $server->{port} += 0;
            }
        }

        if ($stage == 3 && $line =~ /\"weight\"/) {
            my @l = split(/"/, $line);
            $server->{weight} = $l[3] + 0;
        }

        if ($stage == 3 && $line =~ /\"priority\"/) {
            my @l = split(/"/, $line);
            $server->{priority} = $l[3] + 0;
        }

        if ($stage == 3 && $line =~ /\"mark\"/) {
            my @l = split(/"/, $line);
            $server->{tag} = $l[3];
        }

        if ($stage == 3 && $line =~ /\"est-connlimit\"/) {
            my @l = split(/"/, $line);
            $server->{max_conns} = $l[3] + 0;
        }

        if ($stage == 3 && $line =~ /\"state\"/) {
            my @l = split(/"/, $line);
            $server->{status} = $l[3];
            $server->{status} = "undefined"
              if ($server->{status} eq "config_error");
            $server->{status} = "maintenance" if ($server->{status} eq "off");
            $server->{status} = "fgDOWN"      if ($server->{status} eq "down");
            $server->{status} = "up"          if ($server->{status} eq "available");
        }
    }

    return \@servers;
}

=pod

=head1 getL4BackendsWeightProbability

Get probability for every backend

Parameters:

    farm - Farm hash ref. It is a hash with all information about the farm

Returns:

    none

=cut

sub getL4BackendsWeightProbability ($farm) {
    my $weight_sum = 0;

    &doL4FarmProbability($farm);

    for my $server (@{ $$farm{servers} }) {
        # only calculate probability for the servers running
        if ($$server{status} eq 'up') {
            $weight_sum += $$server{weight};
            $$server{prob} = $weight_sum / $$farm{prob};
        }
        else {
            $$server{prob} = 0;
        }
    }

    return;
}

=pod

=head1 resetL4FarmBackendConntrackMark

Reset Connection tracking for a given backend

Parameters:

    server - Backend hash reference. It uses the backend unique mark in order to deletes the conntrack entries.

Returns:

    scalar - 0 if deleted, 1 if not deleted

=cut

sub resetL4FarmBackendConntrackMark ($server) {
    my $conntrack = &getGlobalConfiguration('conntrack');
    my $cmd       = "$conntrack -D -m $server->{tag}/0x7fffffff";

    &log_info("running: $cmd") if &debug();

    # return_code = 0 -> deleted
    # return_code = 1 -> not found/deleted
    my $return_code = &logAndRunCheck("$cmd");

    #check if error in return_code is because connections were not found
    if ($return_code) {
        require Relianoid::Net::ConnStats;
        my $params = {
            proto => 'tcp sctp',
            mark  => "$server->{tag}/0x7fffffff",
            state => "ESTABLISHED"
        };
        my $conntrack_params = &getConntrackParams($params);
        my $conns            = &getConntrackCount($conntrack_params);

        #if connections are not found, no error
        $return_code = 0 if $conns == 0;
    }

    if (&debug()) {
        if ($return_code) {
            &log_info("Connection tracking for " . $server->{ip} . " not removed.");
        }
        else {
            &log_info("Connection tracking for " . $server->{ip} . " removed.");
        }
    }

    return $return_code;
}

=pod

=head1 getL4FarmBackendAvailableID

Get next available backend ID

Parameters:

    farmname - farm name

Returns:

    integer - backend ID available

=cut

sub getL4FarmBackendAvailableID ($farmname) {
    require Relianoid::Farm::Backend;

    my $backends  = &getL4FarmServers($farmname);
    my $nbackends = $#{$backends} + 1;

    for (my $id = 0 ; $id < $nbackends ; $id++) {
        my $exists = &getFarmServer($backends, $id);
        return $id if (!$exists);
    }

    return $nbackends;
}

=pod

=head1 getL4FarmPriorities

Get the list of the backends priorities in a L4 farm

Parameters:

    farmname - Farm name

Returns:

    Array Ref - it returns an array ref of priority values

=cut

sub getL4FarmPriorities ($farmname) {
    my @priorities;
    my $backends = &getL4FarmServers($farmname);

    for my $backend (@{$backends}) {
        if (defined $backend->{priority}) {
            push @priorities, $backend->{priority};
        }
        else {
            push @priorities, 1;
        }
    }

    return \@priorities;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/L4xNAT/Config.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Config;
use Relianoid::Nft;

my $eload     = eval { require Relianoid::ELoad };
my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::L4xNAT::Config

=cut

=pod

=head1 getL4FarmParam

Returns farm parameter

Parameters:

    param - requested parameter. The options are:

        "vip":          get the virtual IP
        "vipp":         get the virtual port
        "bootstatus":   get boot status
        "status":       get the current status
        "mode":         get the topology (or nat type)
        "alg":          get the algorithm
        "proto":        get the protocol
        "persist":      get persistence
        "persisttm":    get client persistence timeout
        "limitrst":     limit RST request per second
        "limitrstbrst": limit RST request per second burst
        "limitsec":     connection limit per second
        "limitsecbrst": Connection limit per second burst
        "limitconns":   total connections limit per source IP
        "bogustcpflags": check bogus TCP flags
        "nfqueue":      queue to verdict the packets
        "sourceaddr":   get the source address

    farm_name - Farm name

Returns:

    Scalar - return the parameter as a string or -1 on failure

=cut

sub getL4FarmParam ($param, $farm_name) {
    require Relianoid::Farm::Core;

    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;

    if ($param eq "status") {
        return &getL4FarmStatus($farm_name);
    }

    if ($param eq "alg") {
        require Relianoid::Farm::L4xNAT::L4sd;
        my $l4sched = &getL4sdType($farm_name);
        return $l4sched if ($l4sched ne "");
    }

    open my $fh, '<', "${configdir}/${farm_filename}";
    chomp(my @content = <$fh>);
    close $fh;

    $output = &_getL4ParseFarmConfig($param, undef, \@content);

    return $output;
}

=pod

=head1 setL4FarmParam

    Writes a farm parameter

Parameters:

    param - requested parameter. The options are:

        "name":         new farm name
        "family":       write ipv4 or ipv6
        "vip":          write the virtual IP
        "vipp":         write the virtual port
        "status" or "bootstatus":
                        write the status and boot status
        "mode":         write the topology (or nat type)
        "alg":          write the algorithm
        "proto":        write the protocol
        "persist":      write persistence
        "persisttm":    write client persistence timeout
        "limitrst":     limit RST request per second
        "limitrstbrst": limit RST request per second burst
        "limitsec":     connection limit per second
        "limitsecbrst": Connection limit per second burst
        "limitconns":   total connections limit per source IP
        "bogustcpflags": check bogus TCP flags
        "nfqueue":      queue to verdict the packets
        "policy":       policy list to be applied
        "sourceaddr":   set the source address

    value - the new value of the given parameter of a certain farm

    farm_name - Farm name

Returns:

    Scalar - return the parameter as a string or -1 on failure

=cut

sub setL4FarmParam ($param, $value, $farm_name) {
    require Relianoid::Farm::Core;

    my $farm_filename = &getFarmFile($farm_name);
    my $output        = -1;
    my $srvparam      = "";
    my $addition      = "";
    my $prev_config   = "";
    my $farm_req      = $farm_name;
    my $parameters    = "";

    if ($param eq "name") {
        $farm_filename = "${value}_l4xnat.cfg";
        $farm_req      = $value;
        $parameters    = qq(, "newname" : "$value" );
    }
    elsif ($param eq "family") {
        $parameters = qq(, "family" : "$value" );
    }
    elsif ($param eq "mode") {
        $value      = "snat"     if ($value eq "nat");
        $value      = "stlsdnat" if ($value eq "stateless_dnat");
        $parameters = qq(, "mode" : "$value" );

        # deactivate leastconn and persistence for ingress modes
        if ($value eq "dsr" || $value eq "stateless_dnat") {
            require Relianoid::Farm::L4xNAT::L4sd;
            &setL4sdType($farm_name, "none");

            if ($eload) {
                # unassign DoS & RBL
                &eload(
                    module => 'Relianoid::EE::IPDS::Base',
                    func   => 'runIPDSStopByFarm',
                    args   => [ $farm_name, "dos" ],
                );
                &eload(
                    module => 'Relianoid::EE::IPDS::Base',
                    func   => 'runIPDSStopByFarm',
                    args   => [ $farm_name, "rbl" ],
                );
            }
        }

        # take care of floating interfaces without masquerading
        if ($value eq "snat" && $eload) {
            my $farm_ref = &getL4FarmStruct($farm_name);
            &eload(
                module => 'Relianoid::EE::Net::Floating',
                func   => 'setFloatingSourceAddr',
                args   => [ $farm_ref, undef ],
            );
        }
    }
    elsif ($param eq "vip") {
        $prev_config = &getFarmStruct($farm_name);
        require Relianoid::Net::Validate;
        my $vip_family = "ipv" . &ipversion($value);
        $parameters = qq(, "virtual-addr" : "$value", "family" : "$vip_family" );
    }
    elsif ($param eq "vipp" or $param eq "vport") {
        $value =~ s/\:/\-/g;
        if ($value eq "*") {
            $parameters = qq(, "virtual-ports" : "" );
        }
        else {
            $parameters = qq(, "virtual-ports" : "$value" );
        }
    }
    elsif ($param eq "alg") {
        $value = "rr" if ($value eq "roundrobin");

        if ($value eq "hash_srcip_srcport") {
            $value    = "hash";
            $addition = $addition . qq( , "sched-param" : "srcip srcport" );
        }

        if ($value eq "hash_srcip") {
            $value    = "hash";
            $addition = $addition . qq( , "sched-param" : "srcip" );
        }

        require Relianoid::Farm::L4xNAT::L4sd;
        if ($value eq "leastconn") {
            &setL4sdType($farm_name, $value);
            $value = "weight";
        }
        else {
            &setL4sdType($farm_name, "none");
        }

        $parameters = qq(, "scheduler" : "$value" ) . $addition;
    }
    elsif ($param eq "proto") {
        $srvparam = "protocol";

        &loadL4Modules($value);

        if ($value =~ /^ftp|irc|pptp|sane/) {
            $addition = $addition . qq( , "helper" : "$value" );
            $value    = "tcp";
        }
        elsif ($value =~ /tftp|snmp|amanda|netbios-ns/) {
            $addition = $addition . qq( , "helper" : "$value" );
            $value    = "udp";
        }
        elsif ($value =~ /all/) {
            $addition = $addition . qq( , "helper" : "none" );
            $addition = $addition . qq( , "virtual-ports" : "" );
        }
        elsif ($value =~ /sip|h323/) {
            $addition = $addition . qq( , "helper" : "$value" );
            $value    = "all";
        }
        else {
            $addition = $addition . qq( , "helper" : "none" );
        }

        $parameters = qq(, "protocol" : "$value" ) . $addition;
    }
    elsif ($param eq "status" || $param eq "bootstatus") {
        $parameters = qq(, "state" : "$value" );
    }
    elsif ($param eq "persist") {
        $value      = "srcip" if ($value eq "ip");
        $value      = "none"  if ($value eq "");
        $parameters = qq(, "persistence" : "$value" );
    }
    elsif ($param eq "persisttm") {
        $parameters = qq(, "persist-ttl" : "$value" );
    }
    elsif ($param eq "limitrst") {
        $parameters = qq(, "rst-rtlimit" : "$value" );
    }
    elsif ($param eq "limitrstbrst") {
        $parameters = qq(, "rst-rtlimit-burst" : "$value" );
    }
    elsif ($param eq "limitrst-logprefix") {
        $parameters = qq(, "rst-rtlimit-log-prefix" : "$value" );
    }
    elsif ($param eq "limitsec") {
        $parameters = qq(, "new-rtlimit" : "$value" );
    }
    elsif ($param eq "limitsecbrst") {
        $parameters = qq(, "new-rtlimit-burst" : "$value" );
    }
    elsif ($param eq "limitsec-logprefix") {
        $parameters = qq(, "new-rtlimit-log-prefix" : "$value" );
    }
    elsif ($param eq "limitconns") {
        $parameters = qq(, "est-connlimit" : "$value" );
    }
    elsif ($param eq "limitconns-logprefix") {
        $parameters = qq(, "est-connlimit-log-prefix" : "$value" );
    }
    elsif ($param eq "bogustcpflags") {
        $parameters = qq(, "tcp-strict" : "$value" );
    }
    elsif ($param eq "bogustcpflags-logprefix") {
        $parameters = qq(, "tcp-strict-log-prefix" : "$value" );
    }
    elsif ($param eq "nfqueue") {
        $parameters = qq(, "queue" : "$value" );
    }
    elsif ($param eq "sourceaddr") {
        $parameters = qq(, "source-addr" : "$value" );
    }
    elsif ($param eq 'policy') {
        $parameters = qq(, "policies" : [ { "name" : "$value" } ] );
    }
    elsif ($param eq "logs") {
        $srvparam   = "log";
        $value      = "forward" if ($value eq "true");
        $value      = "none"    if ($value eq "false");
        $parameters = qq(, "$srvparam" : "$value");
    }
    elsif ($param eq "log-prefix") {
        $srvparam   = "log-prefix";
        $value      = "l4:$farm_name ";
        $parameters = qq(, "$srvparam" : "$value");

        # TODO: put a warning msg when farm name is longer than nftables reserved log size
    }
    else {
        return -1;
    }

    require Relianoid::Farm::L4xNAT::Action;

    $output = &sendL4NlbCmd({
        farm          => $farm_name,
        farm_new_name => $farm_req,
        file          => ($param ne 'status') ? "$configdir/$farm_filename" : undef,
        method        => "PUT",
        body          => qq({"farms" : [ { "name" : "$farm_name"$parameters } ] })
    });

    # Finally, reload rules
    if ($param eq "vip") {
        &doL4FarmRules("reload", $farm_name, $prev_config)
          if ($prev_config->{status} eq "up");

        # reload source address maquerade
        require Relianoid::Farm::Config;
        &reloadFarmsSourceAddressByFarm($farm_name);
    }

    return $output;
}

=pod

=head1 _getL4ParseFarmConfig

Parse the farm file configuration and read/write a certain parameter

Parameters:

    param - requested parameter. The options are 
            "family", 
            "vip", 
            "vipp", 
            "status", 
            "mode", 
            "alg", 
            "proto", 
            "persist", 
            "presisttm", 
            "limitsec", 
            "limitsecbrst", 
            "limitconns", 
            "limitrst", 
            "limitrstbrst", 
            "bogustcpflags", 
            "nfqueue", 
            "sourceaddr"

    value - value to be changed in case of write operation, undef for read only cases

    config - reference of an array with the full configuration file

Returns:

    Scalar - return the parameter value on read or the changed value in case of write as a string or -1 in other case

=cut

sub _getL4ParseFarmConfig ($param, $value, $config) {
    my $output = -1;
    my $exit   = 1;

    for my $line (@{$config}) {
        if ($line =~ /\"family\"/ && $param eq 'family') {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"virtual-addr\"/ && $param eq 'vip') {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"virtual-ports\"/ && $param eq 'vipp') {
            my @l = split /"/, $line;
            $output = $l[3];
            $output = "*" if ($output eq '1-65535' || $output eq '');
            $output =~ s/-/:/g;
        }

        if ($line =~ /\"source-addr\"/ && $param eq 'sourceaddr') {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"mode\"/ && $param eq 'mode') {
            my @l = split /"/, $line;
            $output = $l[3];
            $output = "nat"            if ($output eq "snat");
            $output = "stateless_dnat" if ($output eq "stlsdnat");
        }

        if ($line =~ /\"protocol\"/ && $param eq 'proto') {
            my @l = split /"/, $line;
            $output = $l[3];
            $exit   = 0;
        }

        if ($line =~ /\"persistence\"/ && $param eq 'persist') {
            my @l   = split /"/, $line;
            my $out = $l[3];
            if ($out =~ /none/) {
                $output = "";
            }
            elsif ($out =~ /srcip/) {
                $output = "ip";
                $output = "srcip_srcport" if ($out =~ /srcport/);
                $output = "srcip_dstport" if ($out =~ /dstport/);
            }
            elsif ($out =~ /srcport/) {
                $output = "srcport";
            }
            elsif ($out =~ /srcmac/) {
                $output = "srcmac";
            }
            $exit = 0;
        }

        if ($line =~ /\"persist-ttl\"/ && $param eq 'persisttm') {
            my @l = split /"/, $line;
            $output = $l[3] + 0;
            $exit   = 0;
        }

        if ($line =~ /\"helper\"/ && $param eq 'proto') {
            my @l   = split /"/, $line;
            my $out = $l[3];

            $output = $out if ($out ne "none");
            $exit   = 1;
        }

        if ($line =~ /\"scheduler\"/ && $param eq 'alg') {
            my @l = split /"/, $line;
            $output = $l[3];

            $exit   = 0            if ($output =~ /hash/);
            $output = "roundrobin" if ($output eq "rr");
        }

        if ($line =~ /\"sched-param\"/ && $param eq 'alg') {
            my @l   = split /"/, $line;
            my $out = $l[3];

            if ($output eq "hash") {
                if ($out =~ /srcip/) {
                    $output = "hash_srcip";
                    $output = "hash_srcip_srcport" if ($out =~ /srcport/);
                }
            }
            $exit = 1;
        }

        if ($line =~ /\"log\"/ && $param eq 'logs') {
            my @l = split /"/, $line;
            $output = "false";
            $output = "true" if ($l[3] ne "none");
        }

        if ($line =~ /\"state\"/ && $param =~ /status/) {
            my @l = split /"/, $line;
            if ($l[3] ne "up") {
                $output = "down";
            }
            else {
                $output = "up";
            }
        }

        if ($line =~ /\"rst-rtlimit\"/ && $param eq "limitrst") {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"rst-rtlimit-burst\"/ && $param eq "limitrstbrst") {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"new-rtlimit\"/ && $param eq "limitsec") {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"new-rtlimit-burst\"/ && $param eq "limitsecbrst") {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"est-connlimit\"/ && $param eq "limitconns") {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"tcp-strict\"/ && $param eq "bogustcpflags") {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($line =~ /\"queue\"/ && $param eq "nfqueue") {
            my @l = split /"/, $line;
            $output = $l[3];
        }

        if ($output ne "-1") {
            $line =~ s/$output/$value/g if defined $value;
            return $output              if ($exit);
        }
    }

    return $output;
}

=pod

=head1 modifyLogsParam

It enables or disables the logs for a l4xnat farm

Parameters:

    farmname - Farm name

    log value - The possible values are: 'true' to enable the logs or 'false' to disable them

Returns:

    String - return an error message on error or undef on success

=cut

sub modifyLogsParam ($farmname, $logsValue) {
    my $msg;
    my $err = 0;

    if ($logsValue =~ /(?:true|false)/) {
        $err = &setL4FarmParam('logs',       $logsValue, $farmname);
        $err = &setL4FarmParam('log-prefix', undef,      $farmname)
          if (not $err and $logsValue eq 'true');
    }
    else {
        $msg = "Invalid value for logs parameter.";
    }

    if ($err) {
        $msg = "Error modifying the parameter logs.";
    }
    return $msg;
}

=pod

=head1 getL4FarmStatus

Return current farm status

Parameters:

    farm_name - Farm name

Returns:

    String - "up" or "down"

=cut

sub getL4FarmStatus ($farm_name) {
    require Relianoid::Farm::L4xNAT::Action;

    my $pidfile = &getL4FarmPidFile($farm_name);
    my $output  = "down";

    my $nlbpid = &getNlbPid();
    if ($nlbpid eq "-1") {
        return $output;
    }

    $output = "up" if (-e "$pidfile");

    return $output;
}

=pod

=head1 getL4FarmStruct

Return a hash with all data about a l4 farm

Parameters:

    farmname - Farm name

Returns:

    hash ref - hash with farm values

    # %farm = 
    {
        $name,
        $filename,
        $nattype,
        $lbalg, 
        $vip, 
        $vport, 
        $vproto, 
        $sourceip, 
        $persist, 
        $ttl, 
        $proto, 
        $status, 
        \@servers
    }

    \@servers = [ \%backend1, \%backend2, ... ]

=cut

sub getL4FarmStruct ($farmname) {
    my %farm;

    $farm{name} = $farmname;

    require Relianoid::Farm::L4xNAT::Backend;

    $farm{filename} = &getFarmFile($farm{name});
    require Relianoid::Farm::Config;
    my $config = &getFarmPlainInfo($farm{name});

    $farm{nattype} = &_getL4ParseFarmConfig('mode', undef, $config);
    $farm{mode}    = $farm{nattype};

    require Relianoid::Farm::L4xNAT::L4sd;
    my $l4sched = &getL4sdType($farm{name});
    if ($l4sched ne "") {
        $farm{lbalg} = $l4sched;
    }
    else {
        $farm{lbalg} = &_getL4ParseFarmConfig('alg', undef, $config);
    }

    $farm{vip}      = &_getL4ParseFarmConfig('vip',   undef, $config);
    $farm{vport}    = &_getL4ParseFarmConfig('vipp',  undef, $config);
    $farm{vproto}   = &_getL4ParseFarmConfig('proto', undef, $config);
    $farm{sourceip} = "";
    $farm{sourceip} = &_getL4ParseFarmConfig('sourceaddr', undef, $config);

    my $persist = &_getL4ParseFarmConfig('persist', undef, $config);
    $farm{persist} = ($persist eq "-1") ? '' : $persist;
    my $ttl = &_getL4ParseFarmConfig('persisttm', undef, $config);
    $farm{ttl} = ($ttl == -1) ? 0 : $ttl;

    $farm{proto}      = &getL4ProtocolTransportLayer($farm{vproto});
    $farm{bootstatus} = &_getL4ParseFarmConfig('bootstatus', undef, $config);
    $farm{status}     = &getL4FarmStatus($farm{name});
    $farm{logs}       = &_getL4ParseFarmConfig('logs', undef, $config) if ($eload);
    $farm{servers}    = &_getL4FarmParseServers($config);

    if ($farm{lbalg} eq 'weight') {
        &getL4BackendsWeightProbability(\%farm);
    }

    return \%farm;
}

=pod

=head1 loadL4Modules

Load sip, ftp or tftp conntrack module for l4 farms

Parameters:

    protocol - protocol module to load

Returns:

    Integer - 0 if success, otherwise error

=cut

sub loadL4Modules ($protocol) {
    require Relianoid::Netfilter;

    my $status = 0;

    if ($protocol =~ /sip|tftp|ftp|amanda|h323|irc|netbios-ns|pptp|sane|snmp/) {
        my $params = "";
        $params = &getGlobalConfiguration("l4xnat_sip_params")
          if ($protocol eq "sip");
        $status = &loadNfModule("nf_conntrack_$protocol", $params);
        $status = $status || &loadNfModule("nf_nat_$protocol", "");
    }

    return $status;
}

=pod

=head1 unloadL4Modules

Unload conntrack helpers modules for l4 farms

Parameters:

    protocol - protocol module to load

Returns:

    Integer - 0 if success, otherwise error

=cut

sub unloadL4Modules ($protocol) {
    my $status = 0;

    require Relianoid::Netfilter;

    if ($protocol =~ /sip|tftp|ftp|amanda|h323|irc|netbios-ns|pptp|sane|snmp/) {
        my $n_farms = 0;
        require Relianoid::Farm::Core;
        for my $farm (&getFarmsByType("l4xnat")) {
            if (&getL4FarmParam('proto', $farm) eq $protocol) {
                $n_farms++ if (&getL4FarmStatus($farm) ne "down");
            }
        }
        if (not $n_farms) {
            $status = &removeNfModule("nf_nat_$protocol");
            $status = $status || &removeNfModule("nf_conntrack_$protocol");
        }
    }

    return $status;
}

=pod

=head1 getFarmPortList

If port is multiport, it removes range port and it passes it to a port list

Parameters:

    fvipp - Port string

Returns:

    array - return a list of ports

=cut

sub getFarmPortList ($fvipp) {
    my @portlist    = split(',', $fvipp);
    my @retportlist = ();

    if (!grep { /\*/ } @portlist) {
        for my $port (@portlist) {
            if ($port =~ /:/) {
                my @intlimits = split(':', $port);

                for (my $i = $intlimits[0] ; $i <= $intlimits[1] ; $i++) {
                    push(@retportlist, $i);
                }
            }
            else {
                push(@retportlist, $port);
            }
        }
    }
    else {
        $retportlist[0] = '*';
    }

    return @retportlist;
}

=pod

=head1 getL4ProtocolTransportLayer

Return basic transport protocol used by l4 farm protocol

Parameters:

    protocol - L4xnat farm protocol

Returns:

    String - "udp" or "tcp"

=cut

sub getL4ProtocolTransportLayer ($vproto) {
    return
        ($vproto =~ /sip|tftp/) ? 'udp'
      : ($vproto eq 'ftp')      ? 'tcp'
      :                           $vproto;
}

=pod

=head1 doL4FarmProbability

Create in the passed hash a new key called "prob". In this key is saved total weight of all backends

Parameters:

    farm - farm hash ref. It is a hash with all information about the farm

Returns:

    none

=cut

sub doL4FarmProbability ($farm) {
    $$farm{prob} = 0;

    for my $server_ref (@{ $$farm{servers} }) {
        if ($$server_ref{status} eq 'up') {
            $$farm{prob} += $$server_ref{weight};
        }
    }

    return;
}

=pod

=head1 doL4FarmRules

Created to operate with setBackendRule in order to start, stop or reload ip rules

Parameters:

    action - stop (delete all ip rules), start (create ip rules) or reload (delete old one stored in prev_farm_ref and create new)

    farm_name - farm hash ref. It is a hash with all information about the farm

    prev_farm_ref - farm reference of the old configuration. Optional.

Returns:

    none

=cut

sub doL4FarmRules ($action, $farm_name, $prev_farm_ref = undef) {
    my $farm_ref = &getL4FarmStruct($farm_name);

    require Relianoid::Farm::Backend;

    for my $server (@{ $farm_ref->{servers} }) {
        if ($action eq "stop") {
            &setBackendRule("del", $farm_ref, $server->{tag});
        }
        elsif ($action eq "reload") {
            &setBackendRule("del", $prev_farm_ref, $server->{tag});
            &setBackendRule("add", $farm_ref,      $server->{tag});
        }
        elsif ($action eq "start") {
            &setBackendRule("add", $farm_ref, $server->{tag});
        }
    }

    return;
}

=pod

=head1 writeL4NlbConfigFile

Write the L4 config file from a curl Nlb request, by filtering IPDS parameters.

Parameters:

    nftfile - temporary file captured from the nftlb farm configuration

    cfgfile - definitive file where the definitive nftlb farm configuration will be stored

Returns:

    Integer - 0 if success, other if error.

=cut

sub writeL4NlbConfigFile ($nftfile, $cfgfile) {
    require Relianoid::Lock;

    if (!-e "$nftfile") {
        return 1;
    }

    &log_debug("Saving farm conf '$cfgfile'");

    my $fo = &openlock($cfgfile, 'w');

    my @lines = ();
    if (open(my $fh, '<', $nftfile)) {
        @lines = <$fh>;
        close $fh;
    }

    my $line  = shift @lines;
    my $write = 1;
    my $next_line;

    while (defined $line) {
        $next_line = shift @lines;
        $write     = 0 if ($line =~ /\"policies\"\:/);

        if (   defined($next_line)
            && $next_line =~ /\"policies\"\:/
            && $line      =~ /\]/)
        {
            $line =~ s/,$//g;
            $line =~ s/\n//g;
        }
        print $fo $line
          if ( $line !~ /new-rtlimit|rst-rtlimit|tcp-strict|queue|^[\s]{24}.est-connlimit/
            && $write == 1);

        if ($write == 0 && $line =~ /\]/) {
            $write = 1;
            if ($next_line =~ /\"sessions\"\:/) {
                print $fo ",\n";
            }
            else {
                print $fo "\n";
            }
        }

        $line = $next_line;
    }

    close $fo;
    unlink $nftfile;

    return 0;
}

=pod

=head1 resetL4FarmConntrack

Reset Connection tracking for a given farm

Parameters:

    farm_name

Returns:

    error: 1 in case of error and 0 otherwise

=cut

sub resetL4FarmConntrack ($farm_name) {
    my $error = 0;

    my $servers = &getL4FarmServers($farm_name);
    for my $server (@{$servers}) {
        &resetL4FarmBackendConntrackMark($server);
    }

    # Check there are not connections
    require Relianoid::Farm::L4xNAT::Stats;
    require Relianoid::Net::ConnStats;
    my $vip     = &getL4FarmParam("vip", $farm_name);
    my $netstat = &getConntrack('', $vip, '', '', '');
    my $conns   = &getL4FarmEstConns($farm_name, $netstat);
    $conns += &getL4FarmSYNConns($farm_name, $netstat);

    if ($conns > 0) {
        &log_error("Error flushing conntrack for $farm_name");
        $error = 1;
    }

    return $error;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/L4xNAT/Factory.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Core;
use Relianoid::Farm::L4xNAT::Action;

my $configdir = &getGlobalConfiguration('configdir');

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::L4xNAT::Factory

=cut

=pod

=head1 runL4FarmCreate

Create a l4xnat farm

Parameters:

    vip - Virtual IP
    farm_name - Farm name
    vip_port - Virtual port. In l4xnat it ls possible to define multiport
               using ',' to add ports and ':' for ranges
    status - Set the initial status of the farm. The possible values are:
             - 'down' for creating the farm and do not run it
             - 'up' (default) for running the farm when it has been created

Returns:

    Integer - return 0 on success or other value on failure

=cut

sub runL4FarmCreate ($vip, $farm_name, $vip_port, $status = 'up') {
    my $output        = -1;
    my $farm_type     = 'l4xnat';
    my $farm_filename = "$configdir/$farm_name\_$farm_type.cfg";

    require Relianoid::Farm::L4xNAT::Action;
    require Relianoid::Farm::L4xNAT::Config;

    my $proto = ($vip_port eq "*") ? 'all' : 'tcp';
    $vip_port = "80" if not defined $vip_port;
    $vip_port = ""   if ($vip_port eq "*");
    $vip_port =~ s/\:/\-/g;

    require Relianoid::Net::Validate;
    my $vip_family;
    if (&ipversion($vip) == 6) {
        $vip_family = "ipv6";
    }
    else {
        $vip_family = "ipv4";
    }

    $output = &sendL4NlbCmd({
        farm   => $farm_name,
        file   => "$farm_filename",
        method => "POST",
        body   =>
          qq({"farms" : [ { "name" : "$farm_name", "virtual-addr" : "$vip", "virtual-ports" : "$vip_port", "protocol" : "$proto", "mode" : "snat", "scheduler" : "weight", "state" : "$status", "family" : "$vip_family" } ] })
    });

    if ($output) {
        require Relianoid::Farm::Action;
        &runFarmDelete($farm_name);
        return 1;
    }

    if ($status eq 'up') {
        $output = &startL4Farm($farm_name);
    }

    return $output;
}

=pod

=head1 runL4FarmDelete

Delete a l4xnat farm

Parameters:

    farm_name - Farm name

Returns:

    Integer - return 0 on success or other value on failure

=cut

sub runL4FarmDelete ($farm_name) {
    my $output = -1;

    require Relianoid::Farm::L4xNAT::Action;
    require Relianoid::Farm::L4xNAT::Config;
    require Relianoid::Farm::Core;
    require Relianoid::Netfilter;

    my $farmfile = &getFarmFile($farm_name);

    $output = &sendL4NlbCmd({ farm => $farm_name, method => "DELETE" });

    unlink("$configdir/$farmfile") if (-f "$configdir/$farmfile");

    &delMarks($farm_name, "");

    return $output;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/L4xNAT/L4sd.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::Farm::L4xNAT::L4sd

=cut

=pod

=head1 runL4sdDaemon

Launch the l4sd daemon if it's not already launched

Parameters:

    none

Returns:

    Integer - Error code: 0 on success or other value on failure
=cut

sub runL4sdDaemon () {
    my $l4sdbin = &getGlobalConfiguration('l4sd');
    my $pidfile = &getGlobalConfiguration('l4sdpid');

    if (!-f "$pidfile") {
        return &logAndRunBG($l4sdbin);
    }

    return -1;
}

=pod

=head1 sendL4sdSignal

Send a USR1 signal to L4sd

Parameters:

    none

Returns:

    Integer - Error code: 0 on success or other value on failure
=cut

sub sendL4sdSignal () {
    my $output  = -1;
    my $pidfile = &getGlobalConfiguration('l4sdpid');

    &runL4sdDaemon();

    # read pid number
    open my $fh, "<", $pidfile or return -1;
    my $pid = <$fh>;
    close $fh;

    my $success = kill USR1 => $pid;
    $output = 0 if $success;

    return $output;
}

=pod

=head1 getL4sdType

Obtain if a given farm has l4sd and its type

Parameters:

    farm_name - Name of the farm to search for l4sd configuration

Returns:

    String - Returns a string with the type of dynamic scheduler, empty if none.
=cut

sub getL4sdType ($farm_name) {
    my $output   = "";
    my $l4sdfile = &getGlobalConfiguration('l4sdcfg');

    if (!-f "$l4sdfile") {
        return $output;
    }

    require Config::Tiny;
    my $config = Config::Tiny->read($l4sdfile);
    if (defined $config->{$farm_name} && exists $config->{$farm_name}) {
        $output = $config->{$farm_name}{type};
    }

    return $output;
}

=pod

=head1 setL4sdType

Obtain if a given farm has l4sd and its type

Parameters:

    farm_name - Name of the farm to search for l4sd configuration

    type - Type of dynamic scheduler (ex: leastconn, none )

Returns:

    String - Returns a string with the type of dynamic scheduler, empty if none.

=cut

sub setL4sdType ($farm_name, $type) {
    my $l4sdfile = &getGlobalConfiguration('l4sdcfg');

    if (!-f "$l4sdfile") {
        if(open my $fh, '>', $l4sdfile) {
            close $fh;
        }
        else {
            &log_error("Could not create file $l4sdfile: $!", "L4SD");
            return -1;
        }
    }

    require Config::Tiny;
    my $config = Config::Tiny->read($l4sdfile);

    if ($type eq "none") {
        delete $config->{$farm_name};
    }
    elsif ($type eq "leastconn") {
        $config->{$farm_name}{type} = $type;
    }
    $config->write($l4sdfile);

    &sendL4sdSignal();

    return 0;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/L4xNAT/Service.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::L4xNAT::Service

=cut

=pod

=head1 loadL4FarmModules

Load L4farm system modules and conntrack

Parameters:

    none

Returns:

    Integer - 0 on success or any other value on failure

=cut

sub loadL4FarmModules () {
    my $modprobe_bin = &getGlobalConfiguration("modprobe");
    my $error        = 0;
    if ($eload) {
        my $cmd = "$modprobe_bin nf_conntrack enable_hooks=1";
        $error += &logAndRun("$cmd");
    }
    else {
        $error += &logAndRun("$modprobe_bin nf_conntrack");

        # Initialize conntrack
        my $nftbin = &getGlobalConfiguration("nft_bin");

        # Flush nft tables
        &logAndRun("$nftbin flush table ip dummyTable");

        my $nftCmd =
          "$nftbin add table ip dummyTable; $nftbin add chain ip dummyTable dummyChain { type nat hook input priority 0 \\; }; $nftbin add rule ip dummyTable dummyChain ct state established accept";

        $error += &logAndRun("$nftCmd")
          if (&logAndRunCheck("$nftbin list table dummyTable"));
    }

    return $error;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/L4xNAT/Sessions.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::L4xNAT::Config;

=pod

=head1 Module

Relianoid::Farm::L4xNAT::Sessions

=cut

=pod

=head1 parseL4FarmSessions

It transform the session output of nftlb output in a Relianoid session struct

Parameters:

    session ref - It is the session hash returned for nftlb. Example:

    session = {
        'expiration' => '1h25m31s364ms',
        'backend' => 'bck0',
        'client' => '192.168.10.162'
    }

Returns:

    Hash ref - It is a hash with the following keys:

    'session' 

        Returns the session token.

    'id'

        Returns the backen linked with the session token.
        If any session was found the function will return 'undef'.

    'type'

        Will have the value:

        - 'static' if the session is preloaded by the user.
        - 'dynamic' if the session is created automatically by the system when the connection arrives.

    'ttl'

        Is the time out of the session.
        This field will be 'undef' when the session is static.

        {
            "id" : 3,
            "session" : "192.168.1.186"
            "type" : "dynamic"
            "ttl" : "1h25m31s364ms"
        }

=cut

sub parseL4FarmSessions ($s) {
    # translate session
    my $session = $s->{client};
    $session =~ s/ \. /_/;

    my $obj = {
        'session' => $session,
        'type'    => (exists $s->{expiration}) ? 'dynamic'        : 'static',
        'ttl'     => (exists $s->{expiration}) ? $s->{expiration} : undef,
    };

    if ($s->{backend} =~ /bck(\d+)/) {
        $obj->{id} = $1;
    }

    return $obj;
}

=pod

=head1 listL4FarmSessions

Get a list of the static and dynamic l4 sessions in a farm. Using nftlb

Parameters:

    farmname - Farm name

Returns:

    array ref - Returns a list of hash references with the following parameters:

    "client" 

        is the client position entry in the session table

    "id"

        is the backend id assigned to session

    "session"

        is the key that identifies the session

    "type"

        is the key that identifies the session

    [
        {
            "client" : 0,
            "id" : 3,
            "session" : "192.168.1.186",
            "type" : "dynamic",
            "ttl" : "54m5s",
        }
    ]

=cut

sub listL4FarmSessions ($farmname) {
    require Relianoid::Lock;
    require Relianoid::JSON;
    require Relianoid::Nft;

    my $farm     = &getL4FarmStruct($farmname);
    my @sessions = ();
    my $it;

    return [] if ($farm->{persist} eq "");

    my $session_tmp = "/tmp/session_$farmname.data";
    my $lock_f      = &getLockFile($session_tmp);
    my $lock_fd     = &openlock($lock_f, 'w');
    my $err         = &sendL4NlbCmd({
        method => "GET",
        uri    => "/farms/" . $farmname . '/sessions',
        farm   => $farmname,
        file   => $session_tmp,
    });

    my $nftlb_resp;
    if (!$err) {
        $nftlb_resp = &decodeJSONFile($session_tmp);
    }

    close $lock_fd;

    if ($err or not defined $nftlb_resp) {
        return [];
    }

    my $client_id = 0;
    my $backend_info;
    for my $bck (@{ $farm->{servers} }) {
        $backend_info->{ $bck->{id} }{ip}   = $bck->{ip};
        $backend_info->{ $bck->{id} }{port} = $bck->{port};
    }

    for my $s (@{ $nftlb_resp->{sessions} }) {
        $it                 = &parseL4FarmSessions($s);
        $it->{client}       = $client_id++;
        $it->{backend_ip}   = $backend_info->{ $it->{id} }{ip};
        $it->{backend_port} = $backend_info->{ $it->{id} }{port};
        push @sessions, $it;
    }

    return \@sessions;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/L4xNAT/Stats.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::Farm::L4xNAT::Stats

=cut

=pod

=head1 getL4BackendEstConns

Get all ESTABLISHED connections for a backend

Parameters:

    farm_name - Farm name
    be_ip - IP backend
    be_port - Backend port
    netstat - reference to array with Conntrack -L output

Returns:

    array - Return all ESTABLISHED conntrack lines for the backend

FIXME:

    dnat and nat regexp is duplicated

=cut

sub getL4BackendEstConns ($farm_name, $be_ip, $be_port, $netstat) {
    my $farm = &getL4FarmStruct($farm_name);

    my @fportlist   = &getFarmPortList($farm->{vport});
    my $regexp      = "";
    my $connections = 0;
    my $add_search  = "";

    #if there is a backend port then must be included in the filter
    if ($be_port > 0) {
        $add_search = "sport=$be_port";
    }

    if ($fportlist[0] !~ /\*/) {
        $regexp = "\(" . join('|', @fportlist) . "\)";
    }
    else {
        $regexp = "\.*";
    }

    if ($farm->{mode} eq "dnat") {
        if (   $farm->{proto} eq "sip"
            || $farm->{proto} eq "all"
            || $farm->{proto} eq "tcp")
        {
            # i.e.
            # tcp      6 431998 ESTABLISHED src=192.168.0.168 dst=192.168.100.241 sport=40130 dport=81 src=192.168.100.254 dst=192.168.100.241 sport=80 dport=40130 [ASSURED] mark=523 use=1
            #protocol				 status		      client                         vip                                                           vport          backend_ip                   (vip, but can change)    backend_port
            $connections += scalar @{
                &getNetstatFilter("tcp", "",
                    "\.* ESTABLISHED src=\.* dst=$farm->{vip} \.* dport=$regexp \.*src=$be_ip \.*$add_search",
                    "", $netstat)
            };
        }
        if (   $farm->{proto} eq "sip"
            || $farm->{proto} eq "all"
            || $farm->{proto} eq "udp")
        {
            $connections += scalar @{
                &getNetstatFilter("udp", "", "\.* src=\.* dst=$farm->{vip} \.* dport=$regexp .*src=$be_ip \.*$add_search",
                    "", $netstat)
            };
        }
    }
    else {
        if (   $farm->{proto} eq "sip"
            || $farm->{proto} eq "all"
            || $farm->{proto} eq "tcp")
        {
            $connections += scalar @{
                &getNetstatFilter("tcp", "",
                    "\.*ESTABLISHED src=\.* dst=$farm->{vip} sport=\.* dport=$regexp \.*src=$be_ip \.*$add_search",
                    "", $netstat)
            };
        }
        if (   $farm->{proto} eq "sip"
            || $farm->{proto} eq "all"
            || $farm->{proto} eq "udp")
        {
            $connections += scalar @{
                &getNetstatFilter("udp", "", "\.* src=\.* dst=$farm->{vip} \.* dport=$regexp .*src=$be_ip \.*$add_search",
                    "", $netstat)
            };
        }
    }

    return $connections;
}

=pod

=head1 getL4FarmEstConns

Get all ESTABLISHED connections for a farm

Parameters:

    farm_name - Farm name
    netstat - reference to array with Conntrack -L output

Returns:

    array - Return all ESTABLISHED conntrack lines for a farm

FIXME:

    dnat and nat regexp is duplicated

=cut

sub getL4FarmEstConns ($farm_name, $netstat) {
    require Relianoid::Net::ConnStats;

    my $farm = &getL4FarmStruct($farm_name);

    # states : NONE | SYN_SENT | SYN_RECV | ESTABLISHED | FIN_WAIT | CLOSE_WAIT | LAST_ACK | TIME_WAIT | CLOSE | LISTEN
    my $established_filter = '(?:SYN_RECV|ESTABLISHED|FIN_WAIT|CLOSE_WAIT|LAST_ACK)';

    my @fportlist   = &getFarmPortList($farm->{vport});
    my $regexp      = "";
    my $connections = 0;

    if ($fportlist[0] !~ /\*/) {
        $regexp = "\(" . join('|', @fportlist) . "\)";
    }
    else {
        $regexp = "\.*";
    }

    my $backends = &getL4FarmServers($farm_name);

    for my $backend (@{$backends}) {
        if ($backend->{status} eq "up") {
            if ($farm->{mode} eq "dnat") {
                if (   $farm->{proto} eq "sip"
                    || $farm->{proto} eq "all"
                    || $farm->{proto} eq "tcp")
                {
                    $connections += scalar @{
                        &getNetstatFilter("tcp", "",
                            "\.* $established_filter src=\.* dst=$farm->{vip} \.* dport=$regexp .*src=$backend->{ip} \.*",
                            "", $netstat)
                    };
                }

                if (   $farm->{proto} eq "sip"
                    || $farm->{proto} eq "all"
                    || $farm->{proto} eq "udp")
                {
                    $connections += scalar @{
                        &getNetstatFilter("udp", "", "\.* src=\.* dst=$farm->{vip} \.* dport=$regexp .*src=$backend->{ip} \.*",
                            "", $netstat)
                    };
                }
            }
            else {
                if (   $farm->{proto} eq "sip"
                    || $farm->{proto} eq "all"
                    || $farm->{proto} eq "tcp")
                {
                    $connections += scalar @{
                        &getNetstatFilter("tcp", "",
                            "\.* $established_filter src=\.* dst=$farm->{vip} \.* dport=$regexp .*src=$backend->{ip} \.*",
                            "", $netstat)
                    };
                }

                if (   $farm->{proto} eq "sip"
                    || $farm->{proto} eq "all"
                    || $farm->{proto} eq "udp")
                {
                    $connections += scalar @{ &getNetstatFilter("udp", "",
                            "\.* src=\.* dst=$farm->{vip} \.* dport=$regexp .*src=$backend->{ip}", "", $netstat) };
                }
            }
        }
    }

    return $connections;
}

=pod

=head1 getL4BackendSYNConns

Get all SYN connections for a backend. This connection are called "pending".

UDP protocol doesn't have pending concept

Parameters:

    farmname - Farm name
    be_ip - IP backend
    be_port - Backend port
    netstat - reference to array with Conntrack -L output

Returns:

    array - Return all SYN conntrack lines for a backend of a farm

FIXME:

    dnat and nat regexp is duplicated

=cut

sub getL4BackendSYNConns ($farm_name, $be_ip, $be_port, $netstat) {
    my $farm = &getL4FarmStruct($farm_name);

    my @fportlist   = &getFarmPortList($farm->{vport});
    my $regexp      = "";
    my $connections = 0;
    my $add_search  = "";

    #if there is a backend port then must be included in the filter
    if ($be_port > 0) {
        $add_search = "sport=$be_port";
    }

    if ($fportlist[0] !~ /\*/) {
        $regexp = "\(" . join('|', @fportlist) . "\)";
    }
    else {
        $regexp = "\.*";
    }

    if ($farm->{mode} eq "dnat") {
        if (   $farm->{proto} eq "sip"
            || $farm->{proto} eq "all"
            || $farm->{proto} eq "tcp")
        {
            $connections += scalar @{
                &getNetstatFilter("tcp", "", "\.* SYN\.* src=\.* dst=$farm->{vip} \.* dport=$regexp \.* src=$be_ip \.*$add_search",
                    "", $netstat)
            };
        }

        # udp doesn't have pending connections
    }
    else {
        if (   $farm->{proto} eq "sip"
            || $farm->{proto} eq "all"
            || $farm->{proto} eq "tcp")
        {
            $connections += scalar @{
                &getNetstatFilter("tcp", "", "\.* SYN\.* src=\.* dst=$farm->{vip} \.* dport=$regexp \.* src=$be_ip \.*$add_search",
                    "", $netstat)
            };
        }

        # udp doesn't have pending connections
    }

    return $connections;
}

=pod

=head1 getL4FarmSYNConns

Get all SYN connections for a farm. This connection are called "pending". 

UDP protocol doesn't have pending concept

Parameters:

    farm_name - Farm name
    netstat - reference to array with Conntrack -L output

Returns:

    array - Return all SYN conntrack lines for a farm

FIXME:

    dnat and nat regexp is duplicated

=cut

sub getL4FarmSYNConns ($farm_name, $netstat) {
    my $farm = &getL4FarmStruct($farm_name);

    my @fportlist   = &getFarmPortList($farm->{vport});
    my $regexp      = "";
    my $connections = 0;

    if ($fportlist[0] !~ /\*/) {
        $regexp = "\(" . join('|', @fportlist) . "\)";
    }
    else {
        $regexp = ".*";
    }

    my $backends = &getL4FarmServers($farm_name);

    # tcp      6 299 ESTABLISHED src=192.168.0.186 dst=192.168.100.241 sport=56668 dport=80 src=192.168.0.186 dst=192.168.100.241 sport=80 dport=56668 [ASSURED] mark=517 use=2
    for my $backend (@{$backends}) {
        if ($backend->{status} eq "up") {
            if ($farm->{mode} eq "dnat") {
                if (   $farm->{proto} eq "sip"
                    || $farm->{proto} eq "all"
                    || $farm->{proto} eq "tcp")
                {
                    $connections += scalar @{
                        &getNetstatFilter("tcp", "", "\.* SYN\.* src=\.* dst=$farm->{vip} \.* dport=$regexp \.* src=$backend->{ip} \.*",
                            "", $netstat)
                    };
                }

                # udp doesn't have pending connections
            }
            else {
                if (   $farm->{proto} eq "sip"
                    || $farm->{proto} eq "all"
                    || $farm->{proto} eq "tcp")
                {
                    $connections += scalar @{
                        &getNetstatFilter("tcp", "", "\.* SYN\.* src=\.* dst=$farm->{vip} \.* dport=$regexp \.* src=$backend->{ip} \.*",
                            "", $netstat)
                    };
                }

                # udp doesn't have pending connections
            }
        }
    }

    return $connections;
}

=pod

=head1 getL4FarmBackendsStats

Parameters:

    farmname - Farm name

Returns:

    array ref

=cut

sub getL4FarmBackendsStats ($farmname) {
    require Relianoid::Net::ConnStats;
    require Relianoid::Farm::L4xNAT::Config;

    # Get list of backend hashes and add stats
    my $farm_st  = &getL4FarmStruct($farmname);
    my $backends = $farm_st->{servers};

    for my $be (@{$backends}) {
        # Copy port value, to keep getL4BackendEstConns and
        # getL4BackendSYNConns from converting it to string.
        my $port    = $be->{port};
        my $netstat = &getConntrack("", $farm_st->{vip}, $be->{ip}, "", "");

        # Established
        $be->{established} =
          &getL4BackendEstConns($farmname, $be->{ip}, $port, $netstat);

        # Pending
        $be->{pending} = 0;

        if ($farm_st->{proto} ne "udp") {
            $be->{pending} =
              &getL4BackendSYNConns($farmname, $be->{ip}, $port, $netstat);
        }
    }

    return $backends;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/Service.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

my $configdir = &getGlobalConfiguration('configdir');

=pod

=head1 Module

Relianoid::Farm::Service

=cut

=pod

=head1 getFarmServices

Get a list of services name for a farm

Parameters:

    farm_name - Farm name

Returns:

    Array - list of service names 

=cut

sub getFarmServices ($farm_name) {
    my $farm_type = &getFarmType($farm_name);
    my @output    = ();

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Service;
        @output = &getHTTPFarmServices($farm_name);
    }
    elsif ($farm_type eq "gslb" && $eload) {
        @output = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Service',
            func   => 'getGSLBFarmServices',
            args   => [$farm_name],
        ) if $eload;
    }
    elsif ($farm_type eq "eproxy" && $eload) {
        @output = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Service',
            func   => 'getEproxyFarmServices',
            args   => [{ farm_name => $farm_name }],
        ) if $eload;
    }

    return @output;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/Stats.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Farm::Stats

=cut

=pod

=head1 getFarmEstConns

Get all ESTABLISHED connections for a farm

Parameters:

    farm_name - Farm name
    netstat   - reference to array with Conntrack -L output

Returns:

    unsigned integer - Return number of ESTABLISHED conntrack lines for a farm

=cut

sub getFarmEstConns ($farm_name, $netstat) {
    my $farm_type   = &getFarmType($farm_name);
    my $connections = 0;

    if ($farm_type eq "http" || $farm_type eq "https") {
        my @pid = &getFarmPid($farm_name);
        return $connections if (!@pid);
        require Relianoid::Farm::HTTP::Stats;
        $connections = &getHTTPFarmEstConns($farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Stats;
        $connections = &getL4FarmEstConns($farm_name, $netstat);
    }
    elsif ($farm_type eq "gslb") {
        my @pid = &getFarmPid($farm_name);
        return $connections if (!@pid);
        $connections = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Stats',
            func   => 'getGSLBFarmEstConns',
            args   => [ $farm_name, $netstat ],
        ) if $eload;
    }

    return $connections;
}

=pod

=head1 getBackendSYNConns

Get all SYN connections for a backend

Parameters:

    farm_name    - Farm name
    ip_backend   - IP backend
    port_backend - backend port
    netstat      - reference to array with Conntrack -L output

Returns:

    integer - Return number of SYN conntrack lines for a backend of a farm or -1 if error

=cut

sub getBackendSYNConns ($farm_name, $ip_backend, $port_backend, $netstat = undef) {
    my $farm_type   = &getFarmType($farm_name);
    my $connections = 0;

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Stats;
        $connections = &getHTTPBackendSYNConns($farm_name, $ip_backend, $port_backend);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Stats;
        $connections = &getL4BackendSYNConns($farm_name, $ip_backend, $port_backend, $netstat);
    }

    return $connections;
}

=pod

=head1 getFarmSYNConns

Get all SYN connections for a farm

Parameters:

    farm_name - Farm name
    netstat   - reference to array with Conntrack -L output

Returns:

    unsigned integer - Return number of SYN conntrack lines for a farm

=cut

sub getFarmSYNConns ($farm_name, $netstat = undef) {
    my $farm_type   = &getFarmType($farm_name);
    my $connections = 0;

    if ($farm_type eq "http" || $farm_type eq "https") {
        require Relianoid::Farm::HTTP::Stats;
        $connections = &getHTTPFarmSYNConns($farm_name);
    }
    elsif ($farm_type eq "l4xnat") {
        require Relianoid::Farm::L4xNAT::Stats;
        $connections = &getL4FarmSYNConns($farm_name, $netstat);
    }

    return $connections;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Farm/Validate.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2020-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::Farm::Validate

=cut

=pod

=head1 priorityAlgorithmIsOK

This funcion receives a list of priority values and it checks if all backends will be started according to priority Algorithm

Parameters:

    Priorities - Array reference to priorities to check

Returns:

    Integer - Return 0 if valid priority settings, unsuitable priority value if not.

=cut

sub priorityAlgorithmIsOK ($priority_ref) {
    use List::Util qw( min max );
    my @backends = sort @{$priority_ref};
    my @backendstmp;

    my $prio_last = 0;
    for my $prio_cur (@backends) {
        if ($prio_cur != $prio_last) {
            my $n_backendstmp = @backendstmp;
            return $prio_cur if ($prio_cur > ($n_backendstmp + 1));
            push @backendstmp, $prio_cur;
            $prio_last = $prio_cur;
        }
        else {
            push @backendstmp, $prio_cur;
        }
    }
    return 0;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/FarmGuardian.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use Relianoid::Log;
use Config::Tiny;

my $configdir   = &getGlobalConfiguration("configdir");
my $fg_conf     = "$configdir/farmguardian.conf";
my $fg_template = &getGlobalConfiguration("templatedir") . "/farmguardian.template";

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::FarmGuardian

=cut

=pod

=head1 getFGStatusFile

The function returns the path of the file that is used to save the backend status for a farm.

Parameters:

    fname - Farm name

Returns:

    String - file path

=cut

sub getFGStatusFile ($farm) {
    return "$configdir\/$farm\_status.cfg";
}

=pod

=head1 getFGStruct

It returns a default struct with all farmguardian parameters

Parameters:

    none

Returns:

    Hash ref - hash with the available parameters of fg

    example:

    hash => {
        'description' => "",       # Tiny description about the check
        'command'     => "",       # Command to check. The check must return 0 on sucess
        'farms'       => [],       # farm list where the farm guardian is applied
        'log'         => "false",  # logg farm guardian
        'interval'    => "10",     # Time between checks
        'cut_conns' => "false",    # cut the connections with the backend is marked as down
        'template'  => "false",    # it is a template. The fg cannot be deleted, only reset its configuration
        'backend_alias'     => "false",    # Use the backend alias to do the farmguardian check. The load balancer must resolve the alias
    };

=cut

sub getFGStruct() {
    return {
        'description'   => "",         # Tiny description about the check
        'command'       => "",         # Command to check. The check must return 0 on sucess
        'farms'         => [],         # farm list where the farm guardian is applied
        'log'           => "false",    # logg farm guardian
        'interval'      => "10",       # Time between checks
        'cut_conns'     => "false",    # cut the connections with the backend is marked as down
        'template'      => "false",
        'backend_alias' => "false",
    };
}

=pod

=head1 getFGExistsConfig

It checks out if the fg already exists in the configuration file.

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Integer - 1 if the fg already exists or 0 if it is not

=cut

sub getFGExistsConfig ($fg_name) {
    if (!-f "$fg_conf") {
        return 0;
    }
    my $fh = Config::Tiny->read($fg_conf);
    return (exists $fh->{$fg_name}) ? 1 : 0;
}

=pod

=head1 getFGExistsTemplate

It checks out if a template farmguardian exists with this name.

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Integer - 1 if the fg exists or 0 if it is not

=cut

sub getFGExistsTemplate ($fg_name) {
    if (!-f "$fg_template") {
        return 0;
    }
    my $fh = Config::Tiny->read($fg_template);
    return (exists $fh->{$fg_name}) ? 1 : 0;
}

=pod

=head1 getFGExists

It checks out if the fg exists, in the template file or in the configuraton file

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Integer - 1 if the fg already exists or 0 if it is not

=cut

sub getFGExists ($fg_name) {
    return (&getFGExistsTemplate($fg_name) or &getFGExistsConfig($fg_name));
}

=pod

=head1 getFGConfigList

It returns a list of farmguardian names of the configuration file

Parameters:

    None

Returns:

    Array - List of fg names

=cut

sub getFGConfigList() {
    if (!-f "$fg_conf") {
        return ();
    }

    my $fg_file = Config::Tiny->read($fg_conf);
    return keys %{$fg_file};
}

=pod

=head1 getFGTemplateList

It returns a list of farmguardian names of the template file

Parameters:

    None

Returns:

    Array - List of fg names

=cut

sub getFGTemplateList() {
    if (!-f "$fg_template") {
        return ();
    }
    my $fg_file = Config::Tiny->read($fg_template);
    return keys %{$fg_file};
}

=pod

=head1 getFGList

It is a list with all fg, templates and created by the user

Parameters:

    None

Returns:

    Array - List of fg names

=cut

sub getFGList() {
    my @list = &getFGConfigList();

    # get from template file
    for my $fg (&getFGTemplateList()) {
        next if grep { $fg eq $_ } @list;
        push @list, $fg;
    }

    return @list;
}

=pod

=head1 getFGObject

Get the configuration of a farmguardian

Parameters:

    Farmguardian - Farmguardian name
    template - If this parameter has the value "template", the function returns the object from the template file

Returns:

    Hash ref - It returns a hash with the configuration of the farmguardian

    example:

    hash => {
        'description' => "",       # Tiny description about the check
        'command'     => "",       # Command to check. The check must return 0 on sucess
        'farms'       => [],       # farm list where the farm guardian is applied
        'log'         => "false",  # log farm guardian
        'interval'    => "10",     # Time between checks
        'cut_conns' => "false",    # cut the connections with the backend is marked as down
        'template'  => "false",    # it is a template. The fg cannot be deleted, only reset its configuration
        'backend_alias'     => "false",    # Use the backend alias to do the farmguardian check. The load balancer must resolve the alias
    };

=cut

sub getFGObject ($fg_name, $use_template = '') {
    unless ($fg_name) {
        croak("Farmguardian name required");
    }

    my $file = "";

    # using template file if this parameter is sent
    if ($use_template eq 'template') {
        $file = $fg_template;
    }

    # using farmguardian config file by default
    elsif (grep { $fg_name eq $_ } &getFGConfigList()) {
        $file = $fg_conf;
    }

    # using template file if farmguardian is not defined in config file
    else { $file = $fg_template; }

    my $obj;
    if (!-f "$file") {
        require Relianoid::File;
        createFile($file);
        $obj = Config::Tiny->new;
        return $obj;
    }

    $obj = Config::Tiny->read($file);

    if (!defined $fg_name || $fg_name =~ /^$/) {
        return $obj;
    }

    if (exists $obj->{$fg_name}) {
        $obj = $obj->{$fg_name};
        $obj = &setConfigStr2Arr($obj, ['farms']);
        return $obj;
    }

    return;
}

=pod

=head1 getFGFarm

Get the farmguardian name that a farm is using

Parameters:

    farm    - string - Farm name
    service - string - Optional. Service of the farm. This parameter is mandatory for HTTP and GSLB farms

Returns: string|undef - Farmguardian name if found or undef if not found.

=cut

sub getFGFarm ($farm, $service = undef) {
    my $farmguardian = undef;
    my $farm_tag     = $service ? "${farm}_${service}" : $farm;

    if (!-f $fg_conf) {
        return $farmguardian;
    }

    my $fg_list = Config::Tiny->read($fg_conf);

    for my $fg_name (keys %{$fg_list}) {
        next if not exists $fg_list->{$fg_name}{farms};

        if (grep { /(^| )$farm_tag( |$)/ } $fg_list->{$fg_name}{farms}) {
            $farmguardian = $fg_name;
            last;
        }
    }

    return $farmguardian;
}

=pod

=head1 createFGBlank

Create a fg without configuration

Parameters:

    Name - Farmguardian name

Returns:

    none

=cut

sub createFGBlank ($name) {
    my $values = &getFGStruct();
    &setFGObject($name, $values);

    return;
}

=pod

=head1 createFGTemplate

Create a fg from a template

Parameters:

    Farmguardian - Farmguardian name
    template - If this parameter has the value "template", the function returns the object from the template file

Returns:

    None

=cut

sub createFGTemplate ($name, $template) {
    my $values = &getFGObject($template, 'template');
    return if (!defined $values);
    $values->{template} = "false";

    &setFGObject($name, $values);

    return;
}

=pod

=head1 createFGConfig

Create a farm guardian from another farm guardian

Parameters:

    Farmguardian - Farmguardian name
    template - Farmguardian name of the fg used as template

Returns:

    None

=cut

sub createFGConfig ($name, $fg_config) {
    my $values = &getFGObject($fg_config);
    $values->{farms} = [];
    &setFGObject($name, $values);

    return;
}

=pod

=head1 delFGObject

Remove a farmguardianfrom the configuration file. First, it stops it.
This function will restart the fg process.

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Integer - 0 on success or another value on failure

=cut

sub delFGObject ($fg_name) {
    my $out = &runFGStop($fg_name);
    $out = &delTinyObj($fg_conf, $fg_name);

    return $out;
}

=pod

=head1 setFGObject

Set a configuration for fg.
This function has 2 behaviour:

    * passing to the function a hash with several parameters
    * passing to the function 2 parameters, key and value. So, only is updated one parater.

If the farmguardian name is not found in the configuration file, the configuraton will be got
from the template file and save it in the configuration file.

This function will restart the fg process

Parameters:

    Farmguardian - Farmguardian name
    object / key - object: hash reference with a set of parameters, or key: parameter name to set
    value        - value for the "key"

Returns:

    Integer - 0 on success or another value on failure

=cut

sub setFGObject ($fg_name, $key = undef, $value = undef) {
    my $restart = 0;
    my $out     = 0;

    # not restart if only is changed the parameter description
    if (&getFGExistsConfig($fg_name)) {
        if (@{ &getFGRunningFarms($fg_name) }) {
            if (ref $key and grep { !/^description$/ } keys %{$key}) {
                $restart = 1;
            }
            elsif ($key ne 'description') { $restart = 1; }
        }
    }

    # if the fg does not exist in config file, take it from template file
    unless (&getFGExistsConfig($fg_name)) {
        my $template = &getFGObject($fg_name, 'template');

        if (defined $template) {
            $out = &setTinyObj($fg_conf, $fg_name, $template);
        }
    }

    $out = &runFGStop($fg_name) if $restart;
    $out = &setTinyObj($fg_conf, $fg_name, $key, $value);
    $out = &runFGStart($fg_name) if $restart;

    if ($eload) {
        $out += &eload(
            module => 'Relianoid::EE::Farm::GSLB::FarmGuardian',
            func   => 'updateGSLBFg',
            args   => [$fg_name],
        );
    }

    return $out;
}

=pod

=head1 setFGFarmRename

Re-asign farmguardian to a farm that has been renamed

Parameters:

    old name - Old farm name
    new name - New farm name

Returns:

    Integer - 0 on success or another value on failure

=cut

sub setFGFarmRename ($farm, $new_farm) {
    my $fh;
    my $srv;
    my $farm_tag;
    my $new_farm_tag;
    my $out;

    if (!-f $fg_conf) {
        return 1;
    }
    $fh = Config::Tiny->read($fg_conf);

    # foreach farm check, remove and add farm
    for my $fg (keys %{$fh}) {
        if ($fh->{$fg}{farms} =~ /(?:^| )${farm}_?([\w-]+)?(?:$| )/) {
            $srv          = $1;
            $farm_tag     = ($srv) ? "${farm}_$srv"     : $farm;
            $new_farm_tag = ($srv) ? "${new_farm}_$srv" : $new_farm;

            $out = &setTinyObj($fg_conf, $fg, 'farms', $farm_tag,     'del');
            $out = &setTinyObj($fg_conf, $fg, 'farms', $new_farm_tag, 'add');

            my $status_file     = &getFGStatusFile($farm);
            my $new_status_file = &getFGStatusFile($new_farm);
            &log_info("renaming $status_file =>> $new_status_file") if &debug();
            rename $status_file, $new_status_file;
        }
    }

    return $out;
}

=pod

=head1 linkFGFarm

Assign a farmguardian to a farm (or service of a farm).
Farmguardian will run if the farm is up.

Parameters:

    Farmguardian - Farmguardian name
    Farm         - Farm name
    Service      - Service name. It is used for GSLB and HTTP farms

Returns:

    Integer - 0 on success or another value on failure

=cut

sub linkFGFarm ($fg_name, $farm, $srv = undef) {
    croak("Farmguardian name required") unless ($fg_name);
    croak("Farm name required")         unless ($farm);

    my $out;

    require Relianoid::Farm::Base;
    my $farm_tag = ($srv) ? "${farm}_$srv" : "$farm";

    # if the fg does not exist in config file, take it from template file
    unless (&getFGExistsConfig($fg_name)) {
        my $template = &getFGObject($fg_name, 'template');
        if (defined $template) {
            $out = &setTinyObj($fg_conf, $fg_name, $template);
            return $out if $out;
        }
    }

    $out = &setTinyObj($fg_conf, $fg_name, 'farms', $farm_tag, 'add');
    return $out if $out;

    if (&getFarmType($farm) eq 'gslb' and $eload) {
        $out = &eload(
            module => 'Relianoid::EE::Farm::GSLB::FarmGuardian',
            func   => 'linkGSLBFg',
            args   => [ $fg_name, $farm, $srv ],
        );
    }
    elsif (&getFarmStatus($farm) eq 'up') {
        $out = &runFGFarmStart($farm, $srv);
    }

    return $out;
}

=pod

=head1 unlinkFGFarm

Remove a farmguardian from a farm (or service of a farm).
Farmguardian will be stopped if it is running.

Parameters:

    Farmguardian - Farmguardian name
    Farm         - Farm name
    Service      - Service name. It is used for GSLB and HTTP farms

Returns:

    Integer - 0 on success or another value on failure

=cut

sub unlinkFGFarm ($fg_name, $farm, $srv = undef) {
    my $type = &getFarmType($farm);

    require Relianoid::Log;

    my $farm_tag = ($srv) ? "${farm}_$srv" : "$farm";
    my $out;

    $out = &setTinyObj($fg_conf, $fg_name, 'farms', $farm_tag, 'del');
    return $out if $out;

    if (($type eq 'gslb') and $eload) {
        $out = &eload(
            module => 'Relianoid::EE::Farm::GSLB::FarmGuardian',
            func   => 'unlinkGSLBFg',
            args   => [ $farm, $srv ],
        );
    }
    else {
        $out = &runFGFarmStop($farm, $srv);
    }

    return $out;
}

=pod

=head1 delFGFarm

Function used if a farm is deleted. All farmguardian assigned to it will be unliked.

Parameters:

    Farm    - Farm name
    Service - Service name. It is used for GSLB and HTTP farms

Returns:

    None

=cut

sub delFGFarm ($farm, $service = undef) {
    require Relianoid::Farm::Service;

    my $err  = &runFGFarmStop($farm, $service);
    my $type = &getFarmType($farm);

    # NOT MATCH qw(http https gslb eproxy)
    if (!grep { $type eq $_ } qw(http https gslb eproxy)) {
        if (my $fg = &getFGFarm($farm)) {
            $err |= &setTinyObj($fg_conf, $fg, 'farms', $farm, 'del');
        }

        return;
    }

    # MATCH qw(http https gslb eproxy)
    my @services = $service? ($service): &getFarmServices($farm);

    for my $service (@services) {
        if (my $fg = &getFGFarm($farm, $service)) {
            $err |= &setTinyObj($fg_conf, $fg, 'farms', "${farm}_${service}", 'del');
        }
    }

    return;
}

############# run process

=pod

=head1 getFGPidFile

Get the path of the file where the pid of the farmguardian is saved.

Parameters:

    Farm - Farm name
    Service - Service name. It is used for GSLB and HTTP farms. It expects 'undef' for l4 farms

Returns:

    String - Pid file path.

=cut

sub getFGPidFile ($fname, $svice = undef) {
    my $piddir = &getGlobalConfiguration('piddir');
    my $file;

    if (defined $svice and length $svice) {
        # return a regexp for a farm the request service
        $file = "$piddir/${fname}_${svice}_guardian.pid";
    }
    else {
        # return a regexp for a farm and all its services
        $file = "$piddir/${fname}_guardian.pid";
    }

    return $file;
}

=pod

=head1 getFGPidFarm

It returns the farmguardian PID assigned to a farm (and service)

Parameters:

    Farm - Farm name
    Service - Service name. It is used for GSLB and HTTP farms

Returns:

    Integer - 0 on failure, or a natural number for PID

=cut

sub getFGPidFarm ($farm, $service = undef) {
    my $pid     = 0;
    my $pidFile = &getFGPidFile($farm, $service);

    if (!-f "$pidFile") {
        return $pid;
    }

    open my $fh, '<', $pidFile or return 0;
    $pid = <$fh>;
    close $fh;

    my $run;

    # check if the pid exists
    if ($pid > 0) {
        $run = kill 0, $pid;
    }

    # if it does not exist, remove the pid file
    if (!$run) {
        $pid = 0;
        unlink $pidFile;
    }

    # return status
    return $pid;
}

=pod

=head1 runFGStop

It stops all farmguardian process are using the passed fg name

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Integer - 0 on failure, or another value on success

=cut

sub runFGStop ($fgname) {
    &log_debug("Stopping farmguardian $fgname", "FG");

    my $out;
    my $obj = &getFGObject($fgname);

    for my $farm (@{ $obj->{farms} }) {
        my $srv;
        if ($farm =~ /([^_]+)_(.+)/) {
            $farm = $1;
            $srv  = $2;
        }

        $out |= &runFGFarmStop($farm, $srv);
    }

    return $out;
}

=pod

=head1 runFGStart

It runs fg for each farm is using it and it is running

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Integer - 0 on failure, or another value on success

=cut

sub runFGStart ($fgname) {
    &log_debug("Starting farmguardian $fgname", "FG");

    my $out;
    my $obj = &getFGObject($fgname);

    for my $farm (@{ $obj->{farms} }) {
        my $srv;
        if ($farm =~ /([^_]+)_(.+)/) {
            $farm = $1;
            $srv  = $2;
        }

        $out |= &runFGFarmStart($farm, $srv);
    }

    return $out;
}

=pod

=head1 runFGRestart

It restarts all farmguardian process for each farm is using the passed fg

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Integer - 0 on failure, or another value on success

=cut

sub runFGRestart ($fgname) {
    my $out = &runFGStop($fgname);
    $out |= &runFGStart($fgname);

    return $out;
}

=pod

=head1 runFGFarmStop

It stops farmguardian process used by the farm. If the farm is GSLB or HTTP
and is not passed the service name, all farmguardians will be stoped.

Parameters:

    Farm - Farm name
    Service - Service name. This parameter is for HTTP and GSLB farms. If the farm has not services, this parameter expect 'undef'

Returns:

    Integer - 0 on failure, or another value on success

=cut

sub runFGFarmStop ($farm, $service = undef) {
    # optional, if the farm is http and the service is not sent to
    # the function, all services will be restarted
    $service = undef if (defined $service and not length $service);

    my $out = 0;

    require Relianoid::Farm::Core;
    my $type = &getFarmType($farm);

    # Stop Farmguardian for every service
    if ($type =~ /http|eproxy/ and not defined $service) {
        require Relianoid::Farm::Service;
        for my $srv (&getFarmServices($farm)) {
            $out |= &runFGFarmStop($farm, $srv);
        }
        return $out;
    }

    my $fgpid = &getFGPidFarm($farm, $service);

    if ($fgpid && $fgpid > 0) {
        my $service_str = $service // '';
        &log_debug("running 'kill 9, $fgpid' stopping FarmGuardian $farm $service_str", "FG");

        # kill returns the number of process affected
        $out = kill 9, $fgpid;
        $out = (not $out);
        if ($out) {
            &log_error("running 'kill 9, $fgpid' stopping FarmGuardian $farm $service_str", "FG");
        }

        # delete pid files
        unlink &getFGPidFile($farm, $service);

        # put backend up
        if ($type eq "http" || $type eq "https") {
            my $status_file = &getFGStatusFile($farm);

            if (-e $status_file && -s $status_file) {
                require Relianoid::Farm::HTTP::Service;
                require Tie::File;

                my $idsv = &getFarmVSI($farm, $service);

                tie my @filelines, 'Tie::File', $status_file;

                my @fileAux = @filelines;
                my $lines   = scalar @fileAux;

                while ($lines > 0) {
                    $lines--;

                    my $matched = $fileAux[$lines] =~ /0 $idsv (\d+) fgDOWN/;
                    my $index   = $1;

                    next if not $matched;

                    splice(@fileAux, $lines, 1,);

                    require Relianoid::Farm::HTTP::Backend;
                    my $error_ref = &setHTTPFarmBackendStatus($farm, $service, $index, 'up', 'cut');

                    if ($error_ref->{code} != 1 and $error_ref->{code} != -1) {
                        $error_ref->{code} = 0;
                    }

                    $out |= $error_ref->{code};
                }
                @filelines = @fileAux;
                untie @filelines;
            }
        }

        elsif ($type eq "l4xnat") {
            require Relianoid::Farm::Backend;

            my $be = &getFarmServers($farm);

            for my $l_serv (@{$be}) {
                unless ($l_serv->{status} eq "fgDOWN") {
                    next;
                }

                my $error_ref = &setL4FarmBackendStatus($farm, $l_serv->{id}, "up");
                if ($error_ref->{code} != 1 and $error_ref->{code} != -1) {
                    $error_ref->{code} = 0;
                }
                $out |= $error_ref->{code};
            }
        }

        elsif ($type eq "eproxy") {
            # TODO LGL
        }
    }
    my $srvtag = defined $service ? "${service}_" : '';
    unlink "$configdir/${farm}_${srvtag}status.cfg";

    return $out;
}

=pod

=head1 runFGFarmStart

It starts the farmguardian process used by the farm. If the farm is GSLB or HTTP
and is not passed the service name, all farmguardians will be run.
The pid file is created by the farmguardian process.

Parameters:

    Farm - Farm name
    Service - Service name. This parameter is for HTTP and GSLB farms.

Returns:

    Integer - 0 on failure, or another value on success

=cut

sub runFGFarmStart ($farm, $svice = undef) {
    my $status = 0;
    my $log    = "";
    my $sv     = "";

    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    my $ftype = &getFarmType($farm);

    # check if the farm is up
    return 0 if (&getFarmStatus($farm) ne 'up');

    # if the farmguardian is running...
    if (&getFGPidFarm($farm, $svice)) {
        return 0;
    }

    # check if the node is master
    if ($eload) {
        my $node = "";
        $node = &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'getClusterNodeStatus',
            args   => [],
        );
        return 0 unless (not $node or $node eq 'master');
    }

    $svice = '' if not defined $svice;
    &log_debug("Start fg for farm $farm, $svice", "FG");

    if ($ftype =~ /http|eproxy/ && $svice eq "") {
        require Relianoid::Farm::Service;

        for my $service (&getFarmServices($farm)) {
            $status |= &runFGFarmStart($farm, $service);
        }
    }
    elsif ($ftype =~ /http|l4xnat|eproxy/) {
        my $fgname = &getFGFarm($farm, $svice);

        return 0 if not $fgname;

        &log_debug("Starting fg $fgname, farm $farm, $svice", "FG");
        my $fg = &getFGObject($fgname);

        if ($fg->{log} eq 'true') {
            $log = "-l";
        }

        if ($svice ne "") {
            $sv = "-s $svice";
        }

        my $farmguardian = &getGlobalConfiguration('farmguardian');
        my $fg_cmd       = "$farmguardian $farm $sv $log";

        require Relianoid::Log;
        $status = &logAndRunBG("$fg_cmd");

        # necessary for waiting that fg process write its process
        use Time::HiRes qw(usleep);
        $status = 1;
        my $pid_file = &getFGPidFile($farm, $svice);

        # wait for 2 seconds
        for (my $it = 0 ; $it < 4000 ; $it += 1) {
            if (-f $pid_file) {
                $status = 0;
                last;
            }

            # 500 microseconds == 0.5 milliseconds
            usleep(500);
        }

        if ($status) {
            my $msg = "The farmguardian for the farm '$farm'";
            $msg .= " and the service '$svice'" if ($svice);
            $msg .= " could not start properly";
            &log_error($msg, "fg");
        }
    }
    elsif ($ftype ne 'gslb') {
        # WARNING: farm types not supported by farmguardian return 0.
        $status = 1;
    }

    return $status;
}

=pod

=head1 runFGFarmRestart

It restarts the farmguardian process used by the farm. If the farm is GSLB or HTTP
and is not passed the service name, all farmguardians will be restarted.

Parameters:

    Farm    - Farm name
    Service - Service name. This parameter is for HTTP and GSLB farms.

Returns:

    Integer - 0 on failure, or another value on success

=cut

sub runFGFarmRestart ($farm, $service = undef) {
    my $out = &runFGFarmStop($farm, $service);
    $out |= &runFGFarmStart($farm, $service);

    return $out;
}

=pod

=head1 getFGRunningFarms

Get a list with all running farms where the farmguardian is applied.

Parameters:

    Farmguardian - Farmguardian name

Returns:

    Array ref - list of farm names

=cut

sub getFGRunningFarms ($fg) {
    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    my @runfarm;
    for my $farm (@{ &getFGObject($fg)->{farms} }) {
        my $srv;
        if ($farm =~ /([^_]+)_(.+)/) {
            $farm = $1;
            $srv  = $2;
        }

        if (&getFarmStatus($farm) eq 'up') {
            push @runfarm, $farm;
        }
    }
    return \@runfarm;
}

=pod

=head1 getFGMigrateFile

This function returns a standard name used to migrate the old farmguardians.

Parameters:

    Farm - Farm name
    Service - Service name. This parameter is for HTTP and GSLB farms.

Returns:

    String - Farmguardian name

=cut

sub getFGMigrateFile ($farm, $srv = undef) {
    return ($srv) ? "_default_${farm}_$srv" : "_default_$farm";
}

=pod

=head1 setOldFarmguardian

Create a struct of the new fg using the parameters of the old fg

Parameters:

    Configuration - Hash with the configuration of the old FG

Returns:

    None

=cut

sub setOldFarmguardian ($obj) {
    my $srv  = $obj->{service} // "";
    my $farm = $obj->{farm};
    my $name = &getFGMigrateFile($obj->{farm}, $srv);
    my $type = &getFarmType($farm);
    my $set;

    &log_debug2("setOldFarmguardian: $farm, $srv", "FG");

    # default object
    my $def = {
        'description' => "This farmguardian was created automatically to migrate to Relianoid 5.2 version or higher",
        'command'     => $obj->{command},
        'log'         => $obj->{log},
        'interval'    => $obj->{interval},
        'cut_conns'   => ($type =~ /http/) ? "true" : "false",
        'template'    => "false",
        'farms'       => [],
    };

    &runFGFarmStop($farm, $srv);

    # if exists, update it
    if (&getFGExistsConfig($name)) {
        $set             = &getFGObject($name);
        $set->{command}  = $obj->{command}  if exists $obj->{command};
        $set->{log}      = $obj->{log}      if exists $obj->{log};
        $set->{interval} = $obj->{interval} if exists $obj->{interval};
    }

    # else create it
    else {
        $set = $def;
    }

    &setFGObject($name, $set);
    my $farm_tag = ($srv) ? "${farm}_$srv" : $farm;

    if ($obj->{enable} eq 'true') {
        &setTinyObj($fg_conf, $name, 'farms', $farm_tag, 'add');
    }

    return;
}

####################################################################
######## ######## 	OLD FUNCTIONS 	######## ########
# Those functions are for compatibility with the APIs 3.0 and 3.1
####################################################################

=pod

=head1 runFarmGuardianStart

Start FarmGuardian rutine

Parameters:

    fname - Farm name.
    svice - Service name. Only apply if the farm profile has services. Leave undefined for farms without services.

Returns: integer

- -1 - If farmguardian file was not found or if farmguardian is not running.
- 0  - If farm profile is not supported by farmguardian, or farmguardian was executed.

=cut

sub runFarmGuardianStart ($fname, $svice) {
    return &runFGFarmStart($fname, $svice);
}

=pod

=head1 runFarmGuardianStop

Stop FarmGuardian rutine

Parameters:

    fname - Farm name.
    svice - Service name. Only apply if the farm profile has services. Leave undefined for farms without services.

Returns:

    Integer - 0 on success, or greater than 0 on failure.

=cut

sub runFarmGuardianStop ($fname, $svice) {
    return &runFGFarmStop($fname, $svice);
}

=pod

=head1 runFarmGuardianCreate

Create or update farmguardian config file

ttcheck and script must be defined and non-empty to enable farmguardian.

Parameters:

    fname - Farm name.
    ttcheck - Time between command executions for all the backends.
    script - Command to run.
    usefg - 'true' to enable farmguardian, or 'false' to disable it.
    fglog - 'true' to enable farmguardian verbosity in logs, or 'false' to disable it.
    svice - Service name.

Returns: integer

- -1 - If ttcheck or script is not defined or empty and farmguardian is enabled.
-  0 - If farmguardian configuration was created.

=cut

sub runFarmGuardianCreate ($fname, $ttcheck, $script, $usefg, $fglog, $svice) {
    &log_debug("runFarmGuardianCreate( farm: $fname, interval: $ttcheck, cmd: $script, log: $fglog, enabled: $usefg )",
        "FG");

    my $output = -1;

    # get default name and check not exist
    my $obj = {
        'service'  => $svice,
        'farm'     => $fname,
        'command'  => $script,
        'log'      => $fglog,
        'interval' => $ttcheck,
        'enable'   => $usefg,
    };

    $output = &setOldFarmguardian($obj);

    # start
    $output |= &runFGFarmStart($fname, $svice);

    return $output;
}

=pod

=head1 runFarmGuardianRemove

Remove farmguardian down status on backends.

When farmguardian is stopped or disabled any backend marked as down by farmgardian must reset it's status.

Parameters:

    fname - Farm name.
    svice - Service name. Only apply if the farm profile has services. Leave undefined for farms without services.

Returns:

    none - Nothing is returned explicitly.

=cut

sub runFarmGuardianRemove ($fname, $svice) {
    my $fg = &getFGFarm($fname, $svice);

    return if (not $fg);

    # "unlink" stops the fg
    my $out = &unlinkFGFarm($fg, $fname, $svice);

    if ($fg eq &getFGMigrateFile($fname, $svice) and not @{ &getFGObject($fg)->{farms} }) {
        $out |= &delFGObject($fg);
    }

    return;
}

=pod

=head1 getFarmGuardianPid

Read farmgardian pid from pid file. Check if the pid is running and return it,
else it removes the pid file.

Parameters:

    fname   - Farm name.
    service - Service name. Only apply if the farm profile has services. Leave undefined for farms without services.

Returns:

    -1      - If farmguardian PID file was not found (farmguardian not running).
    integer - PID number (unsigned integer) if farmguardian is running.

Bugs:

    Regex with .* should be fixed.

See Also:

    relianoid

=cut

sub getFarmGuardianPid ($fname, $service = undef) {
    my $pid = &getFGPidFarm($fname, $service);

    return $pid;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/File.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;

=pod

=head1 Module

Relianoid::File

=cut

=pod

=head1 getFile

Returns the content of a file as a string. Binary compatible.

Parameters:

    file_name - string with the location of the file

Returns:

    string - Content of the file.

=cut

sub getFile ($file_name) {
    unless (-f $file_name) {
        &log_info("Could not find file '$file_name'");
        return;
    }

    my $content;
    if (open(my $fh, '<', $file_name)) {
        binmode $fh;

        local $/ = undef;
        $content = <$fh>;

        close $fh;
    }
    else {
        &log_info("Could not open file '$file_name': $!");
        return;
    }

    return $content;
}

=pod

=head1 setFile

Writes a file with the content received. Binary compatible.

Parameters:

    path - string with the location of the file

    content - content to write to the files

Returns:

    integer

    1 - success
    0 - failure

=cut

sub setFile ($path, $content) {
    unless (defined $content) {
        &log_info("Trying to save undefined content");
        return 0;
    }

    if (open(my $fh, '>', $path)) {
        binmode $fh;
        print $fh $content;
        close $fh;
    }
    else {
        &log_info("Could not open file '$path': $!");
        return 0;
    }

    return 1;
}

=pod

=head1 insertFileWithPattern

Insert an array in a file before or after a pattern

=cut

sub insertFileWithPattern ($file, $array, $pattern, $opt = 'after') {
    my $err = 0;

    my $index = 0;
    my $found = 0;
    tie my @fileconf, 'Tie::File', $file;

    for my $line (@fileconf) {
        if ($line =~ /$pattern/) {
            $found = 1;
            last;
        }
        $index++;
    }

    return 1 if (!$found);

    $index++ if ($opt eq 'after');

    splice @fileconf, $index, 0, @{$array};
    untie @fileconf;

    return $err;
}

=pod

=head1 createFile

Create an empty file

Parameters:

    filename

Returns:

    integer

    0 - success
    1 - file already exists
    2 - error creating file

=cut

sub createFile ($filename) {
    if (-f $filename) {
        &log_error("The file $filename already exists", "System");
        return 1;
    }

    if (open(my $fh, '>', $filename)) {
        close $fh;
    }
    else {
        &log_error("The file $filename could not be created: $!", "System");
        return 2;
    }

    return 0;
}

=pod

=head1 deleteFile

=cut

sub deleteFile ($file) {
    if (!-f $file) {
        &log_error("The file $file doesn't exist", "System");
        return 1;
    }
    unlink $file;
    return 0;
}

=pod

=head1 getFileDateGmt

It gets the date of last modification of a file and it returns it in GMT format

Parameters:

    file path - File path

Returns:

    String - Date in GMT format

=cut

sub getFileDateGmt ($filepath) {
    use File::stat;
    my @eject = split(/ /, gmtime(stat($filepath)->mtime));
    splice(@eject, 0, 1);
    push(@eject, "GMT");

    my $date = join(' ', @eject);
    chomp $date;

    return $date;
}

=pod

=head1 getFileChecksumMD5

Returns the checksum MD5 of the file or directory including subdirs.

Parameters:

    file path - File path or Directory path

Returns:

    Hash ref - Hash ref with filepath as key and checksummd5 as value.

=cut

sub getFileChecksumMD5 ($filepath) {
    my $md5 = {};

    if (-d $filepath) {
        opendir(my $directory, $filepath);
        my @files = readdir($directory);
        closedir($directory);

        for my $file (@files) {
            next if ($file eq "." or $file eq "..");
            $md5 = { %{$md5}, %{ &getFileChecksumMD5($filepath . "/" . $file) } };
        }
    }
    elsif (-f $filepath) {
        if (open(my $fh, '<', $filepath)) {
            binmode($fh);
            use Digest::MD5;
            $md5->{$filepath} = Digest::MD5->new->addfile($fh)->hexdigest;
            close $fh;
        }
    }
    return $md5;
}

=pod

=head1 getFileChecksumAction

Compare two Hashes of checksum filepaths and returns the actions to take.

Parameters:

    checksum_filepath1 - Hash ref checksumMD5 file path1
    checksum_filepath2 - Hash ref checksumMD5 file path2

Returns:

    Hash ref - Hash ref with filepath as key and action as value

=cut

sub getFileChecksumAction ($checksum_filepath1, $checksum_filepath2) {
    my $files_changed;

    for my $file (keys %{$checksum_filepath1}) {
        if (!defined $checksum_filepath2->{$file}) {
            $files_changed->{$file} = "del";
        }
        elsif ($checksum_filepath1->{$file} ne $checksum_filepath2->{$file}) {
            $files_changed->{$file} = "modify";
            delete $checksum_filepath2->{$file};
        }
        else {
            delete $checksum_filepath2->{$file};
        }
    }
    for my $file (keys %{$checksum_filepath2}) {
        $files_changed->{$file} = "add";
    }
    return $files_changed;
}

=pod

=head1 readFileAsArray

Get the content of a file as an array of lines

Parameters:

    file_name - string. path to file

Returns:

    list - list of lines in the file

=cut

sub readFileAsArray ($file_name) {
    unless (-f $file_name) {
        my $msg = "Could not find file '$file_name'";
        &log_error($msg);
        croak($msg);
    }

    my @lines;
    if (open(my $fh, '<', $file_name)) {
        @lines = <$fh>;
        close $fh;
    }
    else {
        my $msg = "Could not open file '$file_name': $!";
        &log_error($msg);
        croak($msg);
    }

    return @lines;
}

=pod

=head1 writeFileFromArray

Write an array to a file

Parameters:

    file_name - string. path and file name

    array_ref - reference to the array to be written

Returns:

    list - list of files in the directory

=cut

sub writeFileFromArray ($file_name, $array_ref) {
    unless (defined $file_name and length $file_name) {
        my $msg = "The file name is not a valid string";
        &log_error($msg);
        croak($msg);
    }
    unless (ref $array_ref eq 'ARRAY') {
        my $msg = "Did not receive an array reference";
        &log_error($msg);
        croak($msg);
    }

    if (open(my $fh, '>', $file_name)) {
        print $fh join("", @{$array_ref});
        close $fh;
    }
    else {
        my $msg = "Could not open file '$file_name': $!";
        &log_error($msg);
        croak($msg);
    }

    return 1;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

=pod

=head1 Module

Relianoid::HTTP

=cut

use strict;
use warnings;
use feature qw(signatures);

use Carp;

use Relianoid::API;

my $LOG_TAG = "";
$LOG_TAG = "API"    if get_http_api_key();
$LOG_TAG = "WEBGUI" if (exists $ENV{HTTP_COOKIE});

my $eload = eval { require Relianoid::ELoad };

my %http_status_codes = (
    # 2xx Success codes
    200 => 'OK',
    201 => 'Created',
    204 => 'No Content',

    # 4xx Client Error codes
    400 => 'Bad Request',
    401 => 'Unauthorized',
    402 => 'Certificate not valid',
    403 => 'Forbidden',
    404 => 'Not Found',
    406 => 'Not Acceptable',
    415 => 'Unsupported Media Type',
    410 => 'Gone',
    422 => 'Unprocessable Entity',
);

# Examples of path regexes:
# - Non-capturing: (?^:^/interfaces/nic$)
# - Capturing:     (?^:^/farms/([a-zA-Z0-9\-]+)$)
my $CAPTURING_REGEX = qr{\/.+\(};

sub GET ($path, $code, $mod = undef) {
    return
      unless $ENV{REQUEST_METHOD} eq 'GET'
      or $ENV{REQUEST_METHOD} eq 'HEAD';

    my @captures = ($ENV{PATH_INFO} =~ $path);

    # if @capture is false, there was no match
    return unless @captures;

    # When there is nothing to be captured: @captures = (1)
    # Only attempt to save captured text when there are parenthesis on the url regex '('
    if ($path !~ $CAPTURING_REGEX) {
        @captures = ();
    }

    if (ref $code eq 'CODE') {
        $code->(@captures);
    }
    else {
        &eload(module => $mod, func => $code, args => \@captures) if $eload;
    }
    return;
}

sub POST ($path, $code, $mod = undef) {
    return unless $ENV{REQUEST_METHOD} eq 'POST';

    my @captures = ($ENV{PATH_INFO} =~ $path);

    # if @capture is false, there was no match
    return unless @captures;

    # When there is nothing to be captured: @captures = (1)
    # Only attempt to save captured text when there are parenthesis on the url regex '('
    if ($path !~ $CAPTURING_REGEX) {
        @captures = ();
    }

    require Relianoid::CGI;
    my $data = &getCgiParam('POSTDATA');
    my $input_ref;

    if (exists $ENV{CONTENT_TYPE} && $ENV{CONTENT_TYPE} eq 'application/json' && $data) {
        require JSON;

        $input_ref = eval { JSON::decode_json($data) };

        if (&debug()) {
            &log_debug("json: ${data}", $LOG_TAG);
        }

        if (!$input_ref) {
            my $body = {
                message => 'The body does not look a valid JSON',
                error   => 'true'
            };
            return &httpResponse({ code => 400, body => $body });
        }
    }
    elsif (exists $ENV{CONTENT_TYPE} && $ENV{CONTENT_TYPE} eq 'text/plain') {
        $input_ref = $data;
    }
    elsif (exists $ENV{CONTENT_TYPE}
        && $ENV{CONTENT_TYPE} eq 'application/x-pem-file')
    {
        $input_ref = $data;
    }
    elsif (exists $ENV{CONTENT_TYPE}
        && $ENV{CONTENT_TYPE} eq 'application/gzip')
    {
        $input_ref = $data;
    }
    elsif ($ENV{PATH_INFO} eq '/session' && !exists $ENV{CONTENT_TYPE} && !$data) {
        # Exception for /session. Allow no content, so content type too.
    }
    else {
        &log_error("Content-Type not supported: $ENV{CONTENT_TYPE}", $LOG_TAG);
        my $body = { message => 'Content-Type not supported', error => 'true' };

        return &httpResponse({ code => 415, body => $body });
    }

    my @args = ($input_ref, @captures);

    # stubborn web gui needs to send no body for POST /session
    if ($ENV{PATH_INFO} eq '/session') {
        @args = ();
    }

    if (ref $code eq 'CODE') {
        $code->(@args);
    }
    else {
        &eload(module => $mod, func => $code, args => \@args) if $eload;
    }

    return;
}

sub PUT ($path, $code, $mod = undef) {
    return unless $ENV{REQUEST_METHOD} eq 'PUT';

    my @captures = ($ENV{PATH_INFO} =~ $path);

    # if @capture is false, there was no match
    return unless @captures;

    # When there is nothing to be captured: @captures = (1)
    # Only attempt to save captured text when there are parenthesis on the url regex '('
    if ($path !~ $CAPTURING_REGEX) {
        @captures = ();
    }

    require Relianoid::CGI;
    my $data = &getCgiParam('PUTDATA');
    my $input_ref;

    if (exists $ENV{CONTENT_TYPE} && $ENV{CONTENT_TYPE} eq 'application/json' && $data) {
        require JSON;

        $input_ref = eval { JSON::decode_json($data) };

        if (&debug()) {
            &log_debug("json: ${data}", $LOG_TAG);
        }

        if (!$input_ref) {
            my $body = {
                message => 'The body does not look a valid JSON',
                error   => 'true'
            };

            return &httpResponse({ code => 400, body => $body });
        }
    }
    elsif (exists $ENV{CONTENT_TYPE} && $ENV{CONTENT_TYPE} eq 'text/plain') {
        $input_ref = $data;
    }
    elsif (exists $ENV{CONTENT_TYPE} && $ENV{CONTENT_TYPE} eq 'application/x-pem-file') {
        $input_ref = $data;
    }
    elsif (exists $ENV{CONTENT_TYPE} && $ENV{CONTENT_TYPE} eq 'application/gzip') {
        $input_ref = $data;
    }
    else {
        &log_error("Content-Type not supported: $ENV{CONTENT_TYPE}", $LOG_TAG);
        my $body = { message => 'Content-Type not supported', error => 'true' };

        return &httpResponse({ code => 415, body => $body });
    }

    my @args = ($input_ref, @captures);

    if (ref $code eq 'CODE') {
        $code->(@args);
    }
    else {
        &eload(module => $mod, func => $code, args => \@args) if $eload;
    }

    return;
}

sub DELETE ($path, $code, $mod = undef) {
    return unless $ENV{REQUEST_METHOD} eq 'DELETE';

    my @captures = ($ENV{PATH_INFO} =~ $path);

    # if @capture is false, there was no match
    return unless @captures;

    # When there is nothing to be captured: @captures = (1)
    # Only attempt to save captured text when there are parenthesis on the url regex '('
    if ($path !~ $CAPTURING_REGEX) {
        @captures = ();
    }

    if (ref $code eq 'CODE') {
        $code->(@captures);
    }
    else {
        &eload(module => $mod, func => $code, args => \@captures) if $eload;
    }

    return;
}

sub OPTIONS ($path, $code) {
    return unless $ENV{REQUEST_METHOD} eq 'OPTIONS';

    my @captures = ($ENV{PATH_INFO} =~ $path);

    # if @capture is false, there was no match
    return unless @captures;

    # When there is nothing to be captured: @captures = (1)
    # Only attempt to save captured text when there are parenthesis on the url regex '('
    if ($path !~ $CAPTURING_REGEX) {
        @captures = ();
    }

    &log_debug("OPTIONS captures( @captures )", $LOG_TAG) if &debug();

    $code->(@captures);

    return;
}

=pod

=head1 httpResponse

Serialize and send to STDOUT API response from data input.

Parameters: hash reference

    code    - HTTP status code digit
    headers - Optional. Hash reference of extra http headers to be included
    body    - Optional. Hash reference with data to be sent as JSON
    type    - Optional. HTTP Content-type header. Example: 'text/plain'

Returns: Nothing

=cut

sub httpResponse ($response) {
    return $response unless exists $ENV{GATEWAY_INTERFACE};

    if (not defined $response or ref $response ne 'HASH') {
        die 'httpResponse: Bad input';
    }

    if (not defined $response->{code} or not exists $http_status_codes{ $response->{code} }) {
        die 'httpResponse: Bad http status code';
    }

    require Relianoid::CGI;

    my $q      = &getCGI();
    my $origin = '*';

    if (not get_http_api_key()) {
        my $cors_devel_mode = &getGlobalConfiguration('cors_devel_mode') eq "true";
        $origin = $cors_devel_mode ? $ENV{HTTP_ORIGIN} : "https://$ENV{HTTP_HOST}";
    }

    # Headers included in all the responses, any method, any URI, sucess or error
    my %headers = (
        'Access-Control-Allow-Origin'      => $origin,
        'Access-Control-Allow-Credentials' => 'true',
        'Cache-Control'                    => 'no-cache',
        'Expires'                          => '-1',
        'Pragma'                           => 'no-cache',
    );

    # no session info received
    if ($ENV{REQUEST_METHOD} eq 'OPTIONS') {
        $headers{'Access-Control-Allow-Methods'} = 'GET, POST, PUT, DELETE, OPTIONS';
        $headers{'Access-Control-Allow-Headers'} =
          'API_KEY, ZAPI_KEY, Authorization, Set-cookie, Content-Type, X-Requested-With';
    }

    if (exists $ENV{HTTP_COOKIE} && $ENV{HTTP_COOKIE} =~ /CGISESSID/) {
        require Relianoid::HTTP::Auth;

        if (&validCGISession()) {
            my $session        = CGI::Session->load($q);
            my $session_cookie = $q->cookie(CGISESSID => $session->id);

            $headers{'Set-Cookie'}                    = "${session_cookie}; SameSite=None; Secure; HttpOnly";
            $headers{'Access-Control-Expose-Headers'} = "Set-Cookie, Content-Disposition";
        }
    }

    if ($q->path_info =~ '/session') {
        $headers{'Access-Control-Expose-Headers'} = "Set-Cookie";
    }

    if (exists $response->{headers} && ref $response->{headers} eq 'HASH') {
        %headers = (%headers, %{ $response->{headers} });
    }

    if ($response->{body}) {
        my $json_type = 'application/json';

        use Data::Dumper;
        log_debug("Response Headers: " . Dumper \%headers);

        if (not $headers{-type}) {
            $headers{-type} = $response->{type} || $json_type;
        }

        if ($headers{-type} eq $json_type) {
            $headers{-charset} = 'utf-8';
        }
    }

    print $q->header(
        -status => "$response->{code} $http_status_codes{$response->{code}}",
        %headers,
    );

    if ($response->{body}) {
        if (ref $response->{body} eq 'HASH') {
            require JSON;
            require Relianoid::Debug;

            my $canonical = debug();
            my $pretty    = debug();
            my $json      = JSON->new->utf8->pretty($pretty)->canonical([$canonical]);

            print $json->encode($response->{body});
        }
        elsif (ref $response->{body} eq 'GLOB') {
            my $fh = $response->{body};
            binmode $fh;

            local $/ = \4096;
            print while <$fh>;
            close $fh;
        }
        else {
            print $response->{body};
        }
    }

    # avoid logging frequent requests
    my @path_exceptions = ('/stats/system/connections', '/system/cluster/nodes', '/system/cluster/nodes/localhost');
    my $is_exception    = $ENV{REQUEST_METHOD} eq 'GET' && grep { $ENV{PATH_INFO} eq $_ } @path_exceptions;

    if (not $is_exception) {
        # log request if debug is enabled
        my $req_msg = "STATUS: $response->{code} REQUEST: $ENV{REQUEST_METHOD} $ENV{SCRIPT_URL}";

        # include memory usage if debug is 2 or higher
        $req_msg = sprintf("%s %s", $req_msg, &getMemoryUsage()) if &debug();
        &log_info($req_msg, $LOG_TAG);

        # log error message on error.
        if (ref $response->{body} eq 'HASH' and exists $response->{body}{message}) {
            &log_info($response->{body}{message}, $LOG_TAG);
        }
    }

    exit;
}

sub httpErrorResponse ($args) {
    unless (ref($args) eq 'HASH') {
        my $message = "httpErrorResponse: Argument is not a hash reference.";
        &log_info($message);
        carp($message);
    }

    # check required arguments: code, desc and msg
    unless ($args->{code} && $args->{desc} && $args->{msg}) {
        my $message = "httpErrorResponse: Missing required argument";
        &log_info($message);
        carp($message);
    }

    # check the status code is in a valid range
    unless ($args->{code} =~ /^4[0-9][0-9]$/) {
        my $message = "httpErrorResponse: Non-supported HTTP status code: $args->{code}";
        &log_info($message);
        carp($message);
    }

    my $body = {
        description => $args->{desc},
        error       => "true",
        message     => $args->{msg},
    };

    my $doc_url = &getGlobalConfiguration('doc_v4_0');
    $body->{documentation} = $doc_url if $doc_url;

    &log_error("$args->{desc}: $args->{msg}", $LOG_TAG);
    &log_info($args->{log_msg}, $LOG_TAG) if exists $args->{log_msg};

    my $response = { code => $args->{code}, body => $body };

    if ($0 =~ m!bin/enterprise\.bin$!) {
        return $response;
    }

    return &httpResponse($response);
}

sub httpSuccessResponse ($args) {
    unless (ref($args) eq 'HASH') {
        my $message = "httpSuccessResponse: Argument is not a hash reference";
        &log_info($message);
        carp($message);
    }

    unless ($args->{code} && $args->{desc} && $args->{msg}) {
        my $message = "httpSuccessResponse: Missing required argument";
        &log_info($message);
        carp($message);
    }

    unless ($args->{code} =~ /^2[0-9][0-9]$/) {
        my $message = "httpSuccessResponse: Non-supported HTTP status code: $args->{code}";
        &log_info($message);
        carp($message);
    }

    my $body = {
        description => $args->{desc},
        success     => "true",
        message     => $args->{msg},
    };

    &log_info($args->{log_msg}, $LOG_TAG) if exists $args->{log_msg};

    return &httpResponse({ code => $args->{code}, body => $body });
}

=pod

=head1 httpDownloadResponse

Arguments: array | hash

Receives a hash, or an array with hash parameters.

Hash keys:

    desc - string - Description of the API response
    dir  - string - Location of the file
    file - string - File name

Returns: Nothing

=cut

sub httpDownloadResponse (@args) {
    my $args;

    eval { $args = @args == 1 ? shift @args : {@args}; };

    # check errors loading the hash reference
    if ($@) {
        my $message = "httpDownloadResponse: Wrong argument received";
        &log_info($message);
        carp($message);
    }

    unless (ref($args) eq 'HASH') {
        my $message = "httpDownloadResponse: Argument is not a hash reference";
        &log_info($message);
        carp($message);
    }

    unless ($args->{desc} && $args->{dir} && $args->{file}) {
        my $message = "httpDownloadResponse: Missing required argument";
        &log_info($message);
        carp($message);
    }

    unless (-d $args->{dir}) {
        my $msg = "Invalid directory '$args->{dir}'";
        return &httpErrorResponse({ code => 400, desc => $args->{desc}, msg => $msg });
    }

    my $path = "$args->{dir}/$args->{file}";
    unless (-f $path) {
        my $msg = "The requested file $path could not be found.";
        return &httpErrorResponse({ code => 400, desc => $args->{desc}, msg => $msg });
    }

    my $fh;

    unless (open($fh, "<", $path)) { ## no critic (InputOutput::RequireBriefOpen)
        my $msg = "Could not open file $path: $!";
        return &httpErrorResponse({ code => 400, desc => $args->{desc}, msg => $msg });
    }

    my $type    = 'application/x-download';
    my $headers = {
        -type            => $type,
        -attachment      => $args->{file},
        'Content-length' => -s $path,
    };

    &log_info("[Download] $args->{desc}: $path", $LOG_TAG);

    return &httpResponse({ code => 200, headers => $headers, body => $fh, type => $type });
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Adapters/Backend.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Adapters::Backend

=cut

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 getBackendsResponse

Function to standarizate the backend structure on the API.

Parameters:

    out_b    - hash reference  - Required. Input and output
    type     - string          - Required. Farm type
    api_keys - array reference - Optional. Keys in API response. Only used in `get_farm_stats_controller`

Returns: nothing - It modifies the hash referenced by `out_b`.

=cut

sub getBackendsResponse ($backend_ref, $type, $api_keys = []) {
    die "Waiting a hash input" if not ref $backend_ref;

    if ($type eq 'l4xnat') {
        push @{$api_keys}, qw(id weight port ip priority status max_conns);
    }
    elsif ($type eq 'datalink') {
        push @{$api_keys}, qw(id weight ip priority status interface);
    }
    elsif ($type =~ /http/) {
        push @{$api_keys}, qw(id ip port weight status timeout);
    }
    elsif ($type eq 'gslb') {
        push @{$api_keys}, qw(id ip);
    }

    my $translate->{status} = { "fgdown" => "down", "undefined" => "up" };

    if (ref $backend_ref eq "ARRAY") {
        for my $backend (@{$backend_ref}) {
            _buildBackendAPIParams($backend, $api_keys, $translate);
        }
    }
    elsif (ref $backend_ref eq "HASH") {
        _buildBackendAPIParams($backend_ref, $api_keys, $translate);
    }

    if ($eload) {
        $backend_ref = &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'addAliasBackendsStruct',
            args   => [$backend_ref],
        );
    }

    return;
}

sub _buildBackendAPIParams ($backend, $api_keys, $translate) {
    my @bk_keys = keys(%{$backend});

    for my $param (keys %{$translate}) {
        for my $opt (keys %{ $translate->{$param} }) {
            if ($opt) {
                # This is a workaround to avoid regex substitution on undefined $out_b->{$param}
                if (defined $backend->{$param}) {
                    if (lc($backend->{$param}) eq $opt) {
                        $backend->{$param} = $translate->{$param}{$opt};
                    }
                    # else {
                    #     $out_b->{$param} =~ s/$opt/$translate->{$param}{$opt}/i;
                    # }
                }
                else {
                    if (not exists $backend->{$param}) {
                        $backend->{$param} = undef;
                    }

                    # if ($opt eq 'undefined') {
                    #     $backend->{$param} = $translate->{$param}{$opt};
                    # }
                }
            }
        }
    }

    for my $param (@bk_keys) {
        if (!grep { $param eq $_ } @{$api_keys}) {
            delete $backend->{$param};
        }
    }

    if (&debug()) {
        for my $param (@{$api_keys}) {
            if (!grep { $param eq $_ } @bk_keys) {
                &log_error("API parameter $param is missing", 'API');
            }
        }
    }

    return;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Auth.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::HTTP::Auth

=cut

sub validCGISession() {
    require Relianoid::CGI;
    require CGI::Session;

    my $q            = &getCGI();
    my $validSession = 0;

    my $session = CGI::Session->load($q);

    if ($session && $session->param('is_logged_in') && !$session->is_expired) {
        # ignore cluster nodes status to reset session expiration date
        unless ($q->path_info eq '/system/cluster/nodes') {
            my $session_timeout = &getGlobalConfiguration('session_timeout') // 30;
            $session->expire('is_logged_in', '+' . $session_timeout . 'm');
        }

        $validSession = 1;
        require Relianoid::User;
        &setUser($session->param('username'));
    }

    return $validSession;
}

sub getAuthorizationCredentials() {
    my $base64_digest;
    my $username;
    my $password;

    if (exists $ENV{HTTP_AUTHORIZATION}) {
        # Expected header example: 'Authorization': 'Basic aHR0cHdhdGNoOmY='
        $ENV{HTTP_AUTHORIZATION} =~ /^Basic (.+)$/;
        $base64_digest = $1;
    }

    if ($base64_digest) {
        # $decoded_digest format: "username:password"
        require MIME::Base64;
        chomp(my $decoded_digest = MIME::Base64::decode_base64($base64_digest));

        ($username, $password) = split /:/, $decoded_digest, 2;
    }

    &log_error("User not found",     "api") if not length $username;
    &log_error("Password not found", "api") if not length $password;

    return if not length $username or not length $password;

    require Relianoid::User;
    &setUser($username);

    return ($username, $password);
}

sub authenticateCredentials ($user, $pass) {
    return if not defined $user or not defined $pass;

    my $valid_credentials = 0;    # output

    if ($user eq 'root') {
        require Authen::Simple::Passwd;
        Authen::Simple::Passwd->import;

        my $passfile = "/etc/shadow";
        my $simple   = Authen::Simple::Passwd->new(path => "$passfile");

        if ($simple->authenticate($user, $pass)) {
            &log_debug("The user '$user' login locally", "auth");
            $valid_credentials = 1;
        }
    }
    elsif ($eload) {
        $valid_credentials = &eload(
            module => 'Relianoid::EE::RBAC::Runtime',
            func   => 'runRBACAuthUser',
            args   => [ $user, $pass ]
        );
    }

    return $valid_credentials;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Certificate.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Certificate

=cut

my $eload = eval { require Relianoid::ELoad };

my $CSR_KEY_SIZE = 2048;

# GET /certificates
sub list_certificates_controller () {
    require Relianoid::Certificate;

    my $desc         = "List certificates";
    my @certificates = &getCertFiles();
    my $configdir    = &getGlobalConfiguration('certdir');
    my @out;

    for my $cert (sort @certificates) {
        push @out, &getCertInfo("$configdir/$cert");
    }

    my $body = {
        description => $desc,
        params      => \@out,
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /certificates/CERTIFICATE/info
sub get_certificate_info_controller ($cert_filename) {
    require Relianoid::Certificate;

    my $desc     = "Show certificate details";
    my $cert_dir = &getGlobalConfiguration('certdir');

    # check is the certificate file exists
    if (!-f "$cert_dir\/$cert_filename") {
        my $msg = "Certificate file not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (not &getValidFormat('certificate', $cert_filename)) {
        my $msg = "Could not get such certificate information";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $cert = &getCertData("$cert_dir\/$cert_filename", "true");
    return &httpResponse({ code => 200, body => $cert, type => 'text/plain' });
}

# GET /certificates/CERTIFICATE
sub download_certificate_controller ($cert_filename) {
    my $desc      = "Download certificate";
    my $cert_dir  = &getGlobalConfiguration('certdir');
    my $cert_path = "$cert_dir/$cert_filename";

    unless ($cert_filename =~ /\.(pem|csr)$/ && -f $cert_path) {
        my $msg = "Could not find such certificate";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    return &httpDownloadResponse(desc => $desc, dir => $cert_dir, file => $cert_filename);
}

# DELETE /certificates/CERTIFICATE
sub delete_certificate_controller ($cert_filename) {
    require Relianoid::Certificate;
    require Relianoid::Letsencrypt;

    my $desc     = "Delete certificate";
    my $cert_dir = &getGlobalConfiguration('certdir');

    # check is the certificate file exists
    if (!-f "$cert_dir\/$cert_filename") {
        my $msg = "Certificate file not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $status = &getFarmCertUsed($cert_filename);

    # check is the certificate is being used
    if ($status == 0) {
        my $msg = "File can't be deleted because it's in use by a farm.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($eload) {
        $status = &eload(
            module => 'Relianoid::EE::System::HTTP',
            func   => 'getHttpsCertUsed',
            args   => [$cert_filename]
        );

        if ($status == 0) {
            my $msg = "File can't be deleted because it's in use by HTTPS server";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # check if it is a LE certificate
    my $le_cert_name = $cert_filename;
    $le_cert_name =~ s/.pem//g;
    $le_cert_name =~ s/\_/\./g;
    my $error;
    if (@{ &getLetsencryptCertificates($le_cert_name) }) {
        $error = &runLetsencryptDestroy($le_cert_name);
    }

    if ($eload) {
        my $wildcard = &eload(
            module => 'Relianoid::EE::Letsencrypt::Wildcard',
            func   => 'getLetsencryptWildcardCertificates',
            args   => [$le_cert_name]
        );

        if (@{$wildcard}) {
            $error = &eload(
                module => 'Relianoid::EE::Letsencrypt::Wildcard',
                func   => 'runLetsencryptWildcardDestroy',
                args   => [$le_cert_name]
            );
        }
    }

    if ($error) {
        my $msg = "LE Certificate can not be removed";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &delCert($cert_filename);

    # check if the certificate exists
    if (-f "$cert_dir\/$cert_filename") {
        my $msg = "Error deleting certificate $cert_filename.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no errors found, make a succesful response
    my $msg  = "The Certificate $cert_filename has been deleted.";
    my $body = {
        description => $desc,
        success     => "true",
        message     => $msg,
    };

    return &httpResponse({ code => 200, body => $body });
}

# POST /certificates (Create CSR)
sub create_csr_controller ($json_obj) {
    require Relianoid::Certificate;

    my $desc      = 'Create CSR';
    my $configdir = &getGlobalConfiguration('certdir');

    if (-f "$configdir/$json_obj->{name}.csr") {
        my $msg = "$json_obj->{name} already exists.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("certificate_csr-create.json");
    $params->{fqdn}{function} = \&checkFQDN;

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my $error = &createCSR(
        $json_obj->{name},     $json_obj->{fqdn},         $json_obj->{country},  $json_obj->{state},
        $json_obj->{locality}, $json_obj->{organization}, $json_obj->{division}, $json_obj->{mail},
        $CSR_KEY_SIZE,         ""
    );

    if ($error) {
        my $msg = "Error, creating certificate $json_obj->{name}.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $message = "Certificate $json_obj->{name} created";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
    };

    return &httpResponse({ code => 200, body => $body });
}

# POST /certificates/CERTIFICATE (Upload PEM)
sub upload_certificate_controller ($upload_data, $filename) {
    require Relianoid::File;
    require Relianoid::Certificate;

    my $desc      = "Upload PEM certificate";
    my $configdir = &getGlobalConfiguration('certdir');

    # add extension if it does not exist
    $filename .= ".pem" if $filename !~ /\.pem$/;

    # check if the certificate filename already exists
    $filename =~ s/[\(\)\@ ]//g;
    if (-f "$configdir/$filename") {
        my $msg = "Certificate file name already exists";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    unless (&setFile("$configdir/$filename", $upload_data)) {
        my $msg = "Could not save the certificate file";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if (&checkCertPEMKeyEncrypted("$configdir/$filename") == 1) {
        &delCert("$filename");
        my $msg = "SSL certificates with passphrase are not supported";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no errors found, return sucessful response
    my $message = "Certificate uploaded";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /ciphers
sub get_ciphers_controller () {
    my $desc = "Get the ciphers available";

    my @out = (
        { 'ciphers' => "all",            "description" => "All" },
        { 'ciphers' => "highsecurity",   "description" => "High security" },
        { 'ciphers' => "customsecurity", "description" => "Custom security" }
    );

    if ($eload) {
        push(@out, &eload(module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext', func => 'getExtraCipherProfiles',));
    }

    my $body = {
        description => $desc,
        params      => \@out,
    };

    return &httpResponse({ code => 200, body => $body });
}

# POST /farms/FARM/certificates (Add certificate to farm)
sub add_farm_certificate_controller ($json_obj, $farmname) {
    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;
    unless ($eload) { require Relianoid::Farm::HTTP::HTTPS; }

    my $desc = "Add certificate to farm '$farmname'";

    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "Farm not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Check if the farm exists
    my $farm_type = &getFarmType($farmname);
    if ($farm_type !~ /https|eproxy/) {
        my $msg = "This feature is only available for 'https' or 'eproxy' farms";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_certificate-add.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my $configdir = &getGlobalConfiguration('certdir');

    # validate certificate filename and format
    unless (-f $configdir . "/" . $json_obj->{file}) {
        my $msg = "The certificate does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    require Relianoid::Certificate;
    my $error = &checkCertPEMValid($configdir . "/" . $json_obj->{file});
    if ($error->{code}) {
        &log_error("'Certificate $json_obj->{file}' for farm $farmname is not valid", "LSLB");
        my $msg = "The certificate $json_obj->{file} is not valid.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $cert_in_use;
    if ($eload) {
        if ($farm_type eq 'https') {
            $cert_in_use = grep { $json_obj->{file} eq $_ } &eload(
                module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext',
                func   => 'getFarmCertificatesSNI',
                args   => [$farmname]
            );
        } elsif ($farm_type eq 'eproxy') {
            $cert_in_use = grep { $json_obj->{file} eq $_ } &eload(
                module => 'Relianoid::EE::Farm::Eproxy::SSL',
                func   => 'getEproxyFarmCertificates',
                args   => [{ farm_name => $farmname }]
            );
        }
    }
    else {
        $cert_in_use = &getFarmCertificate($farmname) eq $json_obj->{file};
    }

    if ($cert_in_use) {
        my $msg = "The certificate already exists in the farm.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $status;
    if ($eload) {
        if ($farm_type eq 'https') {
            $status = &eload(
                module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext',
                func   => 'setFarmCertificateSNI',
                args   => [ $json_obj->{file}, $farmname ],
            );
        } elsif ($farm_type eq 'eproxy') {
            $status = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::SSL',
                func   => 'setEproxyFarmCertificate',
                args   => [ { farm_name => $farmname, ssl_cert_filename => $json_obj->{file} } ],
            );
        }
    }
    else {
        $status = &setFarmCertificate($json_obj->{file}, $farmname);
    }

    if ($status) {
        my $msg = "It's not possible to add the certificate with name $json_obj->{file} for the $farmname farm";

        &log_error("It's not possible to add the certificate.", "LSLB");
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no errors found, return succesful response
    &log_info("Success trying to add a certificate to the farm.", "LSLB");

    my $message =
      "The certificate $json_obj->{file} has been added to the farm $farmname, you need restart the farm to apply";

    my $body = {
        description => $desc,
        success     => "true",
        message     => $message,
    };

    if (&getFarmStatus($farmname) ne 'down') {
        if ($farm_type eq 'https') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }
        elsif ($farm_type eq 'eproxy' && $eload) {
            $body->{status} = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Action',
                func   => 'runEproxyFarmReload',
                args   => [ { farm_name => $farmname } ],
            );
            require Relianoid::EE::Cluster;
            &runClusterRemoteManager('farm', 'reload', $farmname);
        }
    }

    return &httpResponse({ code => 200, body => $body });
}

# DELETE /farms/FARM/certificates/CERTIFICATE
sub delete_farm_certificate_controller ($farmname, $certfilename) {
    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    my $desc = "Delete farm certificate";

    unless ($eload) {
        my $msg = "HTTPS farm without certificate is not allowed.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate certificate
    unless ($certfilename && &getValidFormat('cert_pem', $certfilename)) {
        my $msg = "Invalid certificate id, please insert a valid value.";
        &log_error("Invalid certificate id.", "LSLB");
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my @certSNI = &eload(
        module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext',
        func   => 'getFarmCertificatesSNI',
        args   => [$farmname],
    );

    my $number = scalar grep ({ $_ eq $certfilename } @certSNI);
    if (!$number) {
        my $msg = "Certificate is not used by the farm.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if (@certSNI == 1 or ($number == @certSNI)) {
        my $msg = "The certificate '$certfilename' could not be deleted, the farm needs one certificate at least.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $status;

    # This is a BUGFIX: delete the certificate all times that it appears in config file
    for (my $it = 0 ; $it < $number ; $it++) {
        $status = &eload(
            module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext',
            func   => 'setFarmDeleteCertNameSNI',
            args   => [ $certfilename, $farmname ],
        );
        last if ($status == -1);
    }

    # check if the certificate could not be removed
    if ($status == -1) {
        &log_error("It's not possible to delete the certificate.", "LSLB");

        my $msg = "It isn't possible to delete the selected certificate $certfilename from the SNI list";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if removing the certificate would leave the SNI list empty, not supported
    if ($status == 1) {
        &log_error("It's not possible to delete all certificates, at least one is required for HTTPS.", "LSLB");

        my $msg = "It isn't possible to delete all certificates, at least one is required for HTTPS profiles";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no errors found, return succesful response
    my $msg  = "The Certificate $certfilename has been deleted";
    my $body = {
        description => $desc,
        success     => "true",
        message     => $msg
    };

    if (&getFarmStatus($farmname) ne 'down') {
        require Relianoid::Farm::Action;
        &setFarmRestart($farmname);
        $body->{status} = 'needed restart';
    }

    &log_info("Success trying to delete a certificate to the SNI list.", "LSLB");

    return &httpResponse({ code => 200, body => $body });
}

# POST /certificates/pem (Create PEM)
sub create_certificate_controller ($json_obj) {
    my $desc = "Create certificate";

    my $configdir = &getGlobalConfiguration('certdir');

    if (-f "$configdir/$json_obj->{name}.pem") {
        my $msg = "$json_obj->{name} already exists.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("certificate_pem-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    require Relianoid::Certificate;
    my $error = &createPEM($json_obj->{name}, $json_obj->{key}, $json_obj->{ca}, $json_obj->{intermediates});

    if ($error->{code}) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error->{desc} });
    }

    # no errors found, return sucessful response
    my $message = "Certificate $json_obj->{name} created";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
    };

    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Action.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::Core;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Action

=cut

my $eload = eval { require Relianoid::ELoad };

# PUT /farms/<farmname>/actions Set an action in a Farm
sub actions_farm_controller ($json_obj, $farmname) {
    require Relianoid::Farm::Action;
    require Relianoid::Farm::Base;

    my $desc = "Farm actions";

    # validate FARM NAME
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) =~ /http/) {
        require Relianoid::Farm::HTTP::Config;
        my $err_msg = &getHTTPFarmConfigErrorMessage($farmname);

        if ($err_msg) {
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $err_msg });
        }
    }

    my $params = &getAPIModel("farm-action.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    if ($json_obj->{action} eq "stop") {
        my $status = &runFarmStop($farmname, "true");

        if ($status != 0) {
            my $msg = "Error trying to set the action stop in farm $farmname.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    elsif ($json_obj->{action} eq "start") {
        require Relianoid::Net::Interface;

        # check if the ip exists in any interface
        my $ip = &getFarmVip("vip", $farmname);

        if (!&getIpAddressExists($ip)) {
            my $msg = "The virtual ip $ip is not defined in any interface.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        require Relianoid::Farm::Base;
        require Relianoid::Farm::Action;
        if (&getFarmRestartStatus($farmname)) {
            my $msg = "The farm has changes pending of applying, it has to be restarted.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        require Relianoid::Farm::Core;
        my $farm_type = &getFarmType($farmname);
        if ($farm_type ne "datalink") {
            my $if_name = &getInterfaceByIp($ip);
            my $if_ref  = &getInterfaceConfig($if_name);
            if (&getInterfaceSystemStatus($if_ref) ne "up") {
                my $msg = "The virtual IP '$ip' is not UP";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
            if ($farm_type eq "http" or $farm_type eq "https") {
                require Relianoid::Farm::HTTP::Action;
                &checkFarmHTTPSystemStatus($farmname, "down", "true");
            }

            my $port = &getFarmVip("vipp", $farmname);
            if (!&validatePort($ip, $port, undef, $farmname)) {
                my $msg = "There is another farm using the ip '$ip' and the port '$port'";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        my $status = &runFarmStart($farmname, "true");

        if ($status) {
            my $msg = "Error trying to set the action start in farm $farmname.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    elsif ($json_obj->{action} eq "restart") {
        my $status = &runFarmStop($farmname, "true");

        if ($status) {
            my $msg = "Error trying to stop the farm in the action restart in farm $farmname.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        require Relianoid::Net::Interface;

        # check if the ip exists in any interface
        my $ip = &getFarmVip("vip", $farmname);

        if (!&getIpAddressExists($ip)) {
            my $msg = "The virtual ip $ip is not defined in any interface.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        require Relianoid::Farm::Core;
        my $farm_type = &getFarmType($farmname);

        if ($farm_type ne "datalink") {
            my $if_name = &getInterfaceByIp($ip);
            my $if_ref  = &getInterfaceConfig($if_name);

            if (&getInterfaceSystemStatus($if_ref) ne "up") {
                my $msg = "The virtual IP '$ip' is not UP";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            my $port = &getFarmVip("vipp", $farmname);
            if (!&validatePort($ip, $port, undef, $farmname)) {
                my $msg = "There is another farm using the ip '$ip' and the port '$port'";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        $status = &runFarmStart($farmname, "true");

        if ($status) {
            my $msg = "API error, trying to start the farm in the action restart in farm $farmname.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my $msg = "The action $json_obj->{action} has been performed in farm $farmname.";

    &log_info("Success, $msg", "FARMS");

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', $json_obj->{action}, $farmname ],
    ) if ($eload);

    my $body = {
        description => "Set a new action in $farmname",
        params      => {
            "action" => $json_obj->{action},
            "status" => &getFarmVipStatus($farmname),
        },
        message => $msg
    };

    return &httpResponse({ code => 200, body => $body });
}

# Set an action in a backend of http|https farm
# PUT /farms/<farmname>/services/<service>/backends/<backend>/maintenance
sub set_service_backend_maintenance_controller ($json_obj, $farmname, $service, $backend_id) {
    require Relianoid::Farm::Base;
    require Relianoid::Farm::HTTP::Config;
    require Relianoid::Farm::HTTP::Service;
    require Relianoid::Farm::HTTP::Backend;

    my $desc = "Set service backend status";

    # validate FARM NAME
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate FARM TYPE
    if (&getFarmType($farmname) !~ /^https?$/) {
        my $msg = "Only HTTP farm profile supports this feature.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # validate SERVICE
    my @services = &getHTTPFarmServices($farmname);
    my $found_service;

    for my $service_name (@services) {
        if ($service eq $service_name) {
            $found_service = 1;
            last;
        }
    }

    if (!$found_service) {
        my $msg = "Could not find the requested service.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate BACKEND
    my $be_aref = &getHTTPFarmBackends($farmname, $service);
    my $be      = $be_aref->[ $backend_id - 1 ];

    if (!$be) {
        my $msg = "Could not find a service backend with such id.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_service_backend-maintenance.json");
    if ($json_obj->{action} ne 'maintenance') {
        delete $params->{mode};
    }

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # Do not allow to modify the maintenance status if the farm needs to be restarted
    require Relianoid::Farm::Action;
    if (&getFarmRestartStatus($farmname)) {
        my $msg = "The farm needs to be restarted before to apply this action.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # validate STATUS
    my $status;
    if ($json_obj->{action} eq "maintenance") {
        my $maintenance_mode = $json_obj->{mode} // "drain";    # default

        $status = &setHTTPFarmBackendMaintenance($farmname, $backend_id, $maintenance_mode, $service);
    }
    elsif ($json_obj->{action} eq "up") {
        $status = &setHTTPFarmBackendNoMaintenance($farmname, $backend_id, $service);
    }

    if ($status->{code} == 1 or $status->{code} == -1) {
        my $msg = "Errors found trying to change status backend to $json_obj->{action}";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $msg = "The action $json_obj->{action} has been performed in farm '$farmname'.";
    my $warning;
    if ($status->{code} != 0) {
        $warning = $status->{desc};
    }

    my $body = {
        description => $desc,
        params      => {
            action => $json_obj->{action},
            farm   => {
                status => &getFarmVipStatus($farmname),
            },
            message => $msg
        },
    };
    $body->{warning} = $warning if $warning;

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', 'restart', $farmname ],
    ) if ($eload && &getFarmStatus($farmname) eq 'up');

    return &httpResponse({ code => 200, body => $body });
}

# PUT backend in maintenance
# PUT /farms/<farmname>/backends/<backend>/maintenance
sub set_backend_maintenance_controller ($json_obj, $farmname, $backend_id) {
    require Relianoid::Farm::Backend::Maintenance;
    require Relianoid::Farm::Backend;
    require Relianoid::Farm::Base;

    my $desc = "Set backend status";

    # validate FARM NAME
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate FARM TYPE
    unless (&getFarmType($farmname) eq 'l4xnat') {
        my $msg = "Only L4xNAT farm profile supports this feature.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate BACKEND
    require Relianoid::Farm::L4xNAT::Backend;

    my $backends = &getL4FarmServers($farmname);
    my $exists   = &getFarmServer($backends, $backend_id);

    if (!$exists) {
        my $msg = "Could not find a backend with such id.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_l4xnat_service_backend-maintenance.json");

    if ($json_obj->{action} ne 'maintenance') {
        delete $params->{mode};
    }

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # validate STATUS
    my $status;
    if ($json_obj->{action} eq "maintenance") {
        my $maintenance_mode = $json_obj->{mode} // "drain";    # default

        $status = &setFarmBackendMaintenance($farmname, $backend_id, $maintenance_mode);
    }
    elsif ($json_obj->{action} eq "up") {
        $status = &setFarmBackendNoMaintenance($farmname, $backend_id);
    }

    if ($status->{code} == 1 or $status->{code} == -1) {
        my $msg = "Errors found trying to change status backend to $json_obj->{action}";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $msg = "The action $json_obj->{action} has been performed in farm '$farmname'.";
    my $warning;
    if ($status->{code} != 0) {
        $warning = $status->{desc};
    }

    # no error found, send successful response
    my $body = {
        description => $desc,
        params      => {
            action => $json_obj->{action},
            farm   => {
                status => &getFarmVipStatus($farmname),
            },
            message => $msg
        },
    };
    $body->{warning} = $warning if $warning;

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', 'restart', $farmname ],
    ) if ($eload && &getFarmStatus($farmname) eq 'up');

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Backend.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::HTTP;
use Relianoid::Farm::Core;
use Relianoid::Farm::Base;
use Relianoid::Net::Validate;
use Relianoid::HTTP::Controllers::API::Farm::Get;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Backend

=cut

my $eload = eval { require Relianoid::ELoad };

# POST

sub add_farm_backend_controller ($json_obj, $farmname) {
    require Relianoid::Farm::Backend;

    # Initial parameters
    my $desc = "New farm backend";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);
    if ($type ne 'datalink' and $type ne 'l4xnat') {
        my $msg = "The $type farm profile has backends only in services.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $params =
      ($type eq 'l4xnat')
      ? &getAPIModel("farm_l4xnat_service_backend-add.json")
      : &getAPIModel("farm_datalink_service_backend-add.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my $id = &getFarmBackendAvailableID($farmname);

    my $info_msg;

    # check of interface for datalink
    if ($type eq 'datalink') {
        my $msg = &_validate_datalink_backend_interface($json_obj);
        if ($msg) {
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # check of ip version
    if ($type eq 'l4xnat') {
        require Relianoid::Farm::L4xNAT::Config;
        my $farm_vip = &getL4FarmParam("vip", $farmname);

        if (&ipversion($json_obj->{ip}) ne &ipversion($farm_vip)) {
            my $msg = "The IP version of backend IP '$json_obj->{ip}' does not match with farm VIP '$farm_vip'";

            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Create backend
    my $status = &setFarmServer($farmname, undef, $id, $json_obj);

    if ($status && $status == -1) {
        my $msg = "It was not possible to create the backend";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    elsif ($status && $status == -2) {
        my $msg = "The IP $json_obj->{ip} is already set in farm $farmname";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &log_info("New backend created in farm $farmname with IP $json_obj->{ip}.", "FARMS");

    # check priority for l4xnat
    if ($type eq 'l4xnat') {
        require Relianoid::Farm::L4xNAT::Backend;
        require Relianoid::Farm::Validate;

        my $priorities = &getL4FarmPriorities($farmname);

        if (my $prio = &priorityAlgorithmIsOK($priorities)) {
            $info_msg = "Backends with high priority value ($prio) will not be used.";
            &log_warn("Warning, backend with high priority value ($prio) in farm $farmname.", "FARMS");
        }
    }

    # Backend retrieval
    my $serversArray = &getFarmServers($farmname);
    my $backend      = &getFarmServer($serversArray, $id);

    if (!$backend) {
        my $msg = "Error when retrieving the backend created";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::HTTP::Adapters::Backend;
    &getBackendsResponse($backend, $type);

    my $message = "Backend added.";
    my $body    = {
        description => $desc,
        params      => $backend,
        message     => $message,
        status      => &getFarmVipStatus($farmname),
    };

    $body->{warning} = $info_msg if defined $info_msg;

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', 'restart', $farmname ],
    ) if ($eload);

    return &httpResponse({ code => 201, body => $body });
}

sub add_service_backend_controller ($json_obj, $farmname, $service) {
    # Initial parameters
    my $desc = "New service backend";
    my $type = &getFarmType($farmname);

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate FARM TYPE

    if ($type eq "gslb" && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::GSLB',
            func   => 'new_gslb_service_backend',
            args   => [ $json_obj, $farmname, $service ]
        );
    }
    elsif ($type eq "eproxy" && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::Eproxy',
            func   => 'new_eproxy_service_backend',
            args   => [ $json_obj, $farmname, $service ]
        );
    }
    elsif ($type !~ /^https?$/) {
        my $msg = "The $type farm profile does not support services.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # HTTP
    require Relianoid::Farm::Config;
    require Relianoid::Farm::Backend;
    require Relianoid::Farm::Validate;
    require Relianoid::Farm::HTTP::Backend;
    require Relianoid::Farm::HTTP::Service;

    # validate SERVICE
    my @services = &getHTTPFarmServices($farmname);

    # Check if the provided service is configured in the farm
    unless (grep { $service eq $_ } @services) {
        my $msg = "Invalid service name, please insert a valid value.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the service has configured a redirect
    if (&getHTTPFarmVS($farmname, $service, 'redirect')) {
        my $msg = "It is not possible to create a backend when the service has a redirect configured.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_service_backend-add.json");
    undef $params->{connection_limit};

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # get an ID for the new backend
    my $id = &getHTTPFarmBackendAvailableID($farmname, $service);

    my $prio = 1;
    if (defined $json_obj->{priority} && $json_obj->{priority} !~ /^$/) {
        $prio = $json_obj->{priority} + 0;
    }

    if ($type =~ /http/ && $prio > 1) {
        my $priorities = &getHTTPFarmPriorities($farmname, $service);

        if (scalar(@{$priorities}) >= 1) {
            my $msg = "Only one backend as second priority is allowed.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # First param ($id) is an empty string to let function autogenerate the id for the new backend
    my $error = &setHTTPFarmServer(
        "",                   $json_obj->{ip}, $json_obj->{port}, $json_obj->{weight},    #
        $json_obj->{timeout}, $farmname,       $service,          $json_obj->{priority}
    );

    # check if there was an error adding a new backend
    if ($error) {
        my $msg =
            "It's not possible to create the backend with ip $json_obj->{ip}"
          . " and port $json_obj->{port} for the $farmname farm";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no error found, return successful response
    &log_info("Success, a new backend has been created in farm $farmname in service $service with IP $json_obj->{ip}.",
        "FARMS");

    my $message = "Added backend to service successfully.";
    my $backend = &getFarmServers($farmname, $service)->[$id];

    require Relianoid::HTTP::Adapters::Backend;
    &getBackendsResponse($backend, $type);

    my $body = {
        description => $desc,
        params      => $backend,
        message     => $message,
        status      => &getFarmVipStatus($farmname),
    };

    if (&getFarmStatus($farmname) eq 'up') {
        if ($type eq "eproxy" && $eload) {
            $body->{status} = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Action',
                func   => 'runEproxyFarmReload',
                args   => [ { farm_name => $farmname } ],
            );
            require Relianoid::EE::Cluster;
            &runClusterRemoteManager('farm', 'reload', $farmname);
        }
        else {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }
    }

    return &httpResponse({ code => 201, body => $body });
}

# GET

#GET /farms/<name>/backends
sub list_farm_backends_controller ($farmname) {
    require Relianoid::Farm::Backend;

    my $desc = "List backends";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);

    if ($type ne 'l4xnat' and $type ne 'datalink') {
        my $msg = "The farm $farmname with profile $type does not support this request.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::HTTP::Adapters::Backend;

    my $backends = &getFarmServers($farmname);
    &getBackendsResponse($backends, $type);

    my $body = {
        description => $desc,
        params      => $backends,
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET /farms/<name>/services/<service>/backends
sub list_service_backends_controller ($farmname, $service) {
    my $desc = "List service backends";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);
    my $service_ref;

    if ($type eq 'gslb' && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::GSLB',
            func   => 'list_gslb_service_backends',
            args   => [ $farmname, $service ]
        );
    }
    elsif ($type eq 'eproxy' && $eload) {
        $service_ref->{backends} = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Backend',
            func   => 'getEproxyFarmBackends',
            args   => [ { farm_name => $farmname, service_name => $service } ]
        );
    }
    elsif ($type =~ /^https?$/) {
        require Relianoid::Farm::HTTP::Service;
        $service_ref = &getHTTPServiceStruct($farmname, $service);
        # check if the requested service exists
        if ($service_ref == -1) {
            my $msg = "The service $service does not exist.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }
    else {
        my $msg = "The farm profile $type does not support this request.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $body = {
        description => $desc,
        params      => $service_ref->{backends},
    };

    return &httpResponse({ code => 200, body => $body });
}

# PUT

sub modify_farm_backend_controller ($json_obj, $farmname, $id_server) {
    my $desc = "Modify backend";

    require Relianoid::Farm::Backend;
    require Relianoid::Net::Validate;

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);
    if ($type ne 'datalink' and $type ne 'l4xnat') {
        my $msg = "The $type farm profile has backends only in services.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # get backends
    my $serversArray = &getFarmServers($farmname);

    my $backend = &getFarmServer($serversArray, $id_server);

    if (!$backend || ref($backend) ne "HASH") {
        my $msg = "Could not find a backend with such id.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $params =
      ($type eq 'l4xnat')
      ? &getAPIModel("farm_l4xnat_service_backend-modify.json")
      : &getAPIModel("farm_datalink_service_backend-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # check of ip version
    if ($type eq 'l4xnat' && exists $json_obj->{ip}) {
        require Relianoid::Farm::L4xNAT::Config;
        my $farm_vip = &getL4FarmParam("vip", $farmname);

        if (&ipversion($json_obj->{ip}) ne &ipversion($farm_vip)) {
            my $msg = "The IP version of backend IP '$json_obj->{ip}' does not match with farm VIP '$farm_vip'";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    $backend->{ip}        = $json_obj->{ip}        if exists $json_obj->{ip};
    $backend->{port}      = $json_obj->{port}      if exists $json_obj->{port};         # l4xnat
    $backend->{weight}    = $json_obj->{weight}    if exists $json_obj->{weight};
    $backend->{priority}  = $json_obj->{priority}  if exists $json_obj->{priority};
    $backend->{max_conns} = $json_obj->{max_conns} if exists $json_obj->{max_conns};    # l4xnat
    $backend->{interface} = $json_obj->{interface} if exists $json_obj->{interface};    # datalink

    if ($type eq 'datalink') {
        if (my $msg = &_validate_datalink_backend_interface($backend)) {
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my $error = &setFarmServer($farmname, undef, $id_server, $backend);
    if ($error && $error == -2) {
        my $msg = "The IP $json_obj->{ip} is already set in farm $farmname";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    if ($error) {
        my $msg = "Error trying to modify the backend $id_server.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $info_msg;
    if (($type ne 'datalink') and (exists $json_obj->{priority})) {
        require Relianoid::Farm::L4xNAT::Backend;
        require Relianoid::Farm::Validate;
        if (my $prio = &priorityAlgorithmIsOK(&getL4FarmPriorities($farmname))) {
            $info_msg = "Backends with high priority value ($prio) will not be used.";
            &log_warn("Warning, backend with high priority value ($prio) in farm $farmname.", "FARMS");
        }
    }

    &log_info("Success, some parameters have been changed in the backend $id_server in farm $farmname.", "FARMS");

    my $message = "Backend modified.";
    my $body    = {
        description => $desc,
        params      => $json_obj,
        message     => $message,
        status      => &getFarmVipStatus($farmname),
    };
    $body->{warning} = $info_msg if defined $info_msg;

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', 'restart', $farmname ],
    ) if ($eload && &getFarmStatus($farmname) eq 'up');

    return &httpResponse({ code => 200, body => $body });
}

sub modify_service_backends_controller ($json_obj, $farmname, $service, $id_server) {
    my $desc = "Modify service backend";

    my $type = &getFarmType($farmname);

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if ($type eq "gslb" && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::GSLB',
            func   => 'modify_gslb_service_backends',
            args   => [ $json_obj, $farmname, $service, $id_server ]
        );
    }
    if ($type eq "eproxy" && $eload) {
        my $status = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Backend',
            func   => 'modifyEproxyFarmBackend',
            args   => [ {
                farm_name => $farmname,
                service_name => $service,
                backend_id => $id_server,
                backend_ip => $json_obj->{ip},
                backend_port => $json_obj->{port},
                backend_weight => $json_obj->{weight},
                backend_priority => $json_obj->{priority}
            } ]
        );
        if ($status) {
            my $msg = "It's not possible to modify the backend with IP $json_obj->{ip} in service $service.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    elsif ($type =~ /^https?$/) {
        # HTTP
        require Relianoid::Farm::Action;
        require Relianoid::Farm::HTTP::Config;
        require Relianoid::Farm::HTTP::Backend;
        require Relianoid::Farm::HTTP::Service;

        # validate SERVICE
        my @services      = &getHTTPFarmServices($farmname);
        my $found_service = grep { $service eq $_ } @services;

        # check if the service exists
        if (!$found_service) {
            my $msg = "Could not find the requested service.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        # validate BACKEND
        my $be;
        {
            my @be_list = @{ &getHTTPFarmBackends($farmname, $service) };
            $be = $be_list[$id_server];
        }

        # check if the backend was found
        if (!$be) {
            my $msg = "Could not find a service backend with such id.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        my $params = &getAPIModel("farm_http_service_backend-modify.json");
        undef $params->{connection_limit};

        # Check allowed parameters
        if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
        }

        # apply BACKEND change

        $be->{ip}               = $json_obj->{ip}               // $be->{ip};
        $be->{port}             = $json_obj->{port}             // $be->{port};
        $be->{weight}           = $json_obj->{weight}           // $be->{weight};
        $be->{priority}         = $json_obj->{priority}         // $be->{priority};
        $be->{timeout}          = $json_obj->{timeout}          // $be->{timeout};
        $be->{connection_limit} = $json_obj->{connection_limit} // $be->{connection_limit};

        my $prio = 1;
        if (defined $be->{priority} && $be->{priority} !~ /^$/) {
            $prio = $be->{priority} + 0;
        }

        if ($type =~ /http/ && $prio > 1) {
            my $priorities = &getHTTPFarmPriorities($farmname, $service);
            if (scalar(@{$priorities}) >= 1 && !grep { $_->{id} == $id_server } @{$priorities}) {
                my $msg = "Only one backend as second priority is allowed.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        my $status = &setHTTPFarmServer(
            $id_server,     $be->{ip}, $be->{port}, $be->{weight},    #
            $be->{timeout}, $farmname, $service,    $be->{priority}
        );

        # check if there was an error modifying the backend
        if ($status == -1) {
            my $msg = "It's not possible to modify the backend with IP $json_obj->{ip} in service $service.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    else {
        my $msg = "The $type farm profile does not support services.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $msg  = "Backend modified.";
    my $body = {
        description => $desc,
        params      => $json_obj,
        message     => $msg,
        status      => &getFarmVipStatus($farmname),
    };

    if (&getFarmStatus($farmname) eq "up") {
        if ($type eq "eproxy" && $eload) {
            $body->{status} = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Action',
                func   => 'runEproxyFarmReload',
                args   => [ { farm_name => $farmname } ],
            );
            require Relianoid::EE::Cluster;
            &runClusterRemoteManager('farm', 'reload', $farmname);
        }
        else {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }
    }

    return &httpResponse({ code => 200, body => $body });
}

# DELETE

# DELETE /farms/<farmname>/backends/<backendid> Delete a backend of a Farm
sub delete_farm_backend_controller ($farmname, $id_server) {
    require Relianoid::Farm::Backend;

    my $desc = "Delete backend";

    # validate FARM NAME
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate FARM TYPE
    my $type = &getFarmType($farmname);
    unless ($type eq 'l4xnat' || $type eq 'datalink') {
        my $msg = "The $type farm profile has backends only in services.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $backends = &getFarmServers($farmname);
    my $exists   = &getFarmServer($backends, $id_server);

    if (!$exists) {
        my $msg = "Could not find a backend with such id.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $status = &runFarmServerDelete($id_server, $farmname);

    if ($status == -1) {
        my $msg = "It's not possible to delete the backend with ID $id_server of the $farmname farm.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $info_msg;
    if ($type eq 'l4xnat') {
        require Relianoid::Farm::Validate;
        if (my $prio = &priorityAlgorithmIsOK(&getL4FarmPriorities($farmname))) {
            $info_msg = "Backends with high priority value ($prio) will not be used.";
            &log_warn("Warning, backend with high priority value ($prio) in farm $farmname.", "FARMS");
        }
    }

    &log_info("Success, the backend $id_server in farm $farmname has been deleted.", "FARMS");

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', 'delete', $farmname, 'backend', $id_server ],
    ) if ($eload && $type eq 'l4xnat');

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', 'restart', $farmname ],
    ) if ($eload && $type eq 'datalink');

    my $message = "Backend removed";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
        status      => &getFarmVipStatus($farmname),
    };
    $body->{warning} = $info_msg if defined $info_msg;

    return &httpResponse({ code => 200, body => $body });
}

#  DELETE /farms/<farmname>/services/<servicename>/backends/<backendid> Delete a backend of a Service
sub delete_service_backend_controller ($farmname, $service, $id_server) {
    my $desc = "Delete service backend";

    # validate FARM NAME
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate FARM TYPE
    my $type = &getFarmType($farmname);

    if ($type eq 'gslb' && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::GSLB',
            func   => 'delete_gslb_service_backend',
            args   => [ $farmname, $service, $id_server ]
        );
    }
    elsif ($type eq 'eproxy' && $eload) {
        my $status = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Backend',
            func   => 'delEproxyFarmBackend',
            args   => [ { farm_name => $farmname, service_name => $service, backend_id => $id_server } ]
        );
        if ($status) {
            my $msg = "It hasn't been possible to delete the backend ID $id_server in the service $service from the eproxy farm $farmname";
            &log_info($msg, "LSLB");
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }
    elsif ($type =~ /^https?$/) {
        require Relianoid::Farm::Action;
        require Relianoid::Farm::HTTP::Config;
        require Relianoid::Farm::HTTP::Backend;
        require Relianoid::Farm::HTTP::Service;

        # validate SERVICE
        my @services = &getHTTPFarmServices($farmname);

        # check if the SERVICE exists
        unless (grep { $service eq $_ } @services) {
            my $msg = "Could not find the requested service.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        # check if the backend id is available
        my $be_found;
        {
            my $be = &getHTTPFarmBackends($farmname, $service);
            $be_found = defined @{$be}[$id_server];
        }

        unless ($be_found) {
            my $msg = "Could not find the requested backend.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        my $status = &runHTTPFarmServerDelete($id_server, $farmname, $service);

        # check if there was an error deleting the backend
        if ($status == -1) {
            &log_info("It's not possible to delete the backend.", "FARMS");

            my $msg = "Could not find the backend with ID $id_server of the $farmname farm.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }
    else {
        my $msg = "The $type farm profile does not support services.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no error found, return successful response
    &log_info("Success, the backend $id_server in service $service in farm $farmname has been deleted.", "FARMS");

    my $message = "Backend removed";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
        status      => &getFarmVipStatus($farmname),
    };

    if (&getFarmStatus($farmname) eq 'up') {
        if ($type eq "eproxy" && $eload) {
            $body->{status} = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Action',
                func   => 'runEproxyFarmReload',
                args   => [ { farm_name => $farmname } ],
            );
            require Relianoid::EE::Cluster;
            &runClusterRemoteManager('farm', 'reload', $farmname);
        }
        else {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }
    }

    return &httpResponse({ code => 200, body => $body });
}

sub _validate_datalink_backend_interface ($backend) {
    require Relianoid::Net::Interface;

    my $msg;
    my $iface_ref = &getInterfaceConfig($backend->{interface});

    if (not defined $iface_ref) {
        $msg = "$backend->{interface} has not been found";
    }
    elsif ($iface_ref->{vini}) {
        $msg = "It is not possible to configure vlan interface for datalink backends";
    }
    elsif (!&validateGateway($iface_ref->{addr}, $iface_ref->{mask}, $backend->{ip})) {
        $msg = "The $backend->{ip} IP must be in the same network than the $iface_ref->{addr} interface.";
    }

    return $msg;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Delete.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::Core;
use Relianoid::Farm::Base;
use Relianoid::Farm::Action;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Delete

=cut

my $eload = eval { require Relianoid::ELoad };

# DELETE /farms/FARMNAME
sub delete_farm_controller ($farmname) {
    my $desc = "Delete farm $farmname";

    if (!&getFarmExists($farmname)) {
        my $msg = "The farm $farmname doesn't exist, try another name.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmStatus($farmname) eq 'up') {
        if (&runFarmStop($farmname, "true")) {
            my $msg = "The farm $farmname could not be stopped.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'farm', 'stop', $farmname ],
        ) if ($eload);
    }

    my $error = &runFarmDelete($farmname);

    if ($error) {
        my $msg = "The Farm $farmname hasn't been deleted";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &log_info("Success, the farm $farmname has been deleted.", "FARMS");

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'farm', 'delete', $farmname ],
    ) if ($eload);

    my $msg  = "The Farm $farmname has been deleted.";
    my $body = {
        description => $desc,
        success     => "true",
        message     => $msg
    };

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Get.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Config;
use Relianoid::Farm::Core;
use Relianoid::Farm::Base;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Get

=cut

my $eload = eval { require Relianoid::ELoad };

#GET /farms
sub list_farms_controller () {
    require Relianoid::Farm::Base;

    my @out;
    my @files = &getFarmList();

    for my $file (@files) {
        my $name   = &getFarmName($file);
        my $type   = &getFarmType($name);
        my $status = &getFarmVipStatus($name);
        my $vip    = &getFarmVip('vip',  $name);
        my $port   = &getFarmVip('vipp', $name);

        push @out,
          {
            farmname => $name,
            profile  => $type,
            status   => $status,
            vip      => $vip,
            vport    => $port
          };
    }

    if ($eload) {
        @out = @{
            &eload(
                module => 'Relianoid::EE::RBAC::Group::Core',
                func   => 'getRBACUserSet',
                args   => [ 'farms', \@out ],
            )
        };
    }

    my $body = {
        description => "List farms",
        params      => \@out,
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /farms/modules/lslb
sub list_lslb_controller () {
    require Relianoid::Farm::Base;

    my @out;
    my @files = &getFarmList();

    for my $file (@files) {
        my $name = &getFarmName($file);
        my $type = &getFarmType($name);
        next unless $type =~ /^(?:https?|l4xnat|eproxy)$/;
        my $status = &getFarmVipStatus($name);
        my $vip    = &getFarmVip('vip',  $name);
        my $port   = &getFarmVip('vipp', $name);

        push @out,
          {
            farmname => $name,
            profile  => $type,
            status   => $status,
            vip      => $vip,
            vport    => $port
          };
    }

    if ($eload) {
        @out = @{
            &eload(
                module => 'Relianoid::EE::RBAC::Group::Core',
                func   => 'getRBACUserSet',
                args   => [ 'farms', \@out ],
            )
        };
    }

    my $body = {
        description => "List LSLB farms",
        params      => \@out,
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /farms/modules/dslb
sub list_dslb_controller () {
    require Relianoid::Farm::Base;

    my @out;
    my @files = &getFarmList();

    for my $file (@files) {
        my $name = &getFarmName($file);
        my $type = &getFarmType($name);
        next unless $type eq 'datalink';
        my $status = &getFarmVipStatus($name);
        my $vip    = &getFarmVip('vip',  $name);
        my $iface  = &getFarmVip('vipp', $name);

        push @out,
          {
            farmname  => $name,
            status    => $status,
            vip       => $vip,
            interface => $iface
          };
    }

    if ($eload) {
        @out = @{
            &eload(
                module => 'Relianoid::EE::RBAC::Group::Core',
                func   => 'getRBACUserSet',
                args   => [ 'farms', \@out ],
            )
        };
    }

    my $body = {
        description => "List DSLB farms",
        params      => \@out,
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET /farms/<name>/summary
sub get_farm_summary_controller ($farmname) {
    my $desc = "Show farm $farmname";
    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "Farm not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);
    if ($type =~ /https?/) {
        require Relianoid::HTTP::Controllers::API::Farm::Get::HTTP;
        &farms_name_http_summary($farmname);
    }
    else {
        &get_farm_controller($farmname);
    }

    return;
}

#GET /farms/<name>
sub get_farm_controller ($farmname) {
    my $desc = "Show farm $farmname";

    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "Farm not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);

    if ($type =~ /https?/) {
        require Relianoid::HTTP::Controllers::API::Farm::Get::HTTP;
        &farms_name_http($farmname);
    }
    elsif ($type eq 'l4xnat') {
        require Relianoid::HTTP::Controllers::API::Farm::Get::L4xNAT;
        &farms_name_l4($farmname);
    }
    elsif ($type eq 'datalink') {
        require Relianoid::EE::HTTP::Controllers::API::Farm::Get::Datalink;
        &farms_name_datalink($farmname);
    }
    elsif ($type eq 'gslb' && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::Get::GSLB',
            func   => 'farms_name_gslb',
            args   => [$farmname],
        );
    }
    elsif ($type eq 'eproxy' && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::Get::Eproxy',
            func   => 'farms_name_eproxy',
            args   => [$farmname],
        );
    }

    return;
}

#GET /farms/<name>/status
sub get_farm_status_controller ($farmname) {
    my $desc = "Show farm $farmname status";

    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "Farm not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $status = &getFarmVipStatus($farmname);

    # Output
    my $body = {
        description => $desc,
        params      => { status => $status },
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /farms/modules/summary
sub get_farm_modules_controller () {
    require Relianoid::Farm::Service;
    my $out = { lslb => [], gslb => [], dslb => [], };

    for my $farm_name (&getFarmNameList()) {
        my $type = &getFarmType($farm_name);
        $type =~ s/https/http/;
        my $it = {
            name    => $farm_name,
            profile => $type,
        };

        if ($type eq 'gslb' or $type eq 'http') {
            my @srv = &getFarmServices($farm_name);
            $it->{services} = \@srv;
        }

        if    ($type eq 'datalink') { push @{ $out->{dslb} }, $it; }
        elsif ($type eq 'gslb')     { push @{ $out->{gslb} }, $it; }
        else                        { push @{ $out->{lslb} }, $it; }
    }

    my $body = {
        description => "Farm Modules summary",
        params      => $out,
    };

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Get/HTTP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::HTTP::Config;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Get::HTTP

=cut

my $eload = eval { require Relianoid::ELoad };

# GET /farms/<farmname> Request info of a http|https Farm
sub farms_name_http ($farmname) {
    # Get farm reference
    require Relianoid::HTTP::Controllers::API::Farm::Output::HTTP;
    my $farm_ref = &getHTTPOutFarm($farmname);

    # Get farm services reference
    require Relianoid::Farm::HTTP::Service;
    my $services_ref = &getHTTPOutService($farmname);

    # Output
    my $body = {
        description => "List farm $farmname",
        params      => $farm_ref,
        services    => $services_ref,
    };

    if ($eload) {
        $body->{ipds} = &eload(
            module => 'Relianoid::EE::IPDS::Core',
            func   => 'getIPDSfarmsRules',
            args   => [$farmname],
        );
    }

    return &httpResponse({ code => 200, body => $body });
}

# GET /farms/<farmname>/summary
sub farms_name_http_summary ($farmname) {
    # Get farm reference
    require Relianoid::HTTP::Controllers::API::Farm::Output::HTTP;
    my $farm_ref = &getHTTPOutFarm($farmname);

    # Services
    require Relianoid::Farm::HTTP::Service;

    my $services_ref = &get_http_all_services_summary_struct($farmname);

    my $body = {
        description => "List farm $farmname",
        params      => $farm_ref,
        services    => $services_ref,
    };

    if ($eload) {
        $body->{ipds} = &eload(
            module => 'Relianoid::EE::IPDS::Core',
            func   => 'getIPDSfarmsRules',
            args   => [$farmname],
        );
    }

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Get/L4xNAT.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::FarmGuardian;
use Relianoid::Farm::Config;
use Relianoid::Farm::Backend;
use Relianoid::Farm::L4xNAT::Config;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Get::L4xNAT

=cut

my $eload = eval { require Relianoid::ELoad };

# GET /farms/<farmname> Request info of a l4xnat Farm
sub farms_name_l4 ($farmname) {
    require Relianoid::Farm::L4xNAT::Sessions;

    my $farm   = &getL4FarmStruct($farmname);
    my $status = &getFarmVipStatus($farmname);
    my $fields = {
        status      => $status,
        vip         => $farm->{vip},
        vport       => $farm->{vport},
        algorithm   => $farm->{lbalg},
        nattype     => $farm->{nattype},
        persistence => $farm->{persist},
        ttl         => $farm->{ttl} + 0,
        protocol    => $farm->{vproto},

        farmguardian => &getFGFarm($farmname),
        listener     => 'l4xnat',
        sessions     => &listL4FarmSessions($farmname)
    };

    require Relianoid::HTTP::Adapters::Backend;

    my $backends = &getL4FarmServers($farmname);
    &getBackendsResponse($backends, 'l4xnat');

    my $body = {
        description => "List farm $farmname",
        params      => $fields,
        backends    => $backends,
    };

    if ($eload) {
        $fields->{logs} = $farm->{logs};

        $body->{ipds} = &eload(
            module => 'Relianoid::EE::IPDS::Core',
            func   => 'getIPDSfarmsRules',
            args   => [$farmname],
        );
    }

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Guardian.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::FarmGuardian;
use Relianoid::Farm::Core;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Guardian

=cut

my $eload = eval { require Relianoid::ELoad };

sub get_farmguardian_response ($fg_name) {
    my $fg  = &getFGObject($fg_name);
    my $out = {
        'name'          => $fg_name,
        'backend_alias' => $fg->{backend_alias} // 'false',
        'description'   => $fg->{description},
        'command'       => $fg->{command},
        'farms'         => $fg->{farms},
        'log'           => $fg->{log} // 'false',
        'interval'      => $fg->{interval} + 0,
        'cut_conns'     => $fg->{cut_conns},
        'template'      => $fg->{template},
        'timeout'       => ($fg->{timeout} // $fg->{interval}) + 0,
    };

    return $out;
}

sub list_farmguardian_response () {
    my @out;
    my @list = &getFGList();

    for my $fg_name (@list) {
        my $fg = &get_farmguardian_response($fg_name);
        push @out, $fg;
    }

    return \@out;
}

# first, it checks is exists and later look for in both lists, template and config
#  GET /monitoring/fg/<fg_name>
sub get_farmguardian_controller ($fg_name) {
    my $desc = "Retrive the farm guardian '$fg_name'";

    unless (&getFGExists($fg_name)) {
        my $msg = "The farm guardian '$fg_name' has not been found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $out  = &get_farmguardian_response($fg_name);
    my $body = { description => $desc, params => $out };

    return &httpResponse({ code => 200, body => $body });
}

#  GET /monitoring/fg
sub list_farmguardian_controller () {
    my $fg   = &list_farmguardian_response();
    my $desc = "List farm guardian checks and templates";

    return &httpResponse({ code => 200, body => { description => $desc, params => $fg } });
}

#  POST /monitoring/fg
sub create_farmguardian_controller ($json_obj) {
    my $fg_name = $json_obj->{name};
    my $desc    = "Create a farm guardian '$fg_name'";

    if (&getFGExistsConfig($fg_name)) {
        my $msg = "The farm guardian '$fg_name' already exists.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if (&getFGExistsTemplate($fg_name)) {
        my $msg = "The farm guardian '$fg_name' is a template, select another name, please";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farmguardian-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    if (exists $json_obj->{copy_from}
        and not &getFGExists($json_obj->{copy_from}))
    {
        my $msg = "The parent farm guardian '$json_obj->{copy_from}' does not exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if    (not exists $json_obj->{copy_from}) { &createFGBlank($fg_name); }
    elsif (&getFGExistsTemplate($json_obj->{copy_from})) {
        &createFGTemplate($fg_name, $json_obj->{copy_from});
    }
    else { &createFGConfig($fg_name, $json_obj->{copy_from}); }

    my $out = &get_farmguardian_response($fg_name);
    if ($out) {
        my $msg  = "The farm guardian '$fg_name' has been created successfully.";
        my $body = {
            description => $desc,
            params      => $out,
            message     => $msg,
        };
        return &httpResponse({ code => 200, body => $body });
    }
    else {
        my $msg = "The farm guardian '$fg_name' could not be created";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
}

#  PUT /monitoring/fg/<fg_name>
sub modify_farmguardian_controller ($json_obj, $fgname) {
    my $desc = "Modify farm guardian '$fgname'";

    unless (&getFGExists($fgname)) {
        my $msg = "The farm guardian '$fgname' does not exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farmguardian-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my @run_farms = @{ &getFGRunningFarms($fgname) };
    my $run_farms;
    $run_farms = join(', ', @run_farms) if @run_farms;

    # avoid modifying some parameters of a template
    if (&getFGExistsTemplate($fgname)) {
        if (exists $json_obj->{description} or exists $json_obj->{command}) {
            my $msg = "It is not allow to modify the parameters 'description' or 'command' in a template.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # check if farm guardian is running
    if (    $run_farms
        and not exists $json_obj->{force}
        and $json_obj->{force} ne 'true')
    {
        if (exists $json_obj->{command} or exists $json_obj->{backend_alias}) {
            my $error_msg = "Farm guardian '$fgname' is running in: '$run_farms'. To apply, send parameter 'force'";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
        }
    }

    delete $json_obj->{force};

    if (my $error = &setFGObject($fgname, $json_obj)) {
        my $msg  = "Modifying farm guardian '$fgname'.";
        my $body = { description => $desc, message => $msg, };
        return &httpResponse({ code => 400, body => $body });
    }

    # sync with cluster
    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'fg', 'restart', $fgname ],
        );
    }

    # no error found, return successful response
    my $msg  = "Success, some parameters have been changed in farm guardian '$fgname'.";
    my $out  = &get_farmguardian_response($fgname);
    my $body = { description => $desc, params => $out, message => $msg, };

    return &httpResponse({ code => 200, body => $body });
}

#  DELETE /monitoring/fg/<fg_name>
sub delete_farmguardian_controller ($fg_name) {
    my $desc = "Delete the farm guardian '$fg_name'";

    unless (&getFGExists($fg_name)) {
        my $msg = "The farm guardian $fg_name does not exist";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my @running_farms = @{ &getFGRunningFarms($fg_name) };
    if (@running_farms) {
        my $farm_str = join(', ', @running_farms);
        my $msg      = "It is not possible delete farm guardian '$fg_name' because it is running in: '$farm_str'";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &delFGObject($fg_name);

    if (!&getFGExists($fg_name)) {
        # sync with cluster
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'fg', 'stop', $fg_name ],
            );
        }

        my $msg  = "$fg_name has been deleted successfully.";
        my $body = {
            description => $desc,
            success     => "true",
            message     => $msg,
        };
        return &httpResponse({ code => 200, body => $body });
    }
    else {
        my $msg = "Deleting the farm guardian '$fg_name'.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
}

#  POST /farms/<farm>(/services/<service>)?/fg
sub add_fg_to_farm_controller ($json_obj, $farm, $srv = undef) {
    my $srv_message = ($srv) ? "service '$srv' in the farm '$farm'" : "farm '$farm'";

    my $desc = "Add the farm guardian '$json_obj->{name}' to the '$srv_message'";

    require Relianoid::Farm::Service;

    # Check if it exists
    if (!&getFarmExists($farm)) {
        my $msg = "The farm '$farm' does not exist";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farmguardian_to_farm-add.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # Check if it exists
    if (!&getFGExists($json_obj->{name})) {
        my $msg = "The farmguardian '$json_obj->{name}' does not exist";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Check if it exists
    if ($srv and not grep { $srv eq $_ } &getFarmServices($farm)) {
        my $msg = "The service '$srv' does not exist";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # check if another fg is applied to the farm
    my $fg_old = &getFGFarm($farm, $srv);
    if ($fg_old) {
        my $msg = "The '$srv_message' has already linked a farm guardian";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # link the check with the farm_service
    my $farm_tag = $farm;
    $farm_tag = "${farm}_$srv" if $srv;

    # check if the farm guardian is already applied to the farm
    my $fg_obj = &getFGObject($json_obj->{name});
    if (grep { $farm_tag eq $_ } @{ $fg_obj->{farms} }) {
        my $msg = "'$json_obj->{name}' is already applied in the '$srv_message'";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check farm type
    my $type = &getFarmType($farm);
    if ($type =~ /http|gslb|eproxy/ and not $srv) {
        my $msg = "The farm guardian expects a service";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $output = &linkFGFarm($json_obj->{name}, $farm, $srv);

    # check result and return success or failure
    if (!$output) {
        # sync with cluster
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'fg_farm', 'start', $farm, $srv ],
            );
        }

        my $msg  = "Success, The farm guardian '$json_obj->{name}' was added to the '$srv_message'";
        my $body = {
            description => $desc,
            message     => $msg,
            status      => &getFarmVipStatus($farm),
        };
        return &httpResponse({ code => 200, body => $body });
    }
    else {
        my $msg = "There was an error trying to add '$json_obj->{name}' to the '$srv_message'";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
}

#  DELETE /farms/<farm>(/services/<service>)?/fg/<fg_name>
sub delete_fg_from_farm_controller ($farm, $srv, $fgname = undef) {
    unless (defined $fgname) {
        $fgname = $srv;
        $srv    = undef;
    }

    my $srv_message = ($srv) ? "service '$srv' in the farm '$farm'" : "farm '$farm'";
    my $desc        = "Remove the farm guardian '$fgname' from the '$srv_message'";

    require Relianoid::Farm::Service;

    # Check if it exists
    if (!&getFarmExists($farm)) {
        my $msg = "The farm '$farm' does not exist";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Check if it exists
    if (!&getFGExists($fgname)) {
        my $msg = "The farmguardian '$fgname' does not exist";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Check if it exists
    if ($srv and not grep { $srv eq $_ } &getFarmServices($farm)) {
        my $msg = "The service '$srv' does not exist";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # link the check with the farm_service
    my $farm_tag = $farm;
    $farm_tag = "${farm}_$srv" if $srv;

    # check if the farm guardian is already applied to the farm
    my $fg_obj = &getFGObject($fgname);
    if (not grep { $farm_tag eq $_ } @{ $fg_obj->{farms} }) {
        my $msg = "The farm guardian '$fgname' is not applied to the '$srv_message'";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &unlinkFGFarm($fgname, $farm, $srv);

    # check output
    $fg_obj = &getFGObject($fgname);
    if (grep { $farm_tag eq $_ } @{ $fg_obj->{farms} } or &getFGPidFarm($farm)) {
        my $msg = "Error removing '$fgname' from the '$srv_message'";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    else {
        require Relianoid::Farm::Base;

        # sync with cluster
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'fg_farm', 'stop', $farm, $srv ],
            );
        }

        my $msg  = "Success, '$fgname' was removed from the '$srv_message'";
        my $body = {
            description => $desc,
            message     => $msg,
            status      => &getFarmVipStatus($farm),
        };
        return &httpResponse({ code => 200, body => $body });
    }
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/HTTP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

use Relianoid::HTTP;
use Relianoid::Farm::Base;
use Relianoid::Farm::HTTP::Config;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::HTTP

=cut

# POST	/farms/<>/addheader
sub add_addheader_controller ($json_obj, $farmname) {
    my $desc = "Add addheader directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_request_add-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # check if the header is already added
    for my $header (@{ &getHTTPAddReqHeader($farmname) }) {
        if ($header->{header} eq $json_obj->{header}) {
            my $msg = "The header is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&addHTTPAddheader($farmname, $json_obj->{header})) {
        # success
        my $message = "Added a new item to the addheader list";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error adding a new addheader";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

# PUT	/farms/<>/addheader/<id>
sub modify_addheader_controller ($json_obj, $farmname, $index) {
    my $desc = "Modify an addheader directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_request_add-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my @directives = @{ &getHTTPAddReqHeader($farmname) };

    # check if the header exists
    if ((scalar @directives) < $index + 1) {
        my $msg = "The header with index $index not found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the header is already added
    for my $header (@directives) {
        if ($header->{header} eq $json_obj->{header}) {
            my $msg = "The header is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&modifyHTTPAddheader($farmname, $json_obj->{header}, $index)) {
        # success
        my $message = "Modified an item from the addheader list";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error modifying an addheader";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

#  DELETE	/farms/<>/addheader/<>
sub del_addheader_controller ($farmname, $index) {
    my $desc = "Delete addheader directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the header is already added
    if ((scalar @{ &getHTTPAddReqHeader($farmname) }) < $index + 1) {
        my $msg = "The index has not been found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    unless (&delHTTPAddheader($farmname, $index)) {
        # success
        my $message = "The addheader $index was deleted successfully";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error deleting the addheader $index";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

# POST	/farms/<>/headremove
sub add_headremove_controller ($json_obj, $farmname) {
    my $desc = "Add headremove directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_request_remove-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # check if the header is already added
    for my $header (@{ &getHTTPRemReqHeader($farmname) }) {
        if ($header->{pattern} eq $json_obj->{pattern}) {
            my $msg = "The pattern is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&addHTTPHeadremove($farmname, $json_obj->{pattern})) {
        # success
        my $message = "Added a new item to the headremove list";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error adding a new headremove";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

# PUT	/farms/<>/headremove/<id>
sub modify_headremove_controller ($json_obj, $farmname, $index) {
    my $desc = "Modify an headremove directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_request_remove-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my @directives = @{ &getHTTPRemReqHeader($farmname) };

    # check if the header exists
    if ((scalar @directives) < $index + 1) {
        my $msg = "The header with index $index not found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the new pattern is already added
    for my $header (@directives) {
        if ($header->{pattern} eq $json_obj->{pattern}) {
            my $msg = "The pattern is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&modifyHTTPHeadremove($farmname, $json_obj->{pattern}, $index)) {
        # success
        my $message = "Modified an item from the headremove list";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error modifying an headremove";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

#  DELETE	/farms/<>/addheader/<>
sub del_headremove_controller ($farmname, $index) {
    my $desc = "Delete headremove directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the headremove is already added
    if ((scalar @{ &getHTTPRemReqHeader($farmname) }) < $index + 1) {
        my $msg = "The index has not been found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    unless (&delHTTPHeadremove($farmname, $index)) {
        # success
        my $message = "The headremove $index was deleted successfully";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error deleting the headremove $index";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

# POST	/farms/<>/addheader
sub add_addResHeader_controller ($json_obj, $farmname) {
    my $desc = "Add a header to the backend repsonse.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_response_add-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # check if the header is already added
    for my $header (@{ &getHTTPAddRespHeader($farmname) }) {
        if ($header->{header} eq $json_obj->{header}) {
            my $msg = "The header is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&addHTTPAddRespheader($farmname, $json_obj->{header})) {
        # success
        my $message = "Added a new header to the backend response";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error adding a new response header";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

# PUT	/farms/<>/addresponseheader/<id>
sub modify_addResHeader_controller ($json_obj, $farmname, $index) {
    my $desc = "Modify an addresponseheader directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_response_add-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my @directives = @{ &getHTTPAddRespHeader($farmname) };

    # check if the header exists
    if ((scalar @directives) < $index + 1) {
        my $msg = "The header with index $index not found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the header is already added
    for my $header (@directives) {
        if ($header->{header} eq $json_obj->{header}) {
            my $msg = "The header is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&modifyHTTPAddRespheader($farmname, $json_obj->{header}, $index)) {
        # success
        my $message = "Modified an item from the addresponseheader list";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error modifying an addresponseheader";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

#  DELETE	/farms/<>/addresponseheader/<>
sub del_addResHeader_controller ($farmname, $index) {
    my $desc = "Delete a header previously added to the backend response.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the header is already added
    if ((scalar @{ &getHTTPAddRespHeader($farmname) }) < $index + 1) {
        my $msg = "The index has not been found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    unless (&delHTTPAddRespheader($farmname, $index)) {
        # success
        my $message = "The header $index was deleted successfully";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error deleting the response header $index";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

# POST	/farms/<>/removeresponseheader
sub add_delResHeader_controller ($json_obj, $farmname) {
    my $desc = "Remove a header from the backend response.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_response_remove-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # check if the header is already added
    for my $header (@{ &getHTTPRemRespHeader($farmname) }) {
        if ($header->{pattern} eq $json_obj->{pattern}) {
            my $msg = "The pattern is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&addHTTPRemRespHeader($farmname, $json_obj->{pattern})) {
        # success
        my $message = "Added a patter to remove reponse headers";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error adding the remove pattern";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

# PUT	/farms/<>/removeresponseheader/<id>
sub modify_delResHeader_controller ($json_obj, $farmname, $index) {
    my $desc = "Modify a remove response header directive.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_header_response_remove-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my @directices = @{ &getHTTPRemRespHeader($farmname) };

    # check if the header exists
    if ((scalar @directices) < $index + 1) {
        my $msg = "The header with index $index not found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the header is already added
    for my $header (@directices) {
        if ($header->{pattern} eq $json_obj->{pattern}) {
            my $msg = "The pattern is already added.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    unless (&modifyHTTPRemRespHeader($farmname, $json_obj->{header}, $index)) {
        # success
        my $message = "Modified an item from the removeresponseheader list";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error modifying an removeresponseheader";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

#  DELETE	/farms/<>/addheader/<>
sub del_delResHeader_controller ($farmname, $index) {
    my $desc = "Delete a pattern to remove response headers.";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farm '$farmname' does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    if (&getFarmType($farmname) !~ /http/) {
        my $msg = "This feature is only for HTTP profiles.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the headremove is already added
    if ((scalar @{ &getHTTPRemRespHeader($farmname) }) < $index + 1) {
        my $msg = "The index has not been found.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    unless (&delHTTPRemRespHeader($farmname, $index)) {
        # success
        my $message = "The pattern $index was deleted successfully";
        my $body    = {
            description => $desc,
            success     => "true",
            message     => $message,
        };

        if (&getFarmStatus($farmname) ne 'down') {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }

        return &httpResponse({ code => 200, body => $body });
    }

    # error
    my $msg = "Error deleting the pattern $index";
    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Output/HTTP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::HTTP::Config;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Output::HTTP

=cut

# farm parameters
sub getHTTPOutFarm ($farmname) {
    require Relianoid::Farm::HTTP::Config;
    my $farm_ref = &getHTTPFarmStruct($farmname);

    # Remove useless fields
    delete($farm_ref->{name});
    return $farm_ref;
}

sub getHTTPOutService ($farmname) {
    require Relianoid::Farm::HTTP::Service;
    my @services_list = ();

    for my $service (&getHTTPFarmServices($farmname)) {
        my $service_ref = &getHTTPServiceStruct($farmname, $service);
        push @services_list, $service_ref;
    }

    return \@services_list;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Post.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Net::Util;
use Relianoid::Farm::Core;
use Relianoid::Farm::Factory;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Post

=cut

my $eload = eval { require Relianoid::ELoad };

sub add_farm_controller ($json_obj) {
    # 3 Mandatory Parameters ( 1 mandatory for HTTP or GSBL and optional for L4xNAT )
    #
    #	- farmname
    #	- profile
    #	- vip
    #	- vport: optional for L4xNAT and not used in Datalink profile.

    my $desc = "Creating a farm";

    # check if FARM NAME already exists
    unless (&getFarmType($json_obj->{farmname}) eq "1") {
        my $msg = "Error trying to create a new farm, the farm name already exists.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if (exists $json_obj->{copy_from}) {
        my $ori_type = &getFarmType($json_obj->{copy_from});
        $ori_type = 'http' if $ori_type eq 'https';

        if ($ori_type eq "1") {
            my $msg = "The farm '$json_obj->{copy_from}' does not exist.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        if (exists($json_obj->{profile}) and ($ori_type ne $json_obj->{profile})) {
            my $msg =
              "The profile '$json_obj->{profile}' does not match with the profile '$ori_type' of the farm '$json_obj->{copy_from}'.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
        else {
            $json_obj->{profile} = $ori_type;
        }
    }

    require Relianoid::Net::Interface;
    my $ip_list = &getIpAddressList();

    # Check allowed parameters
    my $params = &getAPIModel("farm-create.json");
    $params->{vport}{interval} = "1,65535" if (exists $json_obj->{profile} and $json_obj->{profile} =~ /(?:http|gslb|eproxy)/);
    $params->{vport}{required} = "true"    if (exists $json_obj->{profile} and $json_obj->{profile} ne 'datalink');
    $params->{vip}{values}     = $ip_list;

    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # VIP validation
    if ($json_obj->{profile} =~ /^DATALINK$/i) {
        # interface must be running
        if (!grep { $_ eq $json_obj->{vip} } &listallips()) {
            my $msg = "An available virtual IP must be set.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    else {
        # the ip must exist in some interface
        require Relianoid::Net::Interface;
        if (!&getIpAddressExists($json_obj->{vip})) {
            my $msg = "The vip IP must exist in some interface.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # VPORT validation
    if (!&getValidPort($json_obj->{vport}, $json_obj->{profile})) {
        my $msg = "The virtual port must be an acceptable value and must be available.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check ranges
    if ($json_obj->{vport}) {
        my @ranges = split(/,/, $json_obj->{vport});

        for my $range (@ranges) {
            next unless $range =~ /^(\d+):(\d+)$/;

            if ($1 > $2) {
                my $msg = "Range $range in virtual port is not a valid value.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    $json_obj->{interface} = &getInterfaceOfIp($json_obj->{vip});

    my $status = 0;
    if (exists $json_obj->{copy_from}) {
        $status = &runFarmCreateFrom($json_obj);
    }
    else {
        $status = &runFarmCreate($json_obj->{profile}, $json_obj->{vip}, $json_obj->{vport},
            $json_obj->{farmname}, $json_obj->{interface});
    }

    if ($status) {
        my $msg = "The $json_obj->{farmname} farm can't be created";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &log_info("Success, the farm $json_obj->{farmname} has been created successfully.", "FARMS");

    my $out_p = $json_obj;
    $out_p->{interface} = $json_obj->{interface};

    my $body = {
        description => $desc,
        params      => $out_p,
        message     => "The farm $json_obj->{farmname} has been created successfully."
    };

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'farm', 'start', $json_obj->{farmname} ],
        );
    }

    return &httpResponse({ code => 201, body => $body });
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Put.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::Core;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Put

=cut

my $eload = eval { require Relianoid::ELoad };

sub modify_farm_controller ($json_obj, $farmname) {
    my $desc = "Modify farm";

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);

    if ($type eq "http" || $type eq "https") {
        require Relianoid::HTTP::Controllers::API::Farm::Put::HTTP;
        &modify_http_farm($json_obj, $farmname);
    }

    elsif ($type eq "l4xnat") {
        require Relianoid::HTTP::Controllers::API::Farm::Put::L4xNAT;
        &modify_l4xnat_farm($json_obj, $farmname);
    }

    elsif ($type eq "datalink") {
        require Relianoid::EE::HTTP::Controllers::API::Farm::Put::Datalink;
        &modify_datalink_farm($json_obj, $farmname);
    }

    elsif ($type eq "gslb" && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::Put::GSLB',
            func   => 'modify_gslb_farm',
            args   => [ $json_obj, $farmname ],
        );
    }

    elsif ($type eq "eproxy" && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::Put::Eproxy',
            func   => 'modify_eproxy_farm',
            args   => [ $json_obj, $farmname ],
        );
    }

    return;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Put/HTTP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::Base;
use Relianoid::Farm::HTTP::Config;
use Relianoid::Farm::Action;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Put::HTTP

=cut

my $eload = eval { require Relianoid::ELoad };

# PUT /farms/<farmname> Modify a http|https Farm
sub modify_http_farm ($json_obj, $farmname) {
    my $desc = "Modify HTTP farm $farmname";

    require Relianoid::Net::Interface;
    my $ip_list = &getIpAddressList();

    my $params = &getAPIModel("farm_http-modify.json");
    $params->{vip}{values}               = $ip_list;
    $params->{ciphers}{listener}         = "https";
    $params->{cipherc}{listener}         = "https";
    $params->{certname}{listener}        = "https";
    $params->{disable_sslv2}{listener}   = "https";
    $params->{disable_sslv3}{listener}   = "https";
    $params->{disable_tlsv1}{listener}   = "https";
    $params->{disable_tlsv1_1}{listener} = "https";
    $params->{disable_tlsv1_2}{listener} = "https";

    if (!$eload) {
        $params->{ciphers}{values} = [ "all", "highsecurity", "customsecurity" ];
    }

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # Get current conf
    my $farm_st = &getHTTPFarmStruct($farmname);

    my $vip   = $json_obj->{vip}   // $farm_st->{vip};
    my $vport = $json_obj->{vport} // $farm_st->{vport};

    if (exists($json_obj->{vip}) or exists($json_obj->{vport})) {
        require Relianoid::Net::Validate;
        if ($farm_st->{status} ne 'down' and not &validatePort($vip, $vport, 'http', $farmname)) {
            my $msg =
              "The '$vip' ip and '$vport' port are being used for another farm. This farm should be stopped before modifying it";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    if (exists($json_obj->{vip})) {
        if ($farm_st->{status} ne 'down') {
            require Relianoid::Net::Interface;

            my $if_name = &getInterfaceByIp($json_obj->{vip});
            my $if_ref  = &getInterfaceConfig($if_name);

            if (&getInterfaceSystemStatus($if_ref) ne "up") {
                my $msg = "The '$json_obj->{vip}' ip is not UP. This farm should be stopped before modifying it";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # Flags
    my $reload_ipds = 0;

    if (   exists $json_obj->{vport}
        || exists $json_obj->{vip}
        || exists $json_obj->{newfarmname})
    {
        if ($eload) {
            $reload_ipds = 1;

            &eload(
                module => 'Relianoid::EE::IPDS::Base',
                func   => 'runIPDSStopByFarm',
                args   => [$farmname],
            );

            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'ipds', 'stop', $farmname ],
            );
        }
    }

    ######## Functions
    # Modify Farm's Name
    if (exists($json_obj->{newfarmname})) {
        unless ($farm_st->{status} eq 'down') {
            my $msg = 'Cannot change the farm name while the farm is running';
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        #Check if the new farm's name alredy exists
        if (&getFarmExists($json_obj->{newfarmname})) {
            my $msg = "The farm $json_obj->{newfarmname} already exists, try another name.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        # Change farm name
        if (&setNewFarmName($farmname, $json_obj->{newfarmname})) {
            my $msg = "Error modifying the farm name.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        $farmname = $json_obj->{newfarmname};
    }

    # Modify Backend Connection Timeout
    if (exists $json_obj->{contimeout}) {
        if (&setHTTPFarmConnTO($json_obj->{contimeout}, $farmname) == -1) {
            my $msg = "Some errors happened trying to modify the contimeout.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify Backend Respone Timeout
    if (exists($json_obj->{restimeout})) {
        if (&setFarmTimeout($json_obj->{restimeout}, $farmname) == -1) {
            my $msg = "Some errors happened trying to modify the restimeout.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify Frequency To Check Resurrected Backends
    if (exists($json_obj->{resurrectime})) {
        if (&setFarmBlacklistTime($json_obj->{resurrectime}, $farmname) == -1) {
            my $msg = "Some errors happened trying to modify the resurrectime.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify Client Request Timeout
    if (exists($json_obj->{reqtimeout})) {
        if (&setHTTPFarmClientTimeout($json_obj->{reqtimeout}, $farmname) == -1) {
            my $msg = "Some errors happened trying to modify the reqtimeout.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify Rewrite Location Headers
    if (exists($json_obj->{rewritelocation})) {
        my $rewritelocation = 0;
        my $path            = 0;
        if ($json_obj->{rewritelocation} eq "disabled") {
            $rewritelocation = 0;
        }
        elsif ($json_obj->{rewritelocation} eq "enabled") {
            $rewritelocation = 1;
        }
        elsif ($json_obj->{rewritelocation} eq "enabled-backends") {
            $rewritelocation = 2;
        }
        elsif ($json_obj->{rewritelocation} eq "enabled-path") {
            $rewritelocation = 1;
            $path            = 1;
        }
        elsif ($json_obj->{rewritelocation} eq "enabled-backends-path") {
            $rewritelocation = 2;
            $path            = 1;
        }

        if (my $error = &setHTTPFarmRewriteL($farmname, $rewritelocation, $path)) {
            my $msg = "Some errors happened trying to modify the rewritelocation.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Enable the log connection tracking
    if (exists($json_obj->{logs})) {
        require Relianoid::Farm::HTTP::Config;
        my $status = &setHTTPFarmLogs($farmname, $json_obj->{logs});

        if ($status) {
            my $msg = "Some errors happened trying to modify the log parameter.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Enable or disable ignore 100 continue header
    if (exists($json_obj->{ignore_100_continue})
        and ($json_obj->{ignore_100_continue} ne $farm_st->{ignore_100_continue}))    # this is a bugfix
    {
        my $action = ($json_obj->{ignore_100_continue} eq "true") ? 1 : 0;

        my $status = &setHTTPFarm100Continue($farmname, $action);

        if ($status == -1) {
            my $msg = "Some errors happened trying to modify the ignore_100_continue parameter.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify HTTP Verbs Accepted
    if (exists($json_obj->{httpverb})) {
        my $code = &getHTTPFarmVerbCode($json_obj->{httpverb});
        if (&setHTTPFarmHttpVerb($code, $farmname) == -1) {
            my $msg = "Some errors happened trying to modify the httpverb.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    #Modify Error 414
    if (exists($json_obj->{error414})) {
        if (&setHTTPFarmErr($farmname, $json_obj->{error414}, "414") == -1) {
            my $msg = "Some errors happened trying to modify the error414.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    #Modify Error 500
    if (exists($json_obj->{error500})) {
        if (&setHTTPFarmErr($farmname, $json_obj->{error500}, "500") == -1) {
            my $msg = "Some errors happened trying to modify the error500.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    #Modify Error 501
    if (exists($json_obj->{error501})) {
        if (&setHTTPFarmErr($farmname, $json_obj->{error501}, "501") == -1) {
            my $msg = "Some errors happened trying to modify the error501.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    #Modify Error 503
    if (exists($json_obj->{error503})) {
        if (&setHTTPFarmErr($farmname, $json_obj->{error503}, "503") == -1) {
            my $msg = "Some errors happened trying to modify the error503.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify Farm Listener
    if (exists($json_obj->{listener})) {
        eval { &setHTTPFarmListen($farmname, $json_obj->{listener}); 1 } or do {
            my $msg = "Some errors happened trying to modify the listener.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        };

        $farm_st->{listener} = $json_obj->{listener};    # update listener type
    }

    # Discard parameters of the HTTPS listener when it is not configured
    if ($farm_st->{listener} ne "https") {
        for my $key (keys %{$params}) {
            if (    exists $json_obj->{$key}
                and exists $params->{$key}{listener}
                and $params->{$key}{listener} eq 'https')
            {
                my $msg = "The farm listener has to be 'HTTPS' to configure the parameter '$key'.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # Modify HTTPS Params
    if ($farm_st->{listener} eq "https") {
        require Relianoid::Farm::HTTP::HTTPS;

        # Cipher groups
        # API parameter => library parameter
        my %c = (
            all            => "cipherglobal",
            customsecurity => "ciphercustom",
            highsecurity   => "cipherpci",
            ssloffloading  => "cipherssloffloading",
        );
        my $ciphers_lib;

        # Modify Ciphers
        if (exists($json_obj->{ciphers})) {
            $ciphers_lib = $c{ $json_obj->{ciphers} };

            my $ssloff = 1;
            $ssloff = &eload(
                module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext',
                func   => 'getFarmCipherSSLOffLoadingSupport',
            ) if ($eload);

            unless ($ssloff) {
                &log_warn("The CPU does not support SSL offloading.", "system");
            }

            if (&setFarmCipherList($farmname, $ciphers_lib, $json_obj->{cipherc}) == -1) {
                my $msg = "Error modifying ciphers.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            $farm_st->{ciphers} = $json_obj->{ciphers};    # update ciphers value
        }

        # Modify Customized Ciphers
        if (exists($json_obj->{cipherc})) {
            $ciphers_lib = $c{ $farm_st->{ciphers} };

            if ($farm_st->{ciphers} eq "customsecurity") {
                $json_obj->{cipherc} =~ s/\ //g;
                if (&setFarmCipherList($farmname, $ciphers_lib, $json_obj->{cipherc}) == -1) {
                    my $msg = "Some errors happened trying to modify the cipherc.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
            else {
                my $msg = "'ciphers' has to be 'customsecurity' to set the 'cipherc' parameter.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        # Add Certificate to SNI list
        if (exists($json_obj->{certname})) {
            my $status;
            my $configdir = &getGlobalConfiguration('configdir');

            if (!-f "$configdir/$json_obj->{certname}") {
                my $msg = "The certificate $json_obj->{certname} has to be uploaded to use it in a farm.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            if ($eload) {
                $status = &eload(
                    module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext',
                    func   => 'setFarmCertificateSNI',
                    args   => [ $json_obj->{certname}, $farmname ],
                );
            }
            else {
                $status = &setFarmCertificate($json_obj->{certname}, $farmname);
            }

            if ($status == -1) {
                my $msg = "Some errors happened trying to modify the certname.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        # Disable security protocol
        # API parameter => l7 proxy parameter
        my %ssl_proto_hash = (
            "disable_sslv2"   => "SSLv2",
            "disable_sslv3"   => "SSLv3",
            "disable_tlsv1"   => "TLSv1",
            "disable_tlsv1_1" => "TLSv1_1",
            "disable_tlsv1_2" => "TLSv1_2",
        );

        my %bool_to_int = (
            "false" => 0,
            "true"  => 1,
        );

        my $action;
        my $ssl_proto;

        for my $key_ssl (keys %ssl_proto_hash) {
            next if (!exists $json_obj->{$key_ssl});
            next if ($farm_st->{$key_ssl} && $json_obj->{$key_ssl} eq $farm_st->{$key_ssl});

            $action    = $bool_to_int{ $json_obj->{$key_ssl} };
            $ssl_proto = $ssl_proto_hash{$key_ssl}
              if exists $ssl_proto_hash{$key_ssl};

            if (&setHTTPFarmDisableSSL($farmname, $ssl_proto, $action) == -1) {
                my $msg = "Some errors happened trying to modify $key_ssl.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    if (exists($json_obj->{vip})) {
        # the ip must exist in some interface
        require Relianoid::Net::Interface;
        unless (&getIpAddressExists($json_obj->{vip})) {
            my $msg = "The vip IP must exist in some interface.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify vip and vport
    if (exists($json_obj->{vip}) or exists($json_obj->{vport})) {
        if (&setFarmVirtualConf($vip, $vport, $farmname)) {
            my $msg = "Could not set the virtual configuration.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    &log_info("Success, some parameters have been changed in farm $farmname.", "LSLB");

    # Return the received json object updated.
    require Relianoid::HTTP::Controllers::API::Farm::Output::HTTP;

    #~ my $farm_upd = &getFarmStruct( $farmname );
    #~ for my $key ( keys %{ $json_obj } )
    #~ {
    #~ $json_obj->{ $key } = $farm_upd->{ $key };
    #~ }

    my $out_obj = &getHTTPOutFarm($farmname);

    if ($reload_ipds and $eload) {
        &eload(
            module => 'Relianoid::EE::IPDS::Base',
            func   => 'runIPDSStartByFarm',
            args   => [$farmname],
        );

        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'ipds', 'start', $farmname ],
        );
    }

    my $body = {
        description => $desc,
        params      => $out_obj,
        message     => "Some parameters have been changed in farm $farmname."
    };

    if (exists $json_obj->{newfarmname}) {
        $body->{params}{newfarmname} = $json_obj->{newfarmname};
    }

    if ($farm_st->{status} ne 'down') {
        &setFarmRestart($farmname);
        $body->{status} = 'needed restart';
    }

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Put/L4xNAT.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::Base;
use Relianoid::Farm::L4xNAT::Config;
use Relianoid::Net::Interface;
use Relianoid::Farm::Config;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Put::L4xNAT

=cut

my $eload = eval { require Relianoid::ELoad };

# PUT /farms/<farmname> Modify a l4xnat Farm
sub modify_l4xnat_farm ($json_obj, $farmname) {
    my $desc = "Modify L4xNAT farm '$farmname'";

    # Flags
    my $status = &getFarmStatus($farmname);

    # Check that the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Removed
    if ($json_obj->{algorithm} && $json_obj->{algorithm} =~ /^(prio)$/) {
        my $msg = "'Prio' algorithm is not supported anymore.";
        return &httpErrorResponse({ code => 410, desc => $desc, msg => $msg });
    }

    require Relianoid::Net::Interface;
    my $ip_list = &getIpAddressList();

    # Modify the vport if protocol is set to 'all'
    if (   (exists $json_obj->{protocol} and $json_obj->{protocol} eq 'all')
        or (exists $json_obj->{vport} and $json_obj->{vport} eq '*'))
    {
        $json_obj->{vport}    = "*";      # fixme
        $json_obj->{protocol} = "all";    # fixme
    }
    if (exists $json_obj->{persistence}
        and $json_obj->{persistence} eq 'none')
    {
        $json_obj->{persistence} = '';
    }

    # Check allowed parameters
    my $params = &getAPIModel("farm_l4xnat-modify.json");
    $params->{vip}{values} = $ip_list;

    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    if ($json_obj->{protocol} && $json_obj->{protocol} =~ /^(?:amanda|irc|netbios-ns|sane)$/) {
        my $msg = "'$json_obj->{protocol}' protocol is not supported anymore.";
        return &httpErrorResponse({ code => 410, desc => $desc, msg => $msg });
    }

    # Get current vip & vport & proto
    my $vip   = $json_obj->{vip}      // &getFarmVip('vip',  $farmname);
    my $vport = $json_obj->{vport}    // &getFarmVip('vipp', $farmname);
    my $proto = $json_obj->{protocol} // &getL4FarmParam('proto', $farmname);

    # Extend parameter checks
    if (exists $json_obj->{protocol} and $json_obj->{protocol} ne 'all') {
        if ($vport eq '*') {
            my $msg = "Protocol can not be '$json_obj->{protocol}' with port '$vport'";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    if (exists $json_obj->{vport} and $json_obj->{vport} ne '*') {
        if ($proto eq 'all') {
            my $msg = "Port can not be '$json_obj->{vport}' with protocol '$proto'";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # check ranges
    if (exists $json_obj->{vport}) {
        my @ranges = split(/,/, $json_obj->{vport});
        for my $range (@ranges) {
            if ($range =~ /^(\d+):(\d+)$/) {
                if ($1 > $2) {
                    my $msg = "Range $range in virtual port is not a valid value.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
        }
    }

    if (   exists($json_obj->{vip})
        or exists($json_obj->{vport})
        or exists($json_obj->{protocol}))
    {
        require Relianoid::Net::Validate;
        require Relianoid::Farm::L4xNAT::Config;
        if ($status eq 'up' and not &validatePort($vip, $vport, $proto, $farmname)) {
            my $msg =
              "The '$vip' ip and '$vport' port are being used for another farm. This farm should be stopped before modifying it";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        if (exists($json_obj->{vip})) {
            require Relianoid::Farm::L4xNAT::Backend;

            my $backends = &getL4FarmServers($farmname);
            unless (!@{$backends}[0]
                || &ipversion(@{$backends}[0]->{ip}) eq &ipversion($vip))
            {
                my $msg = "Invalid VIP address, VIP and backends can't be from diferent IP version.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            # the vip must be UP
            if ($status ne 'down') {
                require Relianoid::Net::Interface;
                my $if_name = &getInterfaceByIp($json_obj->{vip});
                my $if_ref  = &getInterfaceConfig($if_name);
                if (&getInterfaceSystemStatus($if_ref) ne "up") {
                    my $msg = "The '$json_obj->{vip}' ip is not UP. This farm should be stopped before modifying it";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
        }

        if (exists($json_obj->{vport})) {
            # VPORT validation
            if (!&getValidPort($vport, "L4XNAT")) {
                my $msg = "The virtual port must be an acceptable value and must be available.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    my $reload_ipds = 0;
    if (   exists $json_obj->{vport}
        || exists $json_obj->{vip}
        || exists $json_obj->{newfarmname})
    {
        if ($eload) {
            $reload_ipds = 1;

            &eload(
                module => 'Relianoid::EE::IPDS::Base',
                func   => 'runIPDSStopByFarm',
                args   => [$farmname],
            );

            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'ipds', 'stop', $farmname ],
            );

            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'farm', 'stop', $farmname ],
            );
        }
    }

    ####### Functions

    # Modify Farm's Name
    if (exists($json_obj->{newfarmname})) {
        unless (&getL4FarmParam('status', $farmname) eq 'down') {
            my $msg = 'Cannot change the farm name while running';
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        if ($json_obj->{newfarmname} ne $farmname) {
            #Check if the new farm's name alredy exists
            if (&getFarmExists($json_obj->{newfarmname})) {
                my $msg = "The farm $json_obj->{newfarmname} already exists, try another name.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            #Change farm name
            require Relianoid::Farm::Action;
            my $fnchange = &setNewFarmName($farmname, $json_obj->{newfarmname});
            if ($fnchange == -1) {
                my $msg = "The name of the farm can't be modified, delete the farm and create a new one.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            $farmname = $json_obj->{newfarmname};
        }
    }

    # Modify Load Balance Algorithm
    if (exists($json_obj->{algorithm})) {
        my $error = &setFarmAlgorithm($json_obj->{algorithm}, $farmname);
        if ($error) {
            my $msg = "Some errors happened trying to modify the algorithm.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify Persistence Mode
    if (exists($json_obj->{persistence})) {
        my $persistence = $json_obj->{persistence};

        if (&getL4FarmParam('persist', $farmname) ne $persistence) {
            my $statusp = &setFarmSessionType($persistence, $farmname);
            if ($statusp) {
                my $msg = "Some errors happened trying to modify the persistence.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # Modify Protocol Type
    if (exists($json_obj->{protocol})) {
        my $error = &setL4FarmParam('proto', $json_obj->{protocol}, $farmname);
        if ($error) {
            my $msg = "Some errors happened trying to modify the protocol.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify NAT Type
    if (exists($json_obj->{nattype})) {
        if (&getL4FarmParam('mode', $farmname) ne $json_obj->{nattype}) {
            my $error = &setL4FarmParam('mode', $json_obj->{nattype}, $farmname);
            if ($error) {
                my $msg = "Some errors happened trying to modify the nattype.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # Modify IP Address Persistence Time To Limit
    if (exists($json_obj->{ttl})) {
        my $error = &setFarmMaxClientTime(0, $json_obj->{ttl}, $farmname);
        if ($error) {
            my $msg = "Some errors happened trying to modify the ttl.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
        $json_obj->{ttl} = $json_obj->{ttl} + 0;
    }

    # Modify vip and vport
    if (exists($json_obj->{vip}) or exists($json_obj->{vport})) {
        if (&setFarmVirtualConf($vip, $vport, $farmname)) {
            my $msg = "Could not set the virtual configuration.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Modify logs
    if (exists($json_obj->{logs})) {
        my $msg = &modifyLogsParam($farmname, $json_obj->{logs});
        if (defined $msg && length $msg) {
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # no error found, return successful response
    &log_info("Success, some parameters have been changed in farm $farmname.", "LSLB");

    if (&getL4FarmParam('status', $farmname) eq 'up' and $eload) {
        if ($reload_ipds) {
            &eload(
                module => 'Relianoid::EE::IPDS::Base',
                func   => 'runIPDSStartByFarm',
                args   => [$farmname],
            );

            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'farm', 'start', $farmname ],
            );

            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'ipds', 'start', $farmname ],
            );
        }
        else {
            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'farm', 'restart', $farmname ],
            );
        }
    }

    my $body = {
        description => $desc,
        params      => $json_obj,
        message     => "Some parameters have been changed in farm $farmname."
    };

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Farm/Service.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Farm::Core;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Farm::Service

=cut

my $eload = eval { require Relianoid::ELoad };

# POST
sub add_farm_service_controller ($json_obj, $farmname) {
    require Relianoid::Farm::Service;

    my $desc = "New service";

    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # check if the service exists
    if (grep { $json_obj->{id} eq $_ } &getFarmServices($farmname)) {
        my $msg = "Error, the service $json_obj->{id} already exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);

    # validate farm profile
    if ($type eq "gslb") {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::GSLB',
            func   => 'new_gslb_farm_service',
            args   => [ $json_obj, $farmname ]
        );
    }
    elsif ($type !~ /^https?$/) {
        my $msg = "The farm profile $type does not support services actions.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("farm_http_service-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # HTTP profile
    require Relianoid::HTTP::Controllers::API::Farm::Get::HTTP;
    require Relianoid::Farm::Base;
    require Relianoid::Farm::HTTP::Service;

    my $result = &setFarmHTTPNewService($farmname, $json_obj->{id});

    # check if a service with such name already exists
    if ($result == 1) {
        my $msg = "Service name " . $json_obj->{id} . " already exists.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the service name has invalid characters
    if ($result == 3) {
        my $msg = "Service name is not valid, only allowed numbers, letters and hyphens.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Return 0 on success
    if ($result) {
        my $msg = "Error creating the service $json_obj->{id}.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no error found, return successful response
    &log_info("Success, a new service has been created in farm $farmname with id $json_obj->{id}.", "FARMS");

    my $body = {
        description => $desc,
        params      => { id => $json_obj->{id} },
        message     => "A new service has been created in farm $farmname with id $json_obj->{id}."
    };

    if (&getFarmStatus($farmname) ne 'down') {
        if ($type eq "eproxy" && $eload) {
            $body->{status} = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Action',
                func   => 'runEproxyFarmReload',
                args   => [ { farm_name => $farmname } ],
            );
            require Relianoid::EE::Cluster;
            &runClusterRemoteManager('farm', 'reload', $farmname);
        }
        else {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }
    }

    return &httpResponse({ code => 201, body => $body });
}

# GET

#GET /farms/<name>/services/<service>
sub get_farm_service_controller ($farmname, $servicename) {
    require Relianoid::HTTP::Controllers::API::Farm::Get::HTTP;
    require Relianoid::Farm::Config;
    require Relianoid::Farm::HTTP::Service;

    my $desc = "Get services of a farm";

    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);

    my @services;
    if ($type =~ /http/i) {
        @services = &getHTTPFarmServices($farmname);
    }
    elsif ($type eq "eproxy" && $eload) {
        @services = @ { &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Service',
            func   => 'getEproxyFarmServices',
            args   => [ { farm_name => $farmname } ]
        ) };
    }
    else {
        my $msg = "This functionality only is available for HTTP or eproxy farms.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the service is available
    if (!grep { $servicename eq $_ } @services) {
        my $msg = "The required service does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $service;
    if ($type =~ /http/i) {
        $service = &getHTTPServiceStruct($farmname, $servicename);
    }
    elsif ($type eq "eproxy" && $eload) {
        $service = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Service',
            func   => 'getEproxyServiceStruct',
            args   => [ { farm_name => $farmname, service_name => $servicename } ]
        );
    }

    my $body    = {
        description => $desc,
        params      => $service,
    };

    return &httpResponse({ code => 200, body => $body });
}

# PUT

sub modify_farm_service_controller ($json_obj, $farmname, $service) {
    require Relianoid::Farm::Base;
    require Relianoid::Farm::Service;

    my $desc = "Modify service";
    my $output_params;
    my $bk_msg = "";

    # validate FARM NAME
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # validate FARM TYPE
    my $type = &getFarmType($farmname);

    unless ($type eq 'gslb' || $type eq 'http' || $type eq 'https' || $type eq 'eproxy') {
        my $msg = "The $type farm profile does not support services settings.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the farm profile gslb is supported
    if ($type eq "gslb") {
        unless (my $found_service = grep { $service eq $_ } &getFarmServices($farmname)) {
            my $msg = "Could not find the requested service.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::GSLB',
            func   => 'modify_gslb_service',
            args   => [ $json_obj, $farmname, $service ]
        );
    }
    elsif ($type eq "eproxy" && $eload) {
        my $args = $json_obj;
        $args->{ farm_name } = $farmname;
        &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Service',
            func   => 'setEproxyServiceStruct',
            args   => [ $args ]
        );
        $output_params = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Service',
            func   => 'getEproxyServiceStruct',
            args   => [ { farm_name => $farmname, service_name => $service } ]
        );
        delete $output_params->{ farm_filename };
    }
    else {
        unless (my $found_service = grep { $service eq $_ } &getFarmServices($farmname)) {
            my $msg = "Could not find the requested service.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        # From here everything is about HTTP farms
        require Relianoid::Farm::HTTP::Config;
        require Relianoid::Farm::HTTP::Service;

        my $params = &getAPIModel("farm_http_service-modify.json");

        # Check allowed parameters
        if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
        }

        # translate params
        if (exists $json_obj->{persistence} and $json_obj->{persistence} eq 'NONE') {
            $json_obj->{persistence} = "";
        }

        # modifying params
        if (exists $json_obj->{vhost}) {
            &setHTTPFarmVS($farmname, $service, "vs", $json_obj->{vhost});
        }

        if (exists $json_obj->{urlp}) {
            &setHTTPFarmVS($farmname, $service, "urlp", $json_obj->{urlp});
        }

        if (exists $json_obj->{redirect}) {
            my $redirect = $json_obj->{redirect};

            &setHTTPFarmVS($farmname, $service, "redirect", $redirect);

            # delete service's backends if redirect has been configured
            if ($redirect) {
                require Relianoid::Farm::HTTP::Backend;
                my $backends = scalar @{ &getHTTPFarmBackends($farmname, $service) };

                if ($backends) {
                    $bk_msg = "The backends of $service have been deleted.";

                    for (my $id = $backends - 1 ; $id >= 0 ; $id--) {
                        &runHTTPFarmServerDelete($id, $farmname, $service);
                    }
                }
            }
        }

        if (exists $json_obj->{redirecttype}) {
            my $redirecttype = $json_obj->{redirecttype};
            &setHTTPFarmVS($farmname, $service, "redirecttype", $redirecttype);
        }

        if (exists $json_obj->{leastresp}) {
            if ($json_obj->{leastresp} eq "true") {
                &setHTTPFarmVS($farmname, $service, "dynscale", $json_obj->{leastresp});
            }
            elsif ($json_obj->{leastresp} eq "false") {
                &setHTTPFarmVS($farmname, $service, "dynscale", "");
            }
        }

        if (exists $json_obj->{persistence}) {
            my $session = $json_obj->{persistence} || 'nothing';
            my $old_persistence;

            if ($eload) {
                require Relianoid::Farm::Config;
                $old_persistence = &getPersistence($farmname);
            }

            if (my $error = &setHTTPFarmVS($farmname, $service, "session", $session)) {
                my $msg = "It's not possible to change the persistence parameter.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            if ($eload) {
                my $new_persistence = &getPersistence($farmname);
                if (($new_persistence == 1) and ($old_persistence == 0)) {
                    &eload(
                        module => 'Relianoid::EE::Ssyncd',
                        func   => 'setSsyncdFarmDown',
                        args   => [$farmname],
                    );
                }
                elsif (($new_persistence == 0) and ($old_persistence == 1)) {
                    &eload(
                        module => 'Relianoid::EE::Ssyncd',
                        func   => 'setSsyncdFarmUp',
                        args   => [$farmname],
                    );
                }
            }
        }

        my $session = &getHTTPFarmVS($farmname, $service, "sesstype");

        # It is necessary evaluate first session, next ttl and later persistence
        if (exists $json_obj->{sessionid}) {
            if ($session =~ /^(URL|COOKIE|HEADER)$/) {
                &setHTTPFarmVS($farmname, $service, "sessionid", $json_obj->{sessionid});
            }
        }

        if (exists $json_obj->{ttl}) {
            if ($session =~ /^(IP|BASIC|URL|PARM|COOKIE|HEADER)$/) {
                my $error = &setHTTPFarmVS($farmname, $service, "ttl", "$json_obj->{ttl}");
                if ($error) {
                    my $msg = "Could not change the ttl parameter.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
        }

        # Cookie insertion
        if (scalar grep { /^cookie/ } keys %{$json_obj}) {
            if ($eload) {
                my $msg = &eload(
                    module   => 'Relianoid::EE::HTTP::Controllers::API::Farm::Service::Ext',
                    func     => 'modify_service_cookie_insertion',
                    args     => [ $farmname, $service, $json_obj ],
                    just_ret => 1,
                );

                if (defined $msg && length $msg) {
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
            else {
                my $msg = "Cookie insertion feature not available.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        if (exists $json_obj->{httpsb}) {
            if ($json_obj->{httpsb} ne &getHTTPFarmVS($farmname, $service, 'httpsbackend')) {
                if ($json_obj->{httpsb} eq "true") {
                    &setHTTPFarmVS($farmname, $service, "httpsbackend", $json_obj->{httpsb});
                }
                elsif ($json_obj->{httpsb} eq "false") {
                    &setHTTPFarmVS($farmname, $service, "httpsbackend", "");
                }
            }
        }

        # Redirect code
        if (exists $json_obj->{redirect_code}) {
            if ($eload) {
                my $err = &eload(
                    module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
                    func   => 'setHTTPServiceRedirectCode',
                    args   => [ $farmname, $service, $json_obj->{redirect_code} ],
                );

                if ($err) {
                    my $msg = "Error modifying redirect code.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
            else {
                my $msg = "Redirect code feature not available.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        if ($eload) {
            # sts options
            if (exists $json_obj->{sts_status}) {
                # status
                if ($type ne 'https') {
                    my $msg = "The farms have to be HTTPS to modify STS";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
                my $err = &eload(
                    module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
                    func   => 'setHTTPServiceSTSStatus',
                    args   => [ $farmname, $service, $json_obj->{sts_status} ],
                );

                if ($err) {
                    my $msg = "Error modifying STS status.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }

            if (exists $json_obj->{sts_timeout}) {
                if ($type ne 'https') {
                    my $msg = "The farms have to be HTTPS to modify STS";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }

                my $err = &eload(
                    module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
                    func   => 'setHTTPServiceSTSTimeout',
                    args   => [ $farmname, $service, $json_obj->{sts_timeout} ],
                );

                if ($err) {
                    my $msg = "Error modifying STS status.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
        }

        # no error found, return succesful response
        require Relianoid::HTTP::Controllers::API::Farm::Get::HTTP;
        $output_params = &get_http_service_struct($farmname, $service);
    }

    &log_info("Success, some parameters have been changed in service $service in farm $farmname.", "FARMS");

    my $body = {
        description => "Modify service $service in farm $farmname",
        params      => $output_params,
    };

    $body->{message} = $bk_msg ? $bk_msg : "The service $service has been updated successfully.";

    if (&getFarmStatus($farmname) ne 'down') {
        if ($type eq "eproxy" && $eload) {
            $body->{status} = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Action',
                func   => 'runEproxyFarmReload',
                args   => [ { farm_name => $farmname } ],
            );
            require Relianoid::EE::Cluster;
            &runClusterRemoteManager('farm', 'reload', $farmname);
        }
        else {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }
    }

    return &httpResponse({ code => 200, body => $body });
}

# DELETE

# DELETE /farms/<farmname>/services/<servicename> Delete a service of a Farm
sub delete_farm_service_controller ($farmname, $service) {
    my $desc = "Delete service";

    # Check if the farm exists
    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # check the farm type is supported
    my $type = &getFarmType($farmname);

    if ($type eq "gslb" && $eload) {
        &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::Farm::GSLB',
            func   => 'delete_gslb_service',
            args   => [ $farmname, $service ]
        );
    }
    elsif ($type !~ /^https?$/) {
        my $msg = "The farm profile $type does not support services actions.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::Farm::Base;
    require Relianoid::Farm::HTTP::Service;

    # Check that the provided service is configured in the farm
    my @services = &getHTTPFarmServices($farmname);
    my $found    = 0;

    for my $farmservice (@services) {
        if ($service eq $farmservice) {
            $found = 1;
            last;
        }
    }

    unless ($found) {
        my $msg = "Invalid service name, please insert a valid value.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $error = &delHTTPFarmService($farmname, $service);

    # check if the service is in use
    if ($error == -2) {
        my $msg = "The service is used by a zone.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if the service could not be deleted
    if ($error) {
        my $msg = "Service $service in farm $farmname hasn't been deleted.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # no errors found, returning successful response
    &log_info("Success, the service $service has been deleted in farm $farmname.", "FARMS");

    my $message = "The service $service has been deleted in farm $farmname.";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
    };

    if (&getFarmStatus($farmname) ne 'down') {
        if ($type eq "eproxy" && $eload) {
            $body->{status} = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Action',
                func   => 'runEproxyFarmReload',
                args   => [ { farm_name => $farmname } ],
            );
            require Relianoid::EE::Cluster;
            &runClusterRemoteManager('farm', 'reload', $farmname);
        }
        else {
            require Relianoid::Farm::Action;
            &setFarmRestart($farmname);
            $body->{status} = 'needed restart';
        }
    }

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Graph.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::RRD;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Graph

=cut

my $eload = eval { require Relianoid::ELoad };

#GET the list of graphs availables in the load balancer
sub list_graphs_controller () {
    require Relianoid::Stats;

    my @farms = ();
    for my $graph (&getGraphs2Show("Farm")) {
        $graph =~ s/-farm$//;
        push(@farms, $graph);
    }

    if ($eload) {
        @farms = @{
            &eload(
                module => 'Relianoid::EE::RBAC::Group::Core',
                func   => 'getRBACResourcesFromList',
                args   => [ 'farms', \@farms ],
            )
        };
    }

    my @net = ();
    for my $graph (&getGraphs2Show("Network")) {
        $graph =~ s/iface$//;
        push(@net, $graph);
    }

    my @sys = ("cpu", "load", "ram", "swap");

    # Get mount point of disks
    my @mount_points;
    my $partitions = &getDiskPartitionsInfo();

    for my $key (keys %{$partitions}) {
        # mount point : root/mount_point
        push(@mount_points, "root$partitions->{$key}{mount_point}");
    }

    @mount_points = sort @mount_points;
    push @sys, { disks => \@mount_points };

    my @vpns = ();
    if ($eload) {
        for my $graph (&getGraphs2Show("VPN")) {
            $graph =~ s/-vpn$//;
            push(@vpns, $graph);
        }
        @vpns = @{
            &eload(
                module => 'Relianoid::EE::RBAC::Group::Core',
                func   => 'getRBACResourcesFromList',
                args   => [ 'vpns', \@vpns ],
            )
        };
    }
    my $body = {
        description => "These are the possible graphs, you'll be able to access to the daily, weekly, monthly or yearly graph",
        system      => \@sys,
        interfaces  => \@net,
        farms       => \@farms
    };

    if ($eload) {
        $body->{ipds} = \@farms;
        $body->{vpns} = \@vpns;
    }

    return &httpResponse({ code => 200, body => $body });
}

# GET all system graphs
sub list_sys_graphs_controller () {
    require Relianoid::Stats;

    # System values
    my @sys = ("cpu", "load", "ram", "swap");

    # Get mount point of disks
    my @mount_points;
    my $partitions = &getDiskPartitionsInfo();

    for my $key (keys %{$partitions}) {
        # mount point : root/mount_point
        push(@mount_points, "root$partitions->{$key}{mount_point}");
    }

    @mount_points = sort @mount_points;
    push @sys, { disk => \@mount_points };

    my $body = {
        description =>
          "These are the possible system graphs, you'll be able to access to the daily, weekly, monthly or yearly graph",
        system => \@sys
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET system graphs
sub get_sys_graphs_controller ($key) {
    my $desc = "Get $key graphs";

    $key = 'mem'   if ($key eq 'ram');
    $key = 'memsw' if ($key eq 'swap');

    # Print Graph Function
    my @graphs = ();
    for my $freq ('daily', 'weekly', 'monthly', 'yearly') {
        my $g = &printGraph($key, $freq);
        push @graphs,
          {
            frequency  => $freq,
            graph      => $g->{img},
            start_time => $g->{start},
            last_time  => $g->{last},
          };
    }

    my $body = { description => $desc, graphs => \@graphs };

    return &httpResponse({ code => 200, body => $body });
}

# GET frequency system graphs
sub get_sys_graphs_freq_controller ($key, $frequency) {
    my $desc = "Get $frequency $key graphs";

    $key = 'mem'   if ($key eq 'ram');
    $key = 'memsw' if ($key eq 'swap');

    # Print Graph Function
    my $graph = &printGraph($key, $frequency);
    my $body  = {
        description => $desc,
        graphs      => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last}
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET a system graph using an interval
# /graphs/system/cpu/custom/start/11-25-2020-05:55/end/11-25-2020-22:25
sub get_sys_graphs_interval_controller ($key, $start, $end) {
    my $desc = "Get $key graphs";

    $key = 'mem'   if ($key eq 'ram');
    $key = 'memsw' if ($key eq 'swap');

    # Print Graph Function
    my $graph = &printGraph($key, $start, $end);
    my $body  = {
        description => $desc,
        graphs      => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last}
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET all interface graphs
sub list_iface_graphs_controller () {
    my @iface = ();
    for my $graph (&getGraphs2Show("Network")) {
        $graph =~ s/iface$//;
        push(@iface, $graph);
    }

    my $body = {
        description =>
          "These are the possible interface graphs, you'll be able to access to the daily, weekly, monthly or yearly graph",
        interfaces => \@iface
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET interface graphs
sub get_iface_graphs_controller ($iface) {
    require Relianoid::Net::Interface;

    my $desc              = "Get interface graphs";
    my @system_interfaces = &getInterfaceList();

    # validate NIC NAME
    if (!grep { $iface eq $_ } @system_interfaces) {
        my $msg = "Nic interface not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # graph for this farm doesn't exist
    elsif (!grep { /${iface}iface$/ } &getGraphs2Show("Network")) {
        my $msg = "There is no rrd files yet.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Print Graph Function
    my @graphs = ();
    for my $freq ('daily', 'weekly', 'monthly', 'yearly') {
        my $g = &printGraph("${iface}iface", $freq);
        push @graphs,
          {
            frequency  => $freq,
            graph      => $g->{img},
            start_time => $g->{start},
            last_time  => $g->{last},
          };
    }

    my $body = { description => $desc, graphs => \@graphs };

    return &httpResponse({ code => 200, body => $body });
}

# GET frequency interface graphs
sub get_iface_graphs_frec_controller ($iface, $frequency) {
    require Relianoid::Net::Interface;

    my $desc              = "Get interface graphs";
    my @system_interfaces = &getInterfaceList();

    # validate NIC NAME
    if (!grep { $iface eq $_ } @system_interfaces) {
        my $msg = "Nic interface not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }
    elsif (!grep { /${iface}iface$/ } &getGraphs2Show("Network")) {
        my $msg = "There is no rrd files yet.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Print Graph Function
    my $graph = &printGraph("${iface}iface", $frequency);
    my $body  = {
        description => $desc,
        graphs      => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last}
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET interface graph in an interval
sub get_iface_graphs_interval_controller ($iface, $start, $end) {
    require Relianoid::Net::Interface;

    my $desc              = "Get interface graphs";
    my @system_interfaces = &getInterfaceList();

    # validate NIC NAME
    if (!grep { $iface eq $_ } @system_interfaces) {
        my $msg = "Nic interface not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }
    elsif (!grep { /${iface}iface$/ } &getGraphs2Show("Network")) {
        my $msg = "There is no rrd files yet.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Print Graph Function
    my $graph = &printGraph("${iface}iface", $start, $end);
    my $body  = {
        description => $desc,
        graphs      => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last}
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET all farm graphs
sub list_farm_graphs_controller () {
    my @farms = ();
    for my $graph (&getGraphs2Show("Farm")) {
        $graph =~ s/-farm$//;
        push(@farms, $graph);
    }

    if ($eload) {
        my $ref_farm = &eload(
            module => 'Relianoid::EE::RBAC::Group::Core',
            func   => 'getRBACResourcesFromList',
            args   => [ 'farms', \@farms ]
        );
        @farms = @{$ref_farm};
    }

    my $body = {
        description =>
          "These are the possible farm graphs, you'll be able to access to the daily, weekly, monthly or yearly graph",
        farms => \@farms
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET farm graphs
sub get_farm_graphs_controller ($farmName) {
    require Relianoid::Farm::Core;

    my $desc = "Get farm graphs";

    # this farm doesn't exist
    if (!&getFarmExists($farmName)) {
        my $msg = "$farmName doesn't exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # graph for this farm doesn't exist
    elsif (!grep { "${farmName}-farm" eq $_ } &getGraphs2Show("Farm")) {
        my $msg = "There are no rrd files yet.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Print Graph Function
    my @graphs = ();
    for my $freq ('daily', 'weekly', 'monthly', 'yearly') {
        my $g = &printGraph("$farmName-farm", $freq);
        push @graphs,
          {
            frequency  => $freq,
            graph      => $g->{img},
            start_time => $g->{start},
            last_time  => $g->{last},
          };
    }

    my $body = { description => $desc, graphs => \@graphs };

    return &httpResponse({ code => 200, body => $body });
}

# GET frequency farm graphs
sub get_farm_graphs_frec_controller ($farmName, $frequency) {
    require Relianoid::Farm::Core;

    my $desc = "Get farm graphs";

    # this farm doesn't exist
    if (!&getFarmExists($farmName)) {
        my $msg = "$farmName doesn't exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # graph for this farm doesn't exist
    elsif (!grep { /$farmName-farm/ } &getGraphs2Show("Farm")) {
        my $msg = "There is no rrd files yet.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Print Graph Function
    my $graph = &printGraph("$farmName-farm", $frequency);
    my $body  = {
        description => $desc,
        graphs      => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last}
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET farm graph in an interval
sub get_farm_graphs_interval_controller ($farmName, $start, $end) {
    require Relianoid::Farm::Core;

    my $desc = "Get farm graphs";

    # this farm doesn't exist
    if (!&getFarmExists($farmName)) {
        my $msg = "$farmName doesn't exist.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # graph for this farm doesn't exist
    elsif (!grep { /$farmName-farm/ } &getGraphs2Show("Farm")) {
        my $msg = "There is no rrd files yet.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Print Graph Function
    my $graph = &printGraph("$farmName-farm", $start, $end);
    my $body  = {
        description => $desc,
        graphs      => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last}
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET mount points list
sub list_disks_graphs_controller () {
    require Relianoid::Stats;

    my @mount_points;
    my $partitions = &getDiskPartitionsInfo();

    for my $key (keys %{$partitions}) {
        # mount point : root/mount_point
        push(@mount_points, "root$partitions->{$key}{mount_point}");
    }

    @mount_points = sort @mount_points;

    my $body = {
        description => "List disk partitions",
        params      => \@mount_points,
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET disk graphs for all periods
sub get_disk_graphs_controller ($mount_point) {
    require Relianoid::Stats;

    $mount_point =~ s/^root[\/]?/\//;    # remove leading 'root/'
    my $desc  = "Disk partition usage graphs";
    my $parts = &getDiskPartitionsInfo();

    my ($part_key) =
      grep { $parts->{$_}{mount_point} eq $mount_point } keys %{$parts};

    unless ($part_key) {
        my $msg = "Mount point not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $dev_id = $parts->{$part_key}{rrd_id};
    my @graphs = ();
    for my $freq ('daily', 'weekly', 'monthly', 'yearly') {
        my $g = &printGraph($dev_id, $freq);
        push @graphs,
          {
            frequency  => $freq,
            graph      => $g->{img},
            start_time => $g->{start},
            last_time  => $g->{last},
          };
    }
    my $body = {
        description => $desc,
        graphs      => \@graphs,
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET disk graph for a single period
sub get_disk_graphs_freq_controller ($mount_point, $frequency) {
    require Relianoid::Stats;

    my $desc  = "Disk partition usage graph";
    my $parts = &getDiskPartitionsInfo();
    $mount_point =~ s/^root[\/]?/\//;

    my ($part_key) =
      grep { $parts->{$_}{mount_point} eq $mount_point } keys %{$parts};

    unless ($part_key) {
        my $msg = "Mount point not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $dev_id = $parts->{$part_key}{rrd_id};
    my $graph  = &printGraph($dev_id, $frequency);
    my $body   = {
        description => $desc,
        graph       => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last},
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET disk graph in an interval
sub get_disk_graphs_interval_controller ($mount_point, $start, $end) {
    require Relianoid::Stats;

    my $desc  = "Disk partition usage graph";
    my $parts = &getDiskPartitionsInfo();
    $mount_point =~ s/^root[\/]?/\//;

    my ($part_key) =
      grep { $parts->{$_}{mount_point} eq $mount_point } keys %{$parts};

    unless ($part_key) {
        my $msg = "Mount point not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $dev_id = $parts->{$part_key}{rrd_id};

    my $graph = &printGraph($dev_id, $start, $end);
    my $body  = {
        description => $desc,
        graph       => $graph->{img},
        start_time  => $graph->{start},
        last_time   => $graph->{last},
    };

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Ids.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Ids

=cut

require Relianoid::Ids;

# GET /ids
sub list_ids_controller () {
    my $desc = "Get a load balancer object IDs";

    my $tree = &getIdsTree();

    my $body = {
        description => $desc,
        params      => $tree,
    };

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Interface/Gateway.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Interface::Gateway

=cut

sub get_gateway_controller ($ip_ver) {
    require Relianoid::Net::Route;

    my $desc = "Default gateway";
    my $ip_v = ($ip_ver == 6) ? 6 : 4;

    my $addr    = ($ip_v == 6) ? &getIPv6DefaultGW()   : &getDefaultGW();
    my $if_name = ($ip_v == 6) ? &getIPv6IfDefaultGW() : &getIfDefaultGW();

    my $body = {
        description => $desc,
        params      => {
            address   => $addr,
            interface => $if_name,
        },
    };

    return &httpResponse({ code => 200, body => $body });
}

sub modify_gateway_controller ($json_obj, $ip_ver) {
    require Relianoid::Net::Route;

    my $desc       = "Modify default gateway";
    my $ip_v       = ($ip_ver == 6) ? 6                   : 4;
    my $default_gw = ($ip_v == 6)   ? &getIPv6DefaultGW() : &getDefaultGW();
    my $ip_format  = ($ip_v == 6)   ? 'IPv6_addr'         : 'IPv4_addr';

    my $params = &getAPIModel("gateway-modify.json");

    # if default gateway is not configured requires address and interface
    if (!$default_gw) {
        $params->{interface}{required} = "true";
        $params->{address}{required}   = "true";
    }
    $params->{address}{valid_format} = $ip_format;

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # validate INTERFACE
    if (exists $json_obj->{interface}) {
        require Relianoid::Net::Interface;

        my @system_interfaces = &getInterfaceList();

        unless (grep ({ $json_obj->{interface} eq $_ } @system_interfaces)) {
            my $msg = "Gateway interface not found.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }

    my $interface = $json_obj->{interface};
    my $address   = $json_obj->{address} // $default_gw;

    unless ($interface) {
        $interface = ($ip_ver == 6) ? &getIPv6IfDefaultGW() : &getIfDefaultGW();
    }

    require Relianoid::Net::Interface;
    my $if_ref = &getInterfaceConfig($interface);

    # check if network is correct
    require Relianoid::Net::Validate;

    unless (&validateGateway($if_ref->{addr}, $if_ref->{mask}, $address)) {
        my $msg = "The gateway is not valid for the network.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &log_debug("applyRoutes interface:$interface address:$address if_ref:$if_ref", "NETWORK")
      if &debug();

    my $error = &applyRoutes("global", $if_ref, $address);

    if ($error) {
        my $msg = "The default gateway hasn't been changed";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $msg  = "The default gateway has been changed successfully";
    my $body = {
        description => $desc,
        success     => "true",
        message     => $msg,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub delete_gateway_controller ($ip_ver) {
    require Relianoid::Net::Route;
    require Relianoid::Net::Interface;

    my $desc = "Remove default gateway";
    my $ip_v = ($ip_ver == 6) ? 6 : 4;

    my $defaultgwif = ($ip_v == 6) ? &getIPv6IfDefaultGW() : &getIfDefaultGW();
    my $if_ref      = &getInterfaceConfig($defaultgwif, $ip_v);
    $$if_ref{ip_v} //= $ip_v;

    my $error = &delRoutes("global", $if_ref);

    if ($error) {
        my $msg = "The default gateway hasn't been deleted";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $addr    = ($ip_v == 6) ? &getIPv6DefaultGW()   : &getDefaultGW();
    my $if_name = ($ip_v == 6) ? &getIPv6IfDefaultGW() : &getIfDefaultGW();

    my $msg  = "The default gateway has been deleted successfully";
    my $body = {
        description => $desc,
        message     => $msg,
        params      => {
            address   => $addr,
            interface => $if_name,
        },
    };

    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Interface/Generic.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Interface::Generic

=cut

# GET /interfaces Get params of the interfaces
sub list_interfaces_controller () {
    require Relianoid::Net::Interface;

    my $desc = "List interfaces";
    my $if_list_ref;

    $if_list_ref = &get_interface_list_struct();

    my $body = {
        description => $desc,
        interfaces  => $if_list_ref,
    };

    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Interface/NIC.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Interface::NIC

=cut

sub delete_nic_controller ($nic) {
    require Relianoid::Net::Core;
    require Relianoid::Net::Route;
    require Relianoid::Net::Interface;

    my $desc   = "Delete nic interface";
    my $ip_v   = 4;
    my $if_ref = &getInterfaceConfig($nic, $ip_v);

    if (!$if_ref) {
        my $msg = "There is no configuration for the network interface.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($eload) {
        if ($if_ref->{addr}) {
            my $msg = &eload(
                module => 'Relianoid::EE::Net::Ext',
                func   => 'isManagementIP',
                args   => [ $if_ref->{addr} ],
            );
            if ($msg) {
                $msg = "The interface cannot be modified. $msg";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        my $zcl_conf = &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'getClusterConfig',
        );

        if (defined $zcl_conf->{_}{interface}
            and $zcl_conf->{_}{interface} eq $if_ref->{name})
        {
            my $msg = "The cluster interface $if_ref->{name} cannot be modified.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        if (defined $if_ref->{is_slave} and $if_ref->{is_slave} eq "true") {
            my $msg = "The slave interface $if_ref->{name} cannot be modified.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        if (defined $zcl_conf->{_}{track_interface}) {
            my @track_interface =
              split(/\s/, $zcl_conf->{_}{track_interface});
            if (grep { $_ eq $if_ref->{name} } @track_interface) {
                my $msg = "The interface $if_ref->{name} cannot be modified because it is been tracked by the cluster.
						If you still want to modify it, remove it from the cluster track interface list.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # not delete the interface if it has some vlan configured
    my @child = &getInterfaceChild($nic);
    if (@child) {
        my $child_string = join(', ', @child);
        my $msg          = "It is not possible to delete $nic because there are virtual interfaces using it: $child_string.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if some farm is using this ip
    if ($if_ref->{addr}) {
        require Relianoid::Farm::Base;
        my @farms = &getFarmListByVip($if_ref->{addr});
        if (@farms) {
            my $str = join(', ', @farms);
            my $msg = "This interface is being used as vip in the farm(s): $str.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    if ($eload && $if_ref->{addr}) {
        # check if some VPN is using this ip
        my $vpns = &eload(
            module => 'Relianoid::EE::VPN::Util',
            func   => 'getVpnByIp',
            args   => [ $if_ref->{addr} ],
        );

        if (@{$vpns}) {
            my $str = join(', ', @{$vpns});
            my $msg = "The interface is being used as Local Gateway in VPN(s): $str";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        $vpns = &eload(
            module => 'Relianoid::EE::VPN::Util',
            func   => 'getVpnByNet',
            args   => [ $if_ref->{net} ],
        );

        if (@{$vpns}) {
            my $str = join(', ', @{$vpns});
            my $msg = "The interface is being used as Local Network in VPN(s): $str";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    eval {
        die if &delRoutes("local", $if_ref);
        die if &delIf($if_ref);
    };

    if ($@) {
        &log_error("Module failed: $@", 'net');
        my $msg = "The configuration for the network interface $nic can't be deleted.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $message = "The configuration for the network interface $nic has been deleted.";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /interfaces Get params of the interfaces
sub list_nic_controller () {
    require Relianoid::Net::Interface;

    my $desc         = "List NIC interfaces";
    my $nic_list_ref = &get_nic_list_struct();

    my $body = {
        description => $desc,
        interfaces  => $nic_list_ref,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub get_nic_controller ($nic) {
    require Relianoid::Net::Interface;

    my $desc      = "Show NIC interface";
    my $interface = &get_nic_struct($nic);

    unless ($interface) {
        my $msg = "Nic interface not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $body = {
        description => $desc,
        interface   => $interface,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub actions_nic_controller ($json_obj, $nic) {
    require Relianoid::Net::Interface;

    my $desc = "Action on nic interface";
    my $ip_v = 4;

    # validate NIC
    unless (grep { $nic eq $_->{name} } &getInterfaceTypeList('nic')) {
        my $msg = "Nic interface not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Check allowed parameters
    my $params = &getAPIModel("nic-action.json");
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    if ($eload) {
        my $zcl_conf = &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'getClusterConfig',
        );

        if (defined $zcl_conf->{_}{track_interface}) {
            my @track_interface = split(/\s/, $zcl_conf->{_}{track_interface});

            if (grep { $_ eq $nic } @track_interface) {
                my $msg = "The interface $nic cannot be modified because it is been tracked by the cluster. "
                  . "If you still want to modify it, remove it from the cluster track interface list.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    my $if_ref = &getInterfaceConfig($nic, $ip_v);

    # validate action parameter
    if ($json_obj->{action} eq "up") {
        require Relianoid::Net::Core;
        require Relianoid::Net::Route;

        # Delete routes in case that it is not a vini
        if ($if_ref->{addr}) {
            &delRoutes("local", $if_ref);
            &addIp($if_ref);
        }

        my $state = &upIf($if_ref, 'writeconf');

        if (!$state) {
            require Relianoid::Net::Util;
            &applyRoutes("local", $if_ref) if $if_ref->{addr};

            # put all dependant interfaces up
            &setIfacesUp($nic, "vlan");
            &setIfacesUp($nic, "vini") if $if_ref;
        }
        else {
            my $msg = "The interface $nic could not be set UP";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    elsif ($json_obj->{action} eq "down") {
        if ($eload && $if_ref->{addr}) {
            my $msg = &eload(
                module => 'Relianoid::EE::Net::Ext',
                func   => 'isManagementIP',
                args   => [ $if_ref->{addr} ],
            );
            if ($msg) {
                $msg = "The interface cannot be stopped. $msg";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        require Relianoid::Net::Core;
        my $state = &downIf($if_ref, 'writeconf');

        if ($state) {
            my $msg = "The interface $nic could not be set DOWN";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my $msg  = "The $nic NIC is $json_obj->{action}";
    my $body = {
        description => $desc,
        params      => { action => $json_obj->{action} },
        message     => $msg
    };

    return &httpResponse({ code => 200, body => $body });
}

sub modify_nic_controller ($json_obj, $nic) {
    require Relianoid::Net::Interface;
    require Relianoid::Net::Core;
    require Relianoid::Net::Route;
    require Relianoid::Net::Validate;

    my $desc = "Configure NIC interface";

    # validate NIC NAME
    my $type = &getInterfaceType($nic);

    unless ($type eq 'nic') {
        my $msg = "NIC interface not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }
    my $params = &getAPIModel("nic-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # Delete old interface configuration
    my $if_ref = &getInterfaceConfig($nic) // &getSystemInterface($nic);

    # Ignore the dhcp parameter if it is equal to the configured one
    delete $json_obj->{dhcp}
      if (exists $json_obj->{dhcp} && $json_obj->{dhcp} eq $if_ref->{dhcp});

    my @child = &getInterfaceChild($nic);

    if (exists $json_obj->{dhcp}) {
        # only allow dhcp when no other parameter was sent
        if ($json_obj->{dhcp} eq 'true') {
            if (   exists $json_obj->{ip}
                or exists $json_obj->{netmask}
                or exists $json_obj->{gateway})
            {
                my $msg = "It is not possible set 'ip', 'netmask' or 'gateway' while 'dhcp' is going to be set up.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
        elsif (!exists $json_obj->{ip}) {
            if (@child) {
                my $msg =
                  "This interface has appending some virtual interfaces, please, set up a new 'ip' in the current networking range.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # check if network is correct

    my $new_if;
    if ($if_ref) {
        $new_if = {
            addr    => $json_obj->{ip}      // $if_ref->{addr},
            mask    => $json_obj->{netmask} // $if_ref->{mask},
            gateway => $json_obj->{gateway} // $if_ref->{gateway},
        };
    }
    else {
        $new_if = {
            addr    => $json_obj->{ip},
            mask    => $json_obj->{netmask},
            gateway => $json_obj->{gateway} // undef,
        };
    }

    # Make sure the address, mask and gateway belong to the same stack
    if ($new_if->{addr}) {
        my $ip_v = &ipversion($new_if->{addr});
        my $gw_v = &ipversion($new_if->{gateway});

        if (!&validateNetmask($new_if->{mask}, $ip_v)) {
            my $msg = "The netmask is not valid";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        if ($new_if->{gateway} && $ip_v ne $gw_v) {
            my $msg = "Invalid IP stack version match.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    if (exists $json_obj->{ip} or exists $json_obj->{netmask}) {
        # check ip and netmask are configured
        unless ($new_if->{addr} ne "" and $new_if->{mask} ne "") {
            my $msg =
              "The networking configuration is not valid. It needs an IP ('$new_if->{addr}') and a netmask ('$new_if->{mask}')";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        # Do not modify gateway or netmask if exists a virtual interface using this interface
        my @wrong_conf;
        for my $child_name (@child) {
            my $child_if = &getInterfaceConfig($child_name);
            unless (&validateGateway($child_if->{addr}, $new_if->{mask}, $new_if->{addr})) {
                push @wrong_conf, $child_name;
            }
        }

        if (@wrong_conf) {
            my $child_string = join(', ', @wrong_conf);
            my $msg          = "The virtual interface(s): '$child_string' will not be compatible with the new configuration.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # check the gateway is in network
    if ($new_if->{gateway}) {
        unless (&validateGateway($new_if->{addr}, $new_if->{mask}, $new_if->{gateway})) {
            my $msg = "The gateway is not valid for the network.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # check if network exists in other interface
    if ($json_obj->{ip} or $json_obj->{netmask}) {
        my $if_used =
          &checkNetworkExists($new_if->{addr}, $new_if->{mask}, $nic);
        if ($if_used) {
            my $msg = "The network already exists in the interface $if_used.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Check new IP address is not in use
    my $different_ip = ((not $if_ref->{addr}) or ($new_if->{addr} ne $if_ref->{addr}));
    if ($json_obj->{ip} and $different_ip) {
        require Relianoid::Net::Util;
        my @activeips = &listallips();
        for my $ip (@activeips) {
            if ($ip eq $json_obj->{ip}) {
                my $msg = "IP address $json_obj->{ip} already in use.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    my @farms;
    my $vpns_localgw  = [];
    my $vpns_localnet = [];
    my $warning_msg;

    if (   exists $json_obj->{ip}
        or (exists $json_obj->{dhcp})
        or (exists $json_obj->{netmask}))
    {
        if (exists $json_obj->{ip}
            or (exists $json_obj->{dhcp}))
        {
            if ($eload) {
                if ($if_ref->{addr}) {
                    my $msg = &eload(
                        module => 'Relianoid::EE::Net::Ext',
                        func   => 'isManagementIP',
                        args   => [ $if_ref->{addr} ],
                    );
                    if ($msg) {
                        $msg = "The interface cannot be modified. $msg";
                        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                    }
                }

                my $zcl_conf = &eload(
                    module => 'Relianoid::EE::Cluster',
                    func   => 'getClusterConfig',
                );

                if (defined $zcl_conf->{_}{interface}
                    and $zcl_conf->{_}{interface} eq $if_ref->{name})
                {
                    my $msg = "The cluster interface $if_ref->{name} cannot be modified.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }

                if (defined $if_ref->{is_slave}
                    and $if_ref->{is_slave} eq "true")
                {
                    my $msg = "The slave interface $if_ref->{name} cannot be modified.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }

            # check if some farm is using this ip
            if ($if_ref->{addr}) {
                require Relianoid::Farm::Base;
                @farms = &getFarmListByVip($if_ref->{addr});
            }

            $vpns_localgw = &eload(
                module => 'Relianoid::EE::VPN::Util',
                func   => 'getVpnByIp',
                args   => [ $if_ref->{addr} ],
            ) if $eload;
        }

        # check if its a new network and a vpn using old network
        if (exists $json_obj->{ip} or exists $json_obj->{netmask}) {
            # check if network is changed
            my $mask = $json_obj->{netmask} // $if_ref->{mask};
            if (not &validateGateway($if_ref->{addr}, $if_ref->{mask}, $json_obj->{ip})
                or $if_ref->{mask} ne $mask)
            {
                my $net = NetAddr::IP->new($if_ref->{addr}, $if_ref->{mask})->cidr();
                $vpns_localnet = &eload(
                    module => 'Relianoid::EE::VPN::Util',
                    func   => 'getVpnByNet',
                    args   => [$net],
                ) if $eload;
            }
        }

        if (@farms or @{$vpns_localgw} or @{$vpns_localnet}) {
            if (    not exists $json_obj->{ip}
                and exists $json_obj->{dhcp}
                and $json_obj->{dhcp} eq 'false')
            {
                my $str_objects;
                my $str_function;
                if (@farms) {
                    $str_objects  = " and farms";
                    $str_function = " and farm VIP";
                }
                if (@{$vpns_localgw} or @{$vpns_localnet}) {
                    $str_objects .= " and vpns";
                }
                if (@{$vpns_localgw}) {
                    $str_function .= " and Local Gateway";
                }
                if (@{$vpns_localnet}) {
                    $str_function .= " and Local Network";
                }
                $str_objects  = substr($str_objects,  5);
                $str_function = substr($str_function, 5);

                my $msg =
                  "This interface is been used by some $str_objects, please, set up a new 'ip' in order to be used as $str_function.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            if (!$json_obj->{force} || $json_obj->{force} ne 'true') {
                my $str_objects;
                my $str_function;
                if (@farms) {
                    $str_objects  = " and farms";
                    $str_function = " and as farm VIP in the farm(s): " . join(', ', @farms);
                }
                if (@{$vpns_localgw} or @{$vpns_localnet}) {
                    $str_objects .= " and vpns";
                }
                if (@{$vpns_localgw}) {
                    $str_function .= " and as Local Gateway in the VPN(s): " . join(', ', @{$vpns_localgw});
                }
                if (@{$vpns_localnet}) {
                    $str_function .= " and as Local Network in the VPN(s): " . join(', ', @{$vpns_localnet});
                }
                $str_objects  = substr($str_objects,  5);
                $str_function = substr($str_function, 5);

                my $msg =
                  "The IP is being used $str_function. If you are sure, repeat with parameter 'force'. All $str_objects using this interface will be restarted.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # END CHECKS

    if ($if_ref->{addr}) {
        # remove custom routes
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Net::Routing',
                func   => 'updateRoutingVirtualIfaces',
                args   => [ $if_ref->{parent}, $json_obj->{ip} // $if_ref->{addr} ],
            );
        }

        # Delete old IP and Netmask from system to replace it
        &delIp($if_ref->{name}, $if_ref->{addr}, $if_ref->{mask});

        # Remove routes if the interface has its own route table: nic and vlan
        &delRoutes("local", $if_ref);

        $if_ref = undef;
    }

    # Setup new interface configuration structure
    $if_ref            = &getInterfaceConfig($nic) // &getSystemInterface($nic);
    $if_ref->{addr}    = $json_obj->{ip}      if exists $json_obj->{ip};
    $if_ref->{mask}    = $json_obj->{netmask} if exists $json_obj->{netmask};
    $if_ref->{gateway} = $json_obj->{gateway} if exists $json_obj->{gateway};
    $if_ref->{ip_v}    = &ipversion($if_ref->{addr});
    $if_ref->{net}     = &getAddressNetwork($if_ref->{addr}, $if_ref->{mask}, $if_ref->{ip_v});
    $if_ref->{dhcp}    = $json_obj->{dhcp} if exists $json_obj->{dhcp};

    # set DHCP
    my $set_flag        = 1;
    my $nic_config_file = "";
    if (exists $json_obj->{dhcp}) {
        if ($json_obj->{dhcp} eq "true") {
            require Relianoid::Lock;
            $nic_config_file = &getGlobalConfiguration('configdir') . "/if_$if_ref->{name}_conf";
            &lockResource($nic_config_file, "l");
        }

        my $func = ($json_obj->{dhcp} eq 'true') ? "enableDHCP" : "disableDHCP";
        &eload(
            module => 'Relianoid::EE::Net::DHCP',
            func   => $func,
            args   => [$if_ref],
        );

        if (   $json_obj->{dhcp} eq 'false' and not exists $json_obj->{ip}
            or $json_obj->{dhcp} eq 'true')
        {
            $set_flag = 0;
        }
    }
    if (!&setInterfaceConfig($if_ref)) {
        if ($json_obj->{dhcp} eq "true") {
            require Relianoid::Lock;
            &lockResource($nic_config_file, "ud");
        }
        my $msg = "Errors found trying to modify interface $nic";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Free the resource
    if ($json_obj->{dhcp} and $json_obj->{dhcp} eq "true") {
        require Relianoid::Lock;
        &lockResource($nic_config_file, "ud");
    }

    # set up
    if ($if_ref->{addr} and $if_ref->{mask} and $set_flag) {
        eval {
            # Add new IP, netmask and gateway
            # sometimes there are expected errors pending to be controlled
            &addIp($if_ref);

            # Writing new parameters in configuration file
            &writeRoutes($if_ref->{name});

            # Put the interface up
            my $previous_status = $if_ref->{status};

            if ($previous_status eq "up") {
                if (&upIf($if_ref, 'writeconf') == 0) {
                    $if_ref->{status} = "up";
                    &applyRoutes("local", $if_ref);
                    if ($if_ref->{ip_v} eq "4") {
                        my $if_gw = &getGlobalConfiguration('defaultgwif');
                        if ($if_ref->{name} eq $if_gw) {
                            my $defaultgw = &getGlobalConfiguration('defaultgw');
                            &applyRoutes("global", $if_ref, $defaultgw);
                        }
                    }
                    elsif ($if_ref->{ip_v} eq "6") {
                        my $if_gw = &getGlobalConfiguration('defaultgwif6');
                        if ($if_ref->{name} eq $if_gw) {
                            my $defaultgw = &getGlobalConfiguration('defaultgw6');
                            &applyRoutes("global", $if_ref, $defaultgw);
                        }
                    }
                }
                else {
                    $if_ref->{status} = $previous_status;
                }
            }

            # if the GW is changed, change it in all appending virtual interfaces
            if (exists $json_obj->{gateway}) {
                for my $appending (&getInterfaceChild($nic)) {
                    my $app_config = &getInterfaceConfig($appending);
                    $app_config->{gateway} = $json_obj->{gateway};
                    &setInterfaceConfig($app_config);
                }
            }

            # modify netmask on all dependent interfaces
            if (exists $json_obj->{netmask}) {
                for my $appending (&getInterfaceChild($nic)) {
                    my $app_config = &getInterfaceConfig($appending);
                    &delRoutes("local", $app_config);
                    &downIf($app_config);
                    $app_config->{mask} = $json_obj->{netmask};
                    &setInterfaceConfig($app_config);
                }
            }

            # put all dependent interfaces up
            require Relianoid::Net::Util;
            &setIfacesUp($nic, "vini");

            # change farm vip,
            if (@farms) {
                require Relianoid::Farm::Config;
                &setAllFarmByVip($json_obj->{ip}, \@farms);
                &reloadFarmsSourceAddress();
            }
            if (@{$vpns_localgw}) {
                my $error = &eload(
                    module => 'Relianoid::EE::VPN::Config',
                    func   => 'setAllVPNLocalGateway',
                    args   => [ $if_ref->{addr}, $vpns_localgw ],
                );
                $warning_msg .= $error->{desc} if ($error->{code});
            }
            if (@{$vpns_localnet}) {
                my $net =
                  NetAddr::IP->new($if_ref->{net}, $if_ref->{mask})->cidr();
                my $error = &eload(
                    module => 'Relianoid::EE::VPN::Config',
                    func   => 'setAllVPNLocalNetwork',
                    args   => [ $net, $vpns_localnet ],
                );
                $warning_msg .= $error->{desc} if ($error->{code});
            }
        };

        if ($@) {
            &log_error("Module failed: $@", "net");
            my $msg = "Errors found trying to modify interface $nic";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my $iface_out = &get_nic_struct($nic);
    my $body      = {
        description => $desc,
        params      => $iface_out,
        message     => "The $nic NIC has been updated successfully."
    };
    $body->{warning} = $warning_msg if ($warning_msg);

    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Interface/VLAN.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Interface::VLAN

=cut

my $eload = eval { require Relianoid::ELoad };

#  POST /interfaces/vlan Create a new vlan network interface
sub add_vlan_controller ($json_obj) {
    require Relianoid::Net::Util;
    require Relianoid::Net::Validate;
    require Relianoid::Net::Interface;

    my $desc = "Add a vlan interface";

    # validate VLAN NAME
    my $nic_re      = &getValidFormat('nic_interface');
    my $vlan_tag_re = &getValidFormat('vlan_tag');

    my $params = &getAPIModel("vlan-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my $dhcp_flag = (exists $json_obj->{dhcp} and $json_obj->{dhcp} ne "false");
    my $ip_mand   = (exists $json_obj->{ip}   and exists $json_obj->{netmask});
    my $ip_opt    = (exists $json_obj->{ip} or exists $json_obj->{netmask} or exists $json_obj->{gateway});

    unless (($dhcp_flag and not $ip_opt) or (not $dhcp_flag and $ip_mand)) {
        my $msg =
          "It is mandatory set an 'ip' and its 'netmask' or enabling the 'dhcp'. It is not allow to send 'ip', 'netmask' or 'gateway' when 'dhcp' is true.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Check if interface already exists
    my $if_ref = &getInterfaceConfig($json_obj->{name});
    if ($if_ref) {
        my $msg = "VLAN network interface $json_obj->{name} already exists.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # vlan_name = pather_name + . + vlan_tag
    # size < 16: size = pather_name.vlan_tag:virtual_name
    if (length $json_obj->{name} > 13) {
        my $msg = "VLAN interface name has a maximum length of 13 characters";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($json_obj->{name} !~ /^($nic_re)\.($vlan_tag_re)$/) {
        my $msg = "Interface name is not valid";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    $json_obj->{parent} = $1;
    $json_obj->{tag}    = $2;

    # validate PARENT
    my $if_parent = &getInterfaceConfig($json_obj->{parent});
    unless (defined $if_parent) {
        my $msg = "The parent interface $json_obj->{parent} doesn't exist";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check that nic interface is no slave of a bonding
    my $is_slave;

    for my $if_ref (&getInterfaceTypeList('nic')) {
        if ($if_ref->{name} eq $json_obj->{parent}) {
            $is_slave = $if_ref->{is_slave};
            last;
        }
    }

    if ($is_slave && $is_slave eq 'true') {
        my $msg = "It is not possible create a VLAN interface from a NIC slave.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # validate VLAN TAG
    unless ($json_obj->{tag} >= 1 && $json_obj->{tag} <= 4094) {
        my $msg = "The VLAN tag must be in the range 1-4094, both included";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    ## Validates all creation parameters, now check the setting parameters

    # setup parameters of vlan
    my $socket = IO::Socket::INET->new(Proto => 'udp');

    $if_ref = {
        name   => $json_obj->{name},
        dev    => $json_obj->{parent},
        status => $if_parent->{status},
        vlan   => $json_obj->{tag},
        dhcp   => $json_obj->{dhcp} // 'false',
        mac    => $socket->if_hwaddr($json_obj->{parent}),
        type   => 'vlan'
    };
    $if_ref->{mac} = lc $json_obj->{mac}
      if ($eload && exists $json_obj->{mac});

    if (exists $json_obj->{ip}) {
        $json_obj->{ip_v} = ipversion($json_obj->{ip});

        if (!&validateNetmask($json_obj->{netmask}, $json_obj->{ip_v})) {
            my $msg = "The netmask is not valid";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        # check if network exists in other interface
        if ($json_obj->{ip} or $json_obj->{netmask}) {
            my $if_used =
              &checkNetworkExists($json_obj->{ip}, $json_obj->{netmask});
            if ($if_used) {
                my $msg = "The network already exists in the interface $if_used.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        $if_ref->{addr}    = $json_obj->{ip};
        $if_ref->{mask}    = $json_obj->{netmask};
        $if_ref->{gateway} = $json_obj->{gateway} // '';
        $if_ref->{ip_v}    = &ipversion($json_obj->{ip});
        $if_ref->{net} =
          &getAddressNetwork($if_ref->{addr}, $if_ref->{mask}, $if_ref->{ip_v});

        # Make sure the address, mask and gateway belong to the same stack
        if ($if_ref->{addr}) {
            my $ip_v = &ipversion($if_ref->{addr});
            my $gw_v = &ipversion($if_ref->{gateway});

            my $mask_v =
                ($ip_v == 4 && &getValidFormat('IPv4_mask', $if_ref->{mask})) ? 4
              : ($ip_v == 6 && &getValidFormat('IPv6_mask', $if_ref->{mask})) ? 6
              :                                                                 '';

            if ($ip_v ne $mask_v
                || ($if_ref->{gateway} && $ip_v ne $gw_v))
            {
                my $msg = "Invalid IP stack version match.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        if ($if_ref->{gateway}) {
            unless (&validateGateway($if_ref->{addr}, $if_ref->{mask}, $if_ref->{gateway})) {
                my $msg = "Gateway does not belong to the interface subnet.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # creating
    if (&createVlan($if_ref)) {
        my $msg = "The $json_obj->{name} vlan network interface can't be created";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # configuring
    if ($dhcp_flag) {
        my $func = ($json_obj->{dhcp} eq 'true') ? "enableDHCP" : "disableDHCP";
        my $err  = &eload(
            module => 'Relianoid::EE::Net::DHCP',
            func   => $func,
            args   => [$if_ref],
        );

        if ($err) {
            my $msg = "The $json_obj->{name} vlan network interface can't be configured";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    else {
        if (&setVlan($if_ref, $json_obj)) {
            my $msg = "The $json_obj->{name} vlan network interface can't be configured";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my $body = {
        description => $desc,
        params      => &get_vlan_struct($json_obj->{name}),
        message     => "The $json_obj->{name} VLAN has been created successfully."
    };

    return &httpResponse({ code => 201, body => $body });
}

sub delete_vlan_controller ($vlan) {
    my $desc = "Delete VLAN interface";
    my $ip_v = 4;

    require Relianoid::Net::Interface;

    my $if_ref = &getInterfaceConfig($vlan, $ip_v);

    # validate VLAN interface
    if (!$if_ref) {
        my $msg = "The VLAN interface $vlan doesn't exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($eload) {
        if ($if_ref->{addr}) {
            my $msg = &eload(
                module => 'Relianoid::EE::Net::Ext',
                func   => 'isManagementIP',
                args   => [ $if_ref->{addr} ],
            );
            if ($msg) {
                $msg = "The interface cannot be modified. $msg";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        my $zcl_conf = &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'getClusterConfig',
        );
        if (defined $zcl_conf->{_}{track_interface}) {
            my @track_interface =
              split(/\s/, $zcl_conf->{_}{track_interface});
            if (grep { $_ eq $if_ref->{name} } @track_interface) {
                my $msg = "The interface $if_ref->{name} cannot be modified because it is been tracked by the cluster.
						If you still want to modify it, remove it from the cluster track interface list.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    # check if some farm is using this ip
    require Relianoid::Farm::Base;
    my @farms = &getFarmListByVip($if_ref->{addr});
    if (@farms) {
        my $str = join(', ', @farms);
        my $msg = "This interface is being used as vip in the farm(s): $str.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($eload) {
        # check if some VPN is using this ip
        my $vpns = &eload(
            module => 'Relianoid::EE::VPN::Util',
            func   => 'getVpnByIp',
            args   => [ $if_ref->{addr} ],
        );
        if (@{$vpns}) {
            my $str = join(', ', @{$vpns});
            my $msg = "This interface is being used as Local Gateway in VPN(s): $str";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
        $vpns = &eload(
            module => 'Relianoid::EE::VPN::Util',
            func   => 'getVpnByNet',
            args   => [ $if_ref->{net} ],
        );
        if (@{$vpns}) {
            my $str = join(', ', @{$vpns});
            my $msg = "This interface is being used as Local Network in VPN(s): $str";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my @child = &getInterfaceChild($vlan);
    if (@child) {
        my $child_string = join(', ', @child);
        my $msg          = "Before removing $vlan interface, delete the virtual interfaces: $child_string.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::Net::Core;
    require Relianoid::Net::Route;

    eval {
        die if &delRoutes("local", $if_ref);
        die if &downIf($if_ref, 'writeconf');
        die if &delIf($if_ref);
    };

    if ($@) {
        &log_error("Module failed: $@", "net");
        my $msg = "The VLAN interface $vlan can't be deleted";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $message = "The VLAN interface $vlan has been deleted.";
    my $body    = {
        description => $desc,
        message     => $message,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub list_vlan_controller () {
    require Relianoid::Net::Interface;

    my $desc        = "List VLAN interfaces";
    my $output_list = &get_vlan_list_struct();

    my $body = {
        description => $desc,
        interfaces  => $output_list,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub get_vlan_controller ($vlan) {
    require Relianoid::Net::Interface;

    my $desc      = "Show VLAN interface $vlan";
    my $interface = &get_vlan_struct($vlan);

    unless ($interface) {
        my $msg = "VLAN interface not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $body = {
        description => $desc,
        interface   => $interface,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub actions_vlan_controller ($json_obj, $vlan) {
    require Relianoid::Net::Interface;

    my $desc = "Action on vlan interface";
    my $ip_v = 4;

    my $params = &getAPIModel("vlan-action.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # validate VLAN
    unless (grep { $vlan eq $_->{name} } &getInterfaceTypeList('vlan')) {
        my $msg = "VLAN interface not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $if_ref = &getInterfaceConfig($vlan, $ip_v);

    # validate action parameter
    if ($json_obj->{action} eq "up") {
        require Relianoid::Net::Validate;
        require Relianoid::Net::Route;
        require Relianoid::Net::Core;

        # Create vlan if required if it doesn't exist
        my $exists = &ifexist($if_ref->{name});
        if ($exists eq "false") {
            &createIf($if_ref);
        }

        # Delete routes in case that it is not a vini
        &delRoutes("local", $if_ref);

        # Add IP
        &addIp($if_ref);

        # Check the parent's status before up the interface
        my $parent_if_name   = &getParentInterfaceName($if_ref->{name});
        my $parent_if_status = 'up';

        if ($parent_if_name) {
            my $parent_if_ref = &getSystemInterface($parent_if_name);
            $parent_if_status = &getInterfaceSystemStatus($parent_if_ref);
        }

        # validate PARENT INTERFACE STATUS
        unless ($parent_if_status eq 'up') {
            my $msg = "The interface $if_ref->{name} has a parent interface DOWN, check the interfaces status";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        my $state = &upIf($if_ref, 'writeconf');

        if (!$state) {
            &applyRoutes("local", $if_ref);

            # put all dependant interfaces up
            require Relianoid::Net::Util;
            &setIfacesUp($if_ref->{name}, "vini");
        }
        else {
            my $msg = "The interface $if_ref->{name} could not be set UP";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }
    elsif ($json_obj->{action} eq "down") {
        if ($eload) {
            if ($if_ref->{addr}) {
                my $msg = &eload(
                    module => 'Relianoid::EE::Net::Ext',
                    func   => 'isManagementIP',
                    args   => [ $if_ref->{addr} ],
                );
                if ($msg) {
                    $msg = "The interface cannot be stopped. $msg";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
            my $zcl_conf = &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'getClusterConfig',
            );
            if (defined $zcl_conf->{_}{track_interface}) {
                my @track_interface = split(/\s/, $zcl_conf->{_}{track_interface});

                if (grep { $_ eq $if_ref->{name} } @track_interface) {
                    my $msg = "The interface $if_ref->{name} cannot be modified because it is been tracked by the cluster.
							If you still want to modify it, remove it from the cluster track interface list.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
        }

        require Relianoid::Net::Core;
        my $state = &downIf($if_ref, 'writeconf');

        if ($state) {
            my $msg = "The interface could not be set DOWN";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my $body = {
        description => $desc,
        params      => { action => $json_obj->{action} },
        message     => "The $vlan VLAN is $json_obj->{action}."
    };

    return &httpResponse({ code => 200, body => $body });
}

sub modify_vlan_controller ($json_obj, $vlan) {
    require Relianoid::Net::Interface;
    require Relianoid::Net::Core;
    require Relianoid::Net::Validate;
    require NetAddr::IP;

    my $desc   = "Modify VLAN interface";
    my $if_ref = &getInterfaceConfig($vlan);
    my $old_ip = $if_ref->{addr};

    my @farms;
    my $vpns_localgw  = [];
    my $vpns_localnet = [];
    my $warning_msg;

    # Check interface errors
    unless ($if_ref) {
        my $msg = "VLAN interface not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("vlan-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my @child = &getInterfaceChild($vlan);

    my $dhcp_status = $json_obj->{dhcp} // $if_ref->{dhcp};

    # only allow dhcp when no other parameter was sent
    if ($dhcp_status eq 'true') {
        if (   exists $json_obj->{ip}
            or exists $json_obj->{netmask}
            or exists $json_obj->{gateway})
        {
            my $msg = "It is not possible set 'ip', 'netmask' or 'gateway' while 'dhcp' is enabled.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    if (not exists $json_obj->{ip} and exists $json_obj->{dhcp} and @child) {
        my $msg =
          "This interface has appending some virtual interfaces, please, set up a new 'ip' in the current networking range.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if (   exists $json_obj->{ip}
        or exists $json_obj->{netmask}
        or exists $json_obj->{gateway})
    {
        my $new_if = {
            addr    => $json_obj->{ip}      // $if_ref->{addr},
            mask    => $json_obj->{netmask} // $if_ref->{mask},
            gateway => $json_obj->{gateway} // $if_ref->{gateway},
        };

        # Make sure the address, mask and gateway belong to the same stack
        if ($new_if->{addr}) {
            my $ip_v = &ipversion($new_if->{addr});
            my $gw_v = &ipversion($new_if->{gateway});

            if (!&validateNetmask($new_if->{mask}, $ip_v)) {
                my $msg = "The netmask is not valid";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            if ($new_if->{gateway} && $ip_v ne $gw_v) {
                my $msg = "Invalid IP stack version match.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        if (exists $json_obj->{ip} or exists $json_obj->{netmask}) {
            # check ip and netmask are configured
            unless ($new_if->{addr} ne "" and $new_if->{mask} ne "") {
                my $msg =
                  "The networking configuration is not valid. It needs an IP ('$new_if->{addr}') and a netmask ('$new_if->{mask}')";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            # Do not modify gateway or netmask if exists a virtual interface using this interface
            my @wrong_conf;
            for my $child_name (@child) {
                my $child_if = &getInterfaceConfig($child_name);
                unless (&validateGateway($child_if->{addr}, $new_if->{mask}, $new_if->{addr})) {
                    push @wrong_conf, $child_name;
                }
            }

            if (@wrong_conf) {
                my $child_string = join(', ', @wrong_conf);
                my $msg          = "The virtual interface(s): '$child_string' will not be compatible with the new configuration.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        # check if network exists in other interface
        if ($json_obj->{ip} or $json_obj->{netmask}) {
            my $if_used =
              &checkNetworkExists($new_if->{addr}, $new_if->{mask}, $vlan);
            if ($if_used) {
                my $msg = "The network already exists in the interface $if_used.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        # check the gateway is in network
        if ($new_if->{gateway}) {
            unless (&validateGateway($new_if->{addr}, $new_if->{mask}, $new_if->{gateway})) {
                my $msg = "The gateway is not valid for the network.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        # Check new IP address is not in use
        if ($json_obj->{ip} and ($new_if->{addr} ne $if_ref->{addr})) {
            require Relianoid::Net::Util;
            my @activeips = &listallips();
            for my $ip (@activeips) {
                if ($ip eq $json_obj->{ip}) {
                    my $msg = "IP address $json_obj->{ip} already in use.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
        }
    }

    if (   exists $json_obj->{ip}
        or (exists $json_obj->{dhcp})
        or (exists $json_obj->{netmask}))
    {
        if (exists $json_obj->{ip}
            or (exists $json_obj->{dhcp}))
        {
            if ($if_ref->{addr}) {
                if ($eload) {
                    my $msg = &eload(
                        module => 'Relianoid::EE::Net::Ext',
                        func   => 'isManagementIP',
                        args   => [ $if_ref->{addr} ],
                    );
                    if ($msg) {
                        $msg = "The interface cannot be modified. $msg";
                        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                    }
                }
            }

            # check if some farm is using this ip
            require Relianoid::Farm::Base;
            @farms        = &getFarmListByVip($if_ref->{addr});
            $vpns_localgw = &eload(
                module => 'Relianoid::EE::VPN::Util',
                func   => 'getVpnByIp',
                args   => [ $if_ref->{addr} ],
            ) if $eload;
        }

        # check if its a new network and a vpn using old network
        if (exists $json_obj->{ip} or exists $json_obj->{netmask}) {
            # check if network is changed
            my $mask = $json_obj->{netmask} // $if_ref->{mask};
            if (not &validateGateway($if_ref->{addr}, $if_ref->{mask}, $json_obj->{ip})
                or $if_ref->{mask} ne $mask)
            {
                my $net =
                  NetAddr::IP->new($if_ref->{addr}, $if_ref->{mask})->cidr();
                $vpns_localnet = &eload(
                    module => 'Relianoid::EE::VPN::Util',
                    func   => 'getVpnByNet',
                    args   => [$net],
                ) if $eload;
            }
        }

        if (@farms or @{$vpns_localgw} or @{$vpns_localnet}) {
            if (    not exists $json_obj->{ip}
                and exists $json_obj->{dhcp}
                and $json_obj->{dhcp} eq 'false')
            {
                my $str_objects;
                my $str_function;
                if (@farms) {
                    $str_objects  = " and farms";
                    $str_function = " and farm VIP";
                }
                if (@{$vpns_localgw} or @{$vpns_localnet}) {
                    $str_objects .= " and vpns";
                }
                if (@{$vpns_localgw}) {
                    $str_function .= " and Local Gateway";
                }
                if (@{$vpns_localnet}) {
                    $str_function .= " and Local Network";
                }
                $str_objects  = substr($str_objects,  5);
                $str_function = substr($str_function, 5);

                my $msg =
                  "This interface is been used by some $str_objects, please, set up a new 'ip' in order to be used as $str_function.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
            if ($json_obj->{force} ne 'true') {
                my $str_objects;
                my $str_function;
                if (@farms) {
                    $str_objects  = " and farms";
                    $str_function = " and as farm VIP in the farm(s): " . join(', ', @farms);
                }
                if (@{$vpns_localgw} or @{$vpns_localnet}) {
                    $str_objects .= " and vpns";
                }
                if (@{$vpns_localgw}) {
                    $str_function .= " and as Local Gateway in the VPN(s): " . join(', ', @{$vpns_localgw});
                }
                if (@{$vpns_localnet}) {
                    $str_function .= " and as Local Network in the VPN(s): " . join(', ', @{$vpns_localnet});
                }
                $str_objects  = substr($str_objects,  5);
                $str_function = substr($str_function, 5);

                my $msg =
                  "The IP is being used $str_function. If you are sure, repeat with parameter 'force'. All $str_objects using this interface will be restarted.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }
    }

    if (exists $json_obj->{dhcp}) {
        my $func = ($json_obj->{dhcp} eq 'true') ? "enableDHCP" : "disableDHCP";
        my $err  = &eload(
            module => 'Relianoid::EE::Net::DHCP',
            func   => $func,
            args   => [$if_ref],
        );

        if ($err) {
            my $msg = "Errors found trying to enabling dhcp for the interface $vlan";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # Delete old parameters
    if ($if_ref) {
        require Relianoid::Net::Core;
        require Relianoid::Net::Route;

        # Delete old IP and Netmask from system to replace it
        &delIp($$if_ref{name}, $$if_ref{addr}, $$if_ref{mask});

        # Remove routes if the interface has its own route table: nic and vlan
        &delRoutes("local", $if_ref);
    }

    $if_ref->{addr} = $json_obj->{ip} if (exists $json_obj->{ip});
    $if_ref->{mac}  = lc $json_obj->{mac}
      if ($eload && exists $json_obj->{mac});
    $if_ref->{mask}    = $json_obj->{netmask} if exists $json_obj->{netmask};
    $if_ref->{gateway} = $json_obj->{gateway} if exists $json_obj->{gateway};
    $if_ref->{ip_v}    = &ipversion($if_ref->{addr});
    $if_ref->{net} =
      &getAddressNetwork($if_ref->{addr}, $if_ref->{mask}, $if_ref->{ip_v});

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Net::Routing',
            func   => 'updateRoutingVirtualIfaces',
            args   => [ $if_ref->{parent}, $old_ip ],
        );
    }

    require Relianoid::Lock;
    my $vlan_config_file = &getGlobalConfiguration('configdir') . "/if_$if_ref->{name}_conf";
    my $dhcp_flag        = $json_obj->{dhcp} // $if_ref->{dhcp};

    if (($dhcp_flag ne 'true') and not($if_ref->{addr} and $if_ref->{mask})) {
        my $msg = "Cannot configure the interface without address or without netmask.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    elsif ($dhcp_flag eq "true") {
        &lockResource($vlan_config_file, "l");
    }

    require Relianoid::Net::Interface;
    if (&setVlan($if_ref, $json_obj)) {
        #Release lock file
        &lockResource($vlan_config_file, "ud") if ($dhcp_flag eq "true");

        my $msg = "Errors found trying to modify interface $vlan";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    #Release lock file
    &lockResource($vlan_config_file, "ud") if ($dhcp_flag eq "true");

    if (@farms) {
        require Relianoid::Farm::Config;
        &setAllFarmByVip($json_obj->{ip}, \@farms);
        &reloadFarmsSourceAddress();
    }

    if (@{$vpns_localgw}) {
        my $error = &eload(
            module => 'Relianoid::EE::VPN::Config',
            func   => 'setAllVPNLocalGateway',
            args   => [ $json_obj->{ip}, $vpns_localgw ],
        );
        $warning_msg .= $error->{desc} if ($error->{code});
    }
    if (@{$vpns_localnet}) {
        my $net   = NetAddr::IP->new($if_ref->{net}, $if_ref->{mask})->cidr();
        my $error = &eload(
            module => 'Relianoid::EE::VPN::Config',
            func   => 'setAllVPNLocalNetwork',
            args   => [ $net, $vpns_localnet ],
        );
        $warning_msg .= $error->{desc} if ($error->{code});
    }

    my $if_out = &get_vlan_struct($vlan);
    my $body   = {
        description => $desc,
        params      => $if_out,
        message     => "The $vlan VLAN has been updated successfully"
    };
    $body->{warning} = $warning_msg if ($warning_msg);

    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Interface/Virtual.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Interface::Virtual

=cut

my $eload = eval { require Relianoid::ELoad };

# POST /interfaces/virtual Create a new virtual network interface
sub add_virtual_controller ($json_obj) {
    my $desc = "Add a virtual interface";

    my $nic_re         = &getValidFormat('nic_interface');
    my $vlan_re        = &getValidFormat('vlan_interface');
    my $virtual_tag_re = &getValidFormat('virtual_tag');

    my $params = &getAPIModel("virtual-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # virtual_name = pather_name + . + virtual_tag
    # size < 16: size = pather_name:virtual_name
    if (length $json_obj->{name} > 15) {
        my $msg = "Virtual interface name has a maximum length of 15 characters";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    unless ($json_obj->{name} =~ /^($nic_re|$vlan_re):($virtual_tag_re)$/) {
        my $msg = "Interface name is not valid";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    $json_obj->{parent} = $1;
    $json_obj->{vini}   = $2;

    my $vlan_tag_re = &getValidFormat('vlan_tag');
    $json_obj->{parent} =~ /^($nic_re)(?:\.($vlan_tag_re))?$/;
    $json_obj->{dev}  = $1;
    $json_obj->{vlan} = $2;

    require Relianoid::Net::Validate;
    $json_obj->{ip_v} = ipversion($json_obj->{ip});

    # validate PARENT
    # virtual interfaces require a configured parent interface
    my $parent_exist = &ifexist($json_obj->{parent});
    my $if_parent =
      &getInterfaceConfig($json_obj->{parent}, $json_obj->{ip_v});
    unless ($parent_exist eq "true" && $if_parent) {
        my $msg = "The parent interface $json_obj->{parent} doesn't exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    if ($if_parent->{type} eq 'nic' and not $if_parent->{addr}) {
        my $msg = "The parent interface $json_obj->{parent} must be configured.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Check network interface errors
    # A virtual interface cannnot exist in two stacks
    my $if_ref = &getInterfaceConfig($json_obj->{name}, $json_obj->{ip_v});

    if ($if_ref) {
        my $msg = "Network interface $json_obj->{name} already exists.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Check new IP address is not in use
    require Relianoid::Net::Util;

    my @activeips = &listallips();

    for my $ip (@activeips) {
        if ($ip eq $json_obj->{ip}) {
            my $msg = "IP address $json_obj->{ip} already in use.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # setup parameters of virtual interface
    $if_ref = &getInterfaceConfig($json_obj->{parent}, $json_obj->{ip_v});

    # $json_obj->{addr} must exist in getInterfaceSystemStatus()
    $json_obj->{addr}  = $json_obj->{ip};
    $if_ref->{status}  = &getInterfaceSystemStatus($json_obj);
    $if_ref->{name}    = $json_obj->{name};
    $if_ref->{vini}    = $json_obj->{vini};
    $if_ref->{addr}    = $json_obj->{ip};
    $if_ref->{gateway} = "" if !$if_ref->{gateway};
    $if_ref->{type}    = 'virtual';
    $if_ref->{dhcp}    = 'false';

    unless (&validateGateway($if_parent->{addr}, $if_ref->{mask}, $if_ref->{addr})) {
        my $msg = "IP Address $json_obj->{ip} must be same net than the parent interface.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::Net::Core;
    require Relianoid::Net::Route;

    eval {
        die if &addIp($if_ref);

        my $state = &upIf($if_ref, 'writeconf');

        if ($state == 0) {
            $if_ref->{status} = "up";
            &applyRoutes("local", $if_ref);
        }

        &setInterfaceConfig($if_ref) or die;
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::RBAC::Group::Config',
                func   => 'addRBACUserResource',
                args   => [ $if_ref->{name}, 'interfaces' ],
            );
        }
    };

    if ($@) {
        &log_error("Module failed: $@", "net");
        my $msg = "The $json_obj->{name} virtual network interface can't be created";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &eload(
        module => 'Relianoid::EE::Cluster',
        func   => 'runClusterRemoteManager',
        args   => [ 'interface', 'start', $if_ref->{name} ],
    ) if ($eload);

    my $body = {
        description => $desc,
        params      => {
            name    => $if_ref->{name},
            ip      => $if_ref->{addr},
            netmask => $if_ref->{mask},
            gateway => $if_ref->{gateway},
            mac     => $if_ref->{mac},
        },
        message => "The $if_ref->{name} Virtual interface has been created successfully"
    };

    return &httpResponse({ code => 201, body => $body });
}

sub delete_virtual_controller ($virtual) {
    require Relianoid::Net::Interface;

    my $desc   = "Delete virtual interface";
    my $ip_v   = 4;
    my $if_ref = &getInterfaceConfig($virtual, $ip_v);

    if (!$if_ref) {
        my $msg = "The virtual interface $virtual doesn't exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # check if some farm is using this ip
    require Relianoid::Farm::Base;

    my @farms = &getFarmListByVip($if_ref->{addr});

    if (@farms) {
        my $str = join(', ', @farms);
        my $msg = "This interface is being used as farm vip in the farm(s): $str.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my @child = &getInterfaceChild($virtual);

    if (@child) {
        my $child_string = join(', ', @child);
        my $msg          = "Before removing $virtual interface, disable the floating IPs: $child_string.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::Net::Route;
    require Relianoid::Net::Core;

    eval {
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'interface', 'stop', $if_ref->{name} ],
            );

            &eload(
                module => 'Relianoid::EE::Net::Routing',
                func   => 'delRoutingDependIfaceVirt',
                args   => [$if_ref],
            );
        }

        if ($if_ref->{status} eq 'up') {
            # removing before in the remote node
            die if &delRoutes("local", $if_ref);
            die if &downIf($if_ref, 'writeconf');
        }
        die if &delIf($if_ref);
    };

    if ($@) {
        &log_error("Module failed: $@", "net");
        my $msg = "The virtual interface $virtual can't be deleted";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'interface', 'delete', $if_ref->{name} ],
        );
    }

    my $message = "The virtual interface $virtual has been deleted.";
    my $body    = {
        description => $desc,
        success     => "true",
        message     => $message,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub list_virtual_controller () {
    require Relianoid::Net::Interface;

    my $desc        = "List virtual interfaces";
    my $output_list = &get_virtual_list_struct();

    if ($eload) {
        $output_list = &eload(
            module => 'Relianoid::EE::RBAC::Group::Core',
            func   => 'getRBACUserSet',
            args   => [ 'interfaces', $output_list ],
        );
    }

    my $body = {
        description => $desc,
        interfaces  => $output_list,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub get_virtual_controller ($virtual) {
    require Relianoid::Net::Interface;

    my $desc      = "Show virtual interface $virtual";
    my $interface = &get_virtual_struct($virtual);

    unless ($interface) {
        my $msg = "Virtual interface not found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $body = {
        description => $desc,
        interface   => $interface,
    };

    return &httpResponse({ code => 200, body => $body });
}

sub actions_virtual_controller ($json_obj, $virtual) {
    require Relianoid::Net::Interface;

    my $desc = "Action on virtual interface";
    my $ip_v = 4;

    my $params = &getAPIModel("virtual-action.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # validate VLAN
    unless (grep { $virtual eq $_->{name} } &getInterfaceTypeList('virtual')) {
        my $msg = "Virtual interface not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $if_ref = &getInterfaceConfig($virtual, $ip_v);

    if ($json_obj->{action} eq "up") {
        require Relianoid::Net::Core;

        &addIp($if_ref);

        # Check the parent's status before up the interface
        my $parent_if_name   = &getParentInterfaceName($if_ref->{name});
        my $parent_if_status = 'up';

        if ($parent_if_name) {
            my $parent_if_ref = &getSystemInterface($parent_if_name);
            $parent_if_status = &getInterfaceSystemStatus($parent_if_ref);
        }

        unless ($parent_if_status eq 'up') {
            my $msg = "The interface $if_ref->{name} has a parent interface DOWN, check the interfaces status";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        my $state = &upIf($if_ref, 'writeconf');
        if (!$state) {
            require Relianoid::Net::Route;
            &applyRoutes("local", $if_ref);

            &eload(
                module => 'Relianoid::EE::Net::Routing',
                func   => 'applyRoutingDependIfaceVirt',
                args   => [ 'add', $if_ref ]
            ) if $eload;
        }
        else {
            my $msg = "The interface could not be set UP";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'interface', 'start', $if_ref->{name} ],
        ) if ($eload);
    }
    elsif ($json_obj->{action} eq "down") {
        require Relianoid::Net::Core;

        my $state = &downIf($if_ref, 'writeconf');

        if ($state) {
            my $msg = "The interface could not be set DOWN";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'interface', 'stop', $if_ref->{name} ],
            );
        }
    }

    my $body = {
        description => $desc,
        params      => { action => $json_obj->{action} },
        message     => "The $if_ref->{name} Virtual interface is $json_obj->{action}"
    };

    return &httpResponse({ code => 200, body => $body });
}

sub modify_virtual_controller ($json_obj, $virtual) {
    require Relianoid::Net::Interface;
    require Net::Netmask;

    my $desc   = "Modify virtual interface";
    my $if_ref = &getInterfaceConfig($virtual);
    my $old_ip = $if_ref->{addr};
    my @farms;

    my $params = &getAPIModel("virtual-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    unless ($if_ref) {
        my $msg = "Virtual interface not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my @child = &getInterfaceChild($virtual);

    if (@child) {
        my $child_string = join(', ', @child);
        my $msg          = "Before modifying $virtual interface, disable the floating IPs: $child_string.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::Farm::Base;

    @farms = &getFarmListByVip($if_ref->{addr});

    # check if ip exists in other interface
    if ($json_obj->{ip}) {
        if ($json_obj->{ip} ne $if_ref->{addr}) {
            require Relianoid::Net::Util;

            if (grep { $json_obj->{ip} eq $_ } &listallips()) {
                my $msg = "The IP address is already in use for other interface.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        if (@farms and $json_obj->{force} ne 'true') {
            my $str = join(', ', @farms);
            my $msg =
              "The IP is being used as farm vip in the farm(s): $str. If you are sure, repeat with parameter 'force'. All farms using this interface will be restarted.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    require Relianoid::Net::Validate;
    my $if_ref_parent = &getInterfaceConfig($if_ref->{parent});

    unless (&validateGateway($if_ref_parent->{addr}, $if_ref_parent->{mask}, $json_obj->{ip})) {
        my $msg = "IP address $json_obj->{ip} must be on the same network than the parent interface.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::Net::Core;

    my $state = $if_ref->{status};
    &downIf($if_ref) if $state eq 'up';

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'interface', 'stop', $if_ref->{name} ],
        );
    }

    eval {
        # Set the new params
        $if_ref->{addr} = $json_obj->{ip};

        if ($state eq 'up') {
            require Relianoid::Net::Route;
            die if &addIp($if_ref);
            &upIf($if_ref);
            &applyRoutes("local", $if_ref);
        }

        # Add new IP, netmask and gateway
        &setInterfaceConfig($if_ref) or die;

        if ($eload and $old_ip) {
            &eload(
                module => 'Relianoid::EE::Net::Routing',
                func   => 'updateRoutingVirtualIfaces',
                args   => [ $if_ref->{parent}, $old_ip, $json_obj->{ip} ],
            );
        }

        # change farm vip,
        if (@farms) {
            require Relianoid::Farm::Config;

            &setAllFarmByVip($json_obj->{ip}, \@farms);
        }
    };

    if ($@) {
        &log_error("Module failed: $@", "net");
        my $msg = "Errors found trying to modify interface $virtual";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'interface', 'start', $if_ref->{name} ],
        );
        &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'runClusterRemoteManager',
            args   => [ 'farm', 'restart_farms', @farms ],
        );
    }

    my $body = {
        description => $desc,
        params      => $json_obj,
        message     => "The $if_ref->{name} Virtual interface has been updated successfully"
    };

    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Letsencrypt.pm ===

#!/usr/bin/perl
##############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Letsencrypt

=cut

my $eload = eval { require Relianoid::ELoad };

# GET /certificates/letsencrypt
sub list_le_cert_controller () {
    require Relianoid::Letsencrypt;

    my $desc         = "List LetsEncrypt certificates";
    my $certificates = &getLetsencryptCertificates();
    my @out;

    if ($certificates) {
        for my $cert (@{$certificates}) {
            push @out, &getLetsencryptCertificateInfo($cert->{name});
        }
    }
    if ($eload) {
        my $wildcards = &eload(
            module => 'Relianoid::EE::Letsencrypt::Wildcard',
            func   => 'getLetsencryptWildcardCertificates'
        );

        for my $cert (@{$wildcards}) {
            push @out,
              &eload(
                module => 'Relianoid::EE::Letsencrypt::Wildcard',
                func   => 'getLetsencryptWildcardCertificateInfo',
                args   => [ $cert->{name} ]
              );
        }
    }

    my $body = {
        description => $desc,
        params      => \@out,
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /certificates/letsencrypt/le_cert_re
sub get_le_cert_controller ($le_cert_name) {
    require Relianoid::Letsencrypt;

    my $desc    = "Show Let's Encrypt certificate $le_cert_name";
    my $le_cert = &getLetsencryptCertificates($le_cert_name);

    if (not defined $le_cert_name or not @{$le_cert}) {
        my $msg = "Let's Encrypt certificate $le_cert_name not found!";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $out = &getLetsencryptCertificateInfo($le_cert_name);

    my $body = {
        description => $desc,
        params      => $out,
    };

    return &httpResponse({ code => 200, body => $body });
}

# POST /certificates/letsencrypt
sub add_le_cert_controller ($json_obj) {
    require Relianoid::Certificate;
    require Relianoid::Letsencrypt;
    require Relianoid::Net::Interface;
    require Relianoid::Farm::Core;

    my $ip_list   = &getIpAddressList();
    my @farm_list = &getFarmsByType("http");

    my $desc   = "Create LetsEncrypt certificate";
    my $params = &getAPIModel("letsencrypt-create.json");
    $params->{vip}{values}      = $ip_list;
    $params->{farmname}{values} = \@farm_list;

    # avoid farmname when no HTTP Farm exists
    if (not @farm_list and defined $json_obj->{farmname}) {
        my $msg = "There is no HTTP Farms in the system, use 'vip' param instead.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # vip or farmname has to be defined
    if (    not $json_obj->{vip}
        and not $json_obj->{farmname}
        and defined $json_obj->{domains})
    {
        my $msg = "No 'vip' or 'farmname' param found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # avoid wildcards domains
    if (grep { /^\*/ } @{ $json_obj->{domains} }) {
        my $msg = "Wildcard domains are not allowed.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # check if the cert exists
    my $force   = "false";
    my $le_cert = &getLetsencryptCertificates($json_obj->{domains}[0]);
    if (@{$le_cert}) {
        if (exists $json_obj->{force} and $json_obj->{force} eq 'true') {
            $force = "true";
        }
        else {
            my $msg =
              "Let's Encrypt certificate $json_obj->{domains}[0] already exists! Why not use the '--renew' instead? If you are sure, use the '--force' parameter.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # check farm has to be listening on port 80 and up
    if (defined $json_obj->{farmname}) {
        require Relianoid::Farm::Base;
        if (&getFarmVip('vipp', $json_obj->{farmname}) ne 80) {
            my $msg = "Farm $json_obj->{farmname} must be listening on Port 80.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        require Relianoid::Farm::HTTP::Config;
        if (&getHTTPFarmStatus($json_obj->{farmname}) ne "up") {
            my $msg = "Farm $json_obj->{farmname} must be up.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }

    # check any farm listening on vip and port 80 and up
    my $le_farm_port = 80;
    if (defined $json_obj->{vip}) {
        require Relianoid::Net::Validate;
        if (&validatePort($json_obj->{vip}, $le_farm_port, "tcp") == 0) {
            #vip:port is in use
            require Relianoid::Farm::Base;
            require Relianoid::Farm::HTTP::Config;

            for my $farm (&getFarmListByVip($json_obj->{vip})) {
                if (    &getHTTPFarmVip("vipp", $farm) eq "$le_farm_port"
                    and &getHTTPFarmStatus($farm) eq "up")
                {
                    my $msg = "Farm $farm is listening on 'vip' $json_obj->{vip} and Port $le_farm_port.";
                    return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
                }
            }
            my $msg = "The system has a process listening on 'vip' $json_obj->{vip} and Port $le_farm_port.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }

    # check Email config
    my $le_conf = &getLetsencryptConfig();
    if (!$le_conf->{email}) {
        my $msg = "Letsencrypt email is not configured.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $error =
      &runLetsencryptObtain($json_obj->{farmname}, $json_obj->{vip}, $json_obj->{domains}, $json_obj->{test}, $force);
    if ($error) {
        my $strdomains = join(", ", @{ $json_obj->{domains} });
        my $msg        = "The Letsencrypt certificate for Domain $strdomains can't be created";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &log_info("Success, the Letsencrypt certificate has been created successfully.", "letsencrypt");

    my $out  = &getLetsencryptCertificateInfo($json_obj->{domains}[0]);
    my $body = {
        description => $desc,
        params      => $out,
        message     => "The Letsencrypt certificate has been created successfully."
    };

    return &httpResponse({ code => 200, body => $body });
}

# DELETE /certificates/letsencrypt/le_cert_re
sub delete_le_cert_controller ($le_cert_name) {
    my $desc = "Delete LetsEncrypt certificate";

    require Relianoid::Letsencrypt;

    my $le_cert = &getLetsencryptCertificates($le_cert_name);
    if (!@{$le_cert}) {
        my $msg = "Let's Encrypt certificate $le_cert_name not found!";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $cert_name = $le_cert_name;
    $cert_name =~ s/\./\_/g;
    $cert_name .= ".pem";

    # check the certificate is being used by a Farm
    require Relianoid::Certificate;
    my $farms_used = &getCertFarmsUsed($cert_name);
    if (@{$farms_used}) {
        my $msg =
          "Let's Encrypt Certificate $le_cert_name can not be deleted because it is in use by " . join(", ", @{$farms_used});
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($eload) {
        # check the certificate is being used by API web server
        my $status = &eload(
            module => 'Relianoid::EE::System::HTTP',
            func   => 'getHttpsCertUsed',
            args   => ['$cert_name']
        );
        if ($status == 0) {
            my $msg = "Let's Encrypt Certificate $le_cert_name can not be deleted because it is in use by HTTPS server";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    # revoke LE cert
    my $error = &runLetsencryptDestroy($le_cert_name);
    if ($error) {
        my $msg = "Let's Encrypt Certificate can not be removed";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # delete autorenewal
    &unsetLetsencryptCron($le_cert_name);

    # delete RELIANOID cert if exists
    my $cert_dir = &getGlobalConfiguration('certdir');
    &delCert($cert_name) if (-f "$cert_dir\/$cert_name");

    if (-f "$cert_dir\/$cert_name") {
        my $msg = "Error deleting certificate $cert_name.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    &log_info("Success, the Let's Encrypt certificate has been deleted successfully.", "letsencrypt");

    my $msg  = "Let's Encrypt Certificate $le_cert_name has been deleted.";
    my $body = {
        description => $desc,
        success     => "true",
        message     => $msg,
    };
    return &httpResponse({ code => 200, body => $body });
}

# POST /certificates/letsencrypt/le_cert_re/actions
sub actions_le_cert_controller ($json_obj, $le_cert_name) {
    my $desc = "Let's Encrypt certificate actions";

    require Relianoid::Certificate;
    require Relianoid::Letsencrypt;

    # check the certificate is a LE cert
    my $le_cert = &getLetsencryptCertificates($le_cert_name);
    if (!@{$le_cert}) {
        my $msg = "Let's Encrypt certificate $le_cert_name not found!";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    require Relianoid::Net::Interface;
    my $ip_list = &getIpAddressList();
    require Relianoid::Farm::Core;
    my @farm_list = &getFarmsByType("http");

    my $params = &getAPIModel("letsencrypt-action.json");
    $params->{vip}{values}      = $ip_list;
    $params->{farmname}{values} = \@farm_list;

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # avoid farmname when no HTTP Farm exists
    if (not @farm_list and defined $json_obj->{farmname}) {
        my $msg = "There is no HTTP Farms in the system, use 'vip' param instead.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # vip or farmname has to be defined
    if (    not $json_obj->{vip}
        and not $json_obj->{farmname})
    {
        my $msg = "No 'vip' or 'farmname' param found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # check farm has to be listening on port 80 and up
    if (defined $json_obj->{farmname}) {
        require Relianoid::Farm::Base;
        if (&getFarmVip('vipp', $json_obj->{farmname}) ne 80) {
            my $msg = "Farm $json_obj->{farmname} must be listening on Port 80.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        require Relianoid::Farm::HTTP::Config;
        if (&getHTTPFarmStatus($json_obj->{farmname}) ne "up") {
            my $msg = "Farm $json_obj->{farmname} must be up.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }

    # check any farm listening on vip and port 80 and up
    my $le_farm_port = 80;
    if (defined $json_obj->{vip}) {
        require Relianoid::Net::Validate;
        if (&validatePort($json_obj->{vip}, $le_farm_port, "tcp") == 0) {
            #vip:port is in use
            require Relianoid::Farm::Base;
            require Relianoid::Farm::HTTP::Config;

            for my $farm (&getFarmListByVip($json_obj->{vip})) {
                if (    &getHTTPFarmVip("vipp", $farm) eq "$le_farm_port"
                    and &getHTTPFarmStatus($farm) eq "up")
                {
                    my $msg = "Farm $farm is listening on 'vip' $json_obj->{vip} and Port $le_farm_port.";
                    return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
                }
            }
            my $msg = "The system has a process listening on 'vip' $json_obj->{vip} and Port $le_farm_port.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }

    # check Email config
    my $le_conf = &getLetsencryptConfig();
    if (!$le_conf->{email}) {
        my $msg = "Letsencrypt email is not configured.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $error_ref = &runLetsencryptRenew($le_cert_name, $json_obj->{farmname}, $json_obj->{vip}, $json_obj->{force_renewal},
        $json_obj->{test});
    if ($error_ref->{code}) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_ref->{desc} });
    }

    &log_info("Success, the Letsencrypt certificate has been renewed successfully.", "letsencrypt");

    my @farms_restarted;
    my @farms_restarted_error;
    if (    (defined $json_obj->{restart})
        and ($json_obj->{restart} eq "true"))
    {
        my $cert_name = $le_cert_name;
        $cert_name =~ s/\./\_/g;
        $cert_name .= ".pem";

        my $error;
        require Relianoid::Farm::Action;
        require Relianoid::Farm::Base;
        for my $farm (@{ getCertFarmsUsed($cert_name) }) {
            # restart farm used and up
            if (&getFarmStatus($farm) ne 'down') {
                $error = &runFarmStop($farm, "");
                if ($error) {
                    push @farms_restarted_error, $farm;
                    next;
                }
                $error = &runFarmStart($farm, "");
                if ($error) {
                    push @farms_restarted_error, $farm;
                    next;
                }
                push @farms_restarted, $farm;
            }
        }

        # restart on backup node
        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'runClusterRemoteManager',
                args   => [ 'farm', 'restart_farms', @farms_restarted ],
            ) if @farms_restarted;
        }
    }

    my $info_msg;
    if (@farms_restarted) {
        $info_msg = "The following farms were been restarted: " . join(", ", @farms_restarted);
    }
    if (@farms_restarted_error) {
        $info_msg = "The following farms could not been restarted: " . join(", ", @farms_restarted_error);
    }

    my $msg  = "The Let's Encrypt certificate $le_cert_name has been renewed successfully.";
    my $out  = &getLetsencryptCertificateInfo($le_cert_name);
    my $body = {
        description => $desc,
        params      => $out,
        message     => $msg
    };
    $body->{warning} = $info_msg if defined $info_msg;
    return &httpResponse({ code => 200, body => $body });
}

# PUT /certificates/letsencrypt/le_cert_re
sub set_le_cert_controller ($json_obj, $le_cert_name) {
    my $desc = "Modify Let's Encrypt certificate";

    require Relianoid::Certificate;
    require Relianoid::Letsencrypt;

    # check the certificate is a LE cert
    my $le_cert = &getLetsencryptCertificates($le_cert_name);
    if (!@{$le_cert}) {
        my $msg = "Let's Encrypt certificate $le_cert_name not found!";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $params = &getAPIModel("letsencrypt-modify.json");

    # dyn_values model
    if (defined $json_obj->{vip}) {
        require Relianoid::Net::Interface;
        my $ip_list = &getIpAddressList();
        $params->{vip}{values} = $ip_list;
    }
    if (defined $json_obj->{farmname}) {
        require Relianoid::Farm::Core;
        my @farm_list = &getFarmsByType("http");
        $params->{farmname}{values} = \@farm_list;
    }

    # depends_on model
    if (defined $json_obj->{farmname}) {
        delete $params->{vip} if defined $json_obj->{vip};
    }

    if (    (defined $json_obj->{autorenewal})
        and ($json_obj->{autorenewal} eq "false"))
    {
        delete $params->{force_renewal} if defined $params->{force_renewal};
        delete $params->{restart}       if defined $params->{restart};
        delete $params->{vip}           if defined $params->{vip};
        delete $params->{farmname}      if defined $params->{farmname};
    }

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # depends_on model
    # vip or farmname has to be defined
    if (    not $json_obj->{vip}
        and not $json_obj->{farmname}
        and $json_obj->{autorenewal} eq "true")
    {
        my $msg = "No 'vip' or 'farmname' param found.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # check farm has to be listening on port 80 and up
    if (defined $json_obj->{farmname}) {
        require Relianoid::Farm::Base;
        if (&getFarmVip('vipp', $json_obj->{farmname}) ne 80) {
            my $msg = "Farm $json_obj->{farmname} must be listening on Port 80.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }

        require Relianoid::Farm::HTTP::Config;
        if (&getHTTPFarmStatus($json_obj->{farmname}) ne "up") {
            my $msg = "Farm $json_obj->{farmname} must be up.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }

    # check any farm listening on vip and port 80 and up
    my $le_farm_port = 80;
    if (defined $json_obj->{vip}) {
        require Relianoid::Net::Validate;
        if (&validatePort($json_obj->{vip}, $le_farm_port, "tcp") == 0) {
            #vip:port is in use
            require Relianoid::Farm::Base;
            require Relianoid::Farm::HTTP::Config;

            for my $farm (&getFarmListByVip($json_obj->{vip})) {
                if (    &getHTTPFarmVip("vipp", $farm) eq "$le_farm_port"
                    and &getHTTPFarmStatus($farm) eq "up")
                {
                    my $msg = "Farm $farm is listening on 'vip' $json_obj->{vip} and Port $le_farm_port.";
                    return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
                }
            }
            my $msg = "The system has a process listening on 'vip' $json_obj->{vip} and Port $le_farm_port.";
            return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
        }
    }

    # check Email config
    my $le_conf = &getLetsencryptConfig();
    if (!$le_conf->{email}) {
        my $msg = "Letsencrypt email is not configured.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $msg;
    if ($json_obj->{autorenewal} eq "true") {
        my $error = &setLetsencryptCron($le_cert_name, $json_obj->{farmname}, $json_obj->{vip}, $json_obj->{force_renewal},
            $json_obj->{restart});

        if ($error) {
            my $msg = "The Auto Renewal for Let's Encrypt certificate $le_cert_name can't be enabled";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        &log_info("Success, the Auto Renewal for Letsencrypt certificate has been enabled successfully.", "letsencrypt");
        $msg = "The Auto Renewal for Let's Encrypt certificate $le_cert_name has been enabled successfully.";
    }
    else {
        my $error = &unsetLetsencryptCron($le_cert_name);
        if ($error) {
            my $msg = "The Auto Renewal for Let's Encrypt certificate $le_cert_name can't be disabled";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
        &log_info("Success, the Auto Renewal for Letsencrypt certificate has been disabled successfully.",
            "letsencrypt");
        $msg = "The Auto Renewal for Let's Encrypt certificate $le_cert_name has been disabled successfully.";
    }

    my $out  = &getLetsencryptCertificateInfo($le_cert_name);
    my $body = {
        description => $desc,
        params      => $out,
        message     => $msg,
    };
    return &httpResponse({ code => 200, body => $body });
}

# GET /certificates/letsencrypt/config
sub get_le_conf_controller () {
    my $desc = "Get LetsEncrypt Config";

    require Relianoid::Letsencrypt;
    my $out  = &getLetsencryptConfig();
    my $body = {
        description => $desc,
        params      => $out,
    };
    return &httpResponse({ code => 200, body => $body });
}

# PUT /certificates/letsencrypt/config
sub set_le_conf_controller ($json_obj) {
    my $desc   = "Modify LetsEncrypt Config";
    my $params = &getAPIModel("letsencrypt_config-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    require Relianoid::Letsencrypt;
    my $error = &setLetsencryptConfig($json_obj);
    if ($error) {
        my $msg = "The Letsencrypt Config can't be updated";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    my $msg  = "The Letsencrypt Config has been updated successfully.";
    my $out  = &getLetsencryptConfig();
    my $body = {
        description => $desc,
        success     => "true",
        message     => $msg,
        params      => $out,
    };
    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Session.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Session

=cut

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::CGI;
use Relianoid::HTTP;
use Relianoid::HTTP::Auth;

use CGI::Session;

my $LOG_TAG = "";
$LOG_TAG = "API"    if get_http_api_key();
$LOG_TAG = "WEBGUI" if (exists $ENV{HTTP_COOKIE});

=pod

=head1 session_login_controller

C<POST /session>

Authentication via HTTP basic access authentication, using the HTTP header

C<Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==>

B<Arguments>: 

IMPORTANT:

- Relianoid::HTTP::POST() has an exception to not include arguments when 
C<POST /session> is called, because the web GUI is sending a non-empty body.

- This call should have no body, so also no content type.

=cut

sub session_login_controller () {
    my $desc    = "Login to new session";
    my $session = CGI::Session->new(&getCGI());

    unless ($session && !$session->param('is_logged_in')) {
        my $msg = "Already logged in a session";
        return &httpErrorResponse({ code => 401, desc => $desc, msg => $msg });
    }

    # not validated credentials
    my ($username, $password) = &getAuthorizationCredentials();

    unless (&authenticateCredentials($username, $password)) {
        $session->delete();
        $session->flush();

        my $msg = "The username and/or password are incorrect";
        return &httpErrorResponse({ code => 401, desc => $desc, msg => $msg });
    }

    # check if the user has got permissions
    my (undef, undef, undef, $webgui_group) = getgrnam('webgui');
    if (!grep { /(^| )$username( |$)/ } $webgui_group) {
        my $msg = "The user $username has not web permissions";
        return &httpErrorResponse({ code => 401, desc => $desc, msg => $msg });
    }

    require Relianoid::SystemInfo;

    $session->param('is_logged_in', 1);
    $session->param('username',     $username);
    my $session_timeout = &getGlobalConfiguration('session_timeout') // 30;
    $session->expire('is_logged_in', '+' . $session_timeout . 'm');

    my ($header) = split("\r\n", $session->header());
    my (undef, $session_cookie) = split(': ', $header);

    my $body = {
        host    => &getHostname(),
        user    => $username,
        version => &getGlobalConfiguration("version"),
    };

    if (my $eload = eval { require Relianoid::ELoad }) {
        $body->{key} = eload(module => 'Relianoid::EE::Certificate::Activation', func => 'getNodeKey');
    }

    &log_info("Login successful for user: $username", $LOG_TAG);

    return &httpResponse({
        code    => 200,
        body    => $body,
        headers => { 'Set-cookie' => "${session_cookie}; SameSite=None; Secure; HttpOnly" },
    });
}

# DELETE /session
sub session_logout_controller () {
    my $desc = "Logout of session";
    my $cgi  = &getCGI();

    unless ($cgi->http('Cookie')) {
        my $msg = "Session cookie not found";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $session = CGI::Session->new($cgi);

    unless ($session && $session->param('is_logged_in')) {
        my $msg = "Session expired or not found";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $username = $session->param('username');
    my $ip_addr  = $session->param('_SESSION_REMOTE_ADDR');

    &log_info("Logged out user $username from $ip_addr", $LOG_TAG);

    $session->delete();
    $session->flush();

    return &httpResponse({ code => 200 });
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/Stats.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::System;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::Stats

=cut

my $eload = eval { require Relianoid::ELoad };

# Get all farm stats
sub _get_all_farm_stats_controller () {
    require Relianoid::Farm::Core;
    require Relianoid::Farm::Base;

    my @files = &getFarmList();
    my @farms;

    for my $file (@files) {
        my $name = &getFarmName($file);
        my $type = &getFarmType($name);

        if ($type eq 'eproxy' && $eload) {
            my $farm_stats = &eload(
                module => 'Relianoid::EE::Farm::Eproxy::Stats',
                func   => 'getEproxyFarmStats',
                args   => [ { 'farm_name' => $name } ],
            );
            push(@farms, $farm_stats);
        }
        else {
            my $status      = &getFarmVipStatus($name);
            my $vip         = &getFarmVip('vip',  $name);
            my $port        = &getFarmVip('vipp', $name);
            my $established = 0;
            my $pending     = 0;

            # datalink has no stats
            if ($type eq 'datalink') {
                $established = undef;
                $pending     = undef;
            }
            elsif ($status ne "down") {
                require Relianoid::Net::ConnStats;
                require Relianoid::Farm::Stats;

                my $netstat;
                $netstat = &getConntrack('', $vip, '', '', '')
                if $type !~ /^https?$/;

                $pending     = &getFarmSYNConns($name, $netstat);
                $established = &getFarmEstConns($name, $netstat);
            }

            push @farms,
            {
                farmname    => $name,
                profile     => $type,
                status      => $status,
                vip         => $vip,
                vport       => $port,
                established => $established,
                pending     => $pending,
            };
        }
    }

    if ($eload) {
        @farms = @{
            &eload(
                module => 'Relianoid::EE::RBAC::Group::Core',
                func   => 'getRBACUserSet',
                args   => [ 'farms', \@farms ],
            )
        };
    }

    return \@farms;
}

#Get Farm Stats
sub get_farm_stats_controller ($farmname, $servicename = undef) {
    if ($farmname eq 'modules') { return; }
    if ($farmname eq 'total')   { return; }

    require Relianoid::Farm::Core;

    my $desc = "Get farm stats";

    if (!&getFarmExists($farmname)) {
        my $msg = "The farmname $farmname does not exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $type = &getFarmType($farmname);

    if (defined $servicename
        && ($type ne 'http' && $type ne 'https' && $type ne 'gslb'))
    {
        my $msg = "The $type farm profile does not support services.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($type eq "http" || $type eq "https") {
        require Relianoid::Farm::HTTP::Stats;

        if (defined $servicename) {
            # validate SERVICE
            require Relianoid::Farm::Service;
            my @services      = &getFarmServices($farmname);
            my $found_service = grep { $servicename eq $_ } @services;

            if (not $found_service) {
                my $msg = "The service $servicename does not exist for $farmname.";
                return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
            }
        }

        my $stats = &getHTTPFarmBackendsStats($farmname, $servicename);

        my $body;
        if ($stats eq -1) {
            $body = {
                warning        => "It was not possible to extract the sessions.",
                description    => $desc,
                backends       => [],
                sessions       => [],
                total_sessions => 0,
            };
        }
        else {
            $body = {
                description    => $desc,
                backends       => $stats->{backends},
                sessions       => $stats->{sessions},
                total_sessions => $#{ $stats->{sessions} } + 1,
            };
        }
        return &httpResponse({ code => 200, body => $body });
    }

    if ($type eq "l4xnat") {
        my $backends = [];
        my $sessions = [];

        require Relianoid::Farm::L4xNAT::Config;

        if (&getL4FarmStatus($farmname) ne "down") {
            require Relianoid::Farm::L4xNAT::Stats;
            $backends = &getL4FarmBackendsStats($farmname);

            require Relianoid::HTTP::Adapters::Backend;
            &getBackendsResponse($backends, $type, [ 'established', 'pending' ]);

            require Relianoid::Farm::L4xNAT::Sessions;
            $sessions = &listL4FarmSessions($farmname);
        }

        my $body = {
            description    => $desc,
            backends       => $backends,
            sessions       => $sessions,
            total_sessions => $#{$sessions} + 1,
        };

        return &httpResponse({ code => 200, body => $body });
    }

    if ($type eq "gslb" && $eload) {
        my $gslb_stats;

        my $gslbStatus = &eload(
            module => 'Relianoid::EE::Farm::GSLB::Config',
            func   => 'getGSLBFarmStatus',
            args   => [$farmname],
        );
        if ($gslbStatus ne "down") {
            if (defined $servicename) {
                my @services = &eload(
                    module => 'Relianoid::EE::Farm::GSLB::Service',
                    func   => 'getGSLBFarmServices',
                    args   => [$farmname],
                );

                # check if the SERVICE exists
                unless (grep { $servicename eq $_ } @services) {
                    my $msg = "Could not find the requested service.";
                    return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
                }
            }
            $gslb_stats = &eload(
                module => 'Relianoid::EE::Farm::GSLB::Stats',
                func   => 'getGSLBFarmBackendsStats',
                args   => [ $farmname, $servicename ],
                decode => 'true'
            );
        }

        my $body = {
            description => $desc,
            backends    => $gslb_stats->{backends} // [],
            client      => $gslb_stats->{udp}      // [],
            server      => $gslb_stats->{tcp}      // [],
            extended    => $gslb_stats->{stats}    // [],
        };

        return &httpResponse({ code => 200, body => $body });
    }

    if ($type eq "eproxy" && $eload) {
        my $backend_stats = &eload(
            module => 'Relianoid::EE::Farm::Eproxy::Stats',
            func   => 'getEproxyFarmBackendsStats',
            args   => [{ farm_name => $farmname, service_name => $servicename}],
        );

        my $body = {
            description    => $desc,
            backends       => $backend_stats,
#            sessions       => $stats->{sessions},
#            total_sessions => $#{ $stats->{sessions} } + 1,
        };
        return &httpResponse({ code => 200, body => $body });
    }

}

#Get Farm Stats
sub list_farms_stats_controller () {
    my $farms = &_get_all_farm_stats_controller();

    my $body = {
        description => "List all farms stats",
        farms       => $farms,
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET /stats
sub get_stats_controller () {
    require Relianoid::Stats;
    require Relianoid::SystemInfo;

    my @data_mem  = &getMemStats();
    my @data_load = &getLoadStats();
    my @data_net  = &getNetworkStats();
    my @data_cpu  = &getCPU();

    my $out = {
        'hostname' => &getHostname(),
        'date'     => &getDate(),
    };

    for my $x (0 .. @data_mem - 1) {
        my $name  = $data_mem[$x][0];
        my $value = $data_mem[$x][1] + 0;
        $out->{memory}{$name} = $value;
    }

    for my $x (0 .. @data_load - 1) {
        my $name  = $data_load[$x][0];
        my $value = $data_load[$x][1] + 0;

        $name =~ s/ /_/;
        $name = 'Last_1' if $name eq 'Last';
        $out->{load}{$name} = $value;
    }

    for my $x (0 .. @data_cpu - 1) {
        my $name  = $data_cpu[$x][0];
        my $value = $data_cpu[$x][1] + 0;

        $name =~ s/CPU//;
        $out->{cpu}{$name} = $value;
    }

    $out->{cpu}{cores} = &getCpuCores();

    for my $x (0 .. @data_net - 1) {
        my $name;
        if ($x % 2 == 0) {
            $name = $data_net[$x][0] . ' in';
        }
        else {
            $name = $data_net[$x][0] . ' out';
        }
        my $value = $data_net[$x][1] + 0;
        $out->{network}{$name} = $value;
    }

    my $body = {
        description => "System stats",
        params      => $out
    };

    return &httpResponse({ code => 200, body => $body });
}

#GET /stats/system/network
sub get_stats_network_controller () {
    require Relianoid::Stats;
    require Relianoid::SystemInfo;

    my @interfaces = &getNetworkStats('hash');
    my $output;
    $output->{hostname}   = &getHostname();
    $output->{date}       = &getDate();
    $output->{interfaces} = \@interfaces;

    my $body = {
        description => "Network interefaces usage",
        params      => $output
    };

    return &httpResponse({ code => 200, body => $body });
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/Backup.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Backup;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::Backup

=cut

# GET /system/backup
sub list_backups_controller () {
    my $desc    = "Get backups";
    my $backups = &getBackup();

    return &httpResponse({ code => 200, body => { description => $desc, params => $backups } });
}

# POST /system/backup
sub create_backup_controller ($json_obj) {
    my $desc = "Create a backups";

    my $params = &getAPIModel("system_backup-create.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    if (&getExistsBackup($json_obj->{name})) {
        my $msg = "A backup already exists with this name.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $error = &createBackup($json_obj->{name});
    if ($error) {
        my $msg = "Error creating backup.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $msg  = "Backup $json_obj->{ 'name' } was created successfully.";
    my $body = {
        description => $desc,
        params      => $json_obj->{name},
        message     => $msg,
    };

    return &httpResponse({ code => 200, body => $body });
}

# GET /system/backup/BACKUP
sub download_backup_controller ($backup) {
    my $desc = "Download a backup";

    if (!&getExistsBackup($backup)) {
        my $msg = "Not found $backup backup.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $backup_dir           = &getGlobalConfiguration('backupdir');
    my $backup_filename      = &getBackupFilename($backup);

    return &httpDownloadResponse(desc => $desc, dir => $backup_dir, file => $backup_filename);
}

# PUT /system/backup/BACKUP
sub upload_backup_controller ($upload_filehandle, $name) {
    my $desc = "Upload a backup";

    if (!$upload_filehandle || !$name) {
        my $msg = "It's necessary to add a data binary file.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    elsif (&getExistsBackup($name)) {
        my $msg = "A backup already exists with this name.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    elsif (!&getValidFormat('backup', $name)) {
        my $msg = "The backup name has invalid characters.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $error = &uploadBackup($name, $upload_filehandle);
    if ($error == 1) {
        my $msg = "Error creating backup.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }
    elsif ($error == 2) {
        my $msg = "$name is not a valid backup.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $msg  = "Backup $name was created successfully.";
    my $body = { description => $desc, params => $name, message => $msg };

    return &httpResponse({ code => 200, body => $body });
}

# DELETE /system/backup/BACKUP
sub delete_backup_controller ($backup) {
    my $desc = "Delete backup $backup'";

    if (!&getExistsBackup($backup)) {
        my $msg = "$backup doesn't exist.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $error = &deleteBackup($backup);

    if ($error) {
        my $msg = "There was a error deleting list $backup.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $msg  = "The list $backup has been deleted successfully.";
    my $body = {
        description => $desc,
        success     => "true",
        message     => $msg,
    };

    return &httpResponse({ code => 200, body => $body });
}

# POST /system/backup/BACKUP/actions
sub restore_backup_controller ($json_obj, $backup) {
    my $desc = "Restore a backup to the system";

    my $params = &getAPIModel("system_backup-restore.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    if (!&getExistsBackup($backup)) {
        my $msg = "Not found $backup backup.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $b_version   = &getBackupVersion($backup);
    my $sys_version = &getGlobalConfiguration('version');
    if ($b_version ne $sys_version) {
        if (not exists $json_obj->{force}
            or (exists $json_obj->{force} and $json_obj->{force} ne 'true'))
        {
            my $msg =
              "The backup version ($b_version) is different to the Relianoid version ($sys_version). The parameter 'force' must be used to force the restore.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
        else {
            &log_info("Restoring The backup version ($b_version) is different to the Relianoid version ($sys_version).");
        }
    }

    my $msg   = "The restore was properly applied. Some changes need a system reboot to work.";
    my $error = &restoreBackup($backup);

    if ($error) {
        $msg = "There was a error restoring the backup.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    return &httpResponse({ code => 200, body => { description => $desc, message => $msg } });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/Info.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::System;

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::Info

=cut

# show license
# GET /system/license/($license_re)
sub get_license_controller ($format) {
    my $desc = "Get license";
    my $licenseFile;

    if ($format eq 'txt') {
        $licenseFile = &getGlobalConfiguration('licenseFileTxt');
    }
    elsif ($format eq 'html') {
        $licenseFile = &getGlobalConfiguration('licenseFileHtml');
    }
    else {
        my $msg = "Not found license.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $file = &slurpFile($licenseFile);

    return &httpResponse({ code => 200, body => $file, type => 'text/plain' });
}

# GET /system/supportsave
sub get_supportsave_controller () {
    my $desc = "Get supportsave file";

    my $req_size = &checkSupportSaveSpace();
    if ($req_size) {
        my $space = &getSpaceFormatHuman($req_size);
        my $msg   = "Supportsave cannot be generated because '/tmp' needs '$space' Bytes of free space";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $ss_filename = &getSupportSave();

    return &httpDownloadResponse(desc => $desc, dir => '/tmp', file => $ss_filename);
}

# GET /system/version
sub get_version_controller () {
    require Relianoid::SystemInfo;

    my $desc = "Get version";

    my $params = {
        'kernel_version'    => &getKernelVersion(),
        'relianoid_version' => &getGlobalConfiguration('version'),
        'hostname'          => &getHostname(),
        'system_date'       => &getDate(),
        'appliance_version' => &getApplianceVersion(),
    };

    # For compatibility with previous versions
    $params->{zevenet_version} = $params->{relianoid_version};

    my $body = { description => $desc, params => $params };

    return &httpResponse({ code => 200, body => $body });
}

# GET /system/info
sub get_system_info_controller () {
    require Relianoid::SystemInfo;
    require Relianoid::User;
    require Relianoid::API;

    my $desc = "Get the system information";

    my @api_versions = &getApiVersionsList();

    my $params = {
        'system_date'             => &getDate(),
        'appliance_version'       => &getApplianceVersion(),
        'kernel_version'          => &getKernelVersion(),
        'relianoid_version'       => &getGlobalConfiguration('version'),
        'hostname'                => &getHostname(),
        'user'                    => &getUser(),
        'supported_zapi_versions' => \@api_versions,
        'supported_api_versions'  => \@api_versions,
        'last_zapi_version'       => $api_versions[-1],
        'last_api_version'        => $api_versions[-1],
        'edition'                 => $eload ? "enterprise" : "community",
        'language'                => &getGlobalConfiguration('lang'),
        'platform'                => &getGlobalConfiguration('cloud_provider'),
    };

    # For compatibility with previous versions
    $params->{zevenet_version} = $params->{relianoid_version};

    if ($eload) {
        $params = &eload(
            module => 'Relianoid::EE::System::Ext',
            func   => 'getSystemInfoExt',
            args   => [$params],
        );
    }

    my $body = { description => $desc, params => $params };
    return &httpResponse({ code => 200, body => $body });
}

# POST /system/language
sub set_language_controller ($json_obj) {
    my $desc   = "Modify the WebGUI language";
    my $params = &getAPIModel("system_language-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # Check allowed parameters
    &setGlobalConfiguration('lang', $json_obj->{language});

    return &httpResponse({
        code => 200,
        body => {
            description => $desc,
            params      => { language => &getGlobalConfiguration('lang') },
            message     => "The WebGui language has been configured successfully"
        }
    });
}

# GET /system/language
sub get_language_controller () {
    my $desc = "List the WebGUI language";
    my $lang = &getGlobalConfiguration('lang') || 'en';

    return &httpResponse({
        code => 200,
        body => {
            description => $desc,
            params      => { lang => $lang },
        }
    });
}

# GET /system/packages
sub get_packages_info_controller () {
    require Relianoid::System::Packages;

    my $desc   = "Relianoid packages list info";
    my $output = &getSystemPackagesUpdatesList();

    if (defined $output->{number}) {
        $output->{number} += 0;
    }

    return &httpResponse({ code => 200, body => { description => $desc, params => $output } });
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/Log.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::System::Log;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::Log

=cut

#	GET	/system/logs
sub list_logs_controller () {
    my $desc = "Get logs";
    my $logs = &getLogs();

    return &httpResponse({ code => 200, body => { description => $desc, params => $logs } });
}

#	GET	/system/logs/LOG
sub download_logs_controller ($logFile) {
    my $desc     = "Download log file '$logFile'";
    my $logfiles = &getLogs();
    my $error    = 1;

    # check if the file exists
    for my $file (@{$logfiles}) {
        if ($file->{file} eq $logFile) {
            $error = 0;
            last;
        }
    }

    if ($error) {
        my $msg = "Not found $logFile file.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    # Download function ends communication if itself finishes successful. It is not necessary send "200 OK" msg
    my $logdir = &getGlobalConfiguration('logdir');

    return &httpDownloadResponse(desc => $desc, dir => $logdir, file => $logFile);
}

#	GET	/system/logs/LOG/lines/LINES
sub show_logs_controller ($logFile, $lines_number) {
    my $desc     = "Show a log file";
    my $logfiles = &getLogs();
    my $error    = 1;

    # check if the file exists
    for my $file (@{$logfiles}) {
        if ($file->{file} eq $logFile) {
            $error = 0;
            last;
        }
    }

    if ($error) {
        my $msg = "Not found $logFile file.";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $lines = &getLogLines($logFile, $lines_number);
    my $body  = { description => $desc, log => $lines };

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/Service/DNS.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::Service::DNS

=cut

# GET /system/dns
sub get_dns_controller () {
    require Relianoid::System::DNS;

    my $desc = "Get dns";
    my $dns  = &getDns();

    return &httpResponse({ code => 200, body => { description => $desc, params => $dns } });
}

#  POST /system/dns
sub set_dns_controller ($json_obj) {
    require Relianoid::System::DNS;

    my $desc = "Modify the DNS";

    my $params = &getAPIModel("system_dns-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    for my $key (keys %{$json_obj}) {
        my $msg = &setDns($key, $json_obj->{$key});
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg }) if $msg;
    }

    my $dns = &getDns();

    return &httpResponse({
        code => 200,
        body => {
            description => $desc,
            params      => $dns,
            message     => "The DNS service has been updated successfully."
        }
    });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/Service/NTP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::Service::NTP

=cut

# GET /system/ntp
sub get_ntp_controller () {
    my $desc = "Get ntp";
    my $ntp  = &getGlobalConfiguration('ntp');

    return &httpResponse({
        code => 200,
        body => { description => $desc, params => { "server" => $ntp } }
    });
}

#  POST /system/ntp
sub set_ntp_controller ($json_obj) {
    my $desc = "Post ntp";

    my $params = &getAPIModel("system_ntp-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    my $error = &setGlobalConfiguration('ntp', $json_obj->{server});

    if ($error) {
        my $msg = "There was a error modifying ntp.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    my $ntp = &getGlobalConfiguration('ntp');
    return &httpResponse({
        code => 200,
        body => {
            description => $desc,
            params      => $ntp,
            message     => "The NTP service has been updated successfully."
        }
    });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/Service/Proxy.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::System::Proxy;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::Service::Proxy

=cut

# GET /system/proxy
sub get_proxy_controller () {
    my $desc = "Get proxy configuration";

    return &httpResponse({
        code => 200,
        body => { description => $desc, params => &getProxyResponse() }
    });
}

#  POST /system/proxy
sub set_proxy_controller ($json_obj) {
    my $desc   = "Configuring proxy";
    my $params = &getAPIModel("system_proxy-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    if (&setProxy($json_obj)) {
        my $msg = "There was a error modifying the proxy configuration.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    # Proxy needs to be updated in apt module
    require Relianoid::Apt;
    &setAPTProxy();

    return &httpResponse({
        code => 200,
        body => {
            description => $desc,
            params      => &getProxyResponse(),
            message     => "The Proxy service has been updated successfully."
        }
    });
}

sub getProxyResponse () {
    my $proxy = &getProxy();

    return {
        "http_proxy"  => $proxy->{http_proxy},
        "https_proxy" => $proxy->{https_proxy}
    };
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/Service/SNMP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::SNMP;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::Service::SNMP

=cut

# GET /system/snmp
sub get_snmp_controller () {
    my $desc = "Get snmp";
    my $snmp = &translateSNMPConfigToApi(&getSnmpdConfig());

    return &httpResponse({ code => 200, body => { description => $desc, params => $snmp } });
}

#  POST /system/snmp
sub set_snmp_controller ($json_obj) {
    my $desc = "Post snmp";

    require Relianoid::Net::Interface;
    my $ip_list = &getIpAddressList();
    push @{$ip_list}, '*';

    my $params = &getAPIModel("system_snmp-modify.json");
    $params->{ip}{values} = $ip_list;

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # check scope value
    if (defined $json_obj->{scope}) {
        my $network = NetAddr::IP->new($json_obj->{scope})->network();
        if ($network ne $json_obj->{scope}) {
            my $msg = "The value '$json_obj->{ 'scope' }' is not a valid network value for the parameter 'scope'.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    my $snmp = &getSnmpdConfig();

    my $status = $json_obj->{status} // $snmp->{status};
    my $port   = $json_obj->{port}   // $snmp->{port};
    my $ip     = $json_obj->{ip}     // $snmp->{ip};

    if (($port ne $snmp->{port}) or ($ip ne $snmp->{ip})) {
        if ($status eq 'true' and not &validatePort($ip, $port, 'udp', undef, 'snmp')) {
            my $msg = "The '$ip' ip and '$port' port are in use.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    delete $json_obj->{status} if exists $json_obj->{status};
    for my $key (keys %{$json_obj}) {
        $snmp->{$key} = $json_obj->{$key};
    }

    my $error = &setSnmpdConfig($snmp);
    &translateSNMPConfigToApi($snmp);

    if ($error) {
        my $msg = "There was an error modifying SNMP.";
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
    }

    if ($status eq 'true' && $snmp->{status} eq 'false') {
        &setSnmpdStatus('true');
    }
    elsif ($status eq 'false' && $snmp->{status} eq 'true') {
        &setSnmpdStatus('false');
    }
    elsif ($status ne 'false' && $snmp->{status} ne 'false') {
        &setSnmpdStatus('false');
        &setSnmpdStatus('true');
    }

    # wait to check pid values
    sleep(1);
    $snmp->{status} = &getSnmpdStatus();

    return &httpResponse({
        code => 200,
        body => {
            description => $desc,
            params      => $snmp,
            message     => "The SNMP service has been updated successfully."
        }
    });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/HTTP/Controllers/API/System/User.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

require Relianoid::User;

=pod

=head1 Module

Relianoid::HTTP::Controllers::API::System::User

=cut

my $eload = eval { require Relianoid::ELoad };

# 	GET /system/users
sub get_system_user_controller () {
    my $user = &getUser();

    my $desc = "Retrieve the user $user";

    if ('root' eq $user) {
        require Relianoid::API;

        my $api_status = &getAPI("status");
        my $params     = {
            user             => $user,
            api_permissions  => $api_status,
            zapi_permissions => $api_status,
            service          => 'local'

            # it is configured if the status is up
            # 'api_key'	=> &getAPI( "api_key" ),
        };

        return &httpResponse({
            code => 200,
            body => { description => $desc, params => $params }
        });
    }

    elsif ($eload) {
        my $params = &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::RBAC::User',
            func   => 'get_system_user_rbac',
        );

        if ($params) {
            return &httpResponse({
                code => 200,
                body => { description => $desc, params => $params }
            });
        }
    }

    my $msg = "The user is not found";
    return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
}

#  POST /system/users
sub set_system_user_controller ($json_obj) {
    require Relianoid::Login;

    my $error = 0;
    my $user  = &getUser();
    my $desc  = "Modify the user $user";

    my $params = &getAPIModel("system_user-modify.json");

    # Check allowed parameters
    if (my $error_msg = &checkApiParams($json_obj, $params, $desc)) {
        return &httpErrorResponse({ code => 400, desc => $desc, msg => $error_msg });
    }

    # check to change password
    if ($json_obj->{newpassword}) {
        if (not exists $json_obj->{password}) {
            my $msg = "The parameter password is required.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }

        elsif ($json_obj->{newpassword} eq $json_obj->{password}) {
            my $msg = "The new password must be different to the current password.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
        if ($eload) {
            my $local_user = &eload(
                module => 'Relianoid::EE::RBAC::User::Core',
                func   => 'getRBACUserLocal',
                args   => [$user],
            );
            if (!$local_user) {
                my $msg = "The $user User is not valid to change password.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        if (!&checkValidUser($user, $json_obj->{password})) {
            my $msg = "Invalid current password.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    if ($json_obj->{password}) {
        if (not exists $json_obj->{newpassword}) {
            my $msg = "The parameter newpassword is required.";
            return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
        }
    }

    if ($user eq 'root') {
        # modify password
        if (exists $json_obj->{newpassword}) {
            $error = &changePassword($user, $json_obj->{newpassword}, $json_obj->{newpassword});

            if ($error) {
                my $msg = "Modifying $user.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }
        }

        # modify api_key. change this parameter before than API permissions
        if (exists $json_obj->{api_key}) {
            if ($eload) {
                my $api_user = &eload(
                    module => 'Relianoid::EE::RBAC::User::Core',
                    func   => 'getRBACUserByAPIKey',
                    args   => [ $json_obj->{api_key} ],
                );

                if ($api_user and $api_user ne $user) {
                    my $msg = "The api_key is not valid.";
                    return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
                }
            }
            &setAPI('key', $json_obj->{api_key});
        }

        # modify API permissions
        my $json_api_permissions = $json_obj->{api_permissions} // $json_obj->{zapi_permissions};

        if (defined $json_api_permissions) {
            if ($json_api_permissions eq 'true' && !&getAPI('api_key')) {
                my $msg = "It is necessary a api_key to enable the API permissions.";
                return &httpErrorResponse({ code => 400, desc => $desc, msg => $msg });
            }

            if ($json_api_permissions eq 'true' && &getAPI("status") eq 'false') {
                &setAPI("enable");
            }
            elsif ($json_api_permissions eq 'false' && &getAPI("status") eq 'true') {
                &setAPI("disable");
            }
        }
    }

    elsif ($eload) {
        $error = &eload(
            module => 'Relianoid::EE::HTTP::Controllers::API::RBAC::User',
            func   => 'set_system_user_rbac',
            args   => [$json_obj],
        );
    }

    else {
        my $msg = "The user is not found";
        return &httpErrorResponse({ code => 404, desc => $desc, msg => $msg });
    }

    my $msg  = "Settings was changed successfully.";
    my $body = { description => $desc, message => $msg };

    return &httpResponse({ code => 200, body => $body });
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Ids.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Log;
use Relianoid::Config;
use Config::Tiny;

my $eload = eval { require Relianoid::ELoad; };

# TODO
# ipds-rbl-domains
# waf-ruleset
# waf-files

# string to use when a branch of the id tree finishes
my $FIN = undef;

=pod

=head1 Module

Relianoid::Ids

=cut

=pod

=head1 getIdsTree

=cut

sub getIdsTree () {
    require Relianoid::Farm::Core;
    require Relianoid::FarmGuardian;
    require Relianoid::Net::Interface;
    require Relianoid::Certificate;
    require Relianoid::Backup;
    require Relianoid::System::Log;

    my $l4_default_srv_tag = "default_service";

    my $tree = $FIN;
    $tree->{farms} = $FIN;

    for my $type ('https', 'http', 'l4xnat', 'gslb', 'datalink') {
        my @farms = &getFarmsByType($type);

        # add farm
        for my $f (@farms) {
            require Relianoid::Farm::Service;
            $tree->{farms}{$f}{services} = $FIN;

            # add srv
            my @srv = ($type =~ /http|gslb/) ? &getFarmServices($f) : ($l4_default_srv_tag);

            for my $s (@srv) {
                require Relianoid::Farm::Backend;

                $tree->{farms}{$f}{services}{$s}{backends} = $FIN;

                # add bk
                my $bks = &getFarmServerIds($f, $s);

                for my $b (@{$bks}) {
                    $tree->{farms}{$f}{services}{$s}{backends}{$b} = $FIN;
                }

                my $fg = &getFGFarm($f, ($type =~ /datalink|l4xnat/) ? undef : $s);

                $tree->{farms}{$f}{services}{$s}{fg}{$fg} = $FIN if ($fg ne '');
            }

            # add certificates
            if ($type =~ /http/) {
                my @cnames;
                if ($eload) {
                    @cnames = &eload(module => 'Relianoid::EE::Farm::HTTP::HTTPS::Ext', func => 'getFarmCertificatesSNI', args => [$f],);
                }
                else {
                    require Relianoid::Farm::HTTP::HTTPS;
                    @cnames = (&getFarmCertificate($f));
                }
                $tree->{farms}{$f}{certificates} = &addIdsArrays(\@cnames);
            }

            if ($eload) {
                # add zones
                if ($type eq 'gslb') {
                    my @zones = &eload(module => 'Relianoid::EE::Farm::GSLB::Zone', func => 'getGSLBFarmZones', args => [$f],);
                    $tree->{farms}{$f}{zones} = &addIdsArrays(\@zones);
                }

                # add bl
                my @bl = &eload(module => 'Relianoid::EE::IPDS::Blacklist::Core', func => 'listBLByFarm', args => [$f],);

                $tree->{farms}{$f}{ipds}{blacklists} = &addIdsArrays(\@bl);

                # add dos
                my @dos = &eload(module => 'Relianoid::EE::IPDS::DoS::Core', func => 'listDOSByFarm', args => [$f],);
                $tree->{farms}{$f}{ipds}{dos} = &addIdsArrays(\@dos);

                # add rbl
                my @rbl = &eload(module => 'Relianoid::EE::IPDS::RBL::Core', func => 'listRBLByFarm', args => [$f],);
                $tree->{farms}{$f}{ipds}{rbl} = &addIdsArrays(\@rbl);

                #add waf
                if ($type =~ /http/) {
                    my @waf = &eload(module => 'Relianoid::EE::IPDS::WAF::Core', func => 'listWAFByFarm', args => [$f],);
                    $tree->{farms}{$f}{ipds}{waf} = &addIdsArrays(\@waf);
                }
            }
        }
    }

    # add fg
    my @fg = &getFGList();
    $tree->{farmguardians} = &addIdsArrays(\@fg);

    # add ssl certs
    my @certs = &getCertFiles();
    $tree->{certificates} = &addIdsArrays(\@certs);

    # add interfaces
    my @if_list = ('nic', 'vlan', 'virtual');
    push @if_list, 'bond' if ($eload);

    for my $type (@if_list) {
        my $if_key = ($type eq 'bond') ? 'bonding' : $type;
        $tree->{interfaces}{$if_key} = $FIN;

        my @list = &getInterfaceTypeList($type);

        for my $if (@list) {
            $tree->{interfaces}{$if_key}{ $if->{name} } = $FIN;
        }
    }

    # add routing
    require Relianoid::Net::Route;
    my @routing_table = listRoutingTablesNames();
    $tree->{routing}{tables} = &addIdsArrays(\@routing_table);

    if ($eload) {
        # add floating interfaces
        my $float = &eload(module => 'Relianoid::EE::Net::Floating', func => 'getFloatingList',);
        $tree->{interfaces}{floating} = &addIdsArrays($float);

        # add ipds rules
        $tree->{ipds} = &eload(module => 'Relianoid::EE::IPDS::Core', func => 'getIPDSIds',);

        # add rbac
        my @users  = &eload(module => 'Relianoid::EE::RBAC::User::Core',   func => 'getRBACUserList',);
        my @groups = &eload(module => 'Relianoid::EE::RBAC::Group::Core',  func => 'getRBACGroupList',);
        my @roles  = &eload(module => 'Relianoid::EE::RBAC::Role::Config', func => 'getRBACRolesList',);
        $tree->{rbac}{users}  = &addIdsArrays(\@users);
        $tree->{rbac}{roles}  = &addIdsArrays(\@roles);
        $tree->{rbac}{groups} = &addIdsArrays(\@groups);

        for my $g (@groups) {
            my $g_cfg = &eload(module => 'Relianoid::EE::RBAC::Group::Core', func => 'getRBACGroupObject', args => [$g]);

            $tree->{rbac}{groups}{$g}{users}      = &addIdsArrays($g_cfg->{users});
            $tree->{rbac}{groups}{$g}{farms}      = &addIdsArrays($g_cfg->{farms});
            $tree->{rbac}{groups}{$g}{interfaces} = &addIdsArrays($g_cfg->{interfaces});
        }

        # add aliases
        my $alias_bck_ref = &eload(module => 'Relianoid::EE::Alias', func => 'getAlias', args => ['backend'],);
        my $alias_if_ref  = &eload(module => 'Relianoid::EE::Alias', func => 'getAlias', args => ['interface'],);
        $tree->{aliases}{backends}   = &addIdsKeys($alias_bck_ref);
        $tree->{aliases}{interfaces} = &addIdsKeys($alias_if_ref);
    }

    # add backups
    my $backups = &getBackup();
    for my $b (@{$backups}) {
        $tree->{system}{backup}{ $b->{name} } = $FIN;
    }

    # add logs
    my $logs = &getLogs();
    $tree->{system}{logs} = $FIN;
    for my $l (@{$logs}) {
        $tree->{system}{logs}{ $l->{file} } = $FIN;
    }

    return $tree;
}

=pod

=head1 addIdsKeys

=cut

sub addIdsKeys ($hash_ref) {
    my @arr_keys = keys %{$hash_ref};
    return &addIdsArrays(\@arr_keys);
}

=pod

=head1 addIdsArrays

=cut

sub addIdsArrays ($arr) {
    my $out = {};

    for my $it (@{$arr}) {
        $out->{$it} = $FIN;
    }

    return (!keys %{$out}) ? undef : $out;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/JSON.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use JSON;
use Relianoid::Lock;

my $json = JSON->new->utf8->pretty(1);

# canonical: if true or missing => sort keys
$json->canonical([1]);

=pod

=head1 Module

Relianoid::JSON

=cut

=pod

=head1 decodeJSONFile

=cut

sub decodeJSONFile ($file) {
    my $file_str;
    my $fh = &openlock($file, 'r');
    return if !defined $fh;

    {
        local $/ = undef;
        $file_str = <$fh>;
    }
    close $fh;

    my $f_json;

    eval { $f_json = $json->decode($file_str); };
    if ($@) {
        &log_error("Error decoding the file $file");
        &log_debug("json: $@");
    }

    return $f_json;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Letsencrypt.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Letsencrypt

=cut

=pod

=head1 getLetsencryptConfigPath

Returns the dirpath for Letsencrypt Config

Parameters:

    none

Returns:

    string -  dir path.

=cut

sub getLetsencryptConfigPath () {
    return &getGlobalConfiguration('le_config_path');
}

=pod

=head1 getLetsencryptConfig

Returns the Letsencrypt Config

Parameters:

    none

Returns:

    Hash ref - Letsencrypt Configuration

=cut

sub getLetsencryptConfig () {
    return { email => &getGlobalConfiguration('le_email') };
}

=pod

=head1 setLetsencryptConfig

Set the Letsencrypt Config

Parameters:

    Hash ref

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub setLetsencryptConfig ($le_conf_re) {
    return &setGlobalConfiguration('le_email', $le_conf_re->{email});
}

=pod

=head1 getLetsencryptCronFile

Returns the Letsencrypt Cron Filepath

Parameters:

    none

Returns:

    string - Letsencrypt Cron filepath

=cut

sub getLetsencryptCronFile () {
    return &getGlobalConfiguration('le_cron_file');
}

=pod

=head1 getLetsencryptCertificates

Returns Letsencrypt Certificates

Parameters:

    le_cert_name - String. LE Certificate Name. None means all certificates.

Returns:

    Hash ref - Letsencrypt Certificates

=cut

sub getLetsencryptCertificates ($le_cert_name = undef) {
    my $le_certs_ref = [];

    my $le_config_path = &getLetsencryptConfigPath();
    my $le_live_path   = $le_config_path . "live";

    my $certs;
    if (defined $le_cert_name) {
        push @{$certs}, "$le_cert_name";
    }
    else {
        opendir(my $directory, "$le_live_path");
        while (defined(my $file = readdir $directory)) {
            next if $file eq ".";
            next if $file eq "..";
            push @{$certs}, $file if -d "$le_live_path/$file";
        }
        closedir($directory);
    }

    require Crypt::OpenSSL::X509;
    my $cert_ref;
    my $domains;

    for my $cert (@{$certs}) {
        # name
        $cert_ref->{name} = $cert;

        # key path
        my $key_path = $le_live_path . "/" . $cert . "/privkey.pem";
        $cert_ref->{keypath} = $key_path if (-l $key_path);

        # certificate path
        my $cert_path = $le_live_path . "/" . $cert . "/fullchain.pem";
        if (-l $cert_path) {
            $cert_ref->{certpath} = $cert_path;

            # domains
            eval {
                my $x509 = Crypt::OpenSSL::X509->new_from_file($cert_ref->{certpath});
                my $exts = $x509->extensions_by_name();
                if (defined $exts->{subjectAltName}) {
                    my $value = $exts->{subjectAltName}->to_string() . ", ";
                    @{$domains} = $value =~ /(?:DNS:(.*?), )/g;
                }
            };
            $cert_ref->{domains} = $domains;
        }

        push @{$le_certs_ref}, $cert_ref if defined $domains;
        $cert_ref = undef;
        $domains  = undef;
    }

    return $le_certs_ref;
}

=pod

=head1 getLetsencryptCertificateInfo

Returns the Letsencrypt no Wildcard Certificates Info

Parameters:

    le_cert_name . LE Certificate name

Returns:

    Hash ref - Letsencrypt Certificate Info

=cut

sub getLetsencryptCertificateInfo ($le_cert_name) {
    my $cert_ref  = {};
    my $cert_info = &getLetsencryptCertificates($le_cert_name);

    return if (!$cert_info);

    $cert_info = @{$cert_info}[0];

    require Crypt::OpenSSL::X509;

    my $status = "unknown";
    my $CN     = "";
    my $ISSUER = "";
    my $x509;
    my @domains;

    eval {
        $x509 = Crypt::OpenSSL::X509->new_from_file($cert_info->{certpath});
        my $time_offset = 60 * 60 * 24 * 15;    # 15 days
        if ($x509->checkend(0)) { $status = 'expired' }
        else {
            $status = ($x509->checkend($time_offset)) ? 'about to expire' : 'valid';
        }
        if (defined $x509->subject_name()->get_entry_by_type('CN')) {
            $CN = $x509->subject_name()->get_entry_by_type('CN')->value;
        }
        if (defined $x509->issuer_name()) {
            for my $entry (@{ $x509->issuer_name()->entries() }) {
                $ISSUER .= $entry->value() . ",";
            }
            chop $ISSUER;
        }
        my $exts = $x509->extensions_by_name();
        if (defined $exts->{subjectAltName}) {
            my $value = $exts->{subjectAltName}->to_string() . ", ";
            @domains = $value =~ /(?:DNS:(.*?), )/g;
        }
    };

    $cert_ref->{file}     = $cert_info->{certpath};
    $cert_ref->{type}     = 'LE Certificate';
    $cert_ref->{wildcard} = 'false';
    $cert_ref->{status}   = $status;

    if ($@) {
        $cert_ref->{CN}         = '';
        $cert_ref->{issuer}     = '';
        $cert_ref->{creation}   = '';
        $cert_ref->{expiration} = '';
        $cert_ref->{domains}    = '';
    }
    else {
        $cert_ref->{CN}         = $CN;
        $cert_ref->{issuer}     = $ISSUER;
        $cert_ref->{creation}   = $x509->notBefore();
        $cert_ref->{expiration} = $x509->notAfter();
        $cert_ref->{domains}    = \@domains;
    }

    my $autorenewal = &getLetsencryptCron($le_cert_name);
    $cert_ref->{autorenewal} = $autorenewal if $autorenewal;

    return $cert_ref;
}

=pod

=head1 setLetsencryptFarmService

Configure the Letsencrypt Service on a Farm

Parameters:

    farm_name - Farm Name.
    vip - Virtual IP to use with Temporal Farm.

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub setLetsencryptFarmService ($farm_name, $vip) {
    # if no exists farm return -1,
    my $le_service = &getGlobalConfiguration('le_service');
    my $le_farm    = &getGlobalConfiguration('le_farm');

    my $error;

    require Relianoid::Farm::Core;

    # create a temporal farm
    if ($farm_name eq $le_farm) {
        require Relianoid::Farm::HTTP::Factory;

        if ($error = &runHTTPFarmCreate($vip, 80, $farm_name, "HTTP")) {
            &log_error("Error creating temporal Farm $farm_name", "letsencrypt");
            return 1;
        }

        &log_info("The temporal Farm $farm_name has been created", "letsencrypt");
    }

    #create Letsencrypt service
    require Relianoid::Farm::HTTP::Service;

    # check Letsencrypt service
    my $service_ref = &getHTTPFarmServices($farm_name, $le_service);
    if (not $service_ref) {
        if ($eload) {
            $error = &setFarmHTTPNewService($farm_name, $le_service);
        }
        else {
            $error = &setFarmHTTPNewServiceFirst($farm_name, $le_service);
        }

        if ($error) {
            &log_error("Error creating the service $le_service", "letsencrypt");
            return 1;
        }

        &log_info("The Service $le_service in Farm $farm_name has been created", "letsencrypt");
    }
    else {
        &log_warn("The Service $le_service in Farm $farm_name already exists", "letsencrypt");
    }

    if ($eload) {
        #Move the service to position 0
        if (not $service_ref or $service_ref->{$le_service}) {
            $error = &eload(
                module => 'Relianoid::EE::Farm::HTTP::Service::Ext',
                func   => 'setHTTPFarmMoveService',
                args   => [ $farm_name, $le_service, 0 ],
            );
            if ($error) {
                &log_error("Error moving the service $le_service", "letsencrypt");
                return 4;
            }
        }
        else {
            &log_warn("The Service $le_service in Farm $farm_name is already in the first position", "letsencrypt");
        }
    }

    # create local Web Server Backend
    require Relianoid::Farm::HTTP::Backend;
    $error = &setHTTPFarmServer("", "127.0.0.1", 80, "", "", $farm_name, $le_service);
    if ($error) {
        &log_error("Error creating the Local Web Server backend on service $le_service", "letsencrypt");
        return 2;
    }

    # create Letsencrypt URL Pattern http challenge
    $error = &setHTTPFarmVS($farm_name, $le_service, "urlp", "^/.well-known/acme-challenge/");
    if ($error) {
        &log_error("Error creating the URL pattern on service $le_service", "letsencrypt");
        return 3;
    }

    &log_info("The Service $le_service in Farm $farm_name has been configured", "letsencrypt");

    # Restart the farm
    require Relianoid::Farm::Action;

    if ($error = &runFarmStop($farm_name, "")) {
        &log_error("Error stopping the farm $farm_name", "letsencrypt");
        return 5;
    }

    $error = &runFarmStart($farm_name, "");
    if ($error) {
        &log_error("Error starting the farm $farm_name", "letsencrypt");
        return 6;
    }

    &log_info("The Farm $farm_name has been restarted", "letsencrypt");

    return 0;
}

=pod

=head1 unsetLetsencryptFarmService

Remove the Letsencrypt Service on a Farm

Parameters:

    farm_name - Farm Name.

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub unsetLetsencryptFarmService ($farm_name) {
    # if no exists farm return -1,
    my $le_service = &getGlobalConfiguration('le_service');
    my $le_farm    = &getGlobalConfiguration('le_farm');

    if ($farm_name eq $le_farm) {
        require Relianoid::Farm::Action;

        if (my $error = &runFarmStop($farm_name)) {
            &log_error("Error stopping the farm $farm_name", "letsencrypt");
            return 1;
        }

        if (my $error = &runFarmDelete($farm_name)) {
            &log_error("Error deleting the farm $farm_name", "letsencrypt");
            return 2;
        }

        &log_info("The Farm $farm_name has been deleted", "letsencrypt");
    }
    else {
        require Relianoid::Farm::HTTP::Service;

        if (&getHTTPFarmServices($farm_name, $le_service)) {
            if (my $error = &delHTTPFarmService($farm_name, $le_service)) {
                &log_error("Error Deleting the service $le_service on farm $farm_name", "letsencrypt");
                return 3;
            }
            &log_info("The service $le_service on farm $farm_name has been deleted", "letsencrypt");

            # Restart the farm
            require Relianoid::Farm::Action;

            if (my $error = &runFarmStop($farm_name, "")) {
                &log_error("Error stopping the farm $farm_name", "letsencrypt");
                return 1;
            }

            if (my $error = &runFarmStart($farm_name, "")) {
                &log_error("Error starting the farm $farm_name", "letsencrypt");
                return 4;
            }

            &log_info("The Farm $farm_name has been restarted", "letsencrypt");
        }
        else {
            &log_warn("The Service $le_service in Farm $farm_name can not be deleted, it does not exist", "letsencrypt");
        }
    }

    return 0;
}

=pod

=head1 runLetsencryptLocalWebserverStart

Start Local Webserver listening on localhost:80

Parameters:

    None

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub runLetsencryptLocalWebserverStart () {
    my $http_dir                 = &getGlobalConfiguration('http_server_dir');
    my $pid_file                 = "$http_dir/var/run/cherokee_localhost.pid";
    my $le_webserver_config_file = &getGlobalConfiguration('le_webserver_config_file');
    my $http_bin                 = &getGlobalConfiguration('http_bin');

    my $rc = 0;

    my $status = &getLetsencryptLocalWebserverRunning();

    if ($status == 1) {
        &log_info("$http_bin -d -C $le_webserver_config_file", "letsencrypt");
        &logAndRunBG("$http_bin -d -C $le_webserver_config_file");
    }

    use Time::HiRes qw(usleep);
    my $retry     = 0;
    my $max_retry = 50;
    while (not -f $pid_file and $retry < $max_retry) {
        $retry++;
        usleep(100_000);
    }
    if (not -f $pid_file) {
        &log_error("Error starting Local Web Server", "letsencrypt");
        $rc = 1;
    }
    else {
        &log_info("Letsencrypt Local Web Server is running", "letsencrypt");
    }

    return $rc;
}

=pod

=head1 runLetsencryptLocalWebserverStop

Stop Local Webserver listening on localhost:80

Parameters:

    None

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub runLetsencryptLocalWebserverStop () {
    my $http_dir = &getGlobalConfiguration('http_server_dir');
    my $pid_file = "$http_dir/var/run/cherokee_localhost.pid";
    my $pid      = "0";
    my $kill_bin = &getGlobalConfiguration('kill_bin');
    my $cat_bin  = &getGlobalConfiguration('cat_bin');

    my $status = &getLetsencryptLocalWebserverRunning();

    if ($status == 0) {
        $pid = &logAndGet("$cat_bin $pid_file");
        my $error = &logAndRun("$kill_bin -15 $pid");
        if ($error) {
            &log_error("Error stopping Letsencrypt Local Web Server", "letsencrypt");
            return 1;
        }
        use Time::HiRes qw(usleep);
        my $retry     = 0;
        my $max_retry = 20;
        while (-f $pid_file and $retry < $max_retry) {
            $retry++;
            usleep(100_000);
        }
        unlink $pid_file if (-f $pid_file);
        &log_info("Letsencrypt Local Web Server is stopped", "letsencrypt");
    }

    return 0;
}

=pod

=head1 getLetsencryptLocalWebserverRunning

Check Local Webserver is running

Parameters:

    None

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub getLetsencryptLocalWebserverRunning () {
    my $rc;
    my $http_dir = &getGlobalConfiguration('http_server_dir');
    my $pid_file = "$http_dir/var/run/cherokee_localhost.pid";

    if (-f $pid_file) {
        use Relianoid::System;

        if (&checkPidFileRunning($pid_file)) {
            &log_warn("Letsencrypt Local Webser is not running but PID file $pid_file exists!", "letsencrypt");
            unlink $pid_file;
        }
        $rc = 0;
    }
    else {
        my $pgrep                    = &getGlobalConfiguration('pgrep');
        my $http_bin                 = &getGlobalConfiguration('http_bin');
        my $le_webserver_config_file = &getGlobalConfiguration('le_webserver_config_file');

        if (&logAndRunCheck("$pgrep -f \"$http_bin -d -C $le_webserver_config_file\"")) {
            &log_warn("Letsencrypt Local Webserver is running but no PID file $pid_file exists!", "letsencrypt");
            $rc = 2;
        }
        else {
            $rc = 1;
        }
    }

    return $rc;
}

=pod

=head1 setLetsencryptCert

Create RELIANOID Pem Certificate. Dot characters are replaced with underscore character.

Parameters:

    le_cert_name - Certificate main domain name.

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub setLetsencryptCert ($le_cert_name) {
    my $rc = 1;

    my $le_cert_conf = &getLetsencryptCertificates($le_cert_name);
    if (@{$le_cert_conf}) {
        $le_cert_conf = @{$le_cert_conf}[0];
        if (    (defined $le_cert_conf->{certpath})
            and (defined $le_cert_conf->{keypath}))
        {
            if (    (-e $le_cert_conf->{keypath})
                and (-e $le_cert_conf->{certpath}))
            {
                my $cert_name = $le_cert_name;
                $cert_name =~ s/\./_/g;
                my $cat_bin   = &getGlobalConfiguration('cat_bin');
                my $cert_dir  = &getGlobalConfiguration('certdir');
                my $cert_file = "$cert_dir/${cert_name}.pem";
                &logAndRun("$cat_bin $le_cert_conf->{keypath} $le_cert_conf->{certpath} > $cert_file");
                return 1 if (!-f $cert_file);
                $rc = 0;
            }
        }
    }

    return $rc;
}

=pod

=head1 runLetsencryptObtain

Obtain a new LetsEncrypt Certificate for the Domains especified.

Parameters:

    farm_name - Farm Name where Letsencrypt will connect.
    vip - VIP where the new Farm and service is created. The virtual Port will be 80.
    domains_list - List of Domains the certificate is created for.
    test - if "true" the action simulates all the process but no certificate is created.
    force - if "true" forces an update cert and renewal the domains if exists.

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub runLetsencryptObtain ($farm_name = undef, $vip = undef, $domains_list = undef, $test = undef, $force = undef) {
    return 1 if (!$domains_list);
    return 2 if (!$vip && !$farm_name);
    my $status;
    my $rc = 0;

    my $le_farm = &getGlobalConfiguration('le_farm');
    $farm_name = $le_farm if (!$farm_name);

    # check is a wildcard
    my $challenge = "http";

    # start local Web Server
    $status = &runLetsencryptLocalWebserverStart();

    return 1 if $status;

    # add le service
    $status = &setLetsencryptFarmService($farm_name, $vip);
    return 2 if $status;

    # run le_binary command
    my $test_opt      = ($test eq "true")  ? "--test-cert"                      : "";
    my $force_opt     = ($force eq "true") ? "--force-renewal --break-my-certs" : "";
    my $certname_opt  = "--cert-name " . @{$domains_list}[0];
    my $domains_opt   = "-d " . join(',', @{$domains_list});
    my $fullchain_opt = "--fullchain-path " . &getGlobalConfiguration('le_fullchain_path');
    my $method_opt;

    if ($challenge eq "http") {
        $method_opt = "--webroot --webroot-path " . &getGlobalConfiguration('le_webroot_path');
    }
    my $configdir_opt = "--config-dir " . &getLetsencryptConfigPath();
    my $email_opt     = "-m " . &getLetsencryptConfig()->{email};
    my $challenge_opt = "--preferred-challenges $challenge";
    my $opts          = "--agree-tos --no-eff-email -n";

    my $le_binary    = &getGlobalConfiguration('le_certbot_bin');
    my @command_args = (
        $le_binary,     "certonly", $certname_opt, $domains_opt,   $fullchain_opt, $method_opt,
        $configdir_opt, $email_opt, $test_opt,     $challenge_opt, $force_opt,     $opts
    );

    my $cmd = join " ", @command_args;

    &log_info("Executing Letsencrypt obtain command : $cmd", "letsencrypt");

    $status = &logRunAndGet($cmd, "array", 1);

    if ($status->{stderr} and ($challenge eq "http")) {
        &log_error("Letsencrypt obtain command failed!: $status->{stdout}[-1]", "letsencrypt");
        $rc = 3;
    }
    else {
        # create RELIANOID PEM cert
        $status = &setLetsencryptCert(@{$domains_list}[0]);

        if ($status) {
            &log_error("Letsencrypt create PEM cert failed!", "letsencrypt");
            $rc = 4;
        }
    }

    # delete le service
    &unsetLetsencryptFarmService($farm_name);

    # stop local Web Server
    &runLetsencryptLocalWebserverStop();

    return $rc;
}

=pod

=head1 runLetsencryptDestroy

Revoke a LetsEncrypt Certificate.

Parameters:

    le_cert_name - LE Certificate name.

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub runLetsencryptDestroy ($le_cert_name) {
    my $le_config_path = &getLetsencryptConfigPath();
    my $local_path     = &getGlobalConfiguration('localconfig');
    my $le_backup_file = "$local_path/le_backup-$le_cert_name.tgz";
    my $rm_bck_cmd     = "rm -f $le_backup_file";

    return 1 if (!$le_cert_name);
    return 2 if (!-d "$le_config_path/live/$le_cert_name");

    if (-f "$le_backup_file") {
        &logAndRun($rm_bck_cmd);
    }

    my $le_binary = &getGlobalConfiguration('le_certbot_bin');

    # run le_binary revoke command ??
    # revoke --cert-path /PATH/TO/live/$cert_name/cert.pem --key-path /PATH/TO/live/$cert_name/privkey.pem

    # run le_binary delete command
    # delete --cert-name $cert_name --config-dir $le_config_path --reason unspecified

    my $certname_opt  = "--cert-name " . $le_cert_name;
    my $configdir_opt = "--config-dir " . &getLetsencryptConfigPath();
    my $opts          = "--reason unspecified";

    my $cmd = "$le_binary delete $certname_opt $configdir_opt $opts";
    &log_info("Executing Letsencrypt obtain command : $cmd", "letsencrypt");

    my $status = &logRunAndGet($cmd, "array");
    if ($status->{stderr}) {
        &log_error("Letsencrypt delete command failed!", "letsencrypt");
        return 3;
    }
    return 3 if (-d "$le_config_path/live/$le_cert_name");

    return 0;
}

=pod

=head1 runLetsencryptRenew

Renew a LetsEncrypt Certificate.

Parameters:

    le_cert_name  - LetsEncrypt Certificate Name
    farm_name     - Farm Name where Letsencrypt will connect.
    vip           - VIP where the new Farm and service is created. The virtual Port will be 80.
    force         - if "true" forces a renew even the cert not yet due for renewal( over 30 days for expire ).
    lock_fh       - FileHandle to lock the process

Returns: hash reference

Error object.

    code - integer - Error code. 0 on success.
    desc - string - Description of the error.

=cut

sub runLetsencryptRenew ($le_cert_name, $farm_name, $vip, $force, $lock_fh) {
    my $status;
    my $error_ref = { code => 0 };

    if (!$le_cert_name) {
        $error_ref->{code} = 1;
        $error_ref->{desc} = "No 'certificate' param found";
        return $error_ref;
    }

    if (!$vip && !$farm_name) {
        $error_ref->{code} = 1;
        $error_ref->{desc} = "No 'farm' param or 'vip' param found";
        return $error_ref;
    }

    my $le_farm = &getGlobalConfiguration('le_farm');
    $farm_name = $le_farm if (!$farm_name);

    # Lock process
    my $lock_le_renew_fh;
    if (not $lock_fh) {
        my $lock_le_renew = "/tmp/letsencrypt-renew.lock";
        if (not -f $lock_le_renew) {
            my $touch = &getGlobalConfiguration('touch');
            &logAndRun("$touch $lock_le_renew");
        }
        $lock_le_renew_fh = &openlock($lock_le_renew, "w");
    }
    else {
        $lock_le_renew_fh = $lock_fh;
    }

    # start local Web Server
    $status = &runLetsencryptLocalWebserverStart();

    if ($status) {
        $error_ref->{code} = 1;
        $error_ref->{desc} = "Letsencrypt Local Webserver can not be created.";
        close $lock_le_renew_fh;
        return $error_ref;
    }

    # add le service
    $status = &setLetsencryptFarmService($farm_name, $vip);
    if ($status) {
        $error_ref->{code} = 2;
        $error_ref->{desc} = "Letsencrypt Service can not be created.";
        close $lock_le_renew_fh;
        return $error_ref;
    }

    # run le_binary command
    my $test_opt  = &isLetsencryptStaging($le_cert_name) ? "--test-cert"                      : "";
    my $force_opt = ($force eq "true")                   ? "--force-renewal --break-my-certs" : "";

    my $fullchain_opt = "--fullchain-path " . &getGlobalConfiguration('le_fullchain_path');
    my $webroot_opt   = "--webroot --webroot-path " . &getGlobalConfiguration('le_webroot_path');
    my $configdir_opt = "--config-dir " . &getLetsencryptConfigPath();
    my $email_opt     = "-m " . &getLetsencryptConfig()->{email};
    my $opts          = "--preferred-challenges http-01 --agree-tos --no-eff-email -n --no-random-sleep-on-renew";

    my $le_binary = &getGlobalConfiguration('le_certbot_bin');
    my $cmd =
      "$le_binary certonly -d $le_cert_name $fullchain_opt $webroot_opt $configdir_opt $email_opt $test_opt $force_opt $opts";

    &log_info("Executing Letsencrypt renew command : $cmd", "letsencrypt");
    $status = &logRunAndGet($cmd, "array");

    alarm(0);

    if ($status->{stderr}) {
        my $error_response = "Error creating new order";

        if (my ($le_msg) = grep { /$error_response/ } @{ $status->{stdout} }) {
            &log_error("$le_msg", "letsencrypt");
            $error_ref->{code} = 6;
            $error_ref->{desc} = $le_msg;
        }
        else {
            my $le_msg = "Letsencrypt renew command failed!";
            &log_error($le_msg, "letsencrypt");
            $error_ref->{code} = 3;
            $error_ref->{desc} = $le_msg;
        }
    }
    else {
        # check is not due to renewal response
        my $renewal_response = "Cert not yet due for renewal";

        if (grep { /$renewal_response/ } @{ $status->{stdout} }) {
            my $le_msg = "Letsencrypt certificate '$le_cert_name' not yet due for renewal!";
            &log_error($le_msg, "letsencrypt");
            $error_ref->{code} = 5;
            $error_ref->{desc} = $le_msg;
        }
        else {
            # create RELIANOID PEM cert
            $status = &setLetsencryptCert($le_cert_name);

            if ($status) {
                my $le_msg = "Letsencrypt create PEM cert failed!";
                &log_error($le_msg, "letsencrypt");
                $error_ref->{code} = 4;
                $error_ref->{desc} = $le_msg;
            }
        }
    }

    # delete le service
    &unsetLetsencryptFarmService($farm_name);

    # stop local Web Server
    &runLetsencryptLocalWebserverStop();

    close $lock_le_renew_fh;
    return $error_ref;
}

=pod

=head1 isLetsencryptStaging

Check the LetsEncrypt Certificate API server.

Parameters:

    le_cert_name - Certificate Name.

Returns: integer - 1 for staging, 0 for production.

=cut

sub isLetsencryptStaging ($le_cert_name) {
    my $le_config_path = &getLetsencryptConfigPath();
    my $rc             = 0;

    return $rc if (!$le_cert_name);

    my $le_cert_renewal_file = "$le_config_path/renewal/$le_cert_name.conf";

    if (-f $le_cert_renewal_file) {
        require Config::Tiny;

        my $le_cert_renewal_conf = Config::Tiny->read($le_cert_renewal_file);
        my $le_api_server        = $le_cert_renewal_conf->{renewalparams}{server};

        $rc = int($le_api_server =~ /acme-staging/);
    }

    return $rc;
}

=pod

=head1 setLetsencryptCron

Set a cron entry for an automatic renewal Letsencrypt certificate

Parameters:

    le_cert_name - LE Cert Name
    farm_name    - Farm Name where Letsencrypt will connect.
    vip          - VIP where the new Farm and service is created. The virtual Port will be 80.
    force        - if "true" forces a renew flag even the cert not yet due for renewal( over 30 days for expire ).
    restart      - if "true" forces a restart flag to restart farms affected by the certificate.

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub setLetsencryptCron ($le_cert_name, $farm_name, $vip, $force, $restart) {
    my $rc = 0;

    return 1 if (!$le_cert_name);
    return 2 if (!$vip && !$farm_name) or ($vip && $farm_name);

    my $le_cron_file   = &getLetsencryptCronFile();
    my $le_renewal_bin = &getGlobalConfiguration('le_renewal_bin');
    my $minute         = int rand(59);

    require Relianoid::Lock;
    &ztielock(\my @le_cron_list, $le_cron_file);
    my $frequency = "$minute 22 * * * ";
    my $command   = "root $le_renewal_bin --cert $le_cert_name";
    @le_cron_list = grep { !/ $command / } @le_cron_list;

    $command .= " --farm $farm_name" if $farm_name;
    $command .= " --vip $vip"        if $vip;
    $command .= " --force"           if (defined $force   and ($force eq "true"));
    $command .= " --restart"         if (defined $restart and ($restart eq "true"));

    push @le_cron_list, "$frequency $command";
    untie @le_cron_list;

    return $rc;
}

=pod

=head1 unsetLetsencryptCron

Delete a cron entry for an automatic renewal Letsencrypt certificate

Parameters:

    le_cert_name - LE Cert Name

Returns:

    Integer - 0 on succesfull, otherwise on error.

=cut

sub unsetLetsencryptCron ($le_cert_name) {
    my $rc = 0;

    return 1 if (!$le_cert_name);

    my $le_cron_file   = &getLetsencryptCronFile();
    my $le_renewal_bin = &getGlobalConfiguration('le_renewal_bin');

    require Relianoid::Lock;
    &ztielock(\my @le_cron_list, $le_cron_file);
    my $command = "root $le_renewal_bin --cert $le_cert_name";
    @le_cron_list = grep { !/ $command / } @le_cron_list;
    untie @le_cron_list;

    return $rc;
}

=pod

=head1 getLetsencryptCron

get the cron entry for an automatic renewal Letsencrypt certificate

Parameters:

    le_cert_name - LE Cert Name

Returns:

    Hash - cron entry Hash ref with values on successful.

=cut

sub getLetsencryptCron ($le_cert_name) {
    my $cron_ref = {
        status  => "disabled",
        farm    => undef,
        vip     => undef,
        force   => undef,
        restart => undef
    };

    my $le_cron_file   = &getLetsencryptCronFile();
    my $le_renewal_bin = &getGlobalConfiguration('le_renewal_bin');

    my @le_cron_list = ();
    if (open my $fd, '<', $le_cron_file) {
        @le_cron_list = <$fd>;
        close $fd;
        chomp(@le_cron_list);
    }
    else {
        log_debug("Could not open $le_cron_file: $!");
    }

    my $command = "root $le_renewal_bin --cert $le_cert_name";
    my @le_cron = grep { / $command / } @le_cron_list;

    if (scalar @le_cron > 0) {
        require Relianoid::Validate;

        my $farm_name = &getValidFormat('farm_name');
        my $vip       = &getValidFormat('ip_addr');

        if ($le_cron[0] =~ /$command(?: --farm ($farm_name))?(?: --vip ($vip))?(?:( --force))?(?:( --restart))?$/) {
            $cron_ref->{status}  = "enabled";
            $cron_ref->{farm}    = $1;
            $cron_ref->{vip}     = $2;
            $cron_ref->{force}   = defined $3 ? "true" : "false";
            $cron_ref->{restart} = defined $4 ? "true" : "false";
        }
    }

    return $cron_ref;
}

=pod

=head1 getLetsencryptCertConfigIsBroken

Detect if the LetsEncrypt configuration folder is broken

Parameters:

    cert_name - the name of the certificate

Returns:

    Integer - 0 if it's not broken, 1 if it's broken.

=cut

sub getLetsencryptCertConfigIsBroken ($cert_name) {
    my $le_fullchain_path = &getGlobalConfiguration('le_fullchain_path');
    my $broken            = 0;
    my $cmd               = "find $le_fullchain_path/live/$cert_name/ -type l ! -exec test -e \{\} \\; -print";

    my $output = &logAndGet($cmd);
    if (   ($output ne "")
        or (!-f "$le_fullchain_path/renewal/$cert_name.conf")
        or (!-d "$le_fullchain_path/archive/$cert_name/"))
    {
        $broken = 1;
        &log_error("Detected LetsEncrypt configuration broken", "letsencrypt");
    }

    return $broken;
}

=pod

=head1 runLetsencryptCertConfigBackup

Create a backup for the Lets Encrypt configuration

Parameters:

    cert_name - the name of the certificate

Returns:

    Integer - 0 on succesful, 1 if there was a problem generating the backup.

=cut

sub runLetsencryptCertConfigBackup ($cert_name) {
    my $le_fullchain_path = &getGlobalConfiguration('le_fullchain_path');
    my $le_backup_path    = &getGlobalConfiguration('localconfig');
    my $le_backup_file    = "le_backup-$cert_name.tgz";
    my $cmd =
      "cd $le_fullchain_path && tar zcf $le_backup_path/$le_backup_file live/$cert_name/ archive/$cert_name/ renewal/$cert_name.conf";
    my $output = 0;

    &log_info("Creating LetsEncrypt Configuration Backup to $le_backup_path/$le_backup_file", "letsencrypt");
    if (-f "$le_backup_path/$le_backup_file") {
        &logAndRun("mv $le_backup_path/$le_backup_file $le_backup_path/$le_backup_file.bck");
    }
    $output = &logAndRun($cmd);
    if (-f "$le_backup_path/$le_backup_file.bck") {
        if ($output) {
            &log_error("Creating LetsEncrypt Configuration Backup Failed, recovering backup", "letsencrypt");
            &logAndRun("mv $le_backup_path/$le_backup_file.bck $le_backup_path/$le_backup_file");
        }
        else {
            &logAndRun("rm $le_backup_path/$le_backup_file.bck");
        }
    }

    return $output;
}

=pod

=head1 runLetsencryptCertConfigRecovery

Apply a backup recovery for the Lets Encrypt configuration

Parameters:

    cert_name - the name of the certificate

Returns:

    Integer - 0 if recovery successful, 1 if there was a problem with the recovery.

=cut

sub runLetsencryptCertConfigRecovery ($cert_name) {
    my $le_fullchain_path = &getGlobalConfiguration('le_fullchain_path');
    my $le_backup_path    = &getGlobalConfiguration('localconfig');
    my $le_backup_file    = "le_backup-$cert_name.tgz";
    my $cmd =
      "cd $le_fullchain_path && rm -rf live/$cert_name/ archive/$cert_name/ renewal/$cert_name.conf && tar zxf $le_backup_path/$le_backup_file";
    my $output = 0;

    if (-f "$le_backup_path/$le_backup_file") {
        &log_info("Recovery LetsEncrypt Configuration Backup from $le_backup_path/$le_backup_file", "letsencrypt");
        &logAndRun($cmd);
        $output = 1;
    }
    else {
        &log_warn("No backup available to recover at $le_backup_path/$le_backup_file", "letsencrypt");
        $output = 1;
    }

    return $output;
}

=pod

=head1 runLetsencryptCertConfigProtection

Protection to ensure that the configuration files in letsencrypt are not corrupted.
Always maintain a copy to be deployed in case a corruption is detected.

Parameters:

    cert_name - the name of the certificate

Returns:

    Integer - 0 if not recovery required, 1 if it was recovered.

=cut

sub runLetsencryptCertConfigProtection ($cert_name) {
    my $output = 0;

    if (!&getLetsencryptCertConfigIsBroken($cert_name)) {
        &runLetsencryptCertConfigBackup($cert_name);
    }
    else {
        $output = &runLetsencryptCertConfigRecovery($cert_name);
        $output = 1;
    }

    return $output;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Lock.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Fcntl ':flock';    #use of lock functions

use Relianoid::Log;

my $lock_file = undef;
my $lock_fh   = undef;

=pod

=head1 Module

Relianoid::Lock

=cut

=pod

=head1 getLockFile

Write a lock file based on a input path

=cut

sub getLockFile ($lock) {
    # replace slash with underscore
    $lock =~ s/\//_/g;
    $lock = "/tmp/$lock.lock";

    return $lock;
}

=pod

=head1 openlock

Open file and lock it, return the filehandle.

    Usage:

        my $filehandle = &openlock( $path, 'r' );

    Lock is exclusive when the file is openend for writing.
    Lock is shared when the file is openend for reading.
    So only opening for writing is blocking the file for other uses.

    Opening modes:

        r - Read
        w - Write
        a - Append

        t - text mode. To enforce encoding UTF-8.
        b - binary mode. To make sure no information is lost.

    'r', 'w' and 'a' are mutually exclusive.
    't' and 'b' are mutually exclusive.

    If neither 't' or 'b' are used on the mode parameter, the default Perl mode is used.

    Take in mind, if you are executing process in parallel, if any of them remove the tmp locking file,
    the resource will be unlocked.

Parameters:

    path - Absolute or relative path to the file to be opened.
    mode - Mode used to open the file.

Returns:

    scalar - File handle

=cut

sub openlock ($path, $mode) {
    my $binmode  = $mode =~ s/b//;
    my $textmode = $mode =~ s/t//;

    if ($binmode && $textmode) {
        log_error("Raw and UTF-8 encoding cannot be used at the same time");
        return;
    }

    my $encoding = '';
    if    ($textmode) { $encoding = ":encoding(UTF-8)" }
    elsif ($binmode)  { $encoding = ":raw :bytes" }

    my $open_mode;
    if    ($mode eq 'a') { $open_mode = '>>' }
    elsif ($mode eq 'w') { $open_mode = '>' }
    elsif ($mode eq 'r') { $open_mode = '<' }

    if (not $open_mode) {
        log_error("Bad open mode");
        return;
    }

    my $fh;
    my $open_mode_with_layer = $encoding ? "${open_mode} ${encoding}" : $open_mode;

    if (open($fh, $open_mode_with_layer, $path)) {    ## no critic (RequireBriefOpen)
        if ($binmode) {
            binmode $fh;
        }
    }
    else {
        &log_error("Error opening the file $path: $!");
        return;
    }

    if ($open_mode eq ">") {
        # exclusive lock for writing
        flock $fh, LOCK_EX;
    }
    else {
        # shared lock for reading
        flock $fh, LOCK_SH;
    }

    return $fh;
}

=pod

=head1 ztielock

tie aperture with lock

    Usage:

        $handleArray = &tielock($file);

    Examples:

        $handleArray = &tielock("test.dat");
        $handleArray = &tielock($filename);

Parameters:

    file_name - Path to File.

Returns:

    scalar - Reference to the array with the content of the file.

Bugs:

    Not used yet.

=cut

sub ztielock ($array_ref, $file_name) {
    require Tie::File;

    my $o = tie @{$array_ref}, "Tie::File", $file_name;
    return $o->flock;
}

=pod

=head1 copyLock

=cut

sub copyLock ($ori, $dst) {
    my $fhOri = &openlock($ori, 'r') or return 1;
    my $fhDst = &openlock($dst, 'w') or do { close $fhOri; return 1; };

    while (my $line = <$fhOri>) {
        print $fhDst $line;
    }

    close $fhOri;
    close $fhDst;

    return 0;
}

=pod

=head1 lockResource

    lock or release an API resource.

Parameters:

    resource - Path to file.
    operation - l (lock), u (unlock), ud (unlock, delete the lock file), r (read)

Bugs:

    Not used yet.

=cut

sub lockResource ($resource, $oper) {
    # TODO: Define here the available resources
    # bonding
    # crl
    # ...

    if ($oper =~ /l/) {
        $lock_file = &getLockFile($resource);
        $lock_fh   = &openlock($lock_file, 'w');
    }
    elsif ($oper =~ /u/) {
        close $lock_fh;
        unlink $lock_file if ($oper =~ /d/);
    }
    elsif ($oper =~ /r/) {
        $lock_file = &getLockFile($resource);
        $lock_fh   = &openlock($lock_file, 'r');
    }

    return;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Log.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use Unix::Syslog qw(:macros :subs);    # Syslog macros

use Relianoid::Debug;

=pod

=head1 Module

Relianoid::Log 

=cut

sub warning_signal (@args) {
    print STDERR @args;
    log_warn("@args");
    return;
}

# Get the program name for logs messages
my $program_name =
    ($0 ne '-e')                                     ? $0
  : (exists $ENV{_} && $ENV{_} !~ /enterprise.bin$/) ? $ENV{_}
  :                                                    $^X;

my $basename = (split('/', $program_name))[-1];

=pod

=head1 _log

Write logs through syslog

Usage:

    &_log($text, $priority, $tag);

Examples:

    &_log("This is a message.", "info", "LSLB");
    &_log("Some errors happened.", "err", "FG");
    &_log("testing debug mode", "debug", "SYSTEM");

The different debug levels are:

    1 - Command executions.
        API inputs.
    2 - The command standart output, when there isn't any error.
        API outputs.
        Parameters modified in configuration files.
    3 - (reserved)
    4 - (reserved)
    5 - Profiling.

Parametes:

    message - String to be written in log.
    type    - Log level. info, error, debug, debug2, warn. Default: info
    tag     - RBAC, LSLB, GSLB, DSLB, IPDS, FG, NOTIF, NETWORK, MONITOR, SYSTEM, CLUSTER, AWS

Returns:

    none - .

=cut

sub _log ($message, $type = 'info', $tag = '') {
    if ($tag eq 'PROFILING') {
        $type = "debug5";
        return if &debug() < 5;
    }

    if ($type =~ /^debug(\d)?$/i) {
        my $log_debug_level = $1 // 1;

        # skip logs messages not included in the log level
        if (&debug() lt $log_debug_level) {
            return;
        }

        $type = "DEBUG";
        $type .= $log_debug_level if $log_debug_level > 1;
    }
    else {
        $type = uc($type);
    }

    if ($tag) {
        $tag = lc "${tag} :: ";
    }

    openlog($basename, LOG_PID, LOG_LOCAL0);
    syslog(LOG_INFO, "(${type}) ${tag}${message}");
    closelog();

    return;
}

sub log_info ($message, $tag = '') {
    return _log($message, 'info', $tag);
}

sub log_warn ($message, $tag = '') {
    return _log($message, 'warning', $tag);
}

sub log_error ($message, $tag = '') {
    return _log($message, 'error', $tag);
}

sub log_debug ($message, $tag = '') {
    return _log($message, 'debug', $tag);
}

sub log_debug2 ($message, $tag = '') {
    return _log($message, 'debug2', $tag);
}

sub log_debug3 ($message, $tag = '') {
    return _log($message, 'debug3', $tag);
}

sub log_debug4 ($message, $tag = '') {
    return _log($message, 'debug4', $tag);
}

sub log_debug5 ($message, $tag = '') {
    return _log($message, 'debug5', $tag);
}

=pod

=head1 logAndRun

Log and run the command string input parameter returning execution error code.

Parameters:

    command - String with the command to be run.

Returns:

    integer - Return code.

See Also:

    Widely used.

=cut

sub logAndRun ($command) {
    my $program     = $basename;
    my @cmd_output  = `$command 2>&1`;
    my $return_code = $?;

    if ($return_code) {
        &log_error("${program} running: ${command}", "SYSTEM");
        &log_error("out: @cmd_output",               "SYSTEM") if @cmd_output;
        &log_error("last command failed!",           "SYSTEM");
    }
    else {
        &log_debug("${program} running: ${command}", "SYSTEM");
        &log_debug2("out: @cmd_output", "SYSTEM");
    }

    return $return_code;
}

=pod

=head1 logAndRunBG

Non-blocking version of logging and running a command, returning execution error code.

Parameters:

    command - String with the command to be run.

Returns:

    boolean - true on error, false on success launching the command.

=cut

sub logAndRunBG ($command) {
    my $program = $basename;

    # system("command &") always returns 0
    my $return_code = system("$command >/dev/null 2>&1 &");

    if ($return_code) {
        &log_error("${program} running: ${command}", "SYSTEM");
        &log_error("last command failed!",           "SYSTEM");
    }
    else {
        &log_debug("${program} running: ${command}", "SYSTEM");
    }

    return $return_code;
}

=pod

=head1 run_with_env

Run a command with the environment parameters customized.

Parameters:

    exec - Command to run.

Returns:

    integer - Returns 0 on success or another value on failure

See Also:

    <runFarmGuardianStart>, <_runHTTPFarmStart>, <runHTTPFarmCreate>, <_runGSLBFarmStart>, <_runGSLBFarmStop>, <runGSLBFarmReload>, <runGSLBFarmCreate>

=cut

sub run_with_env (@command) {
    my $program = $basename;

    my @cmd_output = `. /etc/profile -notbui >/dev/null 2>&1 && @command 2>&1`;
    my $errno      = $?;

    if ($errno) {
        &log_error("${program} running: @command", "SYSTEM");
        &log_error("@cmd_output",                  "SYSTEM") if @cmd_output;
        &log_error("last command failed!",         "SYSTEM");
    }
    else {
        &log_debug("${program} running: @command", "SYSTEM");
        &log_debug2("out: @cmd_output", "SYSTEM");
    }

    return $errno;
}

=pod

=head1 logAndGet

Execute a command in the system to get the output. If the command fails,
it logs the error and returns a empty string or array.
It returns only the standard output, it does not return stderr.

Parameters:

    command - String with the command to be run in order to get info from the system.
    output format - Force that the output will be convert to 'string' or 'array'. String by default
    stderr flag - If this parameter is different of 0, the stderr will be added to the command output '2>&1'

Returns:

    Array ref or string - data obtained from the system. The type of output is specified
    in the type input param

See Also:

    logAndRun

TODO:

    Add an option to manage exclusively the output error and discard the standard output

=cut

sub logAndGet ($cmd, $type = 'string', $add_stderr = 0) {
    my $tmp_err  = ($add_stderr) ? '&1' : "/tmp/err.log";
    my $out      = `$cmd 2>$tmp_err` // '';
    my $err_code = $? >> 8;

    if (&debug() >= 2) {
        &log_debug2("Executed (out: $err_code): $cmd", "system");
    }

    if ($err_code and not $add_stderr) {
        # execute again, removing stdout and getting stderr
        if (open(my $fh, '<', $tmp_err)) {
            local $/ = undef;
            my $err_str = <$fh>;
            &log_debug2("sterr: $err_str", "SYSTEM");
            close $fh;
        }
        else {
            &log_error("file '$tmp_err' not found", "SYSTEM");
        }
    }

    chomp($out);

    # logging if there is not any error
    &log_debug3("out: $out", "SYSTEM");

    if ($type eq 'array') {
        my @out = split("\n", $out);
        return \@out;
    }

    return $out;
}

=pod

=head1 logAndRunCheck

It executes a command but is does not log anything if it fails. This functions
is useful to check things in the system as if a process is running or doing connectibity tests.
This function will log the command if the loglevel is greater than 1, and will
log the error output if the loglevel is greater than 2.

Parameters:

    command - String with the command to be run.

Returns:

    integer - error code of the command. 0 on success or another value on failure

See Also:

    logAndRun

=cut

sub logAndRunCheck ($command) {
    my $program = $basename;

    my @cmd_output  = `$command 2>&1`;
    my $return_code = $? >> 8;

    if (&debug() >= 2) {
        &log_debug2("${program} err_code '${return_code}' checking: ${command}", "SYSTEM");
    }
    if (&debug() >= 3) {
        &log_debug3("${program} output: @cmd_output", "SYSTEM");
    }

    # returning error code of the execution
    return $return_code;
}

=pod

=head1 logRunAndGet

Execute a command in the system to get both the standard output and the stderr.

Parameters:

    command - String with the command to be run in order to get info from the system.
    format - Force that the output will be convert to 'string' or 'array'. String by default.
    outflush - Flush standard output. If true, the standard output will be sent to null.

Returns:

    Hash ref - hash reference with the items:

    stdout - standard output of the command executed in the given format. If 'array'
             format is selected, then a hash array is provided. 'string' by default.

    stderr - output error code of the command executed.

=cut

sub logRunAndGet ($command, $format = 'string', $outflush = 0) {
    $command .= " 2>&1";
    $command .= " > /dev/null" if ($outflush);

    my @get = ($_ = qx{$command}, $? >> 8);

    my $exit;
    $exit->{stdout} = $get[0];
    $exit->{stderr} = $get[1];

    &log_debug("Executed (out: $exit->{stderr}): $command", "system");

    if ($format eq 'array') {
        my @out = split("\n", $get[0]);
        $exit->{stdout} = \@out;
    }

    return $exit;
}

=pod

=head1 run3

Execute a command and returns errno, stdout and stderr of such command.

Parameters:

    command - String with the command to be run.

Returns:

    ($errno, \@stdout, \@stderr) - Array with:

    errno  - Scalar integer. The value is the error number returned.
    stdout - Array reference. Each element of the array is a line of stdout.
    stderr - Array reference. Each element of the array is a line of stderr.

=cut

sub run3 ($command) {
    require IPC::Open3;
    require Symbol;

    my $in_fh;
    my $out_fh;
    my $err_fh = Symbol::gensym();                                        # required to separate stdout and stderr
    my $pid    = IPC::Open3::open3($in_fh, $out_fh, $err_fh, $command);
    waitpid($pid, 0);
    my $status = $? >> 8;

    chomp(my @out = <$out_fh>);
    chomp(my @err = <$err_fh>);
    return ($status, \@out, \@err);
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Login.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $passfile = "/etc/shadow";

=pod

=head1 Module

Relianoid::Login

=cut

=pod

=head1 changePassword

Change the password of a username.

Parameters:

    user - User name.
    newpass - New password.
    verifypass - New password again.

Returns:

    integer - ERRNO or return code .

Bugs:

    Verify password? Really?!

=cut

sub changePassword ($user, $newpass, $verifypass) {
    $verifypass = $newpass if (!$verifypass);

    ##write \$ instead $
    $newpass    =~ s/\$/\\\$/g;
    $verifypass =~ s/\$/\\\$/g;

    chomp($newpass);
    chomp($verifypass);

    ##no move the next lines
    my $cmd = "
/usr/bin/passwd $user 2>/dev/null<<EOF
$newpass
$verifypass
EOF
    ";

    my $output = system($cmd );
    if ($output) {
        &log_error("Error trying to change the $user password");
    }
    else { &log_info("The $user password was changed"); }

    return $output;
}

=pod

=head1 checkValidUser

Validate an user's password.

Parameters:

    user - User name.
    curpasswd - Password.

Returns:

    scalar - Boolean. 1 for valid password, or 0 for invalid one.

Bugs:

    Not a bug, but using pam would be desirable.

See Also:

    API v4: <set_user>

=cut

sub checkValidUser ($user, $passwd_in) {
    my $output = 0;
    use Authen::Simple::Passwd;
    my $passwd = Authen::Simple::Passwd->new(path => "$passfile");
    if ($passwd->authenticate($user, $passwd_in)) {
        $output = 1;
    }

    return $output;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Net/ConnStats.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;

my %conntrack_proto = (
    icmp => 1,
    tcp  => 6,
    udp  => 17,
    gre  => 47,
    sctp => 132,
);

=pod

=head1 Module

Relianoid::Net::ConnStats

=cut

=pod

=head1 getConntrack

Get the connections list.

Parameters:

    orig_src -
    orig_dst -
    reply_src -
    reply_dst -
    protocol -

Returns:

    array ref - Filtered netstat array reference.

=cut

sub getConntrack ($orig_src, $orig_dst, $reply_src, $reply_dst, $protocol) {
    # remove newlines in every argument
    chomp($orig_src, $orig_dst, $reply_src, $reply_dst, $protocol);

    # add iptables options to every available value
    $orig_src  = "-s $orig_src"  if ($orig_src);
    $orig_dst  = "-d $orig_dst"  if ($orig_dst);
    $reply_src = "-r $reply_src" if ($reply_src);
    $reply_dst = "-q $reply_dst" if ($reply_dst);
    $protocol  = "-p $protocol"  if ($protocol);

    my $conntrack     = &getGlobalConfiguration('conntrack');
    my $conntrack_cmd = "$conntrack -L $orig_src $orig_dst $reply_src $reply_dst $protocol";

    # return an array reference
    my @output = @{ &logAndGet($conntrack_cmd, "array") };

    # my $conns_count = scalar @output;
    # &log_info( "getConntrack command: $conntrack_cmd", "MONITOR" );
    # &log_info( "getConntrack returned $conns_count connections.", "MONITOR" );

    return \@output;
}

=pod

=head1 getNetstatFilter

Filter conntrack output

Parameters:

    proto - Protocol: "tcp", "udp", more?
    state - State: ??
    ninfo - Ninfo: ??
    fpid - Fpid: ??
    netstat - Output from getConntrack

Returns:

    array ref - Filtered netstat array reference.

=cut

# Returns array execution of netstat
sub getNetstatFilter ($proto, $state, $ninfo, $fpid, $netstat) {
    my $lfpid = $fpid;
    chomp($lfpid);

    if ($lfpid) {
        $lfpid = "\ $lfpid\/";
    }

    if ($proto ne "tcp" && $proto ne "udp") {
        $proto = "";
    }

    my $filter = "${proto}.* ${ninfo} .* ${state}.*${lfpid}";
    my @output = grep { /$filter/ } @{$netstat};
    my $output = \@output;

    # my $conns_count = scalar @output;
    # &log_info( "getNetstatFilter filter: '$filter'", "MONITOR" );
    # &log_info( "getNetstatFilter returned $conns_count connections.", "MONITOR" );

    return $output;
}

=pod

=head1 getConntrackParams

Get Conntrack params for a filter

Example:

    my $filter = {
        proto         => 'tcp',
        orig_dst      => $vip,
        orig_port_dst => $vip_port,
        state         => 'ESTABLISHED',
    };

Parameters:

    hash ref - Filter of connections

    FILTER PARAMETERS

    src, orig_src IP_ADDRESS
        Match only entries whose source address in the original direction equals the one specified as argument.
        Implies "--mask-src" when CIDR notation is used.

    dst, orig_dst IP_ADDRESS
        Match only entries whose destination address in the original direction equals the one specified as argument.
        Implies "--mask-dst" when CIDR notation is used.

    reply_src IP_ADDRESS
        Match only entries whose source address in the reply direction equals the one specified as argument.

    reply_dst IP_ADDRESS
        Match only entries whose destination address in the reply direction equals the one specified as argument.

    proto PROTO
        Specify layer four (TCP, UDP, ...) protocol.

    family PROTO
        Specify layer three (ipv4, ipv6) protocol This option is only required in conjunction with "-L, --dump".
        If this option is not passed, the default layer 3 protocol will be IPv4.

    timeout TIMEOUT
        Specify the timeout.

    mark MARK[/MASK]
        Specify  the conntrack mark. Optionally, a mask value can be specified.
        In "--update" mode, this mask specifies the bits that should be zeroed before XORing the MARK value into the ctmark.
        Otherwise, the mask is logically ANDed with the existing mark before the comparision.
        In "--create" mode, the mask is ignored.

    label LABEL
        Specify a conntrack label. 
        This option is only available in conjunction with "-L, --dump", "-E, --event", "-U --update" or "-D --delete".
        Match entries whose labels match at least those specified.
        Use multiple -l commands to specify multiple labels that need to be set.
        Match entries whose labels matches at least those specified as arguments.
        --label-add LABEL Specify the conntrack label to add to to the selected conntracks.
        This option is only available in conjunction with "-I, --create" or "-U, --update".
        --label-del [LABEL] Specify the conntrack label to delete from the selected conntracks.
        If no label is given, all labels are  deleted. This option is only available in conjunction with "-U, --update".

    secmark SECMARK
        Specify the conntrack selinux security mark.

    status [ASSURED|SEEN_REPLY|FIXED_TIMEOUT|EXPECTED|UNSET][,...]
        Specify the conntrack status.

    src_nat
        Filter source NAT connections.

    dst_nat
        Filter destination NAT connections.

    any_nat
        Filter any NAT connections.

    zone
        Filter by conntrack zone. See iptables CT target for more information.

    orig_zone
        Filter by conntrack zone in original direction.  See iptables CT target for more information.

    reply_zone
        Filter by conntrack zone in reply direction.  See iptables CT target for more information.

    tuple_src IP_ADDRESS
        Specify the tuple source address of an expectation.  Implies "--mask-src" when CIDR notation is used.

    tuple_dst IP_ADDRESS
        Specify the tuple destination address of an expectation.  Implies "--mask-dst" when CIDR notation is used.

    mask_src IP_ADDRESS
        Specify  the  source  address mask.
        For conntrack this option is only available in conjunction with "-L, --dump", "-E, --event", "-U --update" or "-D --delete".
        For expectations this option is only available in conjunction with "-I, --create".

    mask_dst IP_ADDRESS
        Specify the destination address mask. Same limitations as for "--mask-src".



    PROTOCOL FILTER PARAMETERS

    TCP-specific fields:

    sport, orig_port_src PORT
        Source port in original direction

    dport, orig_port_dst PORT
        Destination port in original direction

    reply_port_src PORT
        Source port in reply direction

    reply_port_dst PORT
        Destination port in reply direction

    state [NONE | SYN_SENT | SYN_RECV | ESTABLISHED | FIN_WAIT | CLOSE_WAIT | LAST_ACK | TIME_WAIT | CLOSE | LISTEN]
        TCP state


    UDP-specific fields:

    sport, orig_port_src PORT
        Source port in original direction

    dport, orig_port_dst PORT
        Destination port in original direction

    reply_port_src PORT
        Source port in reply direction

    reply_port_dst PORT
        Destination port in reply direction

Returns:

    unsigned integer - Number of connections found with the filter applied.

=cut

sub getConntrackParams ($filter) {
    my $conntrack_bin    = &getGlobalConfiguration('conntrack');
    my $conntrack_params = '';

    if (my @protocols = split(/\s/, $filter->{proto})) {
        my @found_protocols = ();
        for my $protocol (@protocols) {
            my $proto_code = $conntrack_proto{$protocol};
            if (defined $proto_code) {
                push(@found_protocols, $proto_code);
            }
            else {
                carp("Protocol '$protocol' not found in conntrack_proto");
            }
        }
        if (@found_protocols) {
            $conntrack_params = "--proto @found_protocols";
        }
    }

    for my $filter_key (keys %$filter) {
        next if $filter_key eq 'proto';

        my $param = $filter_key;
        $param =~ s/_/-/g;

        $conntrack_params = join(" ", $conntrack_params, "--$param $filter->{ $filter_key }");
    }

    return $conntrack_params;
}

=pod

=head1 getConntrackCount

Parameters:

    $conntrack_params - filter received from getConntrackParams()

Returns:

    integer - Count of connection matching the received filter.

=cut

sub getConntrackCount ($conntrack_params) {
    my $conntrack_bin = &getGlobalConfiguration('conntrack');
    my $conntrack_cmd = "$conntrack_bin -L $conntrack_params 2>&1 >/dev/null";

    require Relianoid::Debug;

    &log_debug("Conntrack count: $conntrack_cmd", "MONITOR") if &debug();

    # Do not use the function 'logAndGet', this function manages the output error and code
    my $summary = `$conntrack_cmd`;
    my $error   = $?;
    my ($count) = $summary =~ m/: ([0-9]+) flow entries have been shown./;

    &log_error("Conntrack count: An error happened running the command: $conntrack_cmd", "MONITOR")
      if $error;

    return $count + 0;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Net/Core.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use Relianoid::Core;

my $ip_bin = &getGlobalConfiguration('ip_bin');
my $eload  = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Net::Core

=cut

=pod

=head1 createIf

Create VLAN network interface

Parameters:

    if_ref - Network interface hash reference.

Returns:

    integer - ip command return code.

=cut

# create network interface
sub createIf ($if_ref) {
    my $status = 1;

    if (defined $$if_ref{vlan} && $$if_ref{vlan} ne '') {
        &log_info("Creating vlan $$if_ref{name}", "NETWORK");

        my $ip_cmd = "$ip_bin link add link $$if_ref{dev} name $$if_ref{name} type vlan id $$if_ref{vlan}";
        $status = &logAndRun($ip_cmd);
    }

    return $status;
}

=pod

=head1 upIf

Bring up network interface in system and optionally in configuration file

Parameters:

    if_ref - network interface hash reference.
    writeconf - true value to apply change in interface configuration file. Optional.

Returns:

    integer - return code of ip command.

See Also:

    <downIf>

=cut

# up network interface
sub upIf ($if_ref, $writeconf = 0) {
    my $configdir = &getGlobalConfiguration('configdir');
    my $status    = 0;
    $if_ref->{status} = 'up';

    my $ip_cmd = "$ip_bin link set dev $$if_ref{name} up";

    $status = &logAndRun($ip_cmd);

    # not check virtual interfaces
    if ($if_ref->{type} ne "virtual") {
        #check if link is up after ip link up; checks /sys/class/net/$$if_ref{name}/operstate
        my $cat       = &getGlobalConfiguration('cat_bin');
        my $status_if = &logAndGet("$cat /sys/class/net/$$if_ref{name}/operstate");

        &log_info("Link status for $$if_ref{name} is $status_if", "NETWORK");

        if ($status_if =~ /down/) {
            use Time::HiRes qw(usleep);

            &log_info("Waiting link up for $$if_ref{name}", "NETWORK");

            my $max_retry = 50;
            my $retry     = 0;

            while ($status_if =~ /down/ and $retry < $max_retry) {
                $status_if = &logAndGet("$cat /sys/class/net/$$if_ref{name}/operstate");

                if ($status_if !~ /down/) {
                    &log_info("Link up for $$if_ref{name}", "NETWORK");
                    last;
                }

                $retry++;
                usleep 100_000;
            }

            if ($status_if =~ /down/) {
                $status = 1;
                &log_warn("No link up for $$if_ref{name}", "NETWORK");
                &downIf({ name => $if_ref->{name} }, '');
            }
        }
    }

    if ($writeconf) {
        my $file = "$configdir/if_$$if_ref{name}_conf";

        require Config::Tiny;
        my $fileHandler = Config::Tiny->new();
        $fileHandler = Config::Tiny->read($file) if (-f $file);

        $fileHandler->{ $if_ref->{name} }{status} = "up";
        $fileHandler->write($file);
    }

    if (not $status and $eload and $if_ref->{dhcp} eq 'true') {
        $status = &eload(
            'module' => 'Relianoid::EE::Net::DHCP',
            'func'   => 'startDHCP',
            'args'   => [ $if_ref->{name} ],
        );
    }

    # calculate new backend masquerade IPs
    require Relianoid::Farm::Config;
    &reloadFarmsSourceAddress();

    return $status;
}

=pod

=head1 downIf

Bring down network interface in system and optionally in configuration file

Parameters:

    if_ref - network interface hash reference.

Returns:

    integer - return code of ip command.
    writeconf - true value to apply change in interface configuration file. Optional.

=cut

# down network interface in system and configuration file
sub downIf ($if_ref, $writeconf = 0) {
    my $status;

    if (ref $if_ref ne 'HASH') {
        &log_error("Wrong argument putting down the interface", "NETWORK");
        return -1;
    }

    if ($eload and $if_ref->{dhcp} and $if_ref->{dhcp} eq 'true') {
        $status = &eload(
            'module' => 'Relianoid::EE::Net::DHCP',
            'func'   => 'stopDHCP',
            'args'   => [ $if_ref->{name} ],
        );
    }

    my $ip_cmd;

    # For Eth and Vlan
    if (not defined $$if_ref{vini} or not length $$if_ref{vini}) {
        $ip_cmd = "$ip_bin link set dev $$if_ref{name} down";
    }

    # For Vini
    else {
        my ($routed_iface) = split(":", $$if_ref{name});

        $ip_cmd = "$ip_bin addr del $$if_ref{addr}/$$if_ref{mask} dev $routed_iface";

        &eload(
            module => 'Relianoid::EE::Net::Routing',
            func   => 'applyRoutingDependIfaceVirt',
            args   => [ 'del', $if_ref ]
        ) if $eload;
    }

    &setRuleIPtoTable($$if_ref{name}, $$if_ref{addr}, "del");
    $status = &logAndRun($ip_cmd);

    # Set down status in configuration file
    if ($writeconf) {
        my $configdir = &getGlobalConfiguration('configdir');
        my $file      = "$configdir/if_$$if_ref{name}_conf";

        require Config::Tiny;
        my $fileHandler = Config::Tiny->new();
        $fileHandler = Config::Tiny->read($file) if (-f $file);

        $fileHandler->{ $if_ref->{name} }{status} = "down";
        $fileHandler->write($file);
    }

    # calculate new backend masquerade IPs
    require Relianoid::Farm::Config;
    &reloadFarmsSourceAddress();

    return $status;
}

=pod

=head1 stopIf

Stop network interface, this removes the IP address instead of putting the interface down.

This is an alternative to downIf which performs better in hardware
appliances. Because if the interface is not brought down it wont take
time to bring the interface back up and enable the link.

Parameters:

    if_ref - network interface hash reference.

Returns:

    integer - return code of ip command.

Bugs:

    Remove VLAN interface and bring it up.

See Also:

    <downIf>

    Only used in: relianoid

=cut

# stop network interface
sub stopIf ($if_ref) {
    &log_info("Stopping interface $$if_ref{name}", "NETWORK");

    my $status = 0;
    my $if     = $$if_ref{name};

    # If $if is Vini do nothing
    if (!$$if_ref{vini}) {
        # If $if is a Interface, delete that IP
        my $ip_cmd = "$ip_bin address flush dev $$if_ref{name}";
        $status = &logAndRun($ip_cmd);

        # If $if is a Vlan, delete Vlan
        if ($$if_ref{vlan} ne '') {
            $ip_cmd = "$ip_bin link delete $$if_ref{name} type vlan";
            $status = &logAndRun($ip_cmd);
        }

        #ensure Link Up
        if ($$if_ref{status} eq 'up') {
            $ip_cmd = "$ip_bin link set dev $$if_ref{name} up";
            $status = &logAndRun($ip_cmd);
        }

        my $rttables = &getGlobalConfiguration('rttables');

        # Delete routes table
        open my $fh, '<', $rttables;
        my @contents = <$fh>;
        close $fh;

        @contents = grep { !/^...\ttable_$if$/ } @contents;

        open $fh, '>', $rttables;
        print $fh @contents;
        close $fh;
    }
    else {
        my @ifphysic = split(/:/, $if);
        my $ip       = $$if_ref{addr};

        if ($ip =~ /\./) {
            use Net::IPv4Addr qw(ipv4_network);
            my (undef, $mask) = ipv4_network("$ip / $$if_ref{mask}");
            my $cmd = "$ip_bin addr del $ip/$mask brd + dev $ifphysic[0] label $if";

            &logAndRun("$cmd");

            &eload(
                module => 'Relianoid::EE::Net::Routing',
                func   => 'applyRoutingDependIfaceVirt',
                args   => [ 'del', $if_ref ]
            ) if $eload;
        }
    }

    return $status;
}

=pod

=head1 delIf

Remove system and stored settings and statistics of a network interface.

Parameters:

    if_ref - network interface hash reference.

Returns:

    integer - return code ofip command.

=cut

sub delIf ($if_ref) {
    my $status;

    # remove dhcp configuration
    if (exists $if_ref->{dhcp} and $if_ref->{dhcp} eq 'true') {
        &eload(
            module => 'Relianoid::EE::Net::DHCP',
            func   => 'disableDHCP',
            args   => [$if_ref],
        );
    }

    require Relianoid::Net::Interface;
    $status = &cleanInterfaceConfig($if_ref);
    if ($status) {
        return $status;
    }

    &setRuleIPtoTable($$if_ref{name}, $$if_ref{addr}, "del");

    # Block for any kind of network interface, except virtual interfaces
    if (not(defined $$if_ref{vini} && length $$if_ref{vini})) {
        # If $if is a gre Tunnel, delete gre
        if ($$if_ref{type} eq 'gre') {
            my $ip_cmd = "$ip_bin tunnel delete $$if_ref{name} mode gre";
            $status = &logAndRun($ip_cmd);
        }
        else {
            my $is_dhcp = defined $if_ref->{dhcp} && $if_ref->{dhcp} eq 'true';

            if (! $is_dhcp && $$if_ref{addr}) {
                # If $if is a Interface, delete that IP
                my $ip_cmd = "$ip_bin addr del $$if_ref{addr}/$$if_ref{mask} dev $$if_ref{name}";

                if (length $if_ref->{addr} && length $if_ref->{mask}) {
                    $status = &logAndRun($ip_cmd);
                }
            }

            # If $if is a Vlan, delete Vlan
            if (defined $$if_ref{vlan} and length $$if_ref{vlan}) {
                my $ip_cmd = "$ip_bin link delete $$if_ref{name} type vlan";
                $status = &logAndRun($ip_cmd);
            }
        }

        #delete custom routes
        &eload(
            module => 'Relianoid::EE::Net::Routing',
            func   => 'delRoutingDependIface',
            args   => [ $$if_ref{name} ],
        ) if ($eload);

        # check if alternative stack is in use
        my $ip_v_to_check = ($$if_ref{ip_v} == 4) ? 6 : 4;
        my $interface     = &getInterfaceConfig($$if_ref{name}, $ip_v_to_check);

        if (!$interface
            || ($interface->{type} eq "bond" and not exists $interface->{addr}))
        {
            &deleteRoutesTable($$if_ref{name});
        }
    }

    # delete graphs
    require Relianoid::RRD;
    &delGraph($$if_ref{name}, "iface");

    if ($eload) {
        # delete alias
        &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'delAlias',
            args   => [ 'interface', $$if_ref{name} ]
        );

        #delete from RBAC
        &eload(
            module => 'Relianoid::EE::RBAC::Group::Config',
            func   => 'delRBACResource',
            args   => [ $$if_ref{name}, 'interfaces' ],
        );

        #reload netplug
        if (!defined($$if_ref{vini}) || $$if_ref{vini} eq '') {
            &eload(
                module => 'Relianoid::EE::Net::Ext',
                func   => 'reloadNetplug',
            );
        }
    }

    return $status;
}

=pod

=head1 delIp

Deletes an IP address from an interface

Parameters:

    if - Name of interface.
    ip - IP address.
    netmask - Network mask.

Returns:

    integer - ip command return code.

See Also:

    <addIp>

=cut

# Execute command line to delete an IP from an interface
sub delIp ($if, $ip, $netmask) {
    if (!defined $ip || $ip eq '') {
        return 0;
    }

    &log_info("Deleting ip $ip/$netmask from interface $if", "NETWORK");

    # Vini
    if ($if =~ /\:/) {
        ($if) = split(/\:/, $if);
    }

    &setRuleIPtoTable($if, $ip, "del");
    my $ip_cmd = "$ip_bin addr del $ip/$netmask dev $if";
    my $status = &logAndRun($ip_cmd);

    return $status;
}

=pod

=head1 isIp

It checks if an IP is already applied in the dev

Parameters:

    if_ref - network interface hash reference.

Returns:

    integer - 0 if the IP is not applied or 1 if it is

See Also:

    <delIp>, <setIfacesUp>

=cut

sub isIp ($if_ref) {
    # finish if the address is already assigned
    my $routed_iface = $$if_ref{dev};
    $routed_iface .= ".$$if_ref{vlan}" if defined $$if_ref{vlan} && $$if_ref{vlan} ne '';

    my @ip_output = @{ &logAndGet("$ip_bin -$$if_ref{ip_v} addr show dev $routed_iface", "array") };

    if (grep { /$$if_ref{addr}\// } @ip_output) {
        &log_debug2("The IP '$$if_ref{addr}' already is applied in '$routed_iface'", "NETWORK");
        return 1;
    }

    return 0;
}

=pod

=head1 addIp

Add an IPv4 to an Interface, Vlan or Vini

Parameters:

    if_ref - network interface hash reference.

Returns:

    integer - ip command return code.

See Also:

    <delIp>, <setIfacesUp>

=cut

# Execute command line to add an IPv4 to an Interface, Vlan or Vini
sub addIp ($if_ref) {
    unless (ref $if_ref eq 'HASH') {
        croak("required network interface hash reference");
    }

    unless (exists $$if_ref{addr}) {
        carp("network interface has no address field");
        return 0;
    }

    unless ($$if_ref{addr} and length $$if_ref{addr}) {
        return 0;
    }

    &log_info("Adding IP $$if_ref{addr}/$$if_ref{mask} to interface $$if_ref{name}", "NETWORK");

    # Do not add automatically route in the main table
    # The routes are managed by relianoid
    my $extra_params = "noprefixroute";
    my $ip_cmd;
    my $if_announce   = "";
    my $broadcast_opt = ($$if_ref{ip_v} == 4) ? 'broadcast +' : '';

    if ($$if_ref{ip_v} == 6) {
        $extra_params .= ' nodad';
    }

    # $if is a Virtual Network Interface
    if (defined $$if_ref{vini} && $$if_ref{vini} ne '') {
        my ($toif) = split(':', $$if_ref{name});

        $ip_cmd = "$ip_bin addr add $$if_ref{addr}/$$if_ref{mask} $broadcast_opt dev $toif label $$if_ref{name} $extra_params";
        $if_announce = $toif;
    }

    # $if is a Network Interface
    else {
        $ip_cmd      = "$ip_bin addr add $$if_ref{addr}/$$if_ref{mask} $broadcast_opt dev $$if_ref{name} $extra_params";
        $if_announce = "$$if_ref{name}";
    }

    my $status = 0;

    # The command will fail if the address already exists
    unless (isIp($if_ref)) {
        $status = &logAndRun($ip_cmd);
    }

    #if arp_announce is enabled then send garps to network
    eval {
        if ($eload) {
            my $cl_status = &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'getClusterNodeStatus',
                args   => [],
            );

            if (   &getGlobalConfiguration('arp_announce') eq "true"
                && $cl_status ne "backup")
            {
                require Relianoid::Net::Util;

                &log_info("Announcing garp $if_announce and $$if_ref{addr} ");
                &sendGArp($if_announce, $$if_ref{addr});
            }
        }
    };

    &setRuleIPtoTable($$if_ref{name}, $$if_ref{addr}, "add");

    return $status;
}

=pod

=head1 setRuleIPtoTable

Add / delete a rule for the IP in order to force the traffic to the associated table_<nic>
it only applies if global param $duplicated_net is true

Parameters:

    iface:  Main interface, nic, bond o vlan
    IP:     main IP or VIP
    action: add / del

Returns:

    0 if ok, 1 if failed

=cut

sub setRuleIPtoTable ($iface, $ip, $action) {
    if (!defined($ip) || $ip eq '') {
        return 0;
    }

    my $prio = &getGlobalConfiguration('routingRulePrioIfacesDuplicated');

    if (&getGlobalConfiguration('duplicated_net') ne "true") {
        #this feature is not in use
        return 0;
    }

    #In case <if>:<name> is sent
    my @ifname = split(/:/, $iface);
    my $ip_cmd = "$ip_bin rule $action from $ip/32 lookup table_$ifname[0] prio $prio";
    return (&execIpCmd($ip_cmd) > 0);
}

=pod

=head1 execIpCmd

    This function replaces to logAndRun to exec ip commands. It does not print
    error message if the command already was applied or removed.

Parameters:

    Ip Command: command line with the ip command

Returns:

    Integer - It returns 0 on success, -1 if the command is already applied or 1 if there was an error

=cut

sub execIpCmd ($command) {
    # do not use the logAndGet function, this function is managing the error output and error code
    my @cmd_output  = `$command 2>&1`;
    my $return_code = $?;

    if ($return_code == 512)    # code 2 in shell
    {
        my $msg =
          ($command =~ /add/)
          ? "Trying to apply the rule but it already was applied"
          : "Trying to remove the rule but it was not found";
        &log_debug($msg,                "net");
        &log_debug("running: $command", "SYSTEM");
        &log_debug2("out: @cmd_output", "SYSTEM");
        $return_code = -1;
    }
    elsif ($return_code) {
        &log_error("Command failed: $command", "SYSTEM");
        &log_error("out: @cmd_output",         "SYSTEM");
        $return_code = 1;
    }
    else {
        &log_debug("running: $command", "SYSTEM");
        &log_debug2("out: @cmd_output", "SYSTEM");
        $return_code = 0;
    }

    return $return_code;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Net/Interface.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures state);

use Carp;

my $eload = eval { require Relianoid::ELoad };

my $ip_bin = &getGlobalConfiguration('ip_bin');

=pod

=head1 Module

Relianoid::Net::Interface

=cut

sub getInterfaceConfigFile ($if_name) {
    my $configdir = &getGlobalConfiguration('configdir');
    return "$configdir/if_${if_name}_conf";
}

=pod

=head1 $if_ref

Reference to a hash representation of a network interface.
It can be found dereferenced and used as a (%iface or %interface) hash.

    name     - Interface name.
    addr     - IP address. Empty if not configured.
    mask     - Network mask. Empty if not configured.
    gateway  - Interface gateway. Empty if not configured.
    status   - 'up' for enabled, or 'down' for disabled.
    ip_v     - IP version, 4 or 6.
    dev      - Name without VLAN or Virtual part (same as NIC or Bonding)
    vini     - Part of the name corresponding to a Virtual interface. Can be empty.
    vlan     - Part of the name corresponding to a VLAN interface. Can be empty.
    mac      - Interface hardware address.
    type     - Interface type: nic, bond, vlan, virtual.
    parent   - Interface which this interface is based/depends on.
    float    - Floating interface selected for this interface. For routing interfaces only.
    is_slave - Whether the NIC interface is a member of a Bonding interface. For NIC interfaces only.
    dhcp     - The DHCP service is enabled or not for the current interface.

See also:

    <getInterfaceConfig>, <setInterfaceConfig>, <getSystemInterface>

=cut

=pod

=head1 getInterfaceConfig

Get a hash reference with the stored configuration of a network interface.

Parameters:

    if_name - Interface name.

Returns:

    Hash ref - Reference to a network interface hash ($if_ref). undef if the network interface was not found.

Bugs:

    The configuration file exists but there isn't the requested stack.

=cut

sub getInterfaceConfig ($if_name, $ip_v = '') {
    unless (defined $if_name) {
        &log_debug2('getInterfaceConfig got undefined interface name', 'network');
    }

    my $configdir       = &getGlobalConfiguration('configdir');
    my $config_filename = "$configdir/if_${if_name}_conf";

    require Config::Tiny;
    my $fileHandler = Config::Tiny->new();

    if (-f $config_filename) {
        $fileHandler = Config::Tiny->read($config_filename);
    }

    #Return undef if the file doesn't exists and the iface is not a NIC
    if (!-f $config_filename && $if_name =~ /\.|\:/) {
        return;
    }

    #Return undef if the file doesn't exists and the iface is a gre Tunnel
    if (!-f $config_filename && &getInterfaceType($if_name) eq 'gre') {
        return;
    }

    require IO::Socket;
    my $socket = IO::Socket::INET->new(Proto => 'udp');

    my $iface = {
        addr    => undef,
        mask    => undef,
        gateway => undef,
    };

    $iface->{name}    = $fileHandler->{$if_name}{name} // $if_name;
    $iface->{addr}    = $fileHandler->{$if_name}{addr}    if (length $fileHandler->{$if_name}{addr});
    $iface->{mask}    = $fileHandler->{$if_name}{mask}    if (length $fileHandler->{$if_name}{mask});
    $iface->{gateway} = $fileHandler->{$if_name}{gateway} if (length $fileHandler->{$if_name}{gateway});
    $iface->{status}  = $fileHandler->{$if_name}{status} // '';
    $iface->{dev}     = $if_name;
    $iface->{vini}    = undef;
    $iface->{vlan}    = undef;
    $iface->{mac}     = $fileHandler->{$if_name}{mac} // undef;
    $iface->{type}    = &getInterfaceType($iface->{name});
    $iface->{parent}  = &getParentInterfaceName($iface->{name});

    if (not $ip_v and defined $iface->{addr}) {
        if ($iface->{addr} =~ /:/) {
            $ip_v = '6';
        }
        elsif ($iface->{addr} =~ /\./) {
            $ip_v = '4';
        }
    }

    $iface->{ip_v}    = $ip_v;
    $iface->{net}     = &getAddressNetwork($iface->{addr}, $iface->{mask}, $iface->{ip_v}) if $iface->{addr};
    $iface->{dhcp}    = $fileHandler->{$if_name}{dhcp} || 'false'                          if ($eload);
    $iface->{isolate} = $fileHandler->{$if_name}{isolate} // 'false'                       if ($eload);

    if ($iface->{dev} =~ /:/) {
        ($iface->{dev}, $iface->{vini}) = split(':', $iface->{dev});
    }

    if (!$iface->{name}) {
        $iface->{name} = $if_name;
    }

    # dot must be escaped
    if ($iface->{dev} =~ /./) {
        ($iface->{dev}, $iface->{vlan}) = split('\.', $iface->{dev});
    }

    $iface->{mac} = $socket->if_hwaddr($iface->{dev})
      if (!defined $iface->{mac});

    # Interfaces without ip do not get HW addr via socket,
    # in those cases get the MAC from the OS.
    unless ($iface->{mac}) {
        if (-f "/sys/class/net/$if_name/address") {
            open my $fh, '<', "/sys/class/net/$if_name/address";
            chomp($iface->{mac} = <$fh>);
            close $fh;
        }
    }

    if ($eload) {
        if ((!exists($iface->{vini}) || !defined($iface->{vini}) || $iface->{vini} eq '') && $iface->{addr}) {
            require Config::Tiny;
            my $float = Config::Tiny->read(&getGlobalConfiguration('floatfile'));
            $iface->{float} = $float->{_}{ $iface->{name} } // '';
        }
    }

    state $saved_bond_slaves = 0;

    if ($eload && $iface->{type} eq 'nic') {
        # not die if the appliance has not a certificate
        eval {
            unless ($saved_bond_slaves) {
                @TMP::bond_slaves = &eload(
                    module => 'Relianoid::EE::Net::Bonding',
                    func   => 'getAllBondsSlaves',
                );

                $saved_bond_slaves = 1;
            }
        };

        $iface->{is_slave} =
          (grep { $iface->{name} eq $_ } @TMP::bond_slaves) ? 'true' : 'false';
    }

    # for virtual interface, overwrite mask and gw with parent values
    if ($iface->{type} eq 'vini') {
        my $if_parent = &getInterfaceConfig($iface->{parent});
        $iface->{mask}    = $if_parent->{mask};
        $iface->{gateway} = $if_parent->{gateway};
    }

    return $iface;
}

=pod

=head1 getInterfaceConfigParam

Gets a hash reference of configuration params of a network interface.

Parameters:

    if_name    - Interface name.
    params_ref - Array ref of params

Returns:

    config_ref - Hash ref - Reference to a network interface config params hash ($config_ref).

=cut

sub getInterfaceConfigParam ($if_name, $params_ref) {
    my $config_ref;
    my $config_filename = &getInterfaceConfigFile($if_name);

    #Return undef if the file doesn't exists and the iface is not a NIC
    if (!-f $config_filename && $if_name =~ /\.|\:/) {
        return;
    }

    #Return undef if the file doesn't exists and the iface is a gre Tunnel
    if (!-f $config_filename && &getInterfaceType($if_name) eq 'gre') {
        return;
    }

    require Config::Tiny;
    my $if_config;
    if (!-f "$config_filename") {
        require Relianoid::File;
        createFile($config_filename);
        $if_config = Config::Tiny->new;
    }
    else {
        $if_config = Config::Tiny->read($config_filename);
    }

    for my $param (@{$params_ref}) {
        if (defined $if_config->{$if_name}{$param}) {
            $config_ref->{$param} = $if_config->{$if_name}{$param};
        }
        else {
            $config_ref->{$param} = undef;
        }
    }
    $config_ref->{name} = $if_name if not $config_ref->{name};
    return $config_ref;
}

=pod

=head1 setInterfaceConfig

Store a network interface configuration.

Parameters:

    if_ref - Reference to a network interface hash.

Returns:

    boolean - 1 on success, or 0 on failure.

=cut

sub setInterfaceConfig ($if_ref) {
    require Config::Tiny;

    my $fileHandle = Config::Tiny->new;
    if (ref $if_ref ne 'HASH') {
        &log_warn("Input parameter is not a hash reference", "NETWORK");
        return;
    }

    if (&debug() > 2) {
        require Data::Dumper;
        &log_debug3("setInterfaceConfig: " . Data::Dumper->Dumper($if_ref), "NETWORK");
    }

    my @if_params       = ('status', 'name', 'addr', 'mask', 'gateway', 'mac', 'dhcp', 'isolate');
    my $configdir       = &getGlobalConfiguration('configdir');
    my $config_filename = "$configdir/if_$$if_ref{name}_conf";

    if (!-f $config_filename) {
        require Relianoid::File;
        return 0 if (&createFile($config_filename));
    }

    $fileHandle = Config::Tiny->read($config_filename);

    for my $field (@if_params) {
        $fileHandle->{ $if_ref->{name} }{$field} = $if_ref->{$field};
    }

    if (!exists $fileHandle->{status}) {
        $fileHandle->{ $if_ref->{name} }{status} = $if_ref->{status} // "up";
    }

    return 0 if not $fileHandle->write($config_filename);

    return 1;
}

=pod

=head1 cleanInterfaceConfig

Remove the configuration information of a interface from its config file

Parameters:

    if_ref - Reference to a network interface hash.

Returns:

    Integer - 0 on success, or another value on failure.

=cut

sub cleanInterfaceConfig ($if_ref) {
    my $configdir = &getGlobalConfiguration('configdir');
    my $file      = "$configdir/if_$$if_ref{name}\_conf";
    my $err       = 0;

    if (!-f $file) {
        &log_info("The file $file has not been found", "NETWORK");
        return 1;
    }

    require Config::Tiny;
    my $fileHandler = Config::Tiny->new();
    $fileHandler = Config::Tiny->read($file);
    $fileHandler->{ $if_ref->{name} } = {
        mask    => "",
        status  => $fileHandler->{ $if_ref->{name} }{status},
        addr    => "",
        mac     => $if_ref->{mac},
        gateway => "",
        dhcp    => "false"
    };

    $fileHandler->write("$file");
    if (($$if_ref{name} ne $$if_ref{dev}) or ($$if_ref{type} eq 'gre')) {
        unlink($file) or return 1;
    }

    return $err;
}

=pod

=head1 getDevVlanVini

Get a hash reference with the interface name divided into: dev, vlan, vini.

Parameters:

    if_name - Interface name.

Returns:

    Reference to a hash with:

    dev  - NIC or Bonding part of the interface name.
    vlan - VLAN part of the interface name.
    vini - Virtual interface part of the interface name.

=cut

sub getDevVlanVini ($if_name) {
    my %if = (dev => $if_name);

    if ($if{dev} =~ /:/) {
        ($if{dev}, $if{vini}) = split ':', $if{dev};
    }

    if ($if{dev} =~ /\./)    # dot must be escaped
    {
        ($if{dev}, $if{vlan}) = split '\.', $if{dev};
    }

    return \%if;
}

=pod

=head1 getConfigInterfaceList

Get a reference to an array of all the interfaces saved in files.

Parameters:

    params_ref - Array ref of params. undef means all params

Returns:

    scalar - reference to array of configured interfaces.

=cut

sub getConfigInterfaceList ($params_ref = undef) {
    my @interfaces = ();
    my $configdir  = &getGlobalConfiguration('configdir');
    my @filenames  = ();

    if (opendir my $dir, $configdir) {
        @filenames = readdir $dir;
        closedir $dir;
    }
    else {
        &log_error("Error reading directory $configdir: $!", "NETWORK");
    }

    for my $filename (@filenames) {
        unless ($filename =~ /if_(.+)_conf/) {
            next;
        }

        my $if_name = $1;
        my $if_ref;

        if (defined $params_ref) {
            $if_ref = &getInterfaceConfigParam($if_name, $params_ref);
        }
        else {
            $if_ref = &getInterfaceConfig($if_name);
        }

        if (defined $if_ref) {
            push @interfaces, $if_ref;
        }
    }

    return \@interfaces;
}

=pod

=head1 getInterfaceSystemStatus

Get the status of an network interface in the system.

Parameters:

    if_ref - Reference to a network interface hash.

Returns:

    scalar - 'up' or 'down'.

=cut

sub getInterfaceSystemStatus ($if_ref) {
    my $parent_if_name = &getParentInterfaceName($if_ref->{name});
    my $status_if_name = $if_ref->{name};

    if (defined $if_ref->{vini} and length $if_ref->{vini}) {
        $status_if_name = $parent_if_name;
    }

    my $ip_bin    = &getGlobalConfiguration('ip_bin');
    my $ip_output = &logAndGet("$ip_bin link show $status_if_name");
    $ip_output =~ / state (\w+) /;
    my $if_status = lc $1;

    # if not up or down, ex: UNKNOWN
    if ($if_status !~ /^(?:up|down)$/) {
        my ($flags) = $ip_output =~ /<(.+)>/;
        my @flags = split(',', $flags);

        my $flag_up   = 0;
        my $flag_down = 0;
        for my $flag (@flags) {
            $flag_up++   if ($flag eq "UP");
            $flag_down++ if ($flag eq "NO-CARRIER");
        }
        if ($flag_up and not $flag_down) {
            $if_status = 'up';
        }
        else {
            $if_status = 'down';
        }
    }

    # Set as down vinis not available
    if (defined $if_ref->{vini} and length $if_ref->{vini}) {
        $ip_output = &logAndGet("$ip_bin addr show $status_if_name");
        if ($ip_output !~ /$if_ref->{addr}/) {
            return "down";
        }
    }

    # if it is not a virtual in down
    unless (defined $if_ref->{vini} and length $if_ref->{vini} and $if_ref->{status} eq 'down') {
        $if_ref->{status} = $if_status;
    }

    return $if_ref->{status} if $if_ref->{status} eq 'down';
    return $if_ref->{status} if !$parent_if_name;

    my $params        = [ "name", "addr", "status" ];
    my $parent_if_ref = &getInterfaceConfigParam($parent_if_name, $params);

    # vlans do not require the parent interface to be configured
    return $if_ref->{status} if !$parent_if_ref;

    return &getInterfaceSystemStatus($parent_if_ref);
}

=pod

=head1 getInterfaceSystemStatusAll

Get a hash of the status of all network interfaces in the system.

Parameters:

    none

Returns:

    Hash ref - Hash with name and status values.

=cut

sub getInterfaceSystemStatusAll () {
    my $ip_bin    = &getGlobalConfiguration('ip_bin');
    my $ip_output = &logAndGet("$ip_bin -o link", "array");
    my $links_ref;

    for my $link (@{$ip_output}) {
        if ($link =~ /^\d+: ([a-zA-Z0-9\-]+(?:\.\d{1,4})?)(?:@[a-zA-Z0-9\-]+)?: <(.+)> .+ state (\w+) /) {
            my $interface = $1;
            my $flag      = $2;
            my $status    = lc $3;

            if ($status ne "up" and $status ne "down") {
                my @flags     = split(',', $flag);
                my $flag_up   = 0;
                my $flag_down = 0;
                for my $flag (@flags) {
                    $flag_up++   if ($flag eq "UP");
                    $flag_down++ if ($flag eq "NO-CARRIER");
                }
                if ($flag_up and not $flag_down) {
                    $status = 'up';
                }
                else {
                    $status = 'down';
                }
            }
            $links_ref->{$interface} = $status;
        }
    }

    $ip_output = &logAndGet("$ip_bin -o addr", "array");
    my $addr_ref;
    for my $addr (@{$ip_output}) {
        if ($addr =~
            /^\d+: ([a-zA-Z0-9\-]+)(?:\.\d{1,4})?\s+(inet(?:\d)? (.*) (?:brd .*)?) scope .+ ([a-zA-Z0-9\-]+(?:\.\d{1,4})?:[a-zA-Z0-9\-]+)\\ /
          )
        {
            my $parent  = $1;
            my $virtual = $4;
            $addr_ref->{$virtual} = $links_ref->{$parent};
        }
    }
    $links_ref = { %{$links_ref}, %{$addr_ref} } if $addr_ref;
    return $links_ref;
}

=pod

=head1 getParentInterfaceName

    Get the parent interface name.

Parameters:

    if_name - Interface name.

Returns:

    string - Parent interface name or undef if there is no parent interface (NIC and Bonding).

=cut

sub getParentInterfaceName ($if_name) {
    my $if_ref = &getDevVlanVini($if_name);
    my $parent_if_name;

    my $is_vlan    = defined $if_ref->{vlan} && length $if_ref->{vlan};
    my $is_virtual = defined $if_ref->{vini} && length $if_ref->{vini};

    # child interface: eth0.100:virtual => eth0.100
    if ($is_virtual && $is_vlan) {
        $parent_if_name = "$$if_ref{dev}.$$if_ref{vlan}";
    }

    # child interface: eth0:virtual => eth0
    elsif ($is_virtual && !$is_vlan) {
        $parent_if_name = $if_ref->{dev};
    }

    # child interface: eth0.100 => eth0
    elsif (!$is_virtual && $is_vlan) {
        $parent_if_name = $if_ref->{dev};
    }

    # child interface: eth0 => undef
    elsif (!$is_virtual && !$is_vlan) {
        $parent_if_name = undef;
    }

    return $parent_if_name;
}

=pod

=head1 getActiveInterfaceList

Get a reference to a list of all running (up) and configured network interfaces.

Parameters: 
    none - .

Returns:

    scalar - reference to an array of network interface hashrefs.

=cut

sub getActiveInterfaceList () {
    my @configured_interfaces = @{ &getConfigInterfaceList() };

    # sort list
    @configured_interfaces =
      sort { $a->{name} cmp $b->{name} } @configured_interfaces;

    # apply device status heritage
    $_->{status} = &getInterfaceSystemStatus($_) for @configured_interfaces;

    # discard interfaces down
    @configured_interfaces =
      grep { $_->{status} eq 'up' } @configured_interfaces;

    # find maximun lengths for padding
    my $max_dev_length = 0;
    my $max_ip_length  = 0;

    for my $iface (@configured_interfaces) {
        if ($iface->{status} eq 'up') {
            next unless $iface->{addr};
            my $dev_length = length $iface->{name};
            $max_dev_length = $dev_length if $dev_length > $max_dev_length;

            my $ip_length = length $iface->{addr};
            $max_ip_length = $ip_length if $ip_length > $max_ip_length;
        }
    }

    # make padding
    for my $iface (@configured_interfaces) {
        next unless $iface->{addr};
        my $dev_ip_padded = sprintf("%-${max_dev_length}s -> %-${max_ip_length}s", $$iface{name}, $$iface{addr});
        $dev_ip_padded =~ s/ +$//;
        $dev_ip_padded =~ s/ /&nbsp;/g;

        $iface->{dev_ip_padded} = $dev_ip_padded;
    }

    return \@configured_interfaces;
}

=pod

=head1 getSystemInterfaceList

Get a reference to a list with all the interfaces, configured and not configured.

Parameters:

    none

Returns:

    scalar - reference to an array with configured and system network interfaces.

=cut

sub getSystemInterfaceList () {
    use IO::Interface qw(:flags);

    my @interfaces;    # output

    my @configured_interfaces;
    my $interface_ref = &getInterfaceNameStruct("vlan");

    for my $vlan (@{$interface_ref}) {
        my $if_ref = &getInterfaceConfig($vlan);
        push @configured_interfaces, $if_ref if $if_ref;
    }

    $interface_ref = &getInterfaceNameStruct("virtual");

    for my $virtual (@{$interface_ref}) {
        my $if_ref = &getInterfaceConfig($virtual);
        push @configured_interfaces, $if_ref if $if_ref;
    }

    my $socket            = IO::Socket::INET->new(Proto => 'udp');
    my @system_interfaces = &getInterfaceList();

    my $all_status = &getInterfaceSystemStatusAll();

    ## Build system device "tree"
    for my $if_name (sort @system_interfaces) {
        # ignore vlans and vinis
        next if $if_name =~ /\./;
        next if $if_name =~ /:/;

        # ignore loopback device
        next if $if_name =~ /^lo$/;

        # ignore fallback device from ip_gre module
        next if $if_name =~ /^gre0$|^gretap0$|^erspan0$/;

        # ignore fallback device from ip6_gre module
        next if $if_name =~ /^ip6gre0$|^ip6tnl0$/;

        # ignore fallback device from sit module
        next if $if_name =~ /^sit0$/;

        # ignore fallback device from ip_vti module
        #next if $if_name =~ /^ip_vti0$/;
        # ignore fallback device from ipip module
        #next if $if_name =~ /^tunl0$/;

        my $if_ref;
        my $if_flags = $socket->if_flags($if_name);

        my %if_parts = %{ &getDevVlanVini($if_name) };

        # run for IPv4 and IPv6
        $if_ref = &getInterfaceConfig($if_name);

        if (!$$if_ref{addr}) {
            # populate not configured interface
            $$if_ref{status} = ($if_flags & IFF_UP) ? "up" : "down";
            $$if_ref{mac}    = $socket->if_hwaddr($if_name);
            $$if_ref{name}   = $if_name;
            $$if_ref{addr}   = '';
            $$if_ref{mask}   = '';
            $$if_ref{dev}    = $if_parts{dev};
            $$if_ref{vlan}   = $if_parts{vlan};
            $$if_ref{vini}   = $if_parts{vini};
            $$if_ref{ip_v}   = '';
            $$if_ref{type}   = &getInterfaceType($if_name);
        }

        if (!($if_flags & IFF_RUNNING) && ($if_flags & IFF_UP)) {
            $$if_ref{link} = "off";
        }

        $if_ref->{status} = $all_status->{ $if_ref->{name} };

        # add interface to the list
        push(@interfaces, $if_ref);

        # add vlans and virtuals belonging the dev
        for my $if_conf (@configured_interfaces) {
            next if $if_conf->{dev} ne $if_ref->{dev};
            next if not $if_conf->{parent};

            $if_conf->{status} = $all_status->{ $if_conf->{name} };
            push(@interfaces, $if_conf);
        }
    }

    return \@interfaces;
}

=pod

=head1 getSystemInterface

Get a reference to a network interface hash from the system configuration, not the stored configuration.

Parameters:

    if_name - Interface name.

Returns:

    scalar - reference to a network interface hash as is on the system or undef if not found.

See Also:

    <getInterfaceConfig>, <setInterfaceConfig>

=cut

sub getSystemInterface ($if_name) {
    my $if_ref = { name => $if_name };

    use IO::Interface qw(:flags);

    my %if_parts = %{ &getDevVlanVini($$if_ref{name}) };
    my $socket   = IO::Socket::INET->new(Proto => 'udp');
    my $if_flags = $socket->if_flags($$if_ref{name});

    $$if_ref{mac} = $socket->if_hwaddr($$if_ref{name});
    return if not $$if_ref{mac};

    $$if_ref{status} = ($if_flags & IFF_UP) ? "up" : "down";
    $$if_ref{addr}   = '';
    $$if_ref{mask}   = '';
    $$if_ref{dev}    = $if_parts{dev};
    $$if_ref{vlan}   = $if_parts{vlan};
    $$if_ref{vini}   = $if_parts{vini};
    $$if_ref{type}   = &getInterfaceType($$if_ref{name});
    $$if_ref{parent} = &getParentInterfaceName($$if_ref{name});

    state $saved_bond_slaves = 0;

    if ($eload && $$if_ref{type} eq 'nic') {
        # not die if the appliance has not a certificate
        eval {
            unless ($saved_bond_slaves) {
                @TMP::bond_slaves = &eload(
                    module => 'Relianoid::EE::Net::Bonding',
                    func   => 'getAllBondsSlaves',
                );

                $saved_bond_slaves = 1;
            }
        };

        $$if_ref{is_slave} =
          (grep { $$if_ref{name} eq $_ } @TMP::bond_slaves) ? 'true' : 'false';
    }

    return $if_ref;
}

=pod

=head1 getInterfaceType

Get the type of a network interface from its name using linux 'hints'.

Original source code in bash:

http://stackoverflow.com/questions/4475420/detect-network-connection-type-in-linux

Translated to perl and adapted by Relianoid

Interface types: nic, virtual, vlan, bond, dummy or lo.

Parameters:

    if_name - Interface name.

Returns:

    scalar - Interface type: nic, virtual, vlan, bond, dummy or lo.

=cut

sub getInterfaceType ($if_name) {
    my $type;

    if (!defined $if_name || $if_name eq '') {
        return;
    }

    # interface for cluster when is in maintenance mode
    return 'dummy' if $if_name eq 'cl_maintenance';

    # interfaces added by ip_gre module
    if (   $if_name eq 'gre0'
        or $if_name eq 'gretap0'
        or $if_name eq 'erspan0')
    {
        return 'ip_gre_fallback';
    }

    # interfaces added by ip6_gre module
    return 'ip6_gre_fallback' if $if_name eq 'ip6gre0';

    # interfaces added by ip6_tunnel module
    #return 'ip6_tunnel_fallback' if $if_name eq 'ip6tnl0';
    # interfaces added by ip6_vti module
    #return 'ip6_vti_fallback' if $if_name eq 'ip_vti0';
    # interfaces added by sit module
    #return 'sit_fallback' if $if_name eq 'sit0';
    # interfaces added by ipip module
    #return 'ipip_fallback' if $if_name eq 'tunl0';

    if (!-d "/sys/class/net/$if_name") {
        my $configdir = &getGlobalConfiguration('configdir');
        my $found     = (-f "$configdir/if_${if_name}_conf" && $if_name =~ /^.+\:.+$/);

        if (!$found) {
            my ($parent_if) = split(':', $if_name);
            my $quoted_if   = quotemeta $if_name;
            my $ip_bin      = &getGlobalConfiguration('ip_bin');
            my @out         = @{ &logAndGet("$ip_bin addr show $parent_if", "array") };

            $found = grep { /inet .+ $quoted_if$/ } @out;
        }

        if ($found) {
            return 'virtual';
        }
        else {
            # vpn interfaces that are being deleted will exit here
            # return an empty string to be able to compare with strings
            return '';
        }
    }

    my $code;    # read type code
    {
        my $if_type_filename = "/sys/class/net/$if_name/type";

        if (open(my $fh, '<', $if_type_filename)) {
            chomp($code = <$fh>);
            close $fh;
        }
        else {
            log_error("Could not open file ${if_type_filename}: $!");
            return;
        }
    }

    if ($code == 1) {
        $type = 'nic';

        # Ethernet, may also be wireless, ...
        if (-f "/proc/net/vlan/$if_name") {
            $type = 'vlan';
        }
        elsif (-d "/sys/class/net/$if_name/bonding") {
            $type = 'bond';
        }

        #elsif ( -d "/sys/class/net/$if_name/wireless" || -l "/sys/class/net/$if_name/phy80211" )
        #{
        #	$type = 'wlan';
        #}
        #elsif ( -d "/sys/class/net/$if_name/bridge" )
        #{
        #	$type = 'bridge';
        #}
        #elsif ( -f "/sys/class/net/$if_name/tun_flags" )
        #{
        #	$type = 'tap';
        #}
        #elsif ( -d "/sys/devices/virtual/net/$if_name" )
        #{
        #	$type = 'dummy' if $if_name =~ /^dummy/;
        #}
    }
    elsif ($code == 24) {
        $type = 'nic';    # firewire ;; # IEEE 1394 IPv4 - RFC 2734
    }
    elsif ($code == 32) {
        if (-d "/sys/class/net/$if_name/bonding") {
            $type = 'bond';
        }

        #elsif ( -d "/sys/class/net/$if_name/create_child" )
        #{
        #	$type = 'ib';
        #}
        #else
        #{
        #	$type = 'ibchild';
        #}
    }

    elsif ($code == 512) {
        $type = 'ppp';    # PPP
    }

    #elsif ( $code == 768 )
    #{
    #	$type = 'ipip';    # IPIP tunnel
    #}
    #elsif ( $code == 769 )
    #{
    #	$type = 'ip6tnl';    # IP6IP6 tunnel
    #}
    elsif ($code == 772) { $type = 'lo'; }

    #elsif ( $code == 776 )
    #{
    #	$type = 'sit';       # sit0 device - IPv6-in-IPv4
    #}
    elsif ($code == 778) {
        $type = 'gre';    # GRE over IP
    }

    #elsif ( $code == 783 )
    #{
    #	$type = 'irda';      # Linux-IrDA
    #}
    #elsif ( $code == 801 )   { $type = 'wlan_aux'; }
    #elsif ( $code == 65534 ) { $type = 'tun'; }

    # The following case statement still has to be replaced by something
    # which does not rely on the interface names.
    # case $if_name in
    # 	ippp*|isdn*) type=isdn;;
    # 	mip6mnha*)   type=mip6mnha;;
    # esac

    return $type if defined $type;

    my $msg = "Could not recognize the type of the interface $if_name.";

    &log_error($msg, "NETWORK");

    return;
}

=pod

=head1 getInterfaceTypeList

Get a list of hashrefs with interfaces of a single type.

Types supported are: nic, bond, vlan, virtual and gre.

Parameters:

    list_type - Network interface type.
    iface_name - Interface name

Returns:

    list - list of network interfaces hashrefs.

=cut

sub getInterfaceTypeList ($list_type, $iface_name = undef) {
    my @interfaces = ();

    if (grep { $list_type eq $_ } qw(nic bond vlan gre)) {
        my @system_interfaces;

        if ($iface_name) {
            push @system_interfaces, $iface_name;
        }
        else {
            @system_interfaces = sort &getInterfaceList();
        }

        for my $if_name (@system_interfaces) {
            if ($list_type eq &getInterfaceType($if_name)) {
                my $output_if = &getInterfaceConfig($if_name);

                if (   !$output_if
                    || !$output_if->{mac}
                    || (defined $output_if->{is_slave} && $output_if->{is_slave} eq 'true'))
                {
                    $output_if = &getSystemInterface($if_name);
                }

                push(@interfaces, $output_if);
            }
        }
    }
    elsif ($list_type eq 'virtual') {
        require Relianoid::Validate;

        opendir my $conf_dir, &getGlobalConfiguration('configdir');
        my $virt_if_re = &getValidFormat('virt_interface');

        my $parents_list;
        for my $file_name (sort readdir $conf_dir) {
            if ($file_name =~ /^if_($virt_if_re)_conf$/) {
                my $if_name = $1;
                next if ($iface_name and ($iface_name ne $if_name));
                my $iface = &getInterfaceConfig($if_name);

                #$iface->{status} = &getInterfaceSystemStatus( $iface );

                # put the mac, gateway and netmask of the parent interface
                if (not defined $parents_list->{ $iface->{parent} }) {
                    $parents_list->{ $iface->{parent} } =
                      &getInterfaceConfig($iface->{parent});
                }
                $iface->{mask}    = $parents_list->{ $iface->{parent} }{mask};
                $iface->{mac}     = $parents_list->{ $iface->{parent} }{mac};
                $iface->{gateway} = $parents_list->{ $iface->{parent} }{gateway};
                push(@interfaces, $iface);
            }
        }
    }
    else {
        my $msg = "Interface type '$list_type' is not supported.";
        &log_error($msg, "NETWORK");
        die($msg);
    }

    return @interfaces;
}

=pod

=head1 getAppendInterfaces

Get vlans or virtual interfaces configured from a interface.
If the interface is a nic or bonding, this function return the virtual interfaces
create from the VLANs, for example: eth0.2:virt

Parameters:

    ifaceName - Interface name.
    type - Interface type: vlan or virtual.

Returns:

    scalar - reference to an array of interfaces names.

=cut

# Get vlan or virtual interfaces appended from a interface
sub getAppendInterfaces ($if_parent, $type) {
    my @output      = ();
    my @list        = &getInterfaceList();
    my $vlan_tag    = &getValidFormat('vlan_tag');
    my $virtual_tag = &getValidFormat('virtual_tag');

    for my $if (@list) {
        if ($type eq 'vlan') {
            push @output, $if if ($if =~ /^$if_parent\.$vlan_tag$/);
        }

        if ($type eq 'virtual') {
            push @output, $if
              if ($if =~ /^$if_parent(?:\.$vlan_tag)?\:$virtual_tag$/);
        }
    }

    return \@output;
}

=pod

=head1 getInterfaceList

Return a list of all network interfaces detected in the system.

Parameters:

    None.

Returns:

    array - list of network interface names.
    array empty - if no network interface is detected.

See Also:

    <listActiveInterfaces>

=cut

sub getInterfaceList () {
    my @if_list = ();
    push @if_list, &getLinkNameList();
    push @if_list, &getVirtualInterfaceNameList();
    return @if_list;
}

=pod

=head1 getVirtualInterfaceNameList

Get a list of the virtual interfaces names.

Parameters:

    none - .

Returns:

    list - Every virtual interface name.

=cut

sub getVirtualInterfaceNameList () {
    require Relianoid::Validate;

    opendir(my $conf_dir, &getGlobalConfiguration('configdir'));
    my $virt_if_re = &getValidFormat('virt_interface');
    my @interfaces;

    for my $filename (readdir($conf_dir)) {
        push @interfaces, $1 if ($filename =~ /^if_($virt_if_re)_conf$/);
    }

    closedir($conf_dir);

    return @interfaces;
}

=pod

=head1 getLinkInterfaceNameList

Get a list of the link interfaces names. (nic, bond and vlan)

Parameters:

    none - .

Returns:

    list - Every link interface name.

=cut

sub getLinkNameList () {
    my $sys_net_dir = &getGlobalConfiguration('sys_net_dir');

    # Get link interfaces (nic, bond and vlan)
    opendir(my $if_dir, $sys_net_dir);
    my @if_list = grep { -l "$sys_net_dir/$_" } readdir $if_dir;
    closedir $if_dir;

    return @if_list;
}

=pod

=head1 getInterfaceNameStruct

Get a struct configured interfaces names.

Parameters:

    $if_type - Type of interface. nic, bonding, vlan,virtual.

Returns:

    Hash ref - Struct of every interface name divided by type or List if type param is defined.

=cut

sub getInterfaceNameStruct ($if_type = undef) {
    my $interfaces_ref;

    my $bonding_struct;
    if ($eload) {
        my $params = ["name"];
        $bonding_struct = &eload(
            module => 'Relianoid::EE::Net::Bonding',
            func   => 'getBondListStruct',
            args   => [$params]
        );
    }

    opendir(my $conf_dir, &getGlobalConfiguration('configdir'));
    for my $filename (readdir($conf_dir)) {
        if ($filename =~ /^if_([a-zA-Z0-9\-]+)(?:\.(\d{1,4}))?(?:\:([a-zA-Z0-9\-]+))?_conf$/) {
            my $interface = $1;
            my $tag       = $2;
            my $virtual   = $3;

            my $type = "nic";

            if ($eload) {
                $type = "bond" if (exists $bonding_struct->{$interface});
            }

            if (defined $virtual) {
                if (defined $if_type) {
                    $interface .= ".$tag" if (defined $tag);
                    push @{$interfaces_ref}, "$interface:$virtual"
                      if ($if_type eq "virtual");
                }
                elsif (defined $tag) {
                    $interfaces_ref->{$type}{$interface}{vlan}{$tag}{virtual}{$virtual} =
                      undef;
                }
                else {
                    if (not exists $interfaces_ref->{$type}{$interface}{virtual}{$virtual}) {
                        $interfaces_ref->{$type}{$interface}{virtual}{$virtual} = undef;
                    }
                }
            }
            else {
                if (defined $tag) {
                    if (defined $if_type) {
                        push @{$interfaces_ref}, "$interface.$tag"
                          if ($if_type eq "vlan");
                        next;
                    }
                    elsif (not exists $interfaces_ref->{$type}{$interface}{vlan}{$tag}) {
                        $interfaces_ref->{$type}{$interface}{vlan}{$tag} = undef;
                    }
                }
                else {
                    if (defined $if_type) {
                        push @{$interfaces_ref}, $interface
                          if ($if_type eq $type);
                        next;
                    }
                    elsif (not exists $interfaces_ref->{$type}{$interface}) {
                        $interfaces_ref->{$type}{$interface} = undef;
                    }
                }
            }
        }
    }
    closedir($conf_dir);

    return $interfaces_ref;
}

=pod

=head1 getInterfaceByIp

Ask for the name of the interface using the IP address

Parameters:

    IP - IP address

Returns:

    String - Interface name

=cut

sub getInterfaceByIp ($ip) {
    require Relianoid::Net::Validate;

    my $output         = "";
    my $ip_ver         = &ipversion($ip);
    my $addr_ref       = NetAddr::IP->new($ip);
    my $params         = [ "name", "addr" ];
    my $interface_list = &getConfigInterfaceList($params);

    if ($ip_ver == 4) {
        for my $if_ref (@{$interface_list}) {
            if (    $if_ref->{addr}
                and $if_ref->{addr} eq $ip
                and &ipversion($if_ref->{addr}) eq $ip_ver)
            {
                $output = $if_ref->{name};
                last;
            }
        }
    }
    elsif ($ip_ver == 6) {
        for my $if_ref (@{$interface_list}) {
            if (NetAddr::IP->new($if_ref->{addr}) eq $addr_ref) {
                $output = $if_ref->{name};
                last;
            }
        }
    }

    return $output;
}

=pod

=head1 getIpAddressExists

Return if an IP address is used on any interface

Parameters:

    IP - IP address

Returns:

    Integer - 0 if it doesn't exist or 1 if the IP already exists

=cut

sub getIpAddressExists ($ip) {
    require Relianoid::Net::Validate;

    my $output         = 0;
    my $ip_ver         = &ipversion($ip);
    my $params         = ["addr"];
    my $interface_list = &getConfigInterfaceList($params);

    if ($ip_ver == 4) {
        for my $if_ref (@{$interface_list}) {
            if (    $if_ref->{addr}
                and $if_ref->{addr} eq $ip
                and &ipversion($if_ref->{addr}) eq $ip_ver)
            {
                $output = 1;
                last;
            }
        }
    }
    elsif ($ip_ver == 6) {
        my $addr_ref = NetAddr::IP->new($ip);
        for my $if_ref (@{$interface_list}) {
            if (NetAddr::IP->new($if_ref->{addr}) eq $addr_ref) {
                $output = 1;
                last;
            }
        }
    }

    return $output;
}

=pod

=head1 getIpAddressList

It returns a list with the IPv4 and IPv6 that exist in the system

Parameters:

    none

Returns:

    Array ref - List of IPs

=cut

sub getIpAddressList () {
    my @out    = ();
    my $params = ["addr"];
    for my $if_ref (@{ &getConfigInterfaceList($params) }) {
        if ($if_ref->{addr}) {
            push @out, $if_ref->{addr};
        }
    }

    return \@out;
}

=pod

=head1 getInterfaceChild

Show the interfaces that depends directly of the interface.
From a nic, bonding and VLANs interfaces depend the virtual interfaces.
From a virtual interface depends the floating interfaces.

Parameters:

    string - Interface name.

Returns:

    array - List of interface names.

=cut

sub getInterfaceChild ($if_name) {
    unless (length $if_name) {
        croak('required non-empty string');
    }

    my $if_type = &getInterfaceType($if_name);

    unless (defined $if_type) {
        croak('Network interface not found');
    }

    my @output      = ();
    my $virtual_tag = &getValidFormat('virtual_tag');

    # show floating interfaces used by this virtual interface
    if ($if_type eq 'virtual') {
        if ($eload) {
            require Config::Tiny;
            my $float = Config::Tiny->read(&getGlobalConfiguration('floatfile'));

            for my $iface (keys %{ $float->{_} }) {
                push @output, $iface if ($float->{_}{$iface} eq $if_name);
            }
        }
    }

    # the other type of interfaces can have virtual interfaces as child
    # vlan, bond and nic
    else {
        push @output, grep { "${if_name}:${virtual_tag}" eq $_ } &getVirtualInterfaceNameList();
    }

    return @output;
}

=pod

=head1 getAddressNetwork

Parameters:

    $addr - string - IP address.
    $mask - string or number.
    $ip_v - IP version 4 or 6, optional.

Returns:

    string

=cut

sub getAddressNetwork ($addr, $mask, $ip_v = undef) {
    require NetAddr::IP;
    require Scalar::Util;

    my $net;

    if (not Scalar::Util::looks_like_number($ip_v)) {
        $net  = undef;
        $ip_v = ipversion($addr);
    }

    if ($ip_v == 4) {
        my $ip = NetAddr::IP->new($addr, $mask);
        $net = lc $ip->network()->addr();
    }
    elsif ($ip_v == 6) {
        my $ip = NetAddr::IP->new6($addr, $mask);
        $net = lc $ip->network()->addr();
    }

    return $net;
}

=pod

=head1 get_interface_list_struct

Parameters:

    none

Returns:

    reference to a list of interface hashes

=cut

sub get_interface_list_struct () {
    require Relianoid::User;

    my @output_list;

    # Configured interfaces list
    my @interfaces = @{ &getSystemInterfaceList() };    #140

    # get cluster interfaces
    my $cluster_if;

    if ($eload) {
        $cluster_if = &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'getClusterInterfaces',     # 100
        );
    }

    my $rbac_mod;
    my $rbac_if_list = [];
    my $user         = &getUser();

    if ($eload && ($user ne 'root')) {
        $rbac_mod     = 1;
        $rbac_if_list = &eload(
            module => 'Relianoid::EE::RBAC::Group::Core',    # 100
            func   => 'getRBACUsersResources',
            args   => [ $user, 'interfaces' ],
        );
    }

    # to include 'has_vlan' to nics
    my $interfaces_ref = &getInterfaceNameStruct();

    my $all_status = &getInterfaceSystemStatusAll();
    for my $if_ref (@interfaces) {
        # Exclude cluster maintenance interface
        next if $if_ref->{type} eq 'dummy';

        # Exclude no user's virtual interfaces, but pass the physical ones
        next if ($rbac_mod
             && ($if_ref->{type} ne 'virtual' || !grep { $if_ref->{name} eq $_ } @{$rbac_if_list})
             && ($if_ref->{type} eq 'virtual'));

        $if_ref->{status} = $all_status->{ $if_ref->{name} };

        # Any key must cotain a value or "" but can't be null
        if (!defined $if_ref->{name})    { $if_ref->{name}    = ""; }
        if (!defined $if_ref->{addr})    { $if_ref->{addr}    = ""; }
        if (!defined $if_ref->{mask})    { $if_ref->{mask}    = ""; }
        if (!defined $if_ref->{gateway}) { $if_ref->{gateway} = ""; }
        if (!defined $if_ref->{status})  { $if_ref->{status}  = ""; }
        if (!defined $if_ref->{mac})     { $if_ref->{mac}     = ""; }

        my $if_conf = {
            name    => $if_ref->{name},
            ip      => $if_ref->{addr},
            netmask => $if_ref->{mask},
            gateway => $if_ref->{gateway},
            status  => $if_ref->{status},
            mac     => $if_ref->{mac},
            type    => $if_ref->{type},
            # ipv     => $if_ref->{ip_v},
        };

        if ($eload and $if_ref->{type} ne 'virtual') {
            $if_conf->{dhcp} = $if_ref->{dhcp};
        }

        if ($if_ref->{type} eq 'nic') {
            my @bond_slaves = ();

            @bond_slaves = &eload(
                module => 'Relianoid::EE::Net::Bonding',
                func   => 'getAllBondsSlaves',
            ) if ($eload);

            $if_conf->{is_slave} = (grep { $$if_ref{name} eq $_ } @bond_slaves) ? 'true' : 'false';

            if (exists $interfaces_ref->{ $if_ref->{type} }{ $if_ref->{name} }{vlan}) {
                $if_conf->{has_vlan} = 'true';
            }
            $if_conf->{has_vlan} = 'false' unless $if_conf->{has_vlan};
        }

        if ($cluster_if && @{$cluster_if} && grep { $if_ref->{name} eq $_ } @{$cluster_if}) {
            $if_conf->{is_cluster} = 'true';
        }

        push @output_list, $if_conf;
    }

    if ($eload) {
        my $out = \@output_list;
        $out = &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'addAliasInterfaceStruct',
            args   => [$out],
        );
    }
    return \@output_list;
}

=pod

=head1 get_nic_struct

Parameters:

    $nic - NIC interface name

Returns:

    reference to a nic interface hash

=cut

sub get_nic_struct ($nic) {
    my $interface;
    my @nic_list = &getInterfaceTypeList('nic', $nic);
    my $if_ref   = $nic_list[0];

    $if_ref->{status} = &getInterfaceSystemStatus($if_ref);

    # Any key must contain a value or "" but can't be null
    if (!defined $if_ref->{name})    { $if_ref->{name}    = ""; }
    if (!defined $if_ref->{addr})    { $if_ref->{addr}    = ""; }
    if (!defined $if_ref->{mask})    { $if_ref->{mask}    = ""; }
    if (!defined $if_ref->{gateway}) { $if_ref->{gateway} = ""; }
    if (!defined $if_ref->{status})  { $if_ref->{status}  = ""; }
    if (!defined $if_ref->{mac})     { $if_ref->{mac}     = ""; }

    $interface = {
        name    => $if_ref->{name},
        ip      => $if_ref->{addr},
        netmask => $if_ref->{mask},
        gateway => $if_ref->{gateway},
        status  => $if_ref->{status},
        mac     => $if_ref->{mac},
    };

    $interface->{is_slave} = $if_ref->{is_slave} if $eload;
    $interface->{dhcp}     = $if_ref->{dhcp}     if $eload;
    if ($eload) {
        $interface = &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'addAliasInterfaceStruct',
            args   => [$interface],
        );
    }

    return $interface;
}

=pod

=head1 get_nic_list_struct

Parameters:

    none

Returns:

    reference to a list of interface hashes of nics

=cut

sub get_nic_list_struct () {
    my $interface_ref = &getInterfaceNameStruct();
    my $all_status    = &getInterfaceSystemStatusAll();
    my $cluster_if;
    my @output_list;

    if ($eload) {
        $cluster_if = &eload(module => 'Relianoid::EE::Cluster', func => 'getClusterInterfaces');
    }

    for my $if_ref (&getInterfaceTypeList('nic')) {
        $if_ref->{status} = $all_status->{ $if_ref->{name} };

        # Any key must cotain a value or "" but can't be null
        if (!defined $if_ref->{name})    { $if_ref->{name}    = ""; }
        if (!defined $if_ref->{addr})    { $if_ref->{addr}    = ""; }
        if (!defined $if_ref->{mask})    { $if_ref->{mask}    = ""; }
        if (!defined $if_ref->{gateway}) { $if_ref->{gateway} = ""; }
        if (!defined $if_ref->{status})  { $if_ref->{status}  = ""; }
        if (!defined $if_ref->{mac})     { $if_ref->{mac}     = ""; }

        my $if_conf = {
            name    => $if_ref->{name},
            ip      => $if_ref->{addr},
            netmask => $if_ref->{mask},
            gateway => $if_ref->{gateway},
            status  => $if_ref->{status},
            mac     => $if_ref->{mac},
        };

        if ($eload) {
            $if_conf = &eload(
                module => 'Relianoid::EE::Alias',
                func   => 'addAliasInterfaceStruct',
                args   => [$if_conf],
            );
        }

        $if_conf->{is_slave} = $if_ref->{is_slave}        if $eload;
        $if_conf->{dhcp}     = $if_ref->{dhcp} // 'false' if $eload;

        if (    $cluster_if
            and @{$cluster_if}
            and grep { defined $_ and $if_ref->{name} eq $_ } @{$cluster_if})
        {
            $if_conf->{is_cluster} = 'true';
        }

        if (exists $interface_ref->{nic}{ $if_ref->{name} }{vlan}) {
            $if_conf->{has_vlan} = 'true';
        }

        $if_conf->{has_vlan} = 'false' unless $if_conf->{has_vlan};

        push @output_list, $if_conf;
    }

    return \@output_list;
}

=pod

=head1 get_vlan_struct

Parameters:

    $vlan - VLAN interface name

Returns:

    reference to a VLAN interface hash

=cut

sub get_vlan_struct ($vlan) {
    my @vlan_list = &getInterfaceTypeList('vlan', $vlan);
    my $interface = $vlan_list[0];

    return unless $interface;

    $interface->{status} = &getInterfaceSystemStatus($interface);

    # Any key must contain a value or "" but can't be null
    if (!defined $interface->{name})    { $interface->{name}    = ""; }
    if (!defined $interface->{addr})    { $interface->{addr}    = ""; }
    if (!defined $interface->{mask})    { $interface->{mask}    = ""; }
    if (!defined $interface->{gateway}) { $interface->{gateway} = ""; }
    if (!defined $interface->{status})  { $interface->{status}  = ""; }
    if (!defined $interface->{mac})     { $interface->{mac}     = ""; }

    my $output = {
        name    => $interface->{name},
        ip      => $interface->{addr},
        netmask => $interface->{mask},
        gateway => $interface->{gateway},
        status  => $interface->{status},
        mac     => $interface->{mac},
    };

    if ($eload) {
        $output = &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'addAliasInterfaceStruct',
            args   => [$output],
        );
    }
    $output->{dhcp} = $interface->{dhcp} // 'false' if $eload;

    return $output;
}

=pod

=head1 get_vlan_list_struct

Parameters:

    none

Returns:

    reference to a list of interface hashes of VLANs

=cut

sub get_vlan_list_struct () {
    my @output_list;
    my $cluster_if;

    if ($eload) {
        # get cluster interfaces
        $cluster_if = &eload(
            module => 'Relianoid::EE::Cluster',
            func   => 'getClusterInterfaces',
        );
    }

    my $all_status = &getInterfaceSystemStatusAll();
    for my $if_ref (&getInterfaceTypeList('vlan')) {
        $if_ref->{status} = $all_status->{ $if_ref->{name} };

        # Any key must cotain a value or "" but can't be null
        if (!defined $if_ref->{name})    { $if_ref->{name}    = ""; }
        if (!defined $if_ref->{addr})    { $if_ref->{addr}    = ""; }
        if (!defined $if_ref->{mask})    { $if_ref->{mask}    = ""; }
        if (!defined $if_ref->{gateway}) { $if_ref->{gateway} = ""; }
        if (!defined $if_ref->{status})  { $if_ref->{status}  = ""; }
        if (!defined $if_ref->{mac})     { $if_ref->{mac}     = ""; }

        my $if_conf = {
            name    => $if_ref->{name},
            ip      => $if_ref->{addr},
            netmask => $if_ref->{mask},
            gateway => $if_ref->{gateway},
            status  => $if_ref->{status},
            mac     => $if_ref->{mac},
            parent  => $if_ref->{parent},
        };

        if ($eload) {
            $if_conf = &eload(
                module => 'Relianoid::EE::Alias',
                func   => 'addAliasInterfaceStruct',
                args   => [$if_conf],
            );
        }
        $if_conf->{dhcp} = $if_ref->{dhcp} // 'false' if $eload;

        if ($cluster_if && @{$cluster_if} && (grep { $if_ref->{name} eq $_ } @{$cluster_if})) {
            $if_conf->{is_cluster} = 'true';
        }

        push @output_list, $if_conf;
    }

    return \@output_list;
}

=pod

=head1 get_virtual_struct

Parameters:

    $virtual - Virtual interface name

Returns:

    reference to a Virtual interface hash

=cut

sub get_virtual_struct ($virtual) {
    my @virtual_list = &getInterfaceTypeList('virtual', $virtual);
    my $interface    = $virtual_list[0];

    return unless $interface;

    $interface->{status} = &getInterfaceSystemStatus($interface);

    # Any key must contain a value or "" but can't be null
    if (!defined $interface->{name})    { $interface->{name}    = ""; }
    if (!defined $interface->{addr})    { $interface->{addr}    = ""; }
    if (!defined $interface->{mask})    { $interface->{mask}    = ""; }
    if (!defined $interface->{gateway}) { $interface->{gateway} = ""; }
    if (!defined $interface->{status})  { $interface->{status}  = ""; }
    if (!defined $interface->{mac})     { $interface->{mac}     = ""; }

    my $output = {
        name    => $interface->{name},
        ip      => $interface->{addr},
        netmask => $interface->{mask},
        gateway => $interface->{gateway},
        status  => $interface->{status},
        mac     => $interface->{mac},
    };

    if ($eload) {
        $output = &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'addAliasInterfaceStruct',
            args   => [$output],
        );
    }

    return $output;
}

=pod

=head1 get_virtual_list_struct

Parameters:

    none

Returns:

    reference to a list of virtual interface hashes

=cut

sub get_virtual_list_struct () {
    my @output_list = ();
    my $all_status  = &getInterfaceSystemStatusAll();
    for my $if_ref (&getInterfaceTypeList('virtual')) {
        $if_ref->{status} = $all_status->{ $if_ref->{name} };

        # Any key must cotain a value or "" but can't be null
        if (!defined $if_ref->{name})    { $if_ref->{name}    = ""; }
        if (!defined $if_ref->{addr})    { $if_ref->{addr}    = ""; }
        if (!defined $if_ref->{mask})    { $if_ref->{mask}    = ""; }
        if (!defined $if_ref->{gateway}) { $if_ref->{gateway} = ""; }
        if (!defined $if_ref->{status})  { $if_ref->{status}  = "down"; }
        if (!defined $if_ref->{mac})     { $if_ref->{mac}     = ""; }

        push @output_list,
          {
            name    => $if_ref->{name},
            ip      => $if_ref->{addr},
            netmask => $if_ref->{mask},
            gateway => $if_ref->{gateway},
            status  => $if_ref->{status},
            mac     => $if_ref->{mac},
            parent  => $if_ref->{parent},
          };
    }

    if ($eload) {
        my $out = \@output_list;
        $out = &eload(
            module => 'Relianoid::EE::Alias',
            func   => 'addAliasInterfaceStruct',
            args   => [$out],
        );
    }

    return \@output_list;
}

=pod

=head1 setVlan

Store a VLAN network interface configuration.

Parameters:

    if_ref - Reference to a network interface hash.
    params - Reference to the hash of params to modify.

Returns:

    boolean - 0 on success, or 1 on failure.

=cut

sub setVlan ($if_ref, $params) {
    my $err = 0;

    require Relianoid::Net::Core;
    require Relianoid::Net::Route;

    my $oldIf_ref = &getInterfaceConfig($if_ref->{name});

    if ($if_ref->{dhcp} and $if_ref->{dhcp} eq "true") {
        $if_ref->{addr}    = "";
        $if_ref->{net}     = "";
        $if_ref->{mask}    = "";
        $if_ref->{gateway} = "";
    }

    if (length $if_ref->{mac} == 0) {
        my $parent_if_name = &getParentInterfaceName($if_ref->{name});
        my $parent_config  = &getInterfaceConfig($parent_if_name);

        $if_ref->{mac} = $parent_config->{mac};
    }

    # Creating a new interface
    if (!defined $oldIf_ref) {
        $err = &createVlan($if_ref);
        return 1 if $err;
    }

    # Modifying
    my $oldAddr;

    # Add new IP, netmask and gateway
    if ($if_ref->{addr} and length $if_ref->{addr}) {
        return 1 if &addIp($if_ref);
        return 1 if &writeRoutes($if_ref->{name});

        $oldAddr = $oldIf_ref->{addr};
    }

    my $state = 1;

    if ($if_ref->{status} eq 'up') {
        $state = &upIf($if_ref, 1);
    }

    return 1 if not &setInterfaceConfig($if_ref);

    if ($state == 0) {
        $if_ref->{status} = "up";

        if ($if_ref->{addr}) {
            return 1 if &applyRoutes("local", $if_ref);
        }
    }

    if ($eload && exists $params->{mac}) {
        if (&eload(module => 'Relianoid::EE::Net::Mac', func => 'addMAC', args => [ $if_ref->{name}, $if_ref->{mac} ])) {
            return 1;
        }
    }

    # if the GW is changed, change it in all appending virtual interfaces
    if ($if_ref->{gateway}) {
        for my $appending (&getInterfaceChild($if_ref->{name})) {
            my $app_config = &getInterfaceConfig($appending);
            $app_config->{gateway} = $params->{gateway};
            &setInterfaceConfig($app_config);
        }
    }

    # if the netmask is changed, change it in all appending virtual interfaces
    if (exists $params->{netmask}) {
        for my $appending (&getInterfaceChild($if_ref->{name})) {
            my $app_config = &getInterfaceConfig($appending);
            &delRoutes("local", $app_config);
            &downIf($app_config);
            $app_config->{mask} = $params->{netmask};
            &setInterfaceConfig($app_config);
        }
    }

    # put all dependant interfaces up
    require Relianoid::Net::Util;
    &setIfacesUp($if_ref->{name}, "vini");

    if ($oldAddr) {
        require Relianoid::Farm::Base;
        my @farms = &getFarmListByVip($oldAddr);

        # change farm vip,
        if (@farms) {
            require Relianoid::Farm::Config;
            &setAllFarmByVip($params->{ip}, \@farms);
        }
    }

    return 0;
}

=pod

=head1 createVlan

Create a VLAN from an interface hash

Parameters:

    $if_ref - VLAN interface reference 

Returns: integer

    0        - On success
    Non-zero - If there was an error

=cut

sub createVlan ($if_ref) {
    require Relianoid::Net::Core;
    require Relianoid::Net::Route;

    my $err = 0;

    $err = &createIf($if_ref);

    if (!$err) {
        &writeRoutes($if_ref->{name});
    }

    if (!$err) {
        $err = 2 if (!&setInterfaceConfig($if_ref));
    }

    if ($err) {
        &log_error("The vlan $if_ref->{name} could not be created", "NETWORK");
    }
    else {
        &log_info("The vlan $if_ref->{name} was created properly", "NETWORK");
    }

    return $err;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Net/Route.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use Relianoid::Core;

my $eload = eval { require Relianoid::ELoad };

my $ip_bin = &getGlobalConfiguration('ip_bin');

=pod

=head1 Module

Relianoid::Net::Route

=cut

=pod

=head1 writeRoutes

It sets a routing table id and name pair in rt_tables file.

Only required setting up a routed interface. Complemented in delIf()

Parameters:

    if_name - network interface name.

Returns:

    none

=cut

# create table route identification, complemented in delIf()
sub writeRoutes ($if_name) {
    my $rttables = &getGlobalConfiguration('rttables');

    &log_debug("Creating table 'table_$if_name'");

    open my $fh, '<', $rttables;
    my @contents = <$fh>;
    close $fh;

    # the table is already in the file, nothig to do
    if (grep { /^...\ttable_$if_name$/ } @contents) {
        return;
    }

    my $found = "false";
    my $rtnumber;

    # Find next table number available
    for (my $i = 200 ; $i < 1000 && $found eq "false" ; $i++) {
        next if (grep { /^$i\t/ } @contents);
        $found    = "true";
        $rtnumber = $i;
    }

    if ($found eq "true") {
        open(my $fh, ">>", $rttables);
        print $fh "$rtnumber\ttable_$if_name\n";
        close $fh;

        &log_info("Created the table ID 'table_$if_name'", "network");
    }

    return;
}

=pod

=head1 deleteRoutesTable

It removes the a routing table id and name pair from the rt_tables file.

Parameters:

    if_name - network interface name.

Returns:

    none

=cut

sub deleteRoutesTable ($if_name) {
    my $rttables = &getGlobalConfiguration('rttables');

    open my $route_table_in, '<', $rttables;
    my @contents = <$route_table_in>;
    close $route_table_in;

    @contents = grep { !/\ttable_$if_name\n/ } @contents;

    open my $route_table_out, '>', $rttables;
    for my $table (@contents) {
        print $route_table_out $table;
    }
    close $route_table_out;
    return;
}

=pod

=head1 applyRoutingCmd

It creates the command to add a routing entry in a table.

Depend on the passed parameter, it can delete, add or replace the route

Parameters:

    action - it is the action to apply: add, replace or del
    if_ref - network interface hash reference
    table - it is the routing table where the entry will be added

Returns:

    Integer - Error code, it is 0 on success or another value on

TODO:

    use the 'buildRouteCmd' function

=cut

sub applyRoutingCmd ($action, $if_ref, $table) {
    use NetAddr::IP;
    my $routeparams = &getGlobalConfiguration('routeparams');
    my $ip_local    = NetAddr::IP->new($$if_ref{addr}, $$if_ref{mask});
    my $net_local   = $ip_local->network();

    &log_debug("addlocalnet: $action route for $$if_ref{name} in table $table", "NETWORK")
      if &debug();

    my $ip_cmd =
      "$ip_bin -$$if_ref{ip_v} route $action $net_local dev $$if_ref{name} src $$if_ref{addr} table $table $routeparams";

    my $err = &logAndRun($ip_cmd);
    return $err;
}

=pod

=head1 addlocalnet

Set routes to interface subnet into interface routing tables and fills the interface table.

Parameters:

    if_ref - network interface hash reference.

Returns:

    void - .

See Also:

    Only used here: <applyRoutes>

=cut

sub addlocalnet ($if_ref) {
    &log_debug("addlocalnet( name: $$if_ref{name}, addr: $$if_ref{addr}, mask: $$if_ref{mask} )", "NETWORK")
      if &debug();

    # Get network
    use NetAddr::IP;
    my $ip_local  = NetAddr::IP->new($$if_ref{addr}, $$if_ref{mask});
    my $net_local = $ip_local->network();

    # Add or replace local net to all tables
    my @links = ('main', &getLinkNameList());

    my @isolates = ();
    if ($eload) {
        @isolates = &eload(
            module => 'Relianoid::EE::Net::Routing',
            func   => 'getRoutingIsolate',
            args   => [ $$if_ref{name} ],
        );
    }

    # filling the other tables
    for my $link (@links) {
        my $skip_route = 0;
        next if $link eq 'lo';
        next if $link eq 'cl_maintenance';

        my $table = ($link eq 'main') ? 'main' : "table_$link";

        if (grep { /^(?:\*|$table)$/ } @isolates) {
            $skip_route = 1;
        }
        elsif ($link ne 'main') {
            my $iface = &getInterfaceConfig($link);

            # ignores interfaces down or not configured
            next if defined $iface->{status} and $iface->{status} ne 'up';
            next if not defined $iface->{addr};

            #if duplicated network, next
            my $ip_table        = NetAddr::IP->new($$iface{addr}, $$iface{mask});
            my $net_local_table = $ip_table->network();

            if ($net_local_table eq $net_local && $$if_ref{name} ne $link) {
                &log_error(
                    "The network $net_local of dev $$if_ref{name} is the same than the network for $link, route is not going to be applied in table $table",
                    "network"
                );
                $skip_route = 1;
            }
        }

        if (!$skip_route) {
            &applyRoutingCmd('replace', $if_ref, $table);
        }

        if ($eload) {
            &eload(
                module => 'Relianoid::EE::Net::Routing',
                func   => 'applyRoutingTableByIface',
                args   => [ $table, $$if_ref{name} ],
            );
        }
    }

    # filling the own table
    my @ifaces = @{ &getConfigInterfaceList() };
    for my $iface (@ifaces) {
        next if $iface->{name} eq $if_ref->{name};
        my $iface_sys = &getSystemInterface($iface->{name});
        use Relianoid::Net::Core;

        next if $iface_sys->{status} ne 'up';
        next if $iface->{type} eq 'virtual';
        next if defined $iface->{is_slave} and $iface->{is_slave} eq 'true';    # Is in bonding iface
        next if (!defined $iface->{addr} || length $iface->{addr} == 0);        # IP addr doesn't exist
        next if (!&isIp($iface));

        # do not import the iface route if it is isolate
        my @isolates = ();
        if ($eload) {
            @isolates = &eload(
                module => 'Relianoid::EE::Net::Routing',
                func   => 'getRoutingIsolate',
                args   => [ $$iface{name} ],
            );
        }
        next if (grep { /^(?:\*|table_$$if_ref{name})$/ } @isolates);

        &log_debug("addlocalnet: into current interface: name $$iface{name} type $$iface{type}", "NETWORK");

        #if duplicated network, next
        my $ip    = NetAddr::IP->new($$iface{addr}, $$iface{mask});
        my $net   = $ip->network();
        my $table = "table_$$if_ref{name}";

        if ($net eq $net_local && $$iface{name} ne $$if_ref{name}) {
            &log_error(
                "The network $net of dev $$iface{name} is the same than the network for $$if_ref{name}, the route is not going to be applied in table $table",
                "network"
            );
            next;
        }

        &applyRoutingCmd('replace', $iface, $table);
    }

    if ($eload) {
        &eload(
            module => 'Relianoid::EE::Net::Routing',
            func   => 'applyRoutingCustom',
            args   => [ 'add', "table_$$if_ref{name}" ],
        );
    }

    require Relianoid::Net::Core;
    &setRuleIPtoTable($$if_ref{name}, $$if_ref{addr}, "add");

    return;
}

=pod

=head1 isRoute

Checks if any of the routes applied to the system matchs according to the input parameters.
It receives the ip route command line options and it checks the system. 
Example. "src 1.1.12.5 dev eth3 table table_eth3".

Parameters:

    route      - command line options for the "ip route list" command.
    ip_version - version used for the ip command. If this parameter is not used, 
                the command will be executed without this flag

Returns:

    Integer - It returns 1 if any applied rule matchs, or 0 if not

=cut

sub isRoute ($route, $ipv = undef) {
    $ipv = $ipv ? "-$ipv" : '';

    my $exists = 1;
    my $ip_cmd = "$ip_bin $ipv route list $route";
    my $out    = &logAndGet("$ip_cmd");

    if ($out eq '') {
        $exists = 0;
    }
    else {
        require Relianoid::Validate;
        my $ip_re = &getValidFormat('ipv4v6');
        $exists = 0
          if ($exists && $route !~ /src $ip_re/ && $out =~ /src $ip_re/);
    }

    if (&debug() > 1) {
        my $msg = ($exists) ? "(Already exists)" : "(Not found)";
        $msg .= " $ip_cmd";
        &log_debug($msg, "net");
    }

    return $exists;
}

=pod

=head1 existRoute

Checks if any of the paths applied to the system has same properties to the input.
It receives the ip route command line options and it checks the system. Example. "src 1.1.12.5 dev eth3 table table_eth3".

Parameters:

    route - command line options for the "ip route list" command.
    via   - 1 to check via
    src   - 1 to check via

Returns:

    Integer - It returns 1 if any applied rule matchs, or 0 if not

=cut

sub existRoute ($route, $via, $src) {
    require Relianoid::Validate;

    my $ip_re = &getValidFormat('ipv4v6');

    $route =~ s/via ($ip_re)// if not $via;
    $route =~ s/src ($ip_re)// if not $src;

    my $ip_cmd = "$ip_bin route list $route";
    my $out    = &logAndGet("$ip_cmd");

    my $exist = ($out eq '') ? 0 : 1;

    return $exist;
}

=pod

=head1 buildRuleCmd

It creates the command line for a routing directive.

Parameters:

    action - it is the action to apply, 'add' to create a new routing entry, 'del' to delete the requested routing entry or 'undef' to create the parameters wihout adding the 'ip route <action>'
    conf - It is a hash referece with the parameters expected to build the command. The options are:

        ip_v : is the ip version for the route
        priority : is the priority which the route will be execute. Lower priority will be executed before
        not : is the NOT logical operator
        from : is the source address or networking segment from is comming the request
        to : is the destination address or networking segment the request is comming to
        fwmark : is the traffic mark of the packet
        lookup : is the routing table where is going to be added the route

Returns:

    String - It is the command line string to execute in the system

=cut

sub buildRuleCmd ($action, $conf) {
    my $cmd = "";
    my $ipv = (exists $conf->{ip_v}) ? "-$conf->{ip_v}" : "";

    # ip rule { add | del } [ priority PRIO ] [ not ] from IP/NETMASK [ to IP/NETMASK ] [ fwmark FW_MARK ] lookup TABLE_ID
    $cmd .= "$ip_bin $ipv rule $action" if (defined $action);
    if (    (defined $action and $action ne 'list')
        and (exists $conf->{priority} and $conf->{priority} =~ /\d/))
    {
        $cmd .= " priority $conf->{priority} ";
    }
    $cmd .= " not" if (exists $conf->{not} and $conf->{not} eq 'true');
    $cmd .= " from $conf->{from}";
    $cmd .= " to $conf->{to}"
      if (exists $conf->{to} && $conf->{to} ne "");
    $cmd .= " fwmark $conf->{fwmark}"
      if (exists $conf->{fwmark} && $conf->{fwmark} ne "");
    $cmd .= " lookup $conf->{table}";

    return $cmd;
}

=pod

=head1 isRule

Check if routing rule for the given table, from or fwmark exists.

Parameters:

    conf - Rule hash reference.

Returns:

    scalar - number of times the rule was found. True if found.

Todo:

    Rules for Datalink farms are included.

=cut

sub isRule ($conf) {
    my $ipv  = (exists $conf->{ip_v}) ? "-$conf->{ip_v}" : "";
    my $cmd  = "$ip_bin $ipv rule list";
    my $rule = "";
    $rule .= " not" if (exists $conf->{not} and $conf->{not} eq 'true');
    my ($net, $netmask) = split /\//, $conf->{from};
    if (defined $netmask
        and ($netmask eq "32" or $netmask eq "255.255.255.255"))
    {
        $rule .= " from $net";
    }
    else {
        $rule .= " from $conf->{from}";
    }
    $rule .= " to $conf->{to}"
      if (exists $conf->{to} && $conf->{to} ne "");
    $rule .= " fwmark $conf->{fwmark}"
      if (exists $conf->{fwmark} && $conf->{fwmark} ne "");
    $rule .= " lookup $conf->{table}";
    $rule =~ s/^\s+//;
    $rule =~ s/\s+$//;

    my @out = @{ &logAndGet($cmd, 'array') };
    chomp @out;

    my $exist = (grep { /^\d+:\s*$rule\s*$/ } @out) ? 1 : 0;

    if (&debug() > 1) {
        my $msg = ($exist) ? "(Already existed)" : "(Not found)";
        $msg .= " $cmd";
        &log_debug($msg, "net");
    }

    return $exist;
}

=pod

=head1 applyRule

Add or delete the rule according to the given parameters.

Parameters:

    action - "add" to create a new rule or "del" to remove it.
    rule - Rule hash reference.

Returns:

    integer - ip command return code.

Bugs:

    Rules for Datalink farms are included.

=cut

sub applyRule ($action, $rule) {
    return -1 if ($rule->{table} eq "");

    if ($action eq 'add' and ((!defined $rule->{priority}) || $rule->{priority} eq '')) {
        $rule->{priority} = &genRoutingRulesPrio($rule->{type});
    }

    my $cmd    = &buildRuleCmd($action, $rule);
    my $output = &logAndRun("$cmd");

    return $output;
}

=pod

=head1 genRoutingRulesPrio

Create a priority according to the type of route is going to be created

Parameters:

    Type - type of route, the possible values are:

        'iface' for the default interface routes,
        'l4xnat' for the l4xnat backend routes,
        'http or https' for the L7 backend routes,
        'farm-datalink' for the rules applied by datalink farms,
        'user' for the customized routes created for the user,
        'vpn' for the routes applied by vpn connections

Returns:

    Integer - Priority for the route

=cut

sub genRoutingRulesPrio ($type) {
    # The maximun priority value in the system is '32766'
    my $farmL4       = &getGlobalConfiguration('routingRulePrioFarmL4');
    my $farmDatalink = &getGlobalConfiguration('routingRulePrioFarmDatalink');
    my $userInit     = &getGlobalConfiguration('routingRulePrioUserMin');
    my $userEnd      = &getGlobalConfiguration('routingRulePrioUserMax') + 1;
    my $ifacesInit   = &getGlobalConfiguration('routingRulePrioIfaces');

    my $min;
    my $max;

    # l4xnat farm rules
    if ($type eq 'l4xnat' || $type eq 'http' || $type eq 'https') {
        $min = $farmL4;
        $max = $farmDatalink;
    }

    # datalink farm rules
    elsif ($type eq 'farm-datalink') {
        $min = $farmDatalink;
        $max = $userInit;
    }

    # custom rules
    elsif ($type eq 'user') {
        $min = $userInit;
        $max = $userEnd;
    }

    # iface rules
    else {
        return $ifacesInit;
    }

    if ($eload) {
        # vpn rules
        my $vpn = &getGlobalConfiguration('routingRulePrioVPN');
        if ($type eq 'vpn') {
            $min = $vpn;
            $max = $farmL4;
        }
    }

    my $prio;
    my $prioList = &listRoutingRulesPrio();
    for ($prio = $max - 1 ; $prio >= $min ; $prio--) {
        last if (!grep { $prio eq $_ } @{$prioList});
    }

    return $prio;
}

=pod

=head1 listRoutingRulesPrio

List the priority of the rules that are currently applied in the system

Parameters:

    None

Returns:

    Array ref - list of priorities

=cut

sub listRoutingRulesPrio () {
    my $rules = &listRoutingRules();
    my @list;

    for my $r (@{$rules}) {
        push @list, $r->{priority};
    }

    @list = sort @list;
    return \@list;
}

=pod

=head1 getRuleFromIface

It returns a object with the routing parameters that are needed for creating the default route of an interface.

Parameters:

    Interface - name of the interace

Returns:

    Hash ref

    {
        table => "table_eth3",  # table where creating the entry
        type => 'iface',        # type of route rule
        from => 15.255.25.2/24, # networking segement of the interface
    }

=cut

sub getRuleFromIface ($if_ref) {
    my $from = "";
    if (defined($if_ref->{net}) && $if_ref->{net} ne '') {
        $from =
          ($if_ref->{mask} =~ /^\d$/)
          ? "$if_ref->{net}/$if_ref->{mask}"
          : NetAddr::IP->new($if_ref->{net}, $if_ref->{mask})->cidr();
    }

    my $rule = {
        table => "table_$if_ref->{name}",
        type  => 'iface',
        from  => $from,
        ip_v  => $if_ref->{ip_v}
    };

    return $rule;
}

=pod

=head1 setRule

Check and then apply action to add or delete the rule according to the parameters.

Parameters:

    action - "add" to create a new rule or "del" to remove it.
    rule - Rule hash reference

Returns:

    integer - ip command return code.

Bugs:

    Rules for Datalink farms are included.

=cut

sub setRule ($action, $rule) {
    my $output = 0;

    if (!defined($rule->{from}) || $rule->{from} eq '') {
        return 0;
    }
    if ($action !~ /^add$|^del$/) {
        return -1;
    }
    if (defined $rule->{fwmark} && $rule->{fwmark} =~ /^0x0$/) {
        return -1;
    }

    my $isrule = &isRule($rule);

    &log_debug("action '$action' and the rule exist=$isrule", "net");

    if ($action eq "add" && $isrule == 0) {
        &applyRule($action, $rule);
        $output = &isRule($rule) ? 0 : 1;
    }
    elsif ($action eq "del" && $isrule != 0) {
        &applyRule($action, $rule);
        $output = &isRule($rule);
    }

    return $output;
}

=pod

=head1 applyRoutes

Apply routes for interface or default gateway.

For "local" table set route for interface.
For "global" table set route for default gateway and save the default
gateway in global configuration file.

Parameters:

    table - "local" for interface routes or "global" for default gateway route.
    if_ref - network interface hash reference.
    gateway - Default gateway. Only required if table parameter is "global".

Returns:

    integer - ip command return code.

See Also:

    <delRoutes>

=cut

sub applyRoutes ($table, $if_ref, $gateway = undef) {
    my $if_announce = "";
    my $status      = 0;

    # do not add routes if the inteface is down
    my $if_sys = &getSystemInterface($$if_ref{name});
    if ($$if_sys{status} ne 'up') {
        return 0;
    }
    if ($$if_ref{ip_v} != 4 and $$if_ref{ip_v} != 6) {
        return 0;
    }

    unless ($$if_ref{net}) {
        require Relianoid::Net::Interface;
        $$if_ref{net} =
          &getAddressNetwork($$if_ref{addr}, $$if_ref{mask}, $$if_ref{ip_v});
    }

    # not virtual interface
    if (!defined $$if_ref{vini} || $$if_ref{vini} eq '') {
        if ($table eq "local") {
            my $gateway = $$if_ref{gateway} // '';
            &log_info("Applying $table routes in stack IPv$$if_ref{ip_v} to $$if_ref{name} with gateway \"${gateway}\"", "NETWORK");

            &addlocalnet($if_ref);

            if ($$if_ref{gateway}) {
                my $routeparams = &getGlobalConfiguration('routeparams');
                my $ip_cmd =
                  "$ip_bin -$$if_ref{ip_v} route replace default via $$if_ref{gateway} dev $$if_ref{name} table table_$$if_ref{name} $routeparams";
                $status = &logAndRun("$ip_cmd");
            }

            my $rule = &getRuleFromIface($if_ref);
            $status = &setRule("add", $rule);
        }
        else {
            # Apply routes on the global table
            if ($gateway) {
                my $routeparams = &getGlobalConfiguration('routeparams');

                my $action = "replace";
                my $system_default_gw;
                if ($$if_ref{ip_v} == 4) {
                    $system_default_gw = &getDefaultGW();
                }
                elsif ($$if_ref{ip_v} == 6) {
                    $system_default_gw = &getIPv6DefaultGW();
                }

                if (not $system_default_gw) {
                    $action = "add";
                }

                if (&existRoute("default via $gateway dev $$if_ref{name}", 1, 0)) {
                    &log_info("Gateway \"$gateway\" is already applied in $table routes in stack IPv$$if_ref{ip_v}", "NETWORK");
                }
                else {
                    &log_info("Applying $table routes in stack IPv$$if_ref{ip_v} with gateway \"$gateway\"", "NETWORK");
                    my $ip_cmd = "$ip_bin -$$if_ref{ip_v} route $action default via $gateway dev $$if_ref{name} $routeparams";
                    $status = &logAndRun("$ip_cmd");
                }
                if ($$if_ref{ip_v} == 6) {
                    &setGlobalConfiguration('defaultgw6',   $gateway);
                    &setGlobalConfiguration('defaultgwif6', $$if_ref{name});
                }
                else {
                    &setGlobalConfiguration('defaultgw',   $gateway);
                    &setGlobalConfiguration('defaultgwif', $$if_ref{name});
                }
            }
        }
        $if_announce = $$if_ref{name};
    }

    # virtual interface
    else {
        my ($toif) = split(/:/, $$if_ref{name});

        my $rule = &getRuleFromIface($if_ref);
        $rule->{table} = "table_$toif";
        $status        = &setRule("add", $rule);
        $if_announce   = $toif;
    }

    # not send garps to network if node is backup or it is in maintenance
    eval {
        if ($eload) {
            my $cl_status = &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'getClusterNodeStatus',
                args   => [],
            );
            my $cl_maintenance = &eload(
                module => 'Relianoid::EE::Cluster',
                func   => 'getClMaintenanceManual',
                args   => [],
            );

            if (($cl_status and $cl_status ne "backup") and $cl_maintenance ne "true") {
                require Relianoid::Net::Util;
                &log_info("Announcing garp $if_announce and $$if_ref{addr} ");
                &sendGArp($if_announce, $$if_ref{addr});
            }
        }
    };

    return $status;
}

=pod

=head1 delRoutes

Delete routes for interface or default gateway.

For "local" table remove route for interface.
For "global" table remove route for default gateway and removes the
default gateway in global configuration file.

Parameters:

    table - "local" for interface routes or "global" for default gateway route.
    if_ref - network interface hash reference.

Returns:

    integer - ip command return code.

See Also:

    <applyRoutes>

=cut

sub delRoutes ($table, $if_ref) {
    unless ($$if_ref{ip_v}) {
        croak("IP version stack required");
    }

    my $status = 0;

    &log_info("Deleting $table routes for IPv$$if_ref{ip_v} in interface $$if_ref{name}", "NETWORK");

    if (!defined $$if_ref{vini} || $$if_ref{vini} eq '') {
        #an interface is going to be deleted, delete the rule of the IP first
        require Relianoid::Net::Core;
        &setRuleIPtoTable($$if_ref{name}, $$if_ref{addr}, "del");

        if ($table eq "local") {
            # exists if the tables does not exist
            if (!grep { /^table_$if_ref->{name}/ } &listRoutingTablesNames()) {
                &log_debug2("The table table_$if_ref->{name} was not flushed because it was not found", "net");
                return 0;
            }

            my $ip_cmd = "$ip_bin -$$if_ref{ip_v} route flush table table_$$if_ref{name}";

            my ($errno, $out_ref, $err_ref) = &run3($ip_cmd);
            if ($errno == 2 and not @{$out_ref}) {
                if (    grep { /FIB table does not exist./ } @{$err_ref}
                    and grep { /terminated/ } @{$err_ref})
                {
                    $errno = 0;
                }
            }
            $status = $errno;

            if ($status) {
                &log_error("running: $ip_cmd",     "SYSTEM");
                &log_error("out: @{$out_ref}",     "SYSTEM") if @{$out_ref};
                &log_error("err: @{$err_ref}",     "SYSTEM") if @{$err_ref};
                &log_error("last command failed!", "SYSTEM");
            }
            else {
                &log_debug("running: $ip_cmd", "SYSTEM");
                &log_debug2("out: @{$out_ref}", "SYSTEM") if @{$out_ref};
                &log_debug2("err: @{$err_ref}", "SYSTEM") if @{$err_ref};
            }

            my $rule = &getRuleFromIface($if_ref);
            $status = &setRule("del", $rule);
            return $status;
        }
        else {
            # Delete routes on the global table
            my $ip_cmd = "$ip_bin -$$if_ref{ip_v} route del default";
            $status = &logAndRun("$ip_cmd");

            if ($status == 0) {
                if ($$if_ref{ip_v} == 6) {
                    &setGlobalConfiguration('defaultgw6',   '');
                    &setGlobalConfiguration('defaultgwif6', '');
                }
                else {
                    &setGlobalConfiguration('defaultgw',   '');
                    &setGlobalConfiguration('defaultgwif', '');
                }
            }

            return $status;
        }
    }

    return $status;
}

=pod

=head1 getDefaultGW

Get system or interface default gateway.

Parameters:

    if - interface name. Optional.

Returns:

    scalar - Gateway IP address.

See Also:

    <getIfDefaultGW>

=cut

# get default gw for interface
sub getDefaultGW ($if_name = undef) {
    my $gw;
    my @routes = ();

    if ($if_name) {
        my $routed_if = $if_name;
        if ($if_name =~ /\:/) {
            my @iface = split(/\:/, $routed_if);
            $routed_if = $iface[0];
        }

        open(my $fh, '<', &getGlobalConfiguration('rttables'));

        if (grep { /^...\ttable_${routed_if}$/ } <$fh>) {
            @routes = @{ &logAndGet("${ip_bin} route list table table_${routed_if}", "array") };
        }

        close $fh;
    }
    else {
        @routes = @{ &logAndGet("$ip_bin route list", "array") };
    }

    if (my @default_gw = grep { /^default/ } @routes) {
        my @line = split(/ /, $default_gw[0]);
        $gw = $line[2];
    }

    return $gw;
}

=pod

=head1 getIPv6DefaultGW

Get system IPv6 default gateway.

Parameters:

    none - .

Returns:

    scalar - IPv6 default gateway address.

See Also:

    <getDefaultGW>, <getIPv6IfDefaultGW>

=cut

sub getIPv6DefaultGW () {
    my @routes = @{ &logAndGet("$ip_bin -6 route list", "array") };
    my ($default_line) = grep { /^default/ } @routes;

    my $default_gw;
    if ($default_line) {
        $default_gw = (split(' ', $default_line))[2];
    }

    return $default_gw;
}

=pod

=head1 getIPv6IfDefaultGW

Get network interface to IPv6 default gateway.

Parameters:

    none - .

Returns:

    scalar - Interface to IPv6 default gateway.

See Also:

    <getIPv6DefaultGW>, <getIfDefaultGW>

=cut

sub getIPv6IfDefaultGW () {
    my @routes = @{ &logAndGet("$ip_bin -6 route list", "array") };
    my ($default_line) = grep { /^default/ } @routes;

    my $if_default_gw;
    if ($default_line) {
        $if_default_gw = (split(' ', $default_line))[4];
    }

    return $if_default_gw;
}

=pod

=head1 getIfDefaultGW

Get network interface to default gateway.

Parameters:

    none - .

Returns:

    scalar - Interface to default gateway address.

See Also:

    <getDefaultGW>, <getIPv6IfDefaultGW>

=cut

# get interface for default gw
sub getIfDefaultGW () {
    my $if_name;
    my @routes = @{ &logAndGet("$ip_bin route list", "array") };
    if (my @defgw = grep { /^default/ } @routes) {
        my @line = split(/ /, $defgw[0]);
        $if_name = $line[4];
    }

    return $if_name;
}

=pod

=head1 configureDefaultGW

Setup the configured default gateway (for IPv4 and IPv6).

Parameters:

    none

Returns:

    none

See Also:

    relianoid

=cut

sub configureDefaultGW () {
    my $defaultgw    = &getGlobalConfiguration('defaultgw');
    my $defaultgwif  = &getGlobalConfiguration('defaultgwif');
    my $defaultgw6   = &getGlobalConfiguration('defaultgw6');
    my $defaultgwif6 = &getGlobalConfiguration('defaultgwif6');

    # input: global variables $defaultgw and $defaultgwif
    if ($defaultgw && $defaultgwif) {
        my $if_ref = &getInterfaceConfig($defaultgwif, 4);
        if ($if_ref) {
            &applyRoutes("global", $if_ref, $defaultgw);
        }
    }

    # input: global variables $$defaultgw6 and $defaultgwif6
    if ($defaultgw6 && $defaultgwif6) {
        my $if_ref = &getInterfaceConfig($defaultgwif6, 6);
        if ($if_ref) {
            &applyRoutes("global", $if_ref, $defaultgw6);
        }
    }
    return;
}

=pod

=head1 listRoutingTablesNames

It lists the system routing tables by its nickname

Parameters:

    none

Returns:

    Array - List of routing tables in the system

=cut

sub listRoutingTablesNames () {
    my $rttables   = &getGlobalConfiguration('rttables');
    my @list       = ();
    my @exceptions = ('local', 'default', 'unspec');

    require Relianoid::Lock;
    my $fh = &openlock($rttables, 'r');
    chomp(my @rttables_lines = <$fh>);
    close $fh;

    for my $line (@rttables_lines) {
        next if ($line =~ /^\s*#/);

        if ($line =~ /\d+\s+([\w\-\.]+)/) {
            my $name = $1;
            next if grep { $name eq $_ } @exceptions;
            push @list, $name;
        }
    }

    return @list;
}

=pod

=head1 listRoutingRulesSys

It returns a list of the routing rules from the system.

Parameters:

    filter - filter hash reference for matching rules. No filter means all rules.

Returns:

    Array ref - list of routing rules

=cut

sub listRoutingRulesSys ($filter = undef) {
    my $filter_param;
    my @rules = ();

    if (defined $filter) {
        my @filter_params = keys %{$filter};
        $filter_param = $filter_params[0];
    }

    # get data
    my $cmd  = "$ip_bin -j -p rule list";
    my $data = &logAndGet($cmd);

    require JSON;

    my $dec_data = eval { JSON::decode_json($data); };
    if ($@) {
        &log_error("Decoding json: $@", "net");
        $dec_data = [];
    }

    # filter data
    for my $r (@{$dec_data}) {
        if (   (not defined $filter)
            or ($filter->{$filter_param} eq $r->{$filter_param}))
        {
            my $type = (exists $r->{fwmask}) ? 'farm' : 'system';

            $r->{from} = $r->{src};
            $r->{from} .= "/$r->{srclen}" if exists($r->{srclen});

            delete $r->{src};
            delete $r->{srclen};

            $r->{to} = $r->{dst}        if exists($r->{dst});
            $r->{to} .= "/$r->{dstlen}" if exists($r->{dstlen});

            delete $r->{dst};
            delete $r->{dstlen};

            $r->{type} = $type;
            $r->{not}  = 'true' if (exists $r->{not});
            push @rules, $r;
        }
    }

    return \@rules;
}

=pod

=head1 listRoutingRules

It returns a list of the routing rules. These rules are the resulting list of
join the system administred and the created by the user.

Parameters:

    none

Returns:

    Array ref - list of routing rules

=cut

sub listRoutingRules () {
    my @rules_conf = ();

    if ($eload) {
        @rules_conf = @{ &eload(module => 'Relianoid::EE::Net::Routing', func => 'listRoutingRulesConf', args => [],) };
    }

    my @priorities = ();

    for my $r (@rules_conf) {
        push @priorities, $r->{priority};
    }

    for my $sys (@{ &listRoutingRulesSys() }) {
        if (!grep { $sys->{priority} eq $_ } @priorities) {
            push @rules_conf, $sys;
        }
    }

    return \@rules_conf;
}

=pod

=head1 getRoutingOutgoing

It gets the output interface in the system

Only used for floating interfaces in getFloatingSourceAddr()

Parameters:

    ip - IP address
    mark - Optional mark. For example: '0xX'

Returns:

    Hash ref - $route_ref

Variable: $route_ref

    Hash ref that maps the route info

    $ref->{in}{ip}       - dest ip address
    $ref->{in}{mark}     - mark.
    $ref->{out}{ifname}  - Interface name for output.
    $ref->{out}{srcaddr} - IP address for output.
    $ref->{out}{table}   - Route Table name used
    $ref->{out}{custom}  - Custom route

=cut

sub getRoutingOutgoing ($ip, $mark = undef) {
    my $outgoing_ref;
    $outgoing_ref->{in}{ip}       = $ip;
    $outgoing_ref->{in}{mark}     = "";
    $outgoing_ref->{out}{ifname}  = "";
    $outgoing_ref->{out}{srcaddr} = "";
    $outgoing_ref->{out}{table}   = "";
    $outgoing_ref->{out}{custom}  = "";

    my $mark_option = "";
    if ($mark) {
        $outgoing_ref->{in}{mark} = $mark;
        $mark_option = "mark $mark";
    }

    my $cmd  = "$ip_bin -o -d route get $ip $mark_option";
    my $data = &logAndGet($cmd);

    require Relianoid::Validate;
    my $ip_re = &getValidFormat("ip_addr");

    if ($data =~ /^.* \Q$ip\E (?:via .* )?dev (.*) table (.*) src ($ip_re)(?: $mark_option)? uid (.*)/) {
        my $iface      = $1;
        my $table      = $2;
        my $sourceaddr = $3;
        my $custom     = $4;

        if ($iface eq "lo") {
            my $cmd  = "$ip_bin -o -d route list table $table type local";
            my $data = &logAndGet($cmd, "array");
            for my $route_local (@{$data}) {
                if ($route_local =~ /^local \Q$ip\E dev (.*) proto .* src .*/) {
                    $iface = $1;
                    last;
                }
            }
            $outgoing_ref->{out}{custom} = "false";
        }
        else {
            my $route_params = &getGlobalConfiguration('routeparams');
            if ($custom =~ $route_params) {
                $outgoing_ref->{out}{custom} = "false";
            }
            else {
                $outgoing_ref->{out}{custom} = "true";
            }
        }

        $outgoing_ref->{out}{ifname}  = $iface;
        $outgoing_ref->{out}{table}   = $table;
        $outgoing_ref->{out}{srcaddr} = $sourceaddr;
    }

    return $outgoing_ref;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Net/Util.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::Net::Util

=cut

=pod

=head1 getIfacesFromIf

Get List of Vinis or Vlans from a network interface.

Parameters:

    if_name - interface name.
    type - "vini" or "vlan".

Returns:

    list - list of interface references.

See Also:

    Only used in: <setIfacesUp>

=cut

# Get List of Vinis or Vlans from an interface
sub getIfacesFromIf ($if_name, $type) {
    my @ifaces;
    my @configured_interfaces = @{ &getConfigInterfaceList() };

    for my $interface (@configured_interfaces) {
        next if $$interface{name} !~ /^$if_name.+/;

        # get vinis
        if ($type eq "vini" && $$interface{vini} ne '') {
            push @ifaces, $interface;
        }

        # get vlans (including vlan:vini)
        elsif ($type eq "vlan"
            && $$interface{vlan} ne ''
            && $$interface{vini} eq '')
        {
            push @ifaces, $interface;
        }
    }

    return @ifaces;
}

=pod

=head1 setIfacesUp

Bring up all Virtual or VLAN interfaces on a network interface.

Parameters:

    if_name - Name of interface.
    type - "vini" or "vlan".

Returns:

    undef - .

Bugs:

    Set VLANs up.

=cut

# Check if there are some Virtual Interfaces or Vlan with IPv6 and previous UP status to get it up.
sub setIfacesUp ($if_name, $type) {
    if (not($type eq 'vlan' or $type eq 'vini')) {
        die("setIfacesUp: type variable must be 'vlan' or 'vini'");
    }

    my @ifaces = &getIfacesFromIf($if_name, $type);

    if (@ifaces) {
        for my $iface (@ifaces) {
            if ($iface->{status} eq 'up') {
                &addIp($iface);
                if ($iface->{type} eq 'vlan') {
                    &applyRoutes("local", $iface);
                }
            }
        }

        if ($type eq "vini") {
            &log_info("Virtual interfaces of $if_name have been put up.", "NETWORK");
        }
        elsif ($type eq "vlan") {
            &log_info("VLAN interfaces of $if_name have been put up.", "NETWORK");
        }
    }

    return;
}

=pod

=head1 sendGPing

Send gratuitous ICMP packets for L3 aware.

Parameters:

    pif - ping interface name.

Returns:

    none

See Also:

    <sendGArp>

=cut

# send gratuitous ICMP packets for L3 aware
sub sendGPing ($pif) {
    my $if_conf = &getInterfaceConfig($pif);
    my $gw      = $if_conf->{gateway};

    if ($gw) {
        my $ping_bin = &getGlobalConfiguration('ping_bin');
        my $pingc    = &getGlobalConfiguration('pingc');
        my $ping_cmd = "$ping_bin -c $pingc -I $if_conf->{addr} $gw";

        &log_info("Sending $pingc ping(s) to gateway $gw from $if_conf->{addr}", "NETWORK");
        &logAndRunBG("$ping_cmd");
    }
    return;
}

=pod

=head1 sendGArp

Send gratuitous ARP frames.

Broadcast an ip address with ARP frames through a network interface.
Also, pings the interface gateway.

Parameters:

    if - interface name.
    ip - ip address.

Returns:

    none

See Also:

    <broadcastInterfaceDiscovery>, <sendGPing>

=cut

# send gratuitous ARP frames
sub sendGArp ($if, $ip) {
    require Relianoid::Net::Validate;

    my @iface = split(':', $if);
    my $ip_v  = &ipversion($ip);

    if ($ip_v == 4) {
        my $arping_bin      = &getGlobalConfiguration('arping_bin');
        my $arp_unsolicited = &getGlobalConfiguration('arp_unsolicited');

        my $arp_arg    = $arp_unsolicited ? '-U' : '-A';
        my $arping_cmd = "$arping_bin $arp_arg -c 2 -I $iface[0] $ip";

        &log_info("$arping_cmd", "NETWORK");
        &logAndRunBG("$arping_cmd");
    }
    elsif ($ip_v == 6) {
        my $arpsend_bin = &getGlobalConfiguration('arpsend_bin');
        my $arping_cmd  = "$arpsend_bin -U -i $ip $iface[0]";

        &log_info("$arping_cmd", "NETWORK");
        &logAndRunBG("$arping_cmd");
    }

    &sendGPing($iface[0]);
    return;
}

=pod

=head1 setArpAnnounce

Set a cron task to cast a ARP packet each minute

Parameters:

    none

Returns:

    Integer - Error code: 0 on success or another value on failure

=cut

sub setArpAnnounce () {
    my $script = &getGlobalConfiguration("arp_announce_bin");
    my $path   = &getGlobalConfiguration("arp_announce_cron_path");
    my $err    = 0;

    my $fh = &openlock($path, 'w') or return 1;
    print $fh "* * * * *	root	$script &>/dev/null\n";
    close $fh;

    if (!$err) {
        $err = &setGlobalConfiguration('arp_announce', "true");
    }

    return $err;
}

=pod

=head1 unsetArpAnnounce

Remove the cron task to cast a ARP packet each minute

Parameters:

    none

Returns:

    Integer - Error code: 0 on success or another value on failure

=cut

sub unsetArpAnnounce () {
    my $path         = &getGlobalConfiguration("arp_announce_cron_path");

    if (-f $path) {
        my $rem = unlink $path;
        if (!$rem) {
            &log_error("Error deleting the file '$path'", "NETWORK");
            return 1;
        }
    }

    return &setGlobalConfiguration('arp_announce', "false");
}

=pod

=head1 iponif

Get the (primary) ip address on a network interface.

A copy of this function is in noid-cluster-notify.

Parameters:

    if - interface namm.

Returns:

    scalar - string with IP address.

See Also:

    <getInterfaceOfIp>, <_runDatalinkFarmStart>, <_runDatalinkFarmStop>, <noid-cluster-notify>

=cut

#know if and return ip
sub iponif ($if) {
    require IO::Socket;
    require Relianoid::Net::Interface;

    my $s      = IO::Socket::INET->new(Proto => 'udp');
    my $iponif = $s->if_addr($if);

    # fixes virtual interfaces IPs
    unless ($iponif) {
        my $if_ref = &getInterfaceConfig($if);
        $iponif = $if_ref->{addr};
    }

    return $iponif;
}

=pod

=head1 maskonif

Get the network mask of an network interface (primary) address.

Parameters:

    if - interface namm.

Returns:

    scalar - string with network address.

See Also:

    <_runDatalinkFarmStart>, <_runDatalinkFarmStop>

=cut

# return the mask of an if
sub maskonif ($if) {
    require IO::Socket;

    my $s        = IO::Socket::INET->new(Proto => 'udp');
    my $maskonif = $s->if_netmask($if);

    return $maskonif;
}

=pod

=head1 listallips

List all IPs used for interfaces

Parameters:

    none - .

Returns:

    list - All IP addresses.

Bugs:

    $ip !~ /127.0.0.1/
    $ip !~ /0.0.0.0/

=cut

sub listallips () {
    require Relianoid::Net::Interface;

    my @listinterfaces = ();

    for my $if_name (&getInterfaceList()) {
        my $if_ref = &getInterfaceConfig($if_name);
        push @listinterfaces, $if_ref->{addr} if ($if_ref->{addr});
    }

    return @listinterfaces;
}

=pod

=head1 setIpForward

Set IP forwarding on/off

Parameters:

    arg - "true" to turn it on or other to turn it off.

Returns:

    scalar - return

See Also:

    <_runDatalinkFarmStart>

=cut

# Enable(true) / Disable(false) IP Forwarding
sub setIpForward ($arg) {
    my $status = 0;
    my $switch = $arg eq 'true';

    &log_info("setting $arg to IP forwarding ", "NETWORK");

    # switch forwarding as requested
    $status += &logAndRun("echo $switch > /proc/sys/net/ipv4/conf/all/forwarding");
    $status += &logAndRun("echo $switch > /proc/sys/net/ipv4/ip_forward");
    $status += &logAndRun("echo $switch > /proc/sys/net/ipv6/conf/all/forwarding");

    return $status;
}

=pod

=head1 getInterfaceOfIp

Get the name of the interface with such IP address.

Parameters:

    ip - string with IP address.

Returns:

    scalar - Name of interface, if found, undef otherwise.

See Also:

    <enable_cluster>, <new_farm>, <modify_datalink_farm>

=cut

sub getInterfaceOfIp ($ip) {
    require Relianoid::Net::Interface;
    require NetAddr::IP;

    my $ref_addr = NetAddr::IP->new($ip);

    for my $iface (&getInterfaceList()) {
        # return interface if found in the listç
        my $if_ip = &iponif($iface);
        next if (!$if_ip);

        my $if_addr = NetAddr::IP->new($if_ip);

        return $iface if ($if_addr eq $ref_addr);
    }

    # returns an invalid interface name, an undefined variable
    &log_info("Warning: No interface was found configured with IP address $ip", "NETWORK");

    return;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Net/Validate.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use Relianoid::Core;

=pod

=head1 Module

Relianoid::Net::Validate

=cut

=pod

=head1 getNetIpFormat

It gets an IP and it retuns the same IP with the format that system uses for
the binary choosed

Parameters:

    ip - String with the ipv6
    bin - It is the binary for the format

Returns: string

IPv6 with the format of the binary parameter.

=cut

sub getNetIpFormat ($ip, $bin) {
    require Net::IPv6Addr;
    my $x = Net::IPv6Addr->new($ip);

    if ($bin eq 'netstat') {
        return $x->to_string_compressed();
    }
    else {
        &log_error("The bin '$bin' is not recoignized. The ip '$ip' couldn't be converted", "networking");
    }

    return $ip;
}

=pod

=head1 getProtoTransport

It returns the protocols of layer 4 that use a profile or another protocol.

Parameters:

    profile - This parameter accepts a load balancer profile 
              (for Layer 4 it returns the default one when the farm is created): 
                "http", "https", "l4xnat", "gslb"
              or another protocol:
                "tcp", "udp", "sctp", "amanda", "tftp", "netbios-ns",
                "snmp", "ftp", "irc", "pptp", "sane", "all", "sip" or "h323"

Returns: array reference

List of transport protocols that use the passed protocol.
The possible values are "udp", "tcp" or "sctp".

=cut

sub getProtoTransport ($profile) {
    my $proto = [];
    my $all   = [ "tcp", "udp", "sctp" ];

    # profiles
    if ($profile eq "gslb") {
        $proto = [ "tcp", "udp" ];
    }
    elsif ($profile eq "l4xnat") {
        $proto = ["tcp"];    # default protocol when a l4xnat farm is created
    }
    elsif ($profile =~ /^(?:tcp|udp|sctp)$/) {    # protocols
        $proto = [$profile];
    }
    elsif ($profile =~ /^(?:amanda|tftp|netbios-ns|snmp)$/) {    # udp
        $proto = ["udp"];
    }
    elsif ($profile =~ /^(?:ftp|irc|pptp|sane|https?|eproxy)$/) { # tcp
        $proto = ["tcp"];
    }
    elsif ($profile eq "all") {                                  # mix
        $proto = $all;
    }
    elsif ($profile eq "sip") {
        $proto = [ "tcp", "udp" ];
    }
    elsif ($profile eq "h323") {
        $proto = [ "tcp", "udp" ];
    }
    else {
        &log_error("The funct 'getProtoTransport' does not understand the parameter '$profile'", "networking");
    }

    return $proto;
}

=pod

=head1 validatePortKernelSpace

It checks if the IP, port and protocol are used in some l4xnat farm.
This function does the following actions to validate that the protocol
is not used:

    * Remove the incoming farmname from the farm list
    * Check only with l4xnat farms
    * Check with farms with up status
    * Check that farms contain the same VIP
    * There is not collision with multiport

Parameters:

    vip      - virtual IP
    port     - It accepts multiport string format
    proto    - it is an array reference with the list of protocols to check in the port. 
                The protocols can be 'sctp', 'udp', 'tcp' or 'all'
    farmname - It is the farm that is being modified, if this parameter is passed, 
                the configuration of this farm is ignored to avoid checking with itself. 
                This parameter is optional

Returns: integer

- 1: the incoming info is valid
- 0: there is a(nother) farm with that networking information

=cut

sub validatePortKernelSpace ($ip, $port, $proto, $farmname = undef) {
    # get l4 farms
    require Relianoid::Farm::Base;
    require Relianoid::Arrays;

    my @farm_list = &getFarmListByVip($ip);
    return 1 if !@farm_list;

    if (defined $farmname) {
        @farm_list = grep { !/^$farmname$/ } @farm_list;
        return 1 if !@farm_list;
    }

    # check intervals
    my $port_list = &getMultiporExpanded($port);

    for my $farm (@farm_list) {
        next if (&getFarmType($farm) ne 'l4xnat');
        next if (&getFarmStatus($farm) ne 'up');

        # check protocol collision
        my $f_proto = &getProtoTransport(&getL4FarmParam('proto', $farm));
        next if (!&getArrayCollision($proto, $f_proto));

        my $f_port = &getFarmVip('vipp', $farm);

        # check if farm is all ports
        if ($port eq '*' or $f_port eq '*') {
            &log_warn("Port collision with farm '$farm' for using all ports", "net");
            return 0;
        }

        # check port collision
        my $f_port_list = &getMultiporExpanded($f_port);
        my $col         = &getArrayCollision($f_port_list, $port_list);

        if (defined $col) {
            &log_warn("Port collision ($col) with farm '$farm'", "net");
            return 0;
        }
    }

    return 1;
}

=pod

=head1 getMultiporExpanded

It returns the list of ports that a multiport string contains.

Parameters:

    port - multiport port

Returns: array reference

List of ports used by the farm

=cut

sub getMultiporExpanded ($port) {
    my @total_port = ();

    if ($port ne '*') {
        for my $p (split(',', $port)) {
            my ($init, $end) = split(':', $p);

            if   (defined $end) { push @total_port, ($init .. $end); }
            else                { push @total_port, $init; }
        }
    }

    return \@total_port;
}

=pod

=head1 getMultiportRegex

It creates a regular expression to look for a list of ports.
It expands the l4xnat port format (':' for ranges and ',' for listing ports).

Parameters:

    port - port or multiport

Returns: string - Regular expression

=cut

sub getMultiportRegex ($port) {
    my $reg = $port;

    if ($port eq '*') {
        $reg = '\d+';
    }
    elsif ($port =~ /[:,]/) {
        my $total_port = &getMultiporExpanded($port);
        $reg = '(?:' . join('|', @{$total_port}) . ')';
    }

    return $reg;
}

=pod

=head1 validatePortUserSpace

It validates if the port is being used for some process in the user space

Parameters:

    ip       - IP address. If the IP is '0.0.0.0', it checks that other farm or process are not using the port
    port     - TCP port number. It accepts l4xnat multport format: intervals (55:66,70), all ports (*).
    protocol - It is an array reference with the protocols to check ("udp", "tcp" and "sctp"), if some of them is used, the function returns 0.
    farmname - If the configuration is set in this farm, the check is ignored and true. This parameters is optional.
    process  - It is the process name to ignore. It is used when a process wants to be modified with all IPs parameter. 
               The services to ignore are: "cherokee", "sshd" and "snmp"

Returns: integer

- 1: if the port and IP are valid to be used
- 0: if the port and IP are already applied in the system

=cut

sub validatePortUserSpace ($ip, $port, $proto, $farmname = undef, $process = undef) {
    my $override;

    # skip if the running farm is itself
    if (defined $farmname) {
        require Relianoid::Farm::Base;

        my $type = &getFarmType($farmname);
        if ($type =~ /http|gslb|eproxy/) {
            my $cur_vip  = &getFarmVip('vip',  $farmname);
            my $cur_port = &getFarmVip('vipp', $farmname);

            if (    &getFarmStatus($farmname) eq 'up'
                and $cur_vip eq $ip
                and $cur_port eq $port)
            {
                &log_debug("The networking configuration matches with the own farm", "networking");
                return 1;
            }
        }
        elsif ($type eq "l4xnat") {
            $override = 1;
        }
    }

    my $netstat = &getGlobalConfiguration('netstat_bin');

    my $f_ipversion = (&ipversion($ip) == 6) ? "6" : "4";
    $ip = &getNetIpFormat($ip, 'netstat') if ($f_ipversion eq '6');

    my $f       = "lpnW";
    my $f_proto = "";

    for my $p (@{$proto}) {
        # it is not supported in the system
        if   ($p eq 'sctp') { next; }
        else                { $f_proto .= "--$p "; }
    }

    my $cmd = "$netstat -$f_ipversion -${f} ${f_proto} ";
    my @out = @{ &logAndGet($cmd, 'array') };
    shift @out;
    shift @out;

    if (defined $process) {
        my $filter = '^\s*(?:[^\s]+\s+){5,6}\d+\/' . $process;
        @out = grep { !/$filter/ } @out;
        return 1 if (!@out);
    }

    # This code was modified for a bugfix. There was a issue when a l4 farm
    # is set and some management interface is set to use all the interfaces
    # my $ip_reg = ( $ip eq '0.0.0.0' ) ? '[^\s]+' : "(?:0.0.0.0|::1|$ip)";

    my $ip_reg;
    if (defined $override and $override) {
        # L4xnat overrides the user space daemons that are listening on all interfaces
        $ip_reg = ($ip eq '0.0.0.0') ? '[^\s]+' : "(?:$ip)";
    }
    else {
        # L4xnat farms does not override the user space daemons
        $ip_reg = ($ip eq '0.0.0.0') ? '[^\s]+' : "(?:0.0.0.0|::1|$ip)";
    }

    my $port_reg = &getMultiportRegex($port);

    my $filter = '^\s*(?:[^\s]+\s+){3,3}' . $ip_reg . ':' . $port_reg . '\s';
    @out = grep { /$filter/ } @out;

    if (@out) {
        &log_warn("The ip '$ip' and the port '$port' are being used for some process", "networking");
        return 0;
    }

    return 1;
}

=pod

=head1 validatePort

It checks if an IP and a port (checking the protocol) are already configured in the system.
This is used to validate that more than one process or farm are not running with the same
networking configuration.

It checks the information with the "netstat" command, if the port is not found it will look for
between the l4xnat farms (that are up).

If this function is called with more than one protocol. It will recall itself recursively
for each one.

Parameters:

    ip       - IP address. If the IP is '0.0.0.0', it checks that other farm or process are not using the port
    port     - TCP port number. It accepts l4xnat multport format: intervals (55:66,70), all ports (*).
    protocol - It is an array reference with the protocols to check, if some of them is used, the function returns 0. 
                The accepted protocols are: 'all' (no one is checked), sctp, tcp and udp
    farmname - If the configuration is set in this farm, the check is ignored and true. This parameters is optional.
    process  - It is the process name to ignore. It is used when a process wants to be modified with all IPs parameter. 
                The services to ignore are: "cherokee", "sshd" and "snmp"

Returns: integer

    1 - if the port and IP are available to be used
    0 - if the port and IP are already being used in the system

=cut

sub validatePort ($ip, $port, $proto, $farmname = undef, $process = undef) {
    if ($ip eq '*') {
        $ip = '0.0.0.0';
    }

    if (!defined $proto && !defined $farmname) {
        &log_error("Check port needs the protocol to validate the ip '$ip' and the port '$port'", "networking");
        return 0;
    }

    if (!defined $proto) {
        $proto = &getFarmType($farmname);
        if ($proto eq 'l4xnat') {
            require Relianoid::Farm::L4xNAT::Config;
            $proto = &getL4FarmParam('proto', $farmname);
        }
    }

    $proto = &getProtoTransport($proto);

    # TODO: add check for avoiding collision with datalink VIPs
    return 0 if (!&validatePortUserSpace($ip, $port, $proto, $farmname, $process));
    return 0 if (!&validatePortKernelSpace($ip, $port, $proto, $farmname));
    return 1;
}

=pod

=head1 ipisok

Check if a string has a valid IP address format.

Parameters:

    checkip - IP address string.
    version - Optional. 4 or 6 to validate IPv4 or IPv6 only.

Returns: string - "true" or "false".

=cut

sub ipisok ($checkip, $version = undef) {
    require Data::Validate::IP;
    Data::Validate::IP->import();

    if (!$version || $version == 4) {
        return "true" if is_ipv4($checkip)
    }

    if (!$version || $version == 6) {
        return "true" if is_ipv6($checkip)
    }

    return "false";
}

=pod

=head1 validIpAndNet

Validate if the input is a valid IP or networking segement

Parameters:

    ip - IP address or IP network segment. ipv4 or ipv6

Returns: integer

- 1: The IP address is valid
- 0: The IP address is not valid

=cut

sub validIpAndNet ($ip) {
    use NetAddr::IP;
    my $out = NetAddr::IP->new($ip);

    return int(defined $out);
}

=pod

=head1 ipversion

IP version number of an input IP address

Parameters:

    ip - string - IP address

Returns: integer

- 4: ipv4
- 6: ipv6
- 0: unknown

=cut

sub ipversion ($ip) {
    require Data::Validate::IP;
    Data::Validate::IP->import();

    return 4 if is_ipv4($ip);
    return 6 if is_ipv6($ip);
    return 0;
}

=pod

=head1 validateGateway

Check if the network configuration is valid. This function receive two IP
address and a net segment and check if both address are in the segment.
It is usefull to check if the gateway is correct or to check a new IP
for a interface

Parameters:

    ip      - IP from net segment
    netmask - Net segment
    new_ip  - IP to check if it is from net segment

Returns: integer

    1 - the configuration is correct
    0 - the configuration is not correct

=cut

sub validateGateway ($ip, $mask, $ip2, $mask2 = undef) {
    require NetAddr::IP;

    unless (defined $mask2) {
        $mask2 = $mask;
    }

    my $addr1 = NetAddr::IP->new($ip,  $mask);
    my $addr2 = NetAddr::IP->new($ip2, $mask2);

    return (defined $addr1 && defined $addr2 && ($addr1->network() eq $addr2->network())) ? 1 : 0;
}

=pod

=head1 ifexist

Check if an interface exists.

Look for link interfaces, Virtual interfaces return "false".
If the interface is IFF_RUNNING or configuration file exists return "true".
If interface found but not IFF_RUNNING nor configutaion file exists returns "created".

Parameters:

    nif - network interface name.

Returns: string - "true", "false" or "created".

=cut

sub ifexist ($nif) {
    use IO::Interface qw(:flags);    # Needs to load with 'use'

    require IO::Socket;
    require Relianoid::Net::Interface;

    my $s          = IO::Socket::INET->new(Proto => 'udp');
    my @interfaces = &getInterfaceList();
    my $configdir  = &getGlobalConfiguration('configdir');
    my $status;

    for my $if (@interfaces) {
        next if $if ne $nif;

        my $flags = $s->if_flags($if);

        if   ($flags & IFF_RUNNING) { $status = "up"; }
        else                        { $status = "down"; }

        if ($status eq "up" || -e "$configdir/if_$nif\_conf") {
            return "true";
        }

        return "created";
    }

    return "false";
}

=pod

=head1 checkNetworkExists

Check if a network exists in other interface

Parameters:

    ip         - string - IP address
    mask       - string - Netmask
    exception  - string - Optional. Interface name to be excluded.
                          It is used to exclude the interface that is been changed
    duplicated - string - Optional. Overrides the "check duplicated network" option.
                                    Expects "true" or "false" when defined.

Returns: string

- interface name - if the network is found
- empty string   - if the network is not found

=cut

sub checkNetworkExists ($net, $mask, $exception = undef, $duplicated = undef) {
    # $duplicated will override the configured default
    if (defined $duplicated) {
        return "" if $duplicated eq "true";
    }
    else {
        return "" if &getGlobalConfiguration("duplicated_net") eq "true";
    }

    require Relianoid::Net::Interface;
    require NetAddr::IP;

    my $net1 = NetAddr::IP->new($net, $mask);
    my @interfaces;

    my @system_interfaces = &getInterfaceList();
    my $params            = [ "name", "addr", "mask" ];

    for my $if_name (@system_interfaces) {
        next if (&getInterfaceType($if_name) !~ /^(?:nic|bond|vlan|gre)$/);

        my $output_if = &getInterfaceConfigParam($if_name, $params) || &getSystemInterface($if_name);
        push(@interfaces, $output_if);
    }

    my $found = 0;

    for my $if_ref (@interfaces) {
        next if defined $exception and $if_ref->{name} eq $exception;
        next if !$if_ref->{addr};

        # found
        my $net2 = NetAddr::IP->new($if_ref->{addr}, $if_ref->{mask});

        eval {
            if ($net1->contains($net2) or $net2->contains($net1)) {
                $found = 1;
            }
        };

        return $if_ref->{name} if $found;
    }

    return "";
}

=pod

=head1 checkDuplicateNetworkExists

Check if duplicate network exists in the interfaces

Parameters: None

Returns: string

- interface name - if the network is found
- empty string   - if the network is not found

=cut

sub checkDuplicateNetworkExists () {
    #if duplicated network is not allowed then don't check if network exists.
    require Relianoid::Config;

    return "" if &getGlobalConfiguration("duplicated_net") eq "false";

    require Relianoid::Net::Interface;
    require NetAddr::IP;

    my @interfaces = map { &getInterfaceTypeList($_) } qw(nic bond vlan);

    for my $if_ref (@interfaces) {
        my $iface = &checkNetworkExists($if_ref->{addr}, $if_ref->{mask}, $if_ref->{name}, "false");
        return $iface if $iface;
    }

    return "";
}

=pod

=head1 validBackendStack

Check if a list of backends have their IP address in the same stack (IP version) as an IP address of reference

Parameters:

    be_aref - array reference - Array of backend hashes
    ip      - string - IP address

Returns: integer

    1 - the ip is valid
    0 - the IP address is not in the same network segment

=cut

sub validBackendStack ($be_aref, $ip) {
    my $ip_stack     = &ipversion($ip);
    my $ipv_mismatch = 0;

    # check every backend ip version
    for my $be (@{$be_aref}) {
        my $current_stack = &ipversion($be->{ip});
        $ipv_mismatch = $current_stack ne $ip_stack;
        last if $ipv_mismatch;
    }

    return (!$ipv_mismatch);
}

=pod

=head1 validateNetmask

It validates if a netmask is valid for IPv4 or IPv6

Parameters:

    netmask    - string - Netmask
    ip_version - integer - Optional. 4 or 6 are the expected values.
                           If no value is passed, it checks if the netmask is valid for any IP version

Returns: integer

    1 - success
    0 - error

=cut

sub validateNetmask ($mask, $ipversion = undef) {
    unless (defined $mask) {
        croak("mask is required");
    }

    $ipversion //= 0;
    my $success = 0;
    my $ip      = "127.0.0.1";

    if ($ipversion == 0 or $ipversion == 6) {
        return 1 if ($mask =~ /^\d+$/ and $mask <= 64);
    }
    if ($ipversion == 0 or $ipversion == 4) {
        if ($mask =~ /^\d+$/) {
            $success = 1 if $mask <= 32;
        }
        else {
            require Net::Netmask;
            my $block = Net::Netmask->new($ip, $mask);
            $success = (!exists $block->{ERROR});
        }
    }

    return $success;
}

=pod

=head1 getNextAvailableLocalPort

It validates if the port is being used for some process in the user space

Parameters:

    None.

Returns:

    integer - port to be used. Undefined if there is no port available.

=cut

sub getNextAvailableLocalPort () {
    my $ip = "127.0.0.1";
    my @protocol = ('tcp');
    my $first_port = 100;
    my $last_port = 10000;

    for my $port ($first_port .. $last_port) {
        if (&validatePortUserSpace($ip, $port, \@protocol)) {
            return $port;
        }
    }

    return;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Netfilter.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Netfilter

=cut

=pod

=head1 loadNfModule

=cut

sub loadNfModule ($modname, $params) {
    my $status  = 0;
    my $lsmod   = &getGlobalConfiguration('lsmod');
    my @modules = @{ &logAndGet($lsmod, "array") };

    if (!grep { /^$modname /x } @modules) {
        my $modprobe         = &getGlobalConfiguration('modprobe');
        my $modprobe_command = "$modprobe $modname $params";

        &log_info("L4 loadNfModule: $modprobe_command", "SYSTEM");
        $status = &logAndRun("$modprobe_command");
    }

    return $status;
}

=pod

=head1 removeNfModule

=cut

sub removeNfModule ($modname) {
    my $modprobe         = &getGlobalConfiguration('modprobe');
    my $modprobe_command = "$modprobe -r $modname";

    &log_info("L4 removeNfModule: $modprobe_command", "SYSTEM");

    return &logAndRun("$modprobe_command");
}

=pod

=head1 getNewMark

=cut

sub getNewMark ($farm_name) {
    require Tie::File;
    require Relianoid::Lock;

    my $found       = 0;
    my $marknum     = 0x200;
    my $fwmarksconf = &getGlobalConfiguration('fwmarksconf');
    my @contents;

    &ztielock(\@contents, "$fwmarksconf");

    for my $i (512 .. 4095) {
        my $num = sprintf("0x%x", $i);
        if (!grep { /^$num/x } @contents) {
            $found   = 1;
            $marknum = $num;
            last;
        }
    }

    if ($found) {
        push @contents, "$marknum // FARM\_$farm_name\_";
    }

    untie @contents;

    return $marknum;
}

=pod

=head1 delMarks

=cut

sub delMarks ($farm_name = "", $mark = "") {
    require Relianoid::Lock;

    my $status      = 0;
    my $fwmarksconf = &getGlobalConfiguration('fwmarksconf');
    my @contents;

    if ($farm_name ne "") {
        &ztielock(\@contents, "$fwmarksconf");
        @contents = grep { !/ \/\/ FARM\_$farm_name\_$/ } @contents;
        untie @contents;
    }

    if ($mark ne "") {
        &ztielock(\@contents, "$fwmarksconf");
        @contents = grep { !/^$mark \/\/ FARM\_/ } @contents;
        untie @contents;
    }

    return $status;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Nft.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::Nft

=cut

=pod

=head1 getNlbPid

Return the nftlb pid

Parameters:

    none

Returns:

    Integer - PID if successful or -1 on failure

=cut

sub getNlbPid () {
    my $nlbpidfile = &getNlbPidFile();
    my $nlbpid     = -1;

    if (!-f "$nlbpidfile") {
        return -1;
    }

    open my $fd, '<', "$nlbpidfile";
    $nlbpid = <$fd>;
    close $fd;

    if ($nlbpid eq "") {
        return -1;
    }

    return $nlbpid;
}

=pod

=head1 getNlbPidFile

Return the nftlb pid file

Parameters:

    none

Returns:

    String - Pid file path or -1 on failure

=cut

sub getNlbPidFile () {
    my $piddir     = &getGlobalConfiguration('piddir');
    my $nlbpidfile = "$piddir/nftlb.pid";

    return $nlbpidfile;
}

=pod

=head1 startNlb

Launch the nftlb daemon and create the PID file. Do
nothing if already is launched.

Parameters:

    none

Returns:

    Integer - return PID on success or <= 0 on failure

=cut

sub startNlb () {
    my $nftlbd         = &getGlobalConfiguration('bin_dir') . "/nftlbd";
    my $pidof          = &getGlobalConfiguration('pidof');
    my $nlbpidfile     = &getNlbPidFile();
    my $nlbpid         = &getNlbPid();
    my $nlbpid_current = &logAndGet("$pidof nftlb");

    if (($nlbpid eq "-1") or ($nlbpid_current eq "")) {
        &logAndRun("$nftlbd start");

        #required to wait at startup to ensure the process is up
        sleep 1;

        $nlbpid = &logAndGet("$pidof nftlb");
        if ($nlbpid eq "") {
            return -1;
        }

        open my $fd, '>', "$nlbpidfile";
        print $fd "$nlbpid";
        close $fd;
    }

    return $nlbpid;
}

=pod

=head1 httpNlbRequest

Send an action to nftlb

Parameters:

    self - hash that includes hash_keys:

    file:   file where the HTTP body response of the nftlb is saved
    method: HTTP verb for nftlb request
    uri:    HTTP URI for nftlb request
    body:   body to use in POST and PUT requests
    check:  if this parameter is defined is a flag to not print error if
            the request is used to check if a element exists.

Returns: integer

return code of the request command

=cut

sub httpNlbRequest ($self) {
    my $curl_cmd = &getGlobalConfiguration('curl_bin');
    my $body     = "";

    my $pid = &startNlb();
    if ($pid <= 0) {
        return -1;
    }

    chomp($curl_cmd);

    return -1 if not $curl_cmd;

    if (defined $self->{body} && $self->{body} ne "") {
        $body = qq(-d'$self->{body}');
    }

    my $url    = qq(http://127.0.0.1:27$self->{uri});
    my $execmd = qq($curl_cmd -w "%{http_code}" --noproxy "*" -s -H "Key: HoLa" -X "$self->{method}" $body $url);

    my $file_tmp = "/tmp/nft_$$";
    my $file     = $file_tmp;

    if ($self->{file} && $self->{file} =~ /ipds|policy/) {
        $file = $self->{file};
    }

    # Send output to a file to get only the http code by the standard output
    $execmd = $execmd . " -o $file";

    my $output = &logAndGet($execmd);

    if ($output !~ /^2/) {    # err
        my $tag = (exists $self->{check}) ? 'debug' : 'error';
        my $msg = "cmd failed: $execmd";

        if (not &debug()) {
            if (exists $self->{check}) {
                &log_debug($msg, 'system');
            }
            else {
                &log_error($msg, 'system');
            }
        }

        if (open(my $fh, '<', $file)) {
            local $/ = undef;
            my $err = <$fh>;
            close $fh;

            my $msg = "(code: $output): $err";

            if (exists $self->{check}) {
                &log_debug($msg, 'system');
            }
            else {
                &log_error($msg, 'system');
            }

            unlink $file_tmp if (-f $file_tmp);
        }
        else {
            &log_error("The file '$file' could not be opened", 'system');
        }

        return -1;
    }

    # filter ipds params into the configuration file
    if (   defined $self->{file}
        && $self->{file} ne ""
        && !-z "$file"
        && $file !~ /ipds/
        && $file !~ /policy/)

    {
        require Relianoid::Farm::L4xNAT::Config;
        &writeL4NlbConfigFile($file, $self->{file});
    }
    unlink $file_tmp if (-f $file_tmp);

    return 0;
}

=pod

=head1 execNft

Execute the nft command

Parameters:

    action		- "add", "delete", "check" or "flush"
    table		- type and name of the table to be used (ej "netdev foo")
    chain_def	- name and definition of the chain to be used
    rule		- rule or pattern in case of deletion

Returns:

    Integer - 0 on success or != 0 on failure. In case of check action,

=cut

sub execNft ($action, $table, $chain_def, $rule) {
    my $nft   = &getGlobalConfiguration('nft_bin');
    my $chain = "";
    ($chain) = $chain_def =~ /^([\w\-\.\d]+)\s*.*$/;
    my $output = 0;

    if ($action eq "add") {
        &logAndRun("$nft add table $table");
        &logAndRun("$nft add chain $table $chain_def");
        $output = &logAndRun("$nft add rule $table $chain $rule");
    }
    elsif ($action eq "delete") {
        if (!defined $chain || $chain eq "") {
            &log_info("Deleting cluster table $table");
            $output = &logAndRun("$nft delete table $table");
        }
        elsif (!defined $rule || $rule eq "") {
            $output = &logAndRun("$nft delete chain $table $chain");
        }
        else {
            my @rules = @{ &logAndGet("$nft -a list chain $table $chain", 'array') };
            for my $r (@rules) {
                my ($handle) = $r =~ / $rule.* \# handle (\d)$/;
                if ($handle ne "") {
                    $output = &logAndRun("$nft delete rule $table $chain handle $handle");
                    last;
                }
            }
        }
    }
    elsif ($action eq "check") {
        if (!defined $chain || $chain eq "") {
            $output = 1;
            my @rules = @{ &logAndGet("$nft list table $table", 'array') };
            $output = 0 if (scalar @rules == 0);
            return $output;
        }
        else {
            my @rules = @{ &logAndGet("$nft list chain $table $chain", 'array') };
            for my $r (@rules) {
                if ($r =~ / $rule /) {
                    $output = 1;
                    last;
                }
            }
        }
    }
    elsif ($action eq "flush") {
        &logAndRun("$nft add table $table");
        &logAndRun("$nft add chain $table $chain_def");
        $output = &logAndRun("$nft flush chain $table $chain");
    }

    return $output;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/RRD.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use RRDs;
use MIME::Base64;
use Relianoid::Config;

my $eload = eval { require Relianoid::ELoad };

my $width     = "600";
my $height    = "150";
my $imagetype = "PNG";

=pod

=head1 Module

Relianoid::RRD

=cut

=pod

=head1 translateRRDTime

It translates a time from API format (11-09-2020-14:05) to RRD format (11/09/2020 14:05).
Also, it returns the rrd format for daily, weekly, monthly or yearly.

Parameters:

    time - Time in API format

Returns:

    scalar - Date in RRD format

=cut

sub translateRRDTime ($time) {
    if (!defined $time) {
        return "now";
    }
    elsif ($time =~ /^([dwmy])/) {
        return "-1$1";
    }
    elsif ($time =~ /^(\d\d-\d\d-(?:\d\d)?\d\d)-(\d\d:\d\d)$/) {
        # in (api): "11-09-2020-14:05"
        # out(rrd): "11/09/2020 14:05"
        my $date = $1;
        my $hour = $2;

        $date =~ s'-'/'g;
        return "$date $hour";
    }
    return $time;
}

=pod

=head1 logRRDError

It checks if some error exists in the last RRD read and it logs it

Parameters:

    graph file - it is the graph file created of reading the RRD

Returns: integer - Error code.

- 0: success
- 1: error 

=cut

sub logRRDError ($graph) {
    my $error = RRDs::error;

    if ($error || !-s $graph) {
        $error //= 'The graph was not generated';
        &log_error("$0: unable to generate $graph: $error");
        return 1;
    }

    return 0;
}

=pod

=head1 getRRDAxisXLimits

It returns the first and last time value for a graph.
It returns the times with the RELIANOID API format (11-09-2020-14:05)

Parameters:

    start - string - Date of the begining of the chart
    last  - string - Date of the end of the chart

Returns: array

Pair of strings with the dates defining the range of a chart, both included.

=cut

sub getRRDAxisXLimits ($start, $last) {
    my $format = "%m-%d-%Y-%H:%M";

    use POSIX qw(strftime);

    ($start, $last) = RRDs::times($start, $last);

    #     0    1    2     3     4    5     6     7     8
    # my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
    my @t = localtime($last);
    $last  = strftime($format, @t);
    @t     = localtime($start);
    $start = strftime($format, @t);

    return ($start, $last);
}

=pod

=head1 printImgFile

Get a file encoded in base64 and remove it.

Parameters:

    file - Path to image file.

Returns: string

- On success: Base64 encoded image.
- On error: Empty string.

=cut

sub printImgFile ($file) {
    if (open my $png, '<', $file) {
        my $raw_string = do { local $/ = undef; <$png>; };
        my $encoded    = encode_base64($raw_string);

        close $png;

        unlink($file);
        return $encoded;
    }
    else {
        return "";
    }
}

=pod

=head1 delGraph

Remove a farm,  network interface or vpn graph.

Parameters:

    name - Name of the graph resource, without sufixes.
    type - 'farm', 'iface', 'vpn'.

Returns: Nothing

=cut

sub delGraph ($name, $type) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');

    if ($type =~ /iface/) {
        my $filename = "${collector_rrd_dir}/${name}iface.rrd";
        &log_info("Delete graph file: ${filename}", "MONITOR");
        unlink($filename);
    }

    if ($type =~ /farm/) {
        my $filename = "${collector_rrd_dir}/${name}-farm.rrd";
        &log_info("Delete graph file: ${filename}", "MONITOR");
        unlink glob($filename);

        &eload(
            module => 'Relianoid::EE::IPDS::Stats',
            func   => 'delIPDSRRDFile',
            args   => [$name],
        ) if $eload;
    }

    if ($type =~ /vpn/) {
        my $filename = "${collector_rrd_dir}/${name}-vpn.rrd";
        &log_info("Delete graph file: ${filename}", "MONITOR");
        unlink glob($filename);
    }

    return;
}

=pod

=head1 printGraph

Get a graph 'type' of a period of time base64 encoded.

Parameters:

    type - Filter or name of the graph.
    time/start - This parameter can have one of the following values: *
        * Period of time shown in the image (Possible values: daily, d, weekly, w, monthly, m, yearly, y).
        * time which the graph starts. Format: MM-DD-YYYY-HH:mm (ie: 11-09-2020-14:05)
    end - time which the graph stops. The default value is "now", the current time.

Returns: hash reference

The output hash contains the following keys:

    img   - Base64 encoded image, or an empty string on failure,
    start - firt time of the graph
    last  - last time of the graph

=cut

sub printGraph ($type, $time, $end = "now") {
    my $graph_fn = sprintf "%s/${type}_${time}.png", &getGlobalConfiguration('img_dir');

    $time = &translateRRDTime($time);
    $end  = &translateRRDTime($end);

    if ($type eq "cpu") {
        &genCpuGraph($type, $graph_fn, $time, $end);
    }
    elsif ($type =~ /^dev-*/) {
        &genDiskGraph($type, $graph_fn, $time, $end);
    }
    elsif ($type eq "load") {
        &genLoadGraph($type, $graph_fn, $time, $end);
    }
    elsif ($type eq "mem") {
        &genMemGraph($type, $graph_fn, $time, $end);
    }
    elsif ($type eq "memsw") {
        &genMemSwGraph($type, $graph_fn, $time, $end);
    }
    elsif ($type =~ /iface$/) {
        &genNetGraph($type, $graph_fn, $time, $end);
    }
    elsif ($type =~ /-farm$/) {
        &genFarmGraph($type, $graph_fn, $time, $end);
    }
    elsif ($eload and $type =~ /ipds$/) {
        &eload(
            module => 'Relianoid::EE::IPDS::Stats',
            func   => 'genIPDSGraph',
            args   => [ $type, $graph_fn, $time, $end ],
        );
    }
    elsif ($eload && $type =~ /-vpn$/) {
        &genVPNGraph($type, $graph_fn, $time);
    }
    else {
        &log_error("The requested graph '$type' is unknown");
        return {};
    }

    if (&logRRDError($graph_fn)) {
        return {};
    }

    ($time, $end) = &getRRDAxisXLimits($time, $end);

    return {
        img   => &printImgFile($graph_fn),
        start => $time,
        last  => $end
    };
}

=pod

=head1 genCpuGraph

Generate CPU usage graph image file for a period of time.

Parameters:

    type  - Database name without extension.
    graph - Path to file to be generated.
    start - time which the graph starts. Format: MM-DD-YYYY-HH:mm (ie: 11-09-2020-14:05)
    end   - time which the graph stops

Returns: Nothing

=cut

sub genCpuGraph ($type, $graph, $start, $end) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $cpu_db            = "${collector_rrd_dir}/${type}.rrd";

    if (-e $cpu_db) {
        RRDs::graph(
            $graph,
            "--imgformat=${imagetype}",
            "--start=${start}",
            "--end=${end}",
            "--width=${width}",
            "--height=${height}",
            "--alt-autoscale-max",
            "--lower-limit=0",
            "--title=CPU",
            "--vertical-label=%",
            "DEF:user=${cpu_db}:user:AVERAGE",
            "DEF:nice=${cpu_db}:nice:AVERAGE",
            "DEF:sys=${cpu_db}:sys:AVERAGE",
            "DEF:iowait=${cpu_db}:iowait:AVERAGE",
            "DEF:irq=${cpu_db}:irq:AVERAGE",
            "DEF:softirq=${cpu_db}:softirq:AVERAGE",
            "DEF:idle=${cpu_db}:idle:AVERAGE",
            "DEF:tused=${cpu_db}:tused:AVERAGE",
            "AREA:sys#DC374A:System\\t",
            "GPRINT:sys:LAST:Last\\:%8.2lf %%",
            "GPRINT:sys:MIN:Min\\:%8.2lf %%",
            "GPRINT:sys:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:sys:MAX:Max\\:%8.2lf %%\\n",
            "STACK:user#6B2E9A:User\\t\\t",
            "GPRINT:user:LAST:Last\\:%8.2lf %%",
            "GPRINT:user:MIN:Min\\:%8.2lf %%",
            "GPRINT:user:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:user:MAX:Max\\:%8.2lf %%\\n",
            "STACK:nice#ACD936:Nice\\t\\t",
            "GPRINT:nice:LAST:Last\\:%8.2lf %%",
            "GPRINT:nice:MIN:Min\\:%8.2lf %%",
            "GPRINT:nice:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:nice:MAX:Max\\:%8.2lf %%\\n",
            "STACK:iowait#8D85F3:Iowait\\t",
            "GPRINT:iowait:LAST:Last\\:%8.2lf %%",
            "GPRINT:iowait:MIN:Min\\:%8.2lf %%",
            "GPRINT:iowait:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:iowait:MAX:Max\\:%8.2lf %%\\n",
            "STACK:irq#46F2A2:Irq\\t\\t",
            "GPRINT:irq:LAST:Last\\:%8.2lf %%",
            "GPRINT:irq:MIN:Min\\:%8.2lf %%",
            "GPRINT:irq:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:irq:MAX:Max\\:%8.2lf %%\\n",
            "STACK:softirq#595959:Softirq\\t",
            "GPRINT:softirq:LAST:Last\\:%8.2lf %%",
            "GPRINT:softirq:MIN:Min\\:%8.2lf %%",
            "GPRINT:softirq:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:softirq:MAX:Max\\:%8.2lf %%\\n",
            "STACK:idle#46b971:Idle\\t\\t",
            "GPRINT:idle:LAST:Last\\:%8.2lf %%",
            "GPRINT:idle:MIN:Min\\:%8.2lf %%",
            "GPRINT:idle:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:idle:MAX:Max\\:%8.2lf %%\\n",
            "LINE1:tused#000000:Total used\\t",
            "GPRINT:tused:LAST:Last\\:%8.2lf %%",
            "GPRINT:tused:MIN:Min\\:%8.2lf %%",
            "GPRINT:tused:AVERAGE:Avg\\:%8.2lf %%",
            "GPRINT:tused:MAX:Max\\:%8.2lf %%\\n"
        );
    }

    return;
}

=pod

=head1 genDiskGraph

Generate disk partition usage graph image file for a period of time.

Parameters:

    type  - Database name without extension.
    graph - Path to file to be generated.
    start - time which the graph starts. Format: MM-DD-YYYY-HH:mm (ie: 11-09-2020-14:05)
    end   - time which the graph stops

Returns: Nothing

=cut

sub genDiskGraph ($type, $graph, $start, $end) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $hd_db             = "${collector_rrd_dir}/${type}.rrd";

    my $device = $type;
    $device =~ s/hd$//;
    $device =~ s/dev-//;
    $device =~ s/-/\// if $device !~ /dm-/;

    my $mount = &getDiskMountPoint($device);

    if (-e $hd_db) {
        RRDs::graph(
            $graph,
            "--start=${start}",                        #
            "--end=${end}",                            #
            "--title=PARTITION ${mount}",              #
            "--vertical-label=SPACE",                  #
            "--width=${width}",                        #
            "--height=${height}",                      #
            "--lazy",                                  #
            "-l 0",                                    #
            "-a",                                      #
            "$imagetype",                              #
            "DEF:tot=${hd_db}:tot:AVERAGE",            #
            "DEF:used=${hd_db}:used:AVERAGE",          #
            "DEF:free=${hd_db}:free:AVERAGE",          #
            "CDEF:total=used,free,+",                  #
            "AREA:used#595959:Used\\t",                #
            "GPRINT:used:LAST:Last\\:%8.2lf %s",       #
            "GPRINT:used:MIN:Min\\:%8.2lf %s",         #
            "GPRINT:used:AVERAGE:Avg\\:%8.2lf %s",     #
            "GPRINT:used:MAX:Max\\:%8.2lf %s\\n",      #
            "STACK:free#46b971:Free\\t",               #
            "GPRINT:free:LAST:Last\\:%8.2lf %s",       #
            "GPRINT:free:MIN:Min\\:%8.2lf %s",         #
            "GPRINT:free:AVERAGE:Avg\\:%8.2lf %s",     #
            "GPRINT:free:MAX:Max\\:%8.2lf %s\\n",      #
            "LINE1:total#000000:Total\\t",             #
            "GPRINT:total:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:total:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:total:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:total:MAX:Max\\:%8.2lf %s\\n"      #
        );
    }

    return;
}

=pod

=head1 genLoadGraph

Generate system load graph image file for a period of time.

Parameters:

    type  - Database name without extension.
    graph - Path to file to be generated.
    start - Period of time shown in the graph.
    end   - End time period

Returns: Nothing

=cut

sub genLoadGraph ($type, $graph, $start, $end) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $load_db           = "${collector_rrd_dir}/${type}.rrd";

    if (-e $load_db) {
        RRDs::graph(
            $graph,                                      #
            "--imgformat=${imagetype}",                  #
            "--start=${start}",                          #
            "--end=${end}",                              #
            "--width=${width}",                          #
            "--height=${height}",                        #
            "--alt-autoscale-max",                       #
            "--lower-limit=0",                           #
            "--title=LOAD AVERAGE",                      #
            "--vertical-label=LOAD",                     #
            "DEF:load=${load_db}:load:AVERAGE",          #
            "DEF:load5=${load_db}:load5:AVERAGE",        #
            "DEF:load15=${load_db}:load15:AVERAGE",      #
            "AREA:load#729e00:last minute\\t\\t",        #
            "GPRINT:load:LAST:Last\\:%3.2lf",            #
            "GPRINT:load:MIN:Min\\:%3.2lf",              #
            "GPRINT:load:AVERAGE:Avg\\:%3.2lf",          #
            "GPRINT:load:MAX:Max\\:%3.2lf\\n",           #
            "STACK:load5#46b971:last 5 minutes\\t",      #
            "GPRINT:load5:LAST:Last\\:%3.2lf",           #
            "GPRINT:load5:MIN:Min\\:%3.2lf",             #
            "GPRINT:load5:AVERAGE:Avg\\:%3.2lf",         #
            "GPRINT:load5:MAX:Max\\:%3.2lf\\n",          #
            "STACK:load15#595959:last 15 minutes\\t",    #
            "GPRINT:load15:LAST:Last\\:%3.2lf",          #
            "GPRINT:load15:MIN:Min\\:%3.2lf",            #
            "GPRINT:load15:AVERAGE:Avg\\:%3.2lf",        #
            "GPRINT:load15:MAX:Max\\:%3.2lf\\n"          #
        );
    }

    return;
}

=pod

=head1 genMemGraph

Generate RAM memory usage graph image file for a period of time.

Parameters:

    type - Database name without extension.
    graph - Path to file to be generated.
    start - time which the graph starts. Format: MM-DD-YYYY-HH:mm (ie: 11-09-2020-14:05)
    end - time which the graph stops

Returns: Nothing

=cut

sub genMemGraph ($type, $graph, $start, $end) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $ram_db            = "${collector_rrd_dir}/${type}.rrd";

    if (-e $ram_db) {
        RRDs::graph(
            $graph,                                   #
            "--imgformat=${imagetype}",               #
            "--start=${start}",                       #
            "--end=${end}",                           #
            "--width=${width}",                       #
            "--height=${height}",                     #
            "--alt-autoscale-max",                    #
            "--lower-limit=0",                        #
            "--title=RAM",                            #
            "--vertical-label=MEMORY",                #
            "--base=1024",                            #
            "DEF:memt=${ram_db}:memt:AVERAGE",        #
            "DEF:memu=${ram_db}:memu:AVERAGE",        #
            "DEF:memf=${ram_db}:memf:AVERAGE",        #
            "DEF:memc=${ram_db}:memc:AVERAGE",        #
            "AREA:memu#595959:Used\\t\\t",            #
            "GPRINT:memu:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:memu:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:memu:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:memu:MAX:Max\\:%8.2lf %s\\n",     #
            "STACK:memf#46b971:Free\\t\\t",           #
            "GPRINT:memf:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:memf:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:memf:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:memf:MAX:Max\\:%8.2lf %s\\n",     #
            "LINE2:memc#46F2A2:Cache&Buffer\\t",      #
            "GPRINT:memc:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:memc:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:memc:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:memc:MAX:Max\\:%8.2lf %s\\n",     #
            "LINE1:memt#000000:Total\\t\\t",          #
            "GPRINT:memt:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:memt:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:memt:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:memt:MAX:Max\\:%8.2lf %s\\n"      #
        );
    }

    return;
}

=pod

=head1 genMemSwGraph

Generate swap memory usage graph image file for a period of time.

Parameters:

    type  - Database name without extension.
    graph - Path to file to be generated.
    start - time which the graph starts. Format: MM-DD-YYYY-HH:mm (ie: 11-09-2020-14:05)
    end   - time which the graph stops

Returns: Nothing

=cut

sub genMemSwGraph ($type, $graph, $start, $end) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $swap_db           = "${collector_rrd_dir}/${type}.rrd";

    if (-e $swap_db) {
        RRDs::graph(
            $graph,                                  #
            "--imgformat=${imagetype}",              #
            "--start=${start}",                      #
            "--end=${end}",                          #
            "--width=${width}",                      #
            "--height=${height}",                    #
            "--alt-autoscale-max",                   #
            "--lower-limit=0",                       #
            "--title=SWAP",                          #
            "--vertical-label=MEMORY",               #
            "--base=1024",                           #
            "DEF:swt=${swap_db}:swt:AVERAGE",        #
            "DEF:swu=${swap_db}:swu:AVERAGE",        #
            "DEF:swf=${swap_db}:swf:AVERAGE",        #
            "DEF:swc=${swap_db}:swc:AVERAGE",        #
            "AREA:swu#595959:Used\\t\\t",            #
            "GPRINT:swu:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:swu:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:swu:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:swu:MAX:Max\\:%8.2lf %s\\n",     #
            "STACK:swf#46b971:Free\\t\\t",           #
            "GPRINT:swf:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:swf:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:swf:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:swf:MAX:Max\\:%8.2lf %s\\n",     #
            "LINE2:swc#46F2A2:Cached\\t",            #
            "GPRINT:swc:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:swc:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:swc:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:swc:MAX:Max\\:%8.2lf %s\\n",     #
            "LINE1:swt#000000:Total\\t\\t",          #
            "GPRINT:swt:LAST:Last\\:%8.2lf %s",      #
            "GPRINT:swt:MIN:Min\\:%8.2lf %s",        #
            "GPRINT:swt:AVERAGE:Avg\\:%8.2lf %s",    #
            "GPRINT:swt:MAX:Max\\:%8.2lf %s\\n",     #
        );
    }

    return;
}

=pod

=head1 genNetGraph

Generate network interface usage graph image file for a period of time.

Parameters:

    type  - Database name without extension.
    graph - Path to file to be generated.
    start - time which the graph starts. Format: MM-DD-YYYY-HH:mm (ie: 11-09-2020-14:05)
    end   - time which the graph stops

Returns: Nothing

=cut

sub genNetGraph ($type, $graph, $start, $end) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $interface_db      = "${collector_rrd_dir}/${type}.rrd";
    my $interface_name    = $type;
    $interface_name =~ s/iface//g;

    if (-e $interface_db) {
        RRDs::graph(
            $graph,                                                #
            "--imgformat=${imagetype}",                            #
            "--start=${start}",                                    #
            "--end=${end}",                                        #
            "--height=${height}",                                  #
            "--width=${width}",                                    #
            "--lazy",                                              #
            "-l 0",                                                #
            "--alt-autoscale-max",                                 #
            "--title=TRAFFIC ON ${interface_name}",                #
            "--vertical-label=BANDWIDTH",                          #
            "DEF:in=${interface_db}:in:AVERAGE",                   #
            "DEF:out=${interface_db}:out:AVERAGE",                 #
            "CDEF:in_bytes=in,1024,*",                             #
            "CDEF:out_bytes=out,1024,*",                           #
            "CDEF:out_bytes_neg=out_bytes,-1,*",                   #
            "AREA:in_bytes#46b971:In ",                            #
            "LINE1:in_bytes#000000",                               #
            "GPRINT:in_bytes:LAST:Last\\:%5.1lf %sByte/sec",       #
            "GPRINT:in_bytes:MIN:Min\\:%5.1lf %sByte/sec",         #
            "GPRINT:in_bytes:AVERAGE:Avg\\:%5.1lf %sByte/sec",     #
            "GPRINT:in_bytes:MAX:Max\\:%5.1lf %sByte/sec\\n",      #
            "AREA:out_bytes_neg#595959:Out",                       #
            "LINE1:out_bytes_neg#000000",                          #
            "GPRINT:out_bytes:LAST:Last\\:%5.1lf %sByte/sec",      #
            "GPRINT:out_bytes:MIN:Min\\:%5.1lf %sByte/sec",        #
            "GPRINT:out_bytes:AVERAGE:Avg\\:%5.1lf %sByte/sec",    #
            "GPRINT:out_bytes:MAX:Max\\:%5.1lf %sByte/sec\\n",     #
            "HRULE:0#000000"                                       #
        );
    }

    return;
}

=pod

=head1 genFarmGraph

Generate farm connections graph image file for a period of time.

Parameters:

    type  - Database name without extension.
    graph - Path to file to be generated.
    start - time which the graph starts. Format: MM-DD-YYYY-HH:mm (ie: 11-09-2020-14:05)
    end   - time which the graph stops

Returns:

    none

See Also:

    <printGraph>

    <genCpuGraph>, <genDiskGraph>, <genLoadGraph>, <genMemGraph>, <genMemSwGraph>, <genNetGraph>, <genLoadGraph>

=cut

sub genFarmGraph ($type, $graph, $start, $end) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $farm_db           = "${collector_rrd_dir}/${type}.rrd";
    my $farm_name         = $type;
    $farm_name =~ s/-farm$//g;

    if (-e $farm_db) {
        RRDs::graph(
            $graph,
            "--start=${start}",
            "--end=${end}",
            "--height=${height}",    #
            "--width=${width}",      #
            "--lazy",
            "-l 0",
            "-a",
            "${imagetype}",
            "--title=CONNECTIONS ON ${farm_name} farm",
            "--vertical-label=Connections",
            "DEF:pending=${farm_db}:pending:AVERAGE",
            "DEF:established=${farm_db}:established:AVERAGE",

            # "DEF:closed=$db_farm:closed:AVERAGE",
            "LINE2:pending#595959:Pending\\t",
            "GPRINT:pending:LAST:Last\\:%6.0lf ",
            "GPRINT:pending:MIN:Min\\:%6.0lf ",
            "GPRINT:pending:AVERAGE:Avg\\:%6.0lf ",
            "GPRINT:pending:MAX:Max\\:%6.0lf \\n",
            "LINE2:established#46b971:Established\\t",
            "GPRINT:established:LAST:Last\\:%6.0lf ",
            "GPRINT:established:MIN:Min\\:%6.0lf ",
            "GPRINT:established:AVERAGE:Avg\\:%6.0lf ",
            "GPRINT:established:MAX:Max\\:%6.0lf \\n"

              # "LINE2:closed#46F2A2:Closed\\t",
              # "GPRINT:closed:LAST:Last\\:%6.0lf ",
              # "GPRINT:closed:MIN:Min\\:%6.0lf ",
              # "GPRINT:closed:AVERAGE:Avg\\:%6.0lf ",
              # "GPRINT:closed:MAX:Max\\:%6.0lf \\n"
        );
    }

    return;
}

=pod

=head1 genVPNGraph

Generate VPN usage graph image file for a period of time.

Parameters:

    type - Database name without extension.
    graph - Path to file to be generated.
    time - Period of time shown in the graph.

Returns: Nothing

=cut

sub genVPNGraph ($type, $graph, $time) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my $vpn_db            = "${collector_rrd_dir}/${type}.rrd";
    my $vpn_name          = $type;
    $vpn_name =~ s/-vpn$//g;

    if (-e $vpn_db) {
        RRDs::graph(
            $graph,                                                #
            "--imgformat=${imagetype}",                            #
            "--start=-1${time}",                                   #
            "--height=${height}",                                  #
            "--width=${width}",                                    #
            "--lazy",                                              #
            "-l 0",                                                #
            "--alt-autoscale-max",                                 #
            "--title=TRAFFIC ON ${vpn_name}",                      #
            "--vertical-label=BANDWIDTH",                          #
            "DEF:in=${vpn_db}:in:AVERAGE",                         #
            "DEF:out=${vpn_db}:out:AVERAGE",                       #
            "CDEF:in_bytes=in,1024,*",                             #
            "CDEF:out_bytes=out,1024,*",                           #
            "CDEF:out_bytes_neg=out_bytes,-1,*",                   #
            "AREA:in_bytes#46b971:In ",                            #
            "LINE1:in_bytes#000000",                               #
            "GPRINT:in_bytes:LAST:Last\\:%5.1lf %sByte/sec",       #
            "GPRINT:in_bytes:MIN:Min\\:%5.1lf %sByte/sec",         #
            "GPRINT:in_bytes:AVERAGE:Avg\\:%5.1lf %sByte/sec",     #
            "GPRINT:in_bytes:MAX:Max\\:%5.1lf %sByte/sec\\n",      #
            "AREA:out_bytes_neg#595959:Out",                       #
            "LINE1:out_bytes_neg#000000",                          #
            "GPRINT:out_bytes:LAST:Last\\:%5.1lf %sByte/sec",      #
            "GPRINT:out_bytes:MIN:Min\\:%5.1lf %sByte/sec",        #
            "GPRINT:out_bytes:AVERAGE:Avg\\:%5.1lf %sByte/sec",    #
            "GPRINT:out_bytes:MAX:Max\\:%5.1lf %sByte/sec\\n",     #
            "HRULE:0#000000"                                       #
        );

        my $rrdError = RRDs::error;
        print "$0: unable to generate ${graph}: ${rrdError}\n" if ($rrdError);
    }

    return;
}

=pod

=head1 getGraphs2Show

Get list of graph names by type or all of them.

Parameters:

    graphtype - 'System', 'Network', 'Farm' or 'VPN'.

Returns: string list - List of graph names

=cut

#function that returns the graph list to show
sub getGraphs2Show ($graphtype) {
    my $collector_rrd_dir = &getGlobalConfiguration('collector_rrd_dir');
    my @dir_list;
    my @results = ();

    if (opendir(my $dir, $collector_rrd_dir)) {
        @dir_list = readdir($dir);
        closedir($dir);
    }
    else {
        log_error("Could not open directory '$collector_rrd_dir/': $!");
        return @results;
    }

    if ($graphtype eq 'System') {
        my @disk = grep { /^dev-.*$/ } @dir_list;
        for (@disk) { s/.rrd$//g }
        @results = ("cpu", @disk, "load", "mem", "memsw");
    }
    elsif ($graphtype eq 'Network') {
        @results = grep { /iface.rrd$/ } sort @dir_list;
        for (@results) { s/.rrd$//g }
    }
    elsif ($graphtype eq 'Farm') {
        @results = grep { /farm.rrd$/ } sort @dir_list;
        for (@results) { s/.rrd$//g }
    }
    elsif ($graphtype eq 'VPN') {
        @results = grep { /vpn.rrd$/ } sort @dir_list;
        for (@results) { s/.rrd$//g }
    }
    else {
        log_error("Graph type not supported.");
    }

    return @results;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/SNMP.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Log;
use Relianoid::Config;

=pod

=head1 Module

Relianoid::SNMP

=cut

=pod

=head1 setSnmpdStatus

Start or stop the SNMP service.

Parameters:

    snmpd_status - 'true' to start, or 'stop' to stop the SNMP service.

Returns:

    scalar - 0 on success, non-zero on failure.

=cut

sub setSnmpdStatus ($snmpd_status) {
    my $return_code = -1;
    my $systemctl   = &getGlobalConfiguration('systemctl');
    my $snmpd_srv   = &getGlobalConfiguration('snmpd_service');

    if ($snmpd_status eq 'true') {
        &log_info("Starting snmp service", "SYSTEM");
        &logAndRun("$systemctl enable $snmpd_srv");
        $return_code = &logAndRun("$systemctl start $snmpd_srv");
    }
    elsif ($snmpd_status eq 'false') {
        &log_info("Stopping snmp service", "SYSTEM");
        &logAndRun("$systemctl disable $snmpd_srv");
        $return_code = &logAndRun("$systemctl stop $snmpd_srv");
    }
    else {
        &log_warn("SNMP requested state is invalid", "SYSTEM");
        return -1;
    }

    return $return_code;
}

=pod

=head1 getSnmpdStatus

Get if the SNMP service is running.

Parameters:

    none

Returns:

    string - Boolean. 'true' if it is running, or 'false' if it is not running.

=cut

sub getSnmpdStatus () {
    my $pidof       = &getGlobalConfiguration('pidof');
    my $return_code = (&logAndRunCheck("$pidof snmpd")) ? 'false' : 'true';

    return $return_code;
}

=pod

=head1 setSnmpdLaunchConfig

Set configuration and disable the snmpd service.

Parameters:

    snmp_conf - Configuration for SNMP

Returns:

    integer - 0 if success, error in another case.

=cut

sub setSnmpdLaunchConfig ($snmp_conf) {
    my @config  = ("/etc/default/snmpd", "/usr/lib/systemd/system/snmpd.service");
    my $changed = 0;

    require Tie::File;

    for my $file (@config) {
        tie my @config_file, 'Tie::File', $file;

        if (   defined $snmp_conf->{trapsess}
            && $snmp_conf->{trapsess} eq "true"
            && grep { /mteTrigger/ } @config_file)
        {
            s/ -I -smux,mteTrigger,mteTriggerConf// for @config_file;
            $changed = 1;
        }
        elsif ((!defined $snmp_conf->{trapsess} || $snmp_conf->{trapsess} eq "false")
            && !grep { /mteTrigger/ } @config_file)
        {
            s/ -f / -I -smux,mteTrigger,mteTriggerConf -f / for @config_file;
            $changed = 1;
        }

        if (!grep { /LS6d / } @config_file) {
            s/-L[^\s]+ /-LS6d / for @config_file;
            $changed = 1;
        }

        untie @config_file;
    }

    if ($changed) {
        my $systemctl = &getGlobalConfiguration('systemctl');
        return &logAndRun("$systemctl daemon-reload");
    }

    return 0;
}

=pod

=head1 setSnmpdFactoryReset

Set default configuration and disable the snmpd service.

Parameters:

    none

Returns:

    integer - 0 on success, or -1 on failure.

=cut

sub setSnmpdFactoryReset () {
    my $default_snmp_conf = &getSnmpdDefaultConfig();
    my $snmpdconfig_file  = &getGlobalConfiguration('snmpdconfig_file');

    unlink($snmpdconfig_file);

    &_setSnmpdConfig($default_snmp_conf);
    &setSnmpdLaunchConfig($default_snmp_conf);
    return &setSnmpdStatus("false");
}

=pod

=head1 setSnmpdDefaultConfig

Apply default SNMP config if it was not changed by this service
before. Then, reload the service generators.

Parameters:

    none

Returns:

    scalar - Hash reference with SNMP default configuration.

=cut

sub setSnmpdDefaultConfig () {
    my $snmp_config = &getSnmpdConfig();
    if ($snmp_config->{changed} == 0) {
        $snmp_config = &setSnmpdFactoryReset();
    }
    else {
        &setSnmpdLaunchConfig($snmp_config);
    }

    return $snmp_config;
}

=pod

=head1 getSnmpdDefaultConfig

Get the default configuration of the SNMP service.

Parameters:

    none

Returns:

    scalar - Hash reference with SNMP default configuration.

		$snmpd_conf = {
				proto # agentAddress line
				ip
				port
				community # community line
				community_mode
				scope
			};

=cut

sub getSnmpdDefaultConfig () {
    my $snmpd_conf = {
        proto          => "udp",
        ip             => "*",
        port           => "161",
        community_mode => "rocommunity",
        community      => "public",
        scope          => "0.0.0.0/0",
    };

    return $snmpd_conf;
}

=pod

=head1 getSnmpdConfig

Get the configuration of the SNMP service according to the
snmpd.conf file.

Parameters:

    none

Returns:

    scalar - Hash reference with SNMP configuration.

		$snmpd_conf = {
					   status
					   proto # agentAddress line
					   ip
					   port
					   community # community line
					   community_mode
					   scope
					   authtrapenable # authtrapenable line
					   createuser_user # createuser line
					   createuser_auth
					   createuser_auth_pass
					   createuser_priv
					   createuser_priv_pass
					   iquerysecname # iquerysecname line
					   user_mode # xxuser line
					   user
					   trapsink_host # trapsink line
					   trapsink_port
					   trap2sink_host # trap2sink
					   trapsess_version # trapsess line
					   trapsess_user
					   trapsess_engine
					   trapsess_authproto
					   trapsess_authpass
					   trapsess_privproto
					   trapsess_privpass
					   trapsess_host
					   trapsess_port
					   notif_linkupdown
					   notif_defmonitors
					   load
					   disks
					   monitors # array with monitors configuration
					   changed # 1 if changed by relianoid
		}; 

=cut

sub getSnmpdConfig () {
    require Tie::File;

    my $snmpdconfig_file = &getGlobalConfiguration('snmpdconfig_file');
    my $snmpd_conf;

    $snmpd_conf->{status}  = &getSnmpdStatus();
    $snmpd_conf->{changed} = 1;

    tie my @config_file, 'Tie::File', $snmpdconfig_file;

    for my $line (@config_file) {
        next if ($line =~ /^\s*$/);
        $snmpd_conf->{changed} = 0
          if ($line =~ /^(# EXAMPLE.conf|# An example configuration file)/);
        next if ($line =~ /^\s*#/);
        chomp($line);
        if ($line =~ /^\s*agentAddress\s+/) {
            my (undef, $aline) = split(/\s+/, $line);
            if ($aline =~ /udp:|tcp:/) {
                ($snmpd_conf->{proto}, $snmpd_conf->{ip}, $snmpd_conf->{port}) = split(/:/, $aline);
            }
            else {
                ($snmpd_conf->{ip}, $snmpd_conf->{port}) = split(/:/, $aline);
            }
            $snmpd_conf->{ip} = '*' if ($snmpd_conf->{ip} eq '0.0.0.0');
        }
        elsif ($line =~ /^..community\s+/) {
            ($snmpd_conf->{community_mode}, $snmpd_conf->{community}, $snmpd_conf->{scope}) =
              split(/\s+/, $line);
            $snmpd_conf->{scope} = "0.0.0.0/0" if ($snmpd_conf->{scope} =~ /default/);
        }
        elsif ($line =~ /^trapcommunity\s+/) {
            (undef, $snmpd_conf->{trapcommunity}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^authtrapenable\s+/) {
            (undef, $snmpd_conf->{authtrapenable}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^createuser\s+/) {
            (
                undef,                               $snmpd_conf->{createuser_user}, $snmpd_conf->{createuser_auth},
                $snmpd_conf->{createuser_auth_pass}, $snmpd_conf->{createuser_priv}, $snmpd_conf->{createuser_priv_pass}
            ) = split(/\s+/, $line);
        }
        elsif ($line =~ /^iquerysecname\s+/) {
            (undef, $snmpd_conf->{iquerysecname}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^..user\s+/) {
            ($snmpd_conf->{user_mode}, $snmpd_conf->{user}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^trapsink\s+/) {
            (undef, $snmpd_conf->{trapsink_host}, $snmpd_conf->{trapsink_port}) =
              split(/\s+/, $line);
        }
        elsif ($line =~ /^trap2sink\s+/) {
            (undef, $snmpd_conf->{trap2sink_host}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^trapsess\s+/) {
            $snmpd_conf->{trapsess} = 'true';
            my @trap_line = split(/\s+/, $line);
            my $i         = 0;
            while ($i < (scalar @trap_line)) {
                if ($trap_line[$i] eq "-v") {
                    $i += 1;
                    $snmpd_conf->{trapsess_version} = $trap_line[$i];
                }
                elsif ($trap_line[$i] eq "-u") {
                    $i += 1;
                    $snmpd_conf->{trapsess_user} = $trap_line[$i];
                }
                elsif ($trap_line[$i] eq "-e") {
                    $i += 1;
                    $snmpd_conf->{trapsess_engine} = $trap_line[$i];
                }
                elsif ($trap_line[$i] eq "-a") {
                    $i += 1;
                    $snmpd_conf->{trapsess_authproto} = $trap_line[$i];
                }
                elsif ($trap_line[$i] eq "-A") {
                    $i += 1;
                    $snmpd_conf->{trapsess_authpass} = $trap_line[$i];
                }
                elsif ($trap_line[$i] eq "-x") {
                    $i += 1;
                    $snmpd_conf->{trapsess_privproto} = $trap_line[$i];
                }
                elsif ($trap_line[$i] eq "-X") {
                    $i += 1;
                    $snmpd_conf->{trapsess_privpass} = $trap_line[$i];
                }
                elsif ($i == (scalar @trap_line) - 1) {
                    if ($trap_line[$i] =~ /:/) {
                        ($snmpd_conf->{trapsess_host}, $snmpd_conf->{trapsess_port}) =
                          split(/:/, $trap_line[$i]);
                    }
                    else {
                        $snmpd_conf->{trapsess_host} = $trap_line[$i];
                        $snmpd_conf->{trapsess_port} = '162';
                    }
                }
                $i += 1;
            }
        }
        elsif ($line =~ /^linkUpDownNotifications\s+/) {
            (undef, $snmpd_conf->{notif_linkupdown}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^defaultMonitors\s+/) {
            (undef, $snmpd_conf->{notif_defmonitors}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^load\s+/) {
            (undef, $snmpd_conf->{load}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^includeAllDisks\s+/) {
            (undef, $snmpd_conf->{disks}) = split(/\s+/, $line);
        }
        elsif ($line =~ /^monitor\s+/) {
            $snmpd_conf->{monitors} = () unless (defined $snmpd_conf->{monitors});
            (my $newline = $line) =~ s/^monitor\s+//;
            push(@{ $snmpd_conf->{monitors} }, $newline);
        }
    }

    $snmpd_conf->{ip}   = "*"   if (not defined $snmpd_conf->{ip});
    $snmpd_conf->{port} = "161" if (not defined $snmpd_conf->{port});

    untie @config_file;
    return $snmpd_conf;
}

=pod

=head1 setSnmpdConfig

Apply SNMP configuration and reload services.

Parameters:

    snmpd_conf - Hash reference with SNMP configuration.

Returns:

    integer - 0 on success, or -1 on failure.

=cut

sub setSnmpdConfig ($snmpd_conf) {
    &_setSnmpdConfig($snmpd_conf);
    &setSnmpdLaunchConfig($snmpd_conf);

    return 0;
}

=pod

=head1 _setSnmpdConfig

Store SNMP configuration.

Parameters:

    snmpd_conf - Hash reference with SNMP configuration.

Returns:

    integer - 0 on success, or -1 on failure.

=cut

sub _setSnmpdConfig ($snmpd_conf) {
    my $snmpdconfig_file = &getGlobalConfiguration('snmpdconfig_file');
    my $default_index    = 0;                                             # line to insert the configuration

    return -1 if ref $snmpd_conf ne 'HASH';

    my $ip = $snmpd_conf->{ip};
    $ip = '0.0.0.0' if ($snmpd_conf->{ip} eq '*');

    # scope has to be network range definition
    require NetAddr::IP;
    my $network = NetAddr::IP->new($snmpd_conf->{scope})->network();

    return -1 if ($network ne $snmpd_conf->{scope});

    require Relianoid::Lock;

    my @contents;
    my $lock_file = &getLockFile("snmpd_conf");
    my $lock_fh   = &openlock($lock_file, 'w');

    if (open my $config_file, '<', $snmpdconfig_file) {
        @contents = <$config_file>;
        close $config_file;
        close $lock_fh;

        @contents = grep { !/^agentAddress/ } @contents;
        @contents = grep { !/^..community/ } @contents             if (defined $snmpd_conf->{community_mode});
        @contents = grep { !/^trapcommunity/ } @contents           if (defined $snmpd_conf->{trapcommunity});
        @contents = grep { !/^authtrapenable/ } @contents          if (defined $snmpd_conf->{authtrapenable});
        @contents = grep { !/^createuser/ } @contents              if (defined $snmpd_conf->{createuser_user});
        @contents = grep { !/^iquerysecname/ } @contents           if (defined $snmpd_conf->{iquerysecname});
        @contents = grep { !/^..user/ } @contents                  if (defined $snmpd_conf->{user_mode});
        @contents = grep { !/^trapsink/ } @contents                if (defined $snmpd_conf->{trapsink});
        @contents = grep { !/^trap2sink/ } @contents               if (defined $snmpd_conf->{trap2sink});
        @contents = grep { !/^trapsess/ } @contents                if (defined $snmpd_conf->{trapsess});
        @contents = grep { !/^linkUpDownNotifications/ } @contents if (defined $snmpd_conf->{notif_linkupdown});
        @contents = grep { !/^defaultMonitors/ } @contents         if (defined $snmpd_conf->{notif_defmonitors});
        @contents = grep { !/^load/ } @contents                    if (defined $snmpd_conf->{load});
        @contents = grep { !/^includeAllDisks/ } @contents         if (defined $snmpd_conf->{disks});
        @contents = grep { !/^monitor/ } @contents                 if (defined $snmpd_conf->{monitors});
    }
    else {
        close $lock_fh;
    }

    my $index = $default_index;

    if (defined $snmpd_conf->{proto}) {
        splice @contents, $index, 0, "agentAddress $snmpd_conf->{proto}:$ip:$snmpd_conf->{port}\n";
        $index++;
    }
    else {
        splice @contents, $index, 0, "agentAddress $ip:$snmpd_conf->{port}\n";
        $index++;
    }

    if (defined $snmpd_conf->{community_mode} and $snmpd_conf->{community} and $snmpd_conf->{scope}) {
        splice @contents, $index, 0, "$snmpd_conf->{community_mode} $snmpd_conf->{community} $snmpd_conf->{scope}\n";
        $index++;
    }

    if (defined $snmpd_conf->{trapcommunity}) {
        splice @contents, $index, 0, "trapcommunity $snmpd_conf->{trapcommunity}\n";
        $index++;
    }

    if (defined $snmpd_conf->{authtrapenable}) {
        splice @contents, $index, 0, "authtrapenable $snmpd_conf->{authtrapenable}\n";
        $index++;
    }

    if (defined $snmpd_conf->{createuser_user}) {
        my $line = "createuser $snmpd_conf->{createuser_user}";
        $line .= " $snmpd_conf->{createuser_auth}"      if ($snmpd_conf->{createuser_auth});
        $line .= " $snmpd_conf->{createuser_auth_pass}" if ($snmpd_conf->{createuser_auth_pass});
        $line .= " $snmpd_conf->{createuser_priv}"      if ($snmpd_conf->{createuser_priv});
        $line .= " $snmpd_conf->{createuser_priv_pass}" if ($snmpd_conf->{createuser_priv_pass});
        $line .= "\n";
        splice @contents, $index, 0, "$line";
        $index++;

        if (defined $snmpd_conf->{user_mode}) {
            splice @contents, $index, 0, "$snmpd_conf->{user_mode} $snmpd_conf->{createuser_user}\n";
            $index++;
        }
    }

    if (defined $snmpd_conf->{iquerysecname}) {
        splice @contents, $index, 0, "iquerysecname $snmpd_conf->{iquerysecname}\n";
        $index++;
    }

    if (defined $snmpd_conf->{trapsink}) {
        splice @contents, $index, 0, "trapsink $snmpd_conf->{trapsink}\n";
        $index++;
    }

    if (defined $snmpd_conf->{trap2sink}) {
        splice @contents, $index, 0, "trap2sink $snmpd_conf->{trap2sink}\n";
        $index++;
    }

    if (defined $snmpd_conf->{trapsess}) {
        my $line = "trapsess ";
        $line .= "-v $snmpd_conf->{trapsess_version} "   if ($snmpd_conf->{trapsess_version});
        $line .= "-u $snmpd_conf->{trapsess_user} "      if ($snmpd_conf->{trapsess_user});
        $line .= "-e $snmpd_conf->{trapsess_engine} "    if ($snmpd_conf->{trapsess_engine});
        $line .= "-a $snmpd_conf->{trapsess_authproto} " if ($snmpd_conf->{trapsess_authproto});
        $line .= "-A $snmpd_conf->{trapsess_authpass} "  if ($snmpd_conf->{trapsess_authpass});
        $line .= "-x $snmpd_conf->{trapsess_privproto} " if ($snmpd_conf->{trapsess_privproto});
        $line .= "-X $snmpd_conf->{trapsess_privpass} "  if ($snmpd_conf->{trapsess_privpass});
        $line .= "$snmpd_conf->{trapsess_host}"          if ($snmpd_conf->{trapsess_host});
        $line .= ":$snmpd_conf->{trapsess_port}"         if ($snmpd_conf->{trapsess_port});
        $line .= "\n";
        splice @contents, $index, 0, "$line";
        $index++;
    }

    if (defined $snmpd_conf->{notif_linkupdown}) {
        splice @contents, $index, 0, "linkUpDownNotifications $snmpd_conf->{notif_linkupdown}\n";
        $index++;
    }

    if (defined $snmpd_conf->{notif_defmonitors}) {
        splice @contents, $index, 0, "defaultMonitors $snmpd_conf->{notif_defmonitors}\n";
        $index++;
    }

    if (defined $snmpd_conf->{load}) {
        splice @contents, $index, 0, "load $snmpd_conf->{load}\n";
        $index++;
    }

    if (defined $snmpd_conf->{disks}) {
        splice @contents, $index, 0, "includeAllDisks $snmpd_conf->{disks}\n";
        $index++;
    }

    if (defined $snmpd_conf->{monitors}) {
        for my $monitor (@{ $snmpd_conf->{monitors} }) {
            splice @contents, $index, 0, "monitor $monitor\n";
            $index++;
        }
    }

    $lock_fh = &openlock($lock_file, 'w');

    if (open my $config_file, '>', $snmpdconfig_file) {
        print $config_file @contents;
        close $config_file;
        close $lock_fh;
    }
    else {
        close $lock_fh;
        &log_warn("Could not open ${snmpdconfig_file}: $!", "SYSTEM");
        return -1;
    }

    return 0;
}

=pod

=head1 translateSNMPConfigToApi

Translate the SNMP Config params to API params.

Parameters:

    config_ref - Array of snmp config params.

Returns:

    Hash ref - Translated params.

=cut

sub translateSNMPConfigToApi ($config_ref) {
    my %params = (
        'ip'        => 'ip',
        'community' => 'community',
        'port'      => 'port',
        'scope'     => 'scope',
        'status'    => 'status',
    );

    for my $key (keys %{$config_ref}) {
        if (not defined $params{$key}) {
            delete $config_ref->{$key};
        }
    }

    return $config_ref;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Stats.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Stats

=cut

=pod

=head1 getMemStats

Get stats of memory usage of the system.

Parameters:

    format - "b" for bytes, "kb" for KBytes and "mb" for MBytes (default: mb).

Returns:

    list - Two dimensional array.

    @data = (
        [$ram_total_label,     $ram_total],
        [$ram_free_label,    $ram_free],
        ['MemUsed',  $ram_used],
        [$ram_buffers_label,    $ram_buffers],
        [$ram_cached_label,    $ram_cached],
        [$swap_total_label,   $swap_total],
        [$swap_free_label,   $swap_free],
        ['SwapUsed', $swap_used],
        [$swap_cached_label,   $swap_cached],
    );

=cut

sub getMemStats ($format = "mb") {
    my $meminfo_filename = '/proc/meminfo';

    my ($ram_total, $ram_free, $ram_used, $ram_buffers, $ram_cached, $swap_total, $swap_free, $swap_used, $swap_cached);
    my (
        $ram_total_label,  $ram_free_label,  $ram_cached_label, $ram_buffers_label,
        $swap_total_label, $swap_free_label, $swap_cached_label
    );

    unless (-f $meminfo_filename) {
        print "$0: Error: File $meminfo_filename not exist ...\n";
        exit 1;
    }

    my @lines = ();

    if (open my $file, '<', $meminfo_filename) {
        @lines = <$file>;
        close $file;
    }

    for my $line (@lines) {
        if ($line =~ /^MemTotal:/) {
            ($ram_total_label, $ram_total) = split /[: ]+/, $line;
            $ram_total = $ram_total / 1024 if $format eq "mb";
            $ram_total = $ram_total * 1024 if $format eq "b";
        }
        elsif ($line =~ /^MemFree:/) {
            ($ram_free_label, $ram_free) = split(": ", $line);
            $ram_free =~ /^\s+(\d+)\ /;
            $ram_free = $1;
            $ram_free = $ram_free / 1024 if $format eq "mb";
            $ram_free = $ram_free * 1024 if $format eq "b";
        }
        elsif ($line =~ /^MemAvailable:/) {
            my (undef, $ram_available) = split(/ +/, $line);
            $ram_available = $ram_available / 1024 if $format eq "mb";
            $ram_available = $ram_available * 1024 if $format eq "b";
            $ram_used      = $ram_total - $ram_available;
        }
        elsif ($line =~ /^Buffers:/) {
            ($ram_buffers_label, $ram_buffers) = split /[: ]+/, $line;
            $ram_buffers = $ram_buffers / 1024 if $format eq "mb";
            $ram_buffers = $ram_buffers * 1024 if $format eq "b";
        }
        elsif ($line =~ /^Cached:/) {
            ($ram_cached_label, $ram_cached) = split /[: ]+/, $line;
            $ram_cached = $ram_cached / 1024 if $format eq "mb";
            $ram_cached = $ram_cached * 1024 if $format eq "b";
        }
        elsif ($line =~ /swaptotal/i) {
            ($swap_total_label, $swap_total) = split /[: ]+/, $line;
            $swap_total = $swap_total / 1024 if $format eq "mb";
            $swap_total = $swap_total * 1024 if $format eq "b";
        }
        elsif ($line =~ /swapfree/i) {
            ($swap_free_label, $swap_free) = split /[: ]+/, $line;
            $swap_free = $swap_free / 1024 if $format eq "mb";
            $swap_free = $swap_free * 1024 if $format eq "b";
            $swap_used = $swap_total - $swap_free;
        }
        elsif ($line =~ /swapcached/i) {
            ($swap_cached_label, $swap_cached) = split /[: ]+/, $line;
            $swap_cached = $swap_cached / 1024 if $format eq "mb";
            $swap_cached = $swap_cached * 1024 if $format eq "b";
        }
    }

    return (
        [ $ram_total_label,   sprintf('%.2f', $ram_total) ],
        [ $ram_free_label,    sprintf('%.2f', $ram_free) ],
        [ 'MemUsed',          sprintf('%.2f', $ram_used) ],
        [ $ram_buffers_label, sprintf('%.2f', $ram_buffers) ],
        [ $ram_cached_label,  sprintf('%.2f', $ram_cached) ],
        [ $swap_total_label,  sprintf('%.2f', $swap_total) ],
        [ $swap_free_label,   sprintf('%.2f', $swap_free) ],
        [ 'SwapUsed',         sprintf('%.2f', $swap_used) ],
        [ $swap_cached_label, sprintf('%.2f', $swap_cached) ],
    );
}

=pod

=head1 getLoadStats

Get the system load values.

Parameters:

    none

Returns:

    list - Two dimensional array.

    @data = (
        ['Last', $last],
        ['Last 5', $last5],
        ['Last 15', $last15]
    );

=cut

sub getLoadStats () {
    my $load_filename = '/proc/loadavg';

    my $last;
    my $last5;
    my $last15;

    if (-f $load_filename) {
        my $lastline;

        open my $file, '<', $load_filename;
        while (my $line = <$file>) {
            $lastline = $line;
        }
        close $file;

        ($last, $last5, $last15) = split(" ", $lastline);
    }

    my @data = ([ 'Last', $last ], [ 'Last 5', $last5 ], [ 'Last 15', $last15 ],);

    return @data;
}

=pod

=head1 getNetworkStats

Get stats for the network interfaces.

Parameters:

    format - 'raw', 'hash' or nothing.

Returns:

    When 'format' is not defined:

    @data = (
        [
            'eth0 in',
            '46.11'
        ],
        [
            'eth0 out',
            '63.02'
        ],
        ...
    );

    When 'format' is 'raw':

    @data = (
        [
            'eth0 in',
            '48296309'
        ],
        [
            'eth0 out',
            '66038087'
        ],
        ...
    );

    When 'format' is 'hash':

    @data = (
        {
            'in' => '46.12',
            'interface' => 'eth0',
            'out' => '63.04'
        },
        ...
    );

=cut

sub getNetworkStats ($format = "") {
    my $netinfo_filename = '/proc/net/dev';

    unless (-f $netinfo_filename) {
        print "$0: Error: File $netinfo_filename not exist ...\n";
        exit 1;
    }

    my @outHash;
    my @lines;

    if (open(my $file, '<', $netinfo_filename)) {
        chomp(@lines = <$file>);
        close $file;
    }
    else {
        my $msg = "Could not open the file '$netinfo_filename': $!";
        log_error($msg);
        die $msg;
    }

    my ($in, $out);
    my @data;
    my @interface;
    my @interfacein;
    my @interfaceout;

    my $alias;
    $alias = &eload(
        module => 'Relianoid::EE::Alias',
        func   => 'getAlias',
        args   => ['interface']
    ) if $eload;

    my $i = -1;

    for my $line (@lines) {
        unless ($line =~ /\:/ && $line !~ /^\s*lo\:/) {
            next;
        }

        $i++;
        my @iface = split(":", $line);
        my $if    = $iface[0];
        $if =~ s/\ //g;

        # not show cluster maintenance interface
        $i = $i - 1 if $if eq 'cl_maintenance';
        next        if $if eq 'cl_maintenance';

        # ignore fallback device from ip_gre module
        ($i-- && next) if $if =~ /^gre0$|^gretap0$|^erspan0$/;

        # ignore fallback device from ip6_gre module
        ($i-- && next) if $if =~ /^ip6gre0$|^ip6tnl0$/;

        # ignore fallback device from sit module
        ($i-- && next) if $if =~ /^sit0$/;

        if ($line =~ /:\ /) {
            ($in, $out) = (split /\s+/, $iface[1])[ 1, 9 ];
        }
        else {
            ($in, $out) = (split /\s+/, $line)[ 0, 8 ];
            $in = (split /:/, $in)[1];
        }

        if ($format ne "raw") {
            $in  = (($in / 1024) / 1024);
            $out = (($out / 1024) / 1024);
            $in  = sprintf('%.2f', $in);
            $out = sprintf('%.2f', $out);
        }

        push @interface,    $if;
        push @interfacein,  $in;
        push @interfaceout, $out;
        push @outHash, { 'interface' => $if, 'in' => $in, 'out' => $out };

        $outHash[-1]->{alias} = $alias->{$if} if $eload;
    }

    for (my $j = 0 ; $j <= $i ; $j++) {
        push @data, [ $interface[$j] . ' in', $interfacein[$j] ], [ $interface[$j] . ' out', $interfaceout[$j] ];
    }

    if ($format eq 'hash') {
        @data = sort { $a->{interface} cmp $b->{interface} } @outHash;
    }

    return @data;
}

=pod

=head1 getCPU

Get system CPU usage stats.

Parameters:

    none

Returns:

    list - Two dimensional array.

    Example:

    @data = (
              ['CPUuser',    $cpu_user],
              ['CPUnice',    $cpu_nice],
              ['CPUsys',     $cpu_sys],
              ['CPUiowait',  $cpu_iowait],
              ['CPUirq',     $cpu_irq],
              ['CPUsoftirq', $cpu_softirq],
              ['CPUidle',    $cpu_idle],
              ['CPUusage',   $cpu_usage],
    );

=cut

sub getCPU () {
    my @data;
    my $interval         = 1;
    my $cpuinfo_filename = '/proc/stat';

    unless (-f $cpuinfo_filename) {
        print "$0: Error: File $cpuinfo_filename not exist ...\n";
        exit 1;
    }

    my $cpu_user1;
    my $cpu_nice1;
    my $cpu_sys1;
    my $cpu_idle1;
    my $cpu_iowait1;
    my $cpu_irq1;
    my $cpu_softirq1;
    my $cpu_total1;

    my $cpu_user2;
    my $cpu_nice2;
    my $cpu_sys2;
    my $cpu_idle2;
    my $cpu_iowait2;
    my $cpu_irq2;
    my $cpu_softirq2;
    my $cpu_total2;

    my @line_s;

    if (open my $file, '<', $cpuinfo_filename) {
        my @lines = <$file>;
        close $file;

        for my $line (@lines) {
            if ($line =~ /^cpu\ /) {
                @line_s       = split("\ ", $line);
                $cpu_user1    = $line_s[1];
                $cpu_nice1    = $line_s[2];
                $cpu_sys1     = $line_s[3];
                $cpu_idle1    = $line_s[4];
                $cpu_iowait1  = $line_s[5];
                $cpu_irq1     = $line_s[6];
                $cpu_softirq1 = $line_s[7];
                $cpu_total1   = $cpu_user1 + $cpu_nice1 + $cpu_sys1 + $cpu_idle1 + $cpu_iowait1 + $cpu_irq1 + $cpu_softirq1;
            }
        }
    }

    sleep $interval;

    if (open my $file, '<', $cpuinfo_filename) {
        my @lines = <$file>;
        close $file;

        for my $line (@lines) {
            if ($line =~ /^cpu\ /) {
                @line_s       = split("\ ", $line);
                $cpu_user2    = $line_s[1];
                $cpu_nice2    = $line_s[2];
                $cpu_sys2     = $line_s[3];
                $cpu_idle2    = $line_s[4];
                $cpu_iowait2  = $line_s[5];
                $cpu_irq2     = $line_s[6];
                $cpu_softirq2 = $line_s[7];
                $cpu_total2   = $cpu_user2 + $cpu_nice2 + $cpu_sys2 + $cpu_idle2 + $cpu_iowait2 + $cpu_irq2 + $cpu_softirq2;
            }
        }
    }

    my $diff_cpu_user    = $cpu_user2 - $cpu_user1;
    my $diff_cpu_nice    = $cpu_nice2 - $cpu_nice1;
    my $diff_cpu_sys     = $cpu_sys2 - $cpu_sys1;
    my $diff_cpu_idle    = $cpu_idle2 - $cpu_idle1;
    my $diff_cpu_iowait  = $cpu_iowait2 - $cpu_iowait1;
    my $diff_cpu_irq     = $cpu_irq2 - $cpu_irq1;
    my $diff_cpu_softirq = $cpu_softirq2 - $cpu_softirq1;
    my $diff_cpu_total   = $cpu_total2 - $cpu_total1;

    my $cpu_user    = (100 * $diff_cpu_user) / $diff_cpu_total;
    my $cpu_nice    = (100 * $diff_cpu_nice) / $diff_cpu_total;
    my $cpu_sys     = (100 * $diff_cpu_sys) / $diff_cpu_total;
    my $cpu_idle    = (100 * $diff_cpu_idle) / $diff_cpu_total;
    my $cpu_iowait  = (100 * $diff_cpu_iowait) / $diff_cpu_total;
    my $cpu_irq     = (100 * $diff_cpu_irq) / $diff_cpu_total;
    my $cpu_softirq = (100 * $diff_cpu_softirq) / $diff_cpu_total;

    my $cpu_usage = $cpu_user + $cpu_nice + $cpu_sys + $cpu_iowait + $cpu_irq + $cpu_softirq;

    $cpu_user    = sprintf("%.2f", $cpu_user);
    $cpu_nice    = sprintf("%.2f", $cpu_nice);
    $cpu_sys     = sprintf("%.2f", $cpu_sys);
    $cpu_iowait  = sprintf("%.2f", $cpu_iowait);
    $cpu_irq     = sprintf("%.2f", $cpu_irq);
    $cpu_softirq = sprintf("%.2f", $cpu_softirq);
    $cpu_idle    = sprintf("%.2f", $cpu_idle);
    $cpu_usage   = sprintf("%.2f", $cpu_usage);

    $cpu_user    =~ s/,/\./g;
    $cpu_nice    =~ s/,/\./g;
    $cpu_sys     =~ s/,/\./g;
    $cpu_iowait  =~ s/,/\./g;
    $cpu_softirq =~ s/,/\./g;
    $cpu_idle    =~ s/,/\./g;
    $cpu_usage   =~ s/,/\./g;

    @data = (
        [ 'CPUuser',    $cpu_user ],
        [ 'CPUnice',    $cpu_nice ],
        [ 'CPUsys',     $cpu_sys ],
        [ 'CPUiowait',  $cpu_iowait ],
        [ 'CPUirq',     $cpu_irq ],
        [ 'CPUsoftirq', $cpu_softirq ],
        [ 'CPUidle',    $cpu_idle ],
        [ 'CPUusage',   $cpu_usage ],
    );

    return @data;
}

sub getCPUUsageStats () {
    my $out;

    my @data_cpu = &getCPU();

    for my $x (0 .. @data_cpu - 1) {
        my $name  = $data_cpu[$x][0];
        my $value = $data_cpu[$x][1] + 0;

        (undef, $name) = split('CPU', $name);

        $out->{$name} = $value;
    }

    return $out;
}

=pod

=head1 getDiskSpace

Return total, used and free space for every partition in the system.

Parameters:

    none

Returns:

    list - Two dimensional array.

    @data = (
        [
            'dev-dm-0 Total',
            1981104128
        ],
        [
            'dev-dm-0 Used',
            1707397120
        ],
        [
            'dev-dm-0 Free',
            154591232
        ],
        ...
    );

See Also:

    disk-rrd.pl

=cut

sub getDiskSpace () {
    my @data;

    my $df_bin = &getGlobalConfiguration('df_bin');
    my @system = @{ &logAndGet("$df_bin -k", "array") };
    chomp(@system);
    my @df_system = @system;

    for my $line (@system) {
        next if $line !~ /^\/dev/;

        my @dd_name = split(' ', $line);
        my $dd_name = $dd_name[0];

        my ($line_df) = grep ({ /^$dd_name\s/ } @df_system);
        my @s_line = split(/\s+/, $line_df);

        my $partitions = $s_line[0];
        $partitions =~ s/\///;
        $partitions =~ s/\//-/g;

        my $tot  = $s_line[1] * 1024;
        my $used = $s_line[2] * 1024;
        my $free = $s_line[3] * 1024;

        push(@data, [ $partitions . ' Total', $tot ], [ $partitions . ' Used', $used ], [ $partitions . ' Free', $free ]);
    }

    return @data;
}

=pod

=head1 getDiskPartitionsInfo

Get a reference to a hash with the partitions devices, mount points and name of rrd database.

Parameters:

    none

Returns:

    scalar - Hash reference.

    Example:

    $partitions = {
        '/dev/dm-0' => {
            'mount_point' => '/',
            'rrd_id' => 'dev-dm-0hd'
        },
        '/dev/mapper/zva64-config' => {
            'mount_point' => '/usr/local/relianoid/config',
            'rrd_id' => 'dev-mapper-zva64-confighd'
        },
        '/dev/mapper/zva64-log' => {
            'mount_point' => '/var/log',
            'rrd_id' => 'dev-mapper-zva64-loghd'
        },
        '/dev/xvda1' => {
            'mount_point' => '/boot',
            'rrd_id' => 'dev-xvda1hd'
        }
    };

=cut

sub getDiskPartitionsInfo () {
    my $partitions;

    my $df_bin = &getGlobalConfiguration('df_bin');

    my @out      = @{ &logAndGet("$df_bin -k", "array") };
    my @df_lines = grep { /^\/dev/ } @out;
    chomp(@df_lines);

    for my $line (@df_lines) {
        my @df_line = split(/\s+/, $line);

        my $mount_point = $df_line[5];
        my $partition   = $df_line[0];
        my $part_id     = $df_line[0];
        $part_id =~ s/\///;
        $part_id =~ s/\//-/g;

        $partitions->{$partition} = {
            mount_point => $mount_point,
            rrd_id      => "${part_id}hd",
        };
    }

    return $partitions;
}

=pod

=head1 getDiskMountPoint

Get the mount point of a partition device

Parameters:

    dev - Partition device.

Returns:

    string - Mount point for such partition device.
    undef  - The partition device is not mounted

See Also:

    <genDiskGraph>

=cut

sub getDiskMountPoint ($dev) {
    my $df_bin    = &getGlobalConfiguration('df_bin');
    my @df_system = @{ &logAndGet("$df_bin -k", "array") };
    my $mount;

    for my $line_df (@df_system) {
        if ($line_df =~ /$dev/) {
            my @s_line = split("\ ", $line_df);
            chomp(@s_line);

            $mount = $s_line[5];
        }
    }

    return $mount;
}

=pod

=head1 getCPUTemp

Get the CPU temperature in celsius degrees.

Parameters:

    none

Returns:

    string - Temperature in celsius degrees.

See Also:

    temperature-rrd.pl

=cut

sub getCPUTemp () {
    my $filename = &getGlobalConfiguration("temperatureFile");
    my $lastline;

    unless (-f $filename) {
        exit 1;
    }

    open my $file, '<', $filename;

    while (my $line = <$file>) {
        $lastline = $line;
    }

    close $file;

    my @lastlines = split("\:", $lastline);
    my $temp      = $lastlines[1];
    $temp =~ s/\ //g;
    $temp =~ s/\n//g;
    $temp =~ s/C//g;

    return $temp;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/System.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Relianoid::Log;
use Relianoid::Config;

my $eload = eval { require Relianoid::ELoad; };

=pod

=head1 Module

Relianoid::System

=cut

=pod

=head1 getTotalConnections

Get the number of current connections on this appliance.

Parameters:

    none

Returns:

    integer - The number of connections.

=cut

sub getTotalConnections () {
    my $conntrack = &getGlobalConfiguration("conntrack");
    my $conns     = &logAndGet("$conntrack -C");
    $conns =~ s/(\d+)/$1/;
    $conns += 0;

    return $conns;
}

=pod

=head1 indexOfElementInArray

Get the index of the first position where an element if found in an array.

Parameters:

    searched_element - Element to search.
    array_ref        - Reference to the array to be searched.

Returns:

    integer - Zero or higher if the element was found. -1 if the element was not found. -2 if no array reference was received.

See Also:

    API v4: <new_bond>

=cut

sub indexOfElementInArray ($searched_element, $array_ref) {
    if (ref $array_ref ne 'ARRAY') {
        return -2;
    }

    my @arrayOfElements = @{$array_ref};
    my $index           = 0;

    for my $list_element (@arrayOfElements) {
        if ($list_element eq $searched_element) {
            last;
        }

        $index++;
    }

    # if $index is greater than the last element index
    if ($index > $#arrayOfElements) {
        # return an invalid index
        $index = -1;
    }

    return $index;
}

=pod

=head1 slurpFile

Stores the content of a file in a variable.

Parameters:

    path - string with the file location

Returns:

    string - content of the file

=cut

sub slurpFile ($path) {
    my $file;

    if (open(my $fh, '<', $path)) {
        local $/ = undef;
        $file = <$fh>;
        close $fh;
    }
    else {
        my $msg = "Could not open file '$file': $!";
        &log_info($msg);
        die $msg;
    }

    return $file;
}

=pod

=head1 getSpaceFree

It gets the free space that contains a partition. The partition is calculated
from a directory

Parameters:

    directroy - directory to know the free space

Returns:

    Integer - Number of bytes free in the partition

=cut

sub getSpaceFree ($dir) {
    my $df_bin   = &getGlobalConfiguration("df_bin");
    my $sed_bin  = &getGlobalConfiguration("sed_bin");
    my $cut_bin  = &getGlobalConfiguration("cut_bin");
    my $grep_bin = &getGlobalConfiguration("grep_bin");

    my $cmd  = "$df_bin -B1 $dir | $grep_bin -Ev '^(Filesystem|\$)' | $sed_bin -E 's/\\s+/ /g' | $cut_bin -d ' ' -f4";
    my $size = &logAndGet($cmd);

    &log_debug2("Dir: $dir, Free space (Bytes): $size");

    return $size;
}

=pod

=head1 getSpaceFormatHuman

It converts a number of bytes to human format, converting Bytes to KB, MB or GB

Parameters:

    Bytes - Number of bytes

Returns:

    String - String with size and its units

=cut

sub getSpaceFormatHuman ($size) {
    my $human = $size;
    my $unit  = 'B';

    if ($human > 1024) {
        $human = $human / 1024;
        $unit  = "KB";
    }
    if ($human > 1024) {
        $human = $human / 1024;
        $unit  = "MB";
    }
    if ($human > 1024) {
        $human = $human / 1024;
        $unit  = "GB";
    }

    $human = sprintf("%.2f", $human);
    my $out = $human . $unit;
    return $out;
}

=pod

=head1 getSupportSaveSize

It gets the aproximate size that the supportsave will need.
The size is calculated using the config and log directories size and adding
a offset of 20MB

Parameters:

    none

Returns:

    Integer - Number of bytes that supportsave will use

=cut

sub getSupportSaveSize () {
    my $offset = "20971520";                               # 20 MB
    my $dirs   = "/usr/local/relianoid/config /var/log";

    my $tar_bin = &getGlobalConfiguration('tar');
    my $wc      = &getGlobalConfiguration('wc_bin');
    my $size    = &logAndGet("$tar_bin cz - $dirs 2>/dev/null | $wc -c");

    return $offset + $size;
}

=pod

=head1 checkSupportSaveSpace

Check if the disk has enough space to create a supportsave

Parameters:

    directory - Directory where the supportsave will be created

Returns:

    Integer - It returns 0 on success or the number of bytes needed to create a supportsave

=cut

sub checkSupportSaveSpace ($dir = "/tmp") {
    my $supp_size = &getSupportSaveSize();
    my $freeSpace = &getSpaceFree($dir);

    my $out = ($freeSpace > $supp_size) ? 0 : $supp_size;

    if ($out) {
        &log_error("There is no enough free space ('$freeSpace') in the '$dir' partition. Supportsave needs '$supp_size' bytes",
            "system");
    }
    else {
        &log_debug("Checking free space ('$freeSpace') in the '$dir' partition. Supportsave needs '$supp_size' bytes",
            "system");
    }

    return $out;
}

=pod

=head1 getSupportSave

It creates a support save file used for supporting purpose. It is created in the '/tmp/' directory

Parameters:

    none

Returns:

    String - The supportsave file name is returned.

=cut

sub getSupportSave () {
    my $bin_dir   = &getGlobalConfiguration('bin_dir');
    my @ss_output = @{ &logAndGet("${bin_dir}/supportsave", "array") };

    # get the last "word" from the first line
    my $first_line = shift @ss_output;
    my $last_word  = (split(' ', $first_line))[-1];

    my $ss_path = $last_word;

    my (undef, $ss_filename) = split('/tmp/', $ss_path);

    return $ss_filename;
}

=pod

=head1 checkPidRunning

Check if Pid is running on the system.

Parameters:

    pid - pid to check.

Returns:

    scalar - 0 if success, otherwise an error.

=cut

sub checkPidRunning ($pid) {
    my $ret = 1;
    $ret = 0 if (-e "/proc/" . $pid);
    return $ret;
}

=pod

=head1 checkPidFileRunning

Check if PidFile contains a Pid is running on the system.

Parameters:

    pid_file - pid file to check.

Returns:

    scalar - 0 if success, otherwise an error.

=cut

sub checkPidFileRunning ($pid_file) {
    open my $fileh, '<', $pid_file;
    my $pid = <$fileh>;
    chomp $pid;
    close $fileh;
    return &checkPidRunning($pid);
}

=pod

=head1 setSshDefaultConfig

Apply default SSH config if it was not changed by this service
before. Then, reload the service generators.

Parameters:

    None.

Returns:

    ssh_config - Hash reference with SSH default configuration.

=cut

sub setSshDefaultConfig () {
    my $output = 0;
    $output = &eload(
        module => 'Relianoid::EE::System::SSH',
        func   => 'setSshDefaultConfigPriv',
        soft   => 1
    ) if ($eload);
    return $output;
}

=pod

=head1 setSshFactoryReset

Set default configuration of the ssh service.

Parameters:

    None.

Returns:

    integer - 0 on success, or -1 on failure.

=cut

sub setSshFactoryReset () {
    my $ssh_tpl = "/etc/ssh/sshd_config.ucf-dist";
    my $ssh_cfg = "/etc/ssh/sshd_config";
    my $output  = 0;

    if (-f $ssh_tpl) {
        my $cmd = "cp -f $ssh_tpl $ssh_cfg";
        &logAndRun($cmd);
    }

    $output = &eload(
        module => 'Relianoid::EE::System::SSH',
        func   => 'setSshFactoryResetPriv',
        soft   => 1
    ) if ($eload);
    return $output;
}

=pod

=head1 initHttpServer

Initialize required files to make http server to work.

Parameters:

    None.

Returns:

    none 0 on success other value if there is an error.

=cut

sub initHttpServer () {
    my $httpFile          = &getGlobalConfiguration('confhttp');
    my $httpFileTpl       = &getGlobalConfiguration('confhttp_tpl');
    my $httpServerKey     = &getGlobalConfiguration('http_server_key');
    my $httpServerKeyTpl  = &getGlobalConfiguration('http_server_key_tpl');
    my $httpServerCert    = &getGlobalConfiguration('http_server_cert');
    my $httpServerCertTpl = &getGlobalConfiguration('http_server_cert_tpl');
    my $output            = 0;
    my $cmd;

    if (!-f "$httpFile") {
        $cmd = "cp -f $httpFileTpl $httpFile";
        $output += &logAndRun($cmd);
    }

    if (!-f "$httpServerKey") {
        $cmd = "cp -f $httpServerKeyTpl $httpServerKey";
        $output += &logAndRun($cmd);
    }

    if (!-f "$httpServerCert") {
        $cmd = "cp -f $httpServerCertTpl $httpServerCert";
        $output += &logAndRun($cmd);
    }

    $output += &eload(
        module => 'Relianoid::EE::System::HTTP',
        func   => 'setHttpDefaultConfigPriv',
        soft   => 1
    ) if ($eload);
    return $output;
}

=pod

=head1 setHttpDefaultConfig

Apply default HTTP config if it was not changed by this service
before. Then, reload the service generators.

Parameters:

    None.

Returns:

    http_conf - Hash reference with HTTP default configuration.

=cut

sub setHttpDefaultConfig () {
    my $output = 0;
    $output = &eload(
        module => 'Relianoid::EE::System::HTTP',
        func   => 'setHttpDefaultConfigPriv',
        soft   => 1
    ) if ($eload);
    return $output;
}

=pod

=head1 restartHttpServer

Restart the HTTP web server.

Parameters:

    None.

Returns:

    none 0 on success other value if there is an error.

=cut

sub restartHttpServer () {
    my $output = 0;
    $output = &eload(
        module => 'Relianoid::EE::System::HTTP',
        func   => 'restartHttpServerPriv',
        soft   => 1
    ) if ($eload);
    return $output;
}

=pod

=head1 setHttpFactoryReset

Set default configuration of the http service.

Parameters:

    None.

Returns:

    integer - 0 on success, or -1 on failure.

=cut

sub setHttpFactoryReset () {
    my $httpFile          = &getGlobalConfiguration('confhttp');
    my $httpFileTpl       = &getGlobalConfiguration('confhttp_tpl');
    my $httpServerKey     = &getGlobalConfiguration('http_server_key');
    my $httpServerKeyTpl  = &getGlobalConfiguration('http_server_key_tpl');
    my $httpServerCert    = &getGlobalConfiguration('http_server_cert');
    my $httpServerCertTpl = &getGlobalConfiguration('http_server_cert_tpl');
    my $output            = 0;

    my $cmd = "cp -f $httpFileTpl $httpFile";
    $output += &logAndRun($cmd);

    $cmd = "cp -f $httpServerKeyTpl $httpServerKey";
    $output += &logAndRun($cmd);

    $cmd = "cp -f $httpServerCertTpl $httpServerCert";
    $output += &logAndRun($cmd);

    $output += &eload(
        module => 'Relianoid::EE::System::HTTP',
        func   => 'setHttpDefaultConfigPriv',
        soft   => 1
    ) if ($eload);

    return $output;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/System/DNS.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::System::DNS

=cut

=pod

=head1 getDns

Get the dns servers.

Parameters:

    none - .

Returns:

    scalar - Hash reference.

    Example:

    $dns = {
        primary => "value",
        secundary => "value",
    };

=cut

sub getDns () {
    my $dns     = { 'primary' => '', 'secondary' => '' };
    my $dnsFile = &getGlobalConfiguration('filedns');

    if (!-f $dnsFile) {
        return;
    }

    open(my $fh, '<', $dnsFile);
    my @file = <$fh>;
    close $fh;

    my $index = 1;
    for my $line (@file) {
        if ($line =~ /nameserver\s+([^\s]+)/) {
            $dns->{primary}   = $1 if ($index == 1);
            $dns->{secondary} = $1 if ($index == 2);

            $index++;
            last if ($index > 2);
        }
    }

    return $dns;
}

=pod

=head1 setDns

Set a primary or secondary dns server.

Parameters:

    dns - 'primary' or 'secondary'.
    value - ip addres of dns server.

Returns:

    none - .

Bugs:

    Returned value.

=cut

sub setDns ($dns, $value) {
    my $dnsFile = &getGlobalConfiguration('filedns');

    if (!-f $dnsFile) {
        my $bin = &getGlobalConfiguration('touch');
        &logAndRun("$bin $dnsFile");
    }

    require Tie::File;
    tie my @dnsArr, 'Tie::File', $dnsFile;

    my $index      = 1;
    my $line_index = 0;
    for my $line (@dnsArr) {
        $line_index++;
        if ($line =~ /\s*nameserver/) {
            $line = "nameserver $value"
              if ($index == 1 and $dns eq 'primary' and $value ne '');
            $line = "nameserver $value"
              if ($index == 2 and $dns eq 'secondary' and $value ne '');
            splice @dnsArr, ($line_index - 1)
              if ($index == 2 and $dns eq 'secondary' and $value eq '');
            $index++;
            last if ($index > 2);
        }
    }

    # if there is not any nameserver, add one
    push @dnsArr, "nameserver $value"
      if ($index == 1 and $value ne '');

    # if the secondary nameserver has not been found, add it
    push @dnsArr, "nameserver $value"
      if ($index == 2 and $dns eq 'secondary' and $value ne '');

    untie @dnsArr;

    return 0;
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/System/Log.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::System::Log

=cut

=pod

=head1 getLogs

Get list of log files.

Parameters:

    none

Returns:

    scalar - Array reference.

    Array element example:

    {
        'file' => $line,
        'date' => $datetime_string
    }

=cut

sub getLogs () {
    my @logs;
    my $logdir = &getGlobalConfiguration('logdir');

    require Relianoid::File;

    opendir(my $directory, $logdir);
    my @files = readdir($directory);
    closedir($directory);

    for my $line (@files) {
        # not list if it is a directory
        next if -d "$logdir/$line";

        my $filepath = "$logdir/$line";
        chomp($filepath);

        push @logs, { 'file' => $line, 'date' => &getFileDateGmt($filepath) };
    }

    return \@logs;
}

=pod

=head1 getLogLines

Show a number of the last lines of a log file

Parameters:

    logFile - log file name in /var/log
    lines - number of lines to show

Returns:

    array - last lines of log file

=cut

sub getLogLines ($logFile, $lines_number) {
    my @lines;
    my $path = &getGlobalConfiguration('logdir');
    my $tail = &getGlobalConfiguration('tail');

    if ($logFile =~ /\.gz$/) {
        my $zcat = &getGlobalConfiguration('zcat');
        @lines = @{ &logAndGet("$zcat ${path}/$logFile | $tail -n $lines_number", "array") };
    }
    else {
        @lines = @{ &logAndGet("$tail -n $lines_number ${path}/$logFile", "array") };
    }

    return \@lines;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/System/Packages.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);
require Relianoid::Log;
use Relianoid::SystemInfo;
use autodie;

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::System::Packages

=cut

=pod

=head1 setSystemPackagesRepo

It configures the system to connect with the APT.

Parameters:

    none

Returns:

    Integer - Error code, 0 on success or another value on failure

=cut

sub setSystemPackagesRepo () {
    if ($eload) {
        return &eload(
            module => 'Relianoid::EE::Apt',
            func   => 'setAPTRepo',
        );
    }

    require Relianoid::File;

    my $host         = &getGlobalConfiguration('repo_url_relianoid');
    my $file         = &getGlobalConfiguration('apt_source_relianoid');
    my $aptget_bin   = &getGlobalConfiguration('aptget_bin');
    my $distribution = "bookworm";
    my $repo_version = "v7";
    my $content      = "deb http://$host/ce/$repo_version/ $distribution main\n";

    &log_info("Configuring the APT repository", "SYSTEM");

    my $success    = 1;
    my $error_code = (setFile($file, $content) == $success) ? 0 : 1;

    return $error_code;
}

=pod

=head1 getSystemPackagesUpdatesList

It returns information about the status of the system regarding updates.
This information is parsed from a file

Parameters:

    none

Returns:

    Hash reference

    'message'    : message with the instructions to update the system
    'last_check' : date of the last time that nod-updater (or apt-get) was executed
    'status'     : information about if there is pending updates.
    'number'     : number of packages pending of updating
    'packages'   : list of packages pending of updating

=cut

sub getSystemPackagesUpdatesList () {
    require Relianoid::Lock;
    my $package_list = &getGlobalConfiguration('apt_outdated_list');
    my $message_file = &getGlobalConfiguration('apt_msg');

    my @pkg_list = ();
    my $msg;
    my $date        = "";
    my $status      = "unknown";
    my $install_msg = "To upgrade the system, please, execute in a shell the following command:\n    'noid-updater -i'";

    my $fh = &openlock($package_list, 'r');
    if ($fh) {
        @pkg_list = split(' ', <$fh>);
        close $fh;

        # remove the first item
        shift @pkg_list
          if ((exists $pkg_list[0]) and ($pkg_list[0] eq 'Listing...'));
    }

    $fh = &openlock($message_file, 'r');
    if (defined $fh) {
        $msg = <$fh>;
        close $fh;

        if ($msg =~ /last check at (.+) -/) {
            $date   = $1;
            $status = "Updates available";
        }
        elsif ($msg =~ /Relianoid Packages are up-to-date/) {
            $status = "Updated";
        }
    }

    return {
        'message'    => $install_msg,
        'last_check' => $date,
        'status'     => $status,
        'number'     => scalar @pkg_list,
        'packages'   => \@pkg_list
    };
}

1;

=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/System/Proxy.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

=pod

=head1 Module

Relianoid::System::Proxy

=cut

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 getProxy

Get a reference to a hash with the proxy configuration

Parameters: None

Returns: hash reference

    {
        "http_proxy" => "https://10.10.21.13:8080",
        "https_proxy" => "https://10.10.21.12:8080",
    }

=cut

sub getProxy () {
    my $http_proxy  = &getGlobalConfiguration('http_proxy')  // '';
    my $https_proxy = &getGlobalConfiguration('https_proxy') // '';

    return {
        'http_proxy'  => $http_proxy,
        'https_proxy' => $https_proxy,
    };
}

=pod

=head1 setProxy

Configure a system proxy

Parameters: hash reference

proxy structure

    {
        "http_proxy" => "https://10.10.21.13:8080",
        "https_proxy" => "https://10.10.21.12:8080",
    }

Returns: integer

    0 - succes
    1 - error

=cut

sub setProxy ($proxy_conf) {
    my $error = 0;

    for my $key ('http_proxy', 'https_proxy') {
        next if not exists $proxy_conf->{$key};

        if ($error = &setGlobalConfiguration($key, $proxy_conf->{$key})) {
            &log_error("Error setting '$key' with the value '$proxy_conf->{ $key }'", "System");
        }
    }

    if (not $error) {
        require Relianoid::Apt;
        &setAPTProxy();
    }

    return $error;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/SystemInfo.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures state);

=pod

=head1 Module

Relianoid::SystemInfo

=cut

=pod

=head1 getDate

Get date string

Parameters:

    none

Returns:

    string - Date string. Example: "Mon May 22 10:42:39 2017"

=cut

sub getDate() {
    return scalar CORE::localtime();
}

=pod

=head1 getHostname

Get system hostname, and it is saved all the process life time

Parameters:

    none - .

Returns:

    string - Hostname.

=cut

sub getHostname() {
    require Sys::Hostname;
    state $hostname = Sys::Hostname::hostname();
    return Sys::Hostname::hostname();
}

=pod

=head1 getApplianceVersion

Returns a string with the description of the appliance.

NOTE: This function uses Tie::File, this module should be used only for writing files.

Parameters:

    none - .

Returns:

    string - Version string.

=cut

sub getApplianceVersion() {
    my $version;
    my $hyperv;
    my $applianceFile = &getGlobalConfiguration('applianceVersionFile');
    my $lsmod         = &getGlobalConfiguration('lsmod');
    my @packages      = @{ &logAndGet("$lsmod", "array") };
    my @hypervisor    = grep { /(xen|vm|hv|kvm)_/ } @packages;

    # look for appliance vesion
    if (-f $applianceFile) {
        require Tie::File;
        Tie::File->import;

        tie my @filelines, 'Tie::File', $applianceFile;
        $version = $filelines[0];
        untie @filelines;
    }

    # generate appliance version
    if (!$version) {
        my $kernel = &getKernelVersion();

        my $awk      = &getGlobalConfiguration('awk');
        my $ifconfig = &getGlobalConfiguration('ifconfig');

        # look for mgmt interface
        my @ifaces = @{ &logAndGet("$ifconfig -s | $awk '{print $1}'", "array") };

        # Network appliance
        if (grep { /mgmt/ } @ifaces) {
            $version = "ZNA 3300";
        }
        else {
            # select appliance verison
            if    ($kernel =~ /3\.2\.0\-4/)      { $version = "3110"; }
            elsif ($kernel =~ /3\.16\.0\-4/)     { $version = "4000"; }
            elsif ($kernel =~ /3\.16\.7\-ckt20/) { $version = "4100"; }
            else                                 { $version = "System version not detected"; }

            # virtual appliance
            if ($hypervisor[0] =~ /(xen|vm|hv|kvm)_/) {
                $version = "ZVA $version";
            }

            # baremetal appliance
            else {
                $version = "ZBA $version";
            }
        }

        # save version for future request
        require Tie::File;
        Tie::File->import;

        tie my @filelines, 'Tie::File', $applianceFile;
        $filelines[0] = $version;
        untie @filelines;
    }

    # virtual appliance
    if (@hypervisor && $hypervisor[0] =~ /(xen|vm|hv|kvm)_/) {
        $hyperv = $1;
        $hyperv = 'HyperV' if ($hyperv eq 'hv');
        $hyperv = 'Vmware' if ($hyperv eq 'vm');
        $hyperv = 'Xen'    if ($hyperv eq 'xen');
        $hyperv = 'KVM'    if ($hyperv eq 'kvm');
    }

    # before relianoid versions had hypervisor in appliance version file, so not inclue it in the chain
    if ($hyperv && $version !~ /hypervisor/) {
        $version = "$version, hypervisor: $hyperv";
    }

    return $version;
}

=pod

=head1 getCpuCores

Get the number of CPU cores in the system.

Parameters:

    none

Returns:

    integer - Number of CPU cores.

=cut

sub getCpuCores() {
    my $cpuinfo_filename = '/proc/stat';
    my $cores            = 1;

    open my $stat_file, '<', $cpuinfo_filename;

    while (my $line = <$stat_file>) {
        next unless $line =~ /^cpu(\d+) /;
        $cores = $1 + 1;
    }

    close $stat_file;

    return $cores;
}

=head1 setEnv

Set envorioment variables. Get variables from global.conf

Parameters:

    none

Returns:

    none

=cut

sub setEnv() {
    use Relianoid::Config;

    local $ENV{http_proxy}  = &getGlobalConfiguration('http_proxy')  // "";
    local $ENV{https_proxy} = &getGlobalConfiguration('https_proxy') // "";

    my $provider = &getGlobalConfiguration('cloud_provider');

    if ($provider && $provider eq 'aws') {
        local $ENV{AWS_SHARED_CREDENTIALS_FILE} = &getGlobalConfiguration('aws_credentials') // "";
        local $ENV{AWS_CONFIG_FILE}             = &getGlobalConfiguration('aws_config')      // "";
    }

    return;
}

=pod

=head1 getKernelVersion

Returns the kernel version

Parameters:

    none

Returns:

    string - kernel version

=cut

sub getKernelVersion() {
    require Relianoid::Config;
    my $uname   = &getGlobalConfiguration('uname');
    my $version = &logAndGet("$uname -r");
    return $version;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/User.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

=pod

=head1 Module

Relianoid::User

=cut

=pod

=head1 getUser

Get the user that is executing the API or WEBGUI

Parameters:

    None

Returns:

    String - User name

=cut

sub getUser () {
    return $ENV{REQ_USER} // '';
}

=pod

=head1 setUser

Save the user that is executing the API or WEBGUI

Parameters:

    None - .

Returns:

    String - User name

=cut

sub setUser ($user) {
    $ENV{REQ_USER} = $user;    ## no critic (Variables::RequireLocalizedPunctuationVars)

    return;
}

=pod

=head1 getSysGroupList

List all Operating System groups

Parameters:

    None

Returns:

    Array - List of groups

=cut

sub getSysGroupList () {
    require Relianoid::Lock;
    my @groupSet   = ();
    my $group_file = &openlock("/etc/group", "r");
    while (my $group = <$group_file>) {
        push(@groupSet, $1) if ($group =~ m/(\w+):x:.*/g);
    }
    close $group_file;

    return @groupSet;
}

=pod

=head1 getSysUserList

List all Operating System users

Parameters:

    None

Returns:

    Array - List of users

=cut

sub getSysUserList () {
    require Relianoid::Lock;
    my @userSet   = ();
    my $user_file = &openlock("/etc/passwd", "r");
    while (my $user = <$user_file>) {
        push(@userSet, $1) if ($user =~ m/(\w+):x:.*/g);
    }
    close $user_file;

    return @userSet;
}

=pod

=head1 getSysUserExists

    Check if a user exists in the Operting System

Parameters:

    User - User name

Returns:

    Integer - 1 if the user exists or 0 if it doesn't exist

=cut

sub getSysUserExists ($user) {
    my $out = 0;
    $out = 1 if (grep { $user eq $_ } &getSysUserList());

    return $out;
}

=pod

=head1 getSysGroupExists

    Check if a group exists in the Operting System

Parameters:

    Group - group name

Returns:

    Integer - 1 if the group exists or 0 if it doesn't exist

=cut

sub getSysGroupExists ($group) {
    my $out = 0;
    $out = 1 if (grep { $group eq $_ } &getSysGroupList());

    return $out;
}

1;


=== ./background/relianoid_adc/source_tree/usr/share/perl5/Relianoid/Validate.pm ===

#!/usr/bin/perl
###############################################################################
#
#    RELIANOID Software License
#    This file is part of the RELIANOID Load Balancer software package.
#
#    Copyright (C) 2014-today RELIANOID
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;
use feature qw(signatures);

use Carp;
use Regexp::IPv6 qw($IPv6_re);
use Relianoid::Net::Validate;

my $eload = eval { require Relianoid::ELoad };

=pod

=head1 Module

Relianoid::Validate

=cut

# Notes about regular expressions:
#
# \w matches the 63 characters [a-zA-Z0-9_] (most of the time)
#

my $UNSIGNED8BITS = qr/(?:25[0-5]|2[0-4]\d|(?!0)[1]?\d\d?|0)/;                         # (0-255)
my $UNSIGNED7BITS = qr/(?:[0-9]{1,2}|10[0-9]|11[0-9]|12[0-8])/;                        # (0-128)
my $HEXCHAR       = qr/(?:[A-Fa-f0-9])/;
my $ipv6_word     = qr/(?:$HEXCHAR+){1,4}/;
my $ipv4_addr     = qr/(?:$UNSIGNED8BITS\.){3}$UNSIGNED8BITS/;
my $ipv6_addr     = $IPv6_re;
my $mac_addr      = qr/(?:$HEXCHAR$HEXCHAR\:){5}$HEXCHAR$HEXCHAR/;
my $ipv4v6        = qr/(?:$ipv4_addr|$ipv6_addr)/;
my $boolean       = qr/(?:true|false)/;
my $enable        = qr/(?:enable|disable)/;
my $integer       = qr/\d+/;
my $natural       = qr/[1-9]\d*/;                                                      # natural number = {1, 2, 3, ...}
my $weekdays      = qr/(?:monday|tuesday|wednesday|thursday|friday|saturday|sunday)/;
my $minutes       = qr/(?:\d|[0-5]\d)/;
my $hours         = qr/(?:\d|[0-1]\d|2[0-3])/;
my $months        = qr/(?:[1-9]|1[0-2])/;
my $dayofmonth    = qr/(?:[1-9]|[1-2]\d|3[01])/;                                       # day of month
my $rrdTime       = qr/\d\d-\d\d-(?:\d\d)?\d\d-\d\d:\d\d/;    # MM-DD-[YY]YY-hh:mm ; example: "11-09-2020-14:05";

my $hostname = qr/[a-z][a-z0-9\-]{0,253}[a-z0-9]/;
my $service  = qr/[a-zA-Z0-9][a-zA-Z0-9_\-\.]*/;
my $zone     = qr/(?:$hostname\.)+[a-z]{2,}/;

my $cert_name = qr/(?:\*[_|\.])?\w[\w\.\(\)\@ \-]*/;

my $vlan_tag        = qr/\d{1,4}/;
my $virtual_tag     = qr/[a-zA-Z0-9\-]{1,13}/;
my $nic_if          = qr/[a-zA-Z0-9\-]{1,15}/;
my $bond_if         = qr/[a-zA-Z0-9\-]{1,15}/;
my $vlan_if         = qr/[a-zA-Z0-9\-]{1,13}\.$vlan_tag/;
my $interface       = qr/$nic_if(?:\.$vlan_tag)?(?:\:$virtual_tag)?/;
my $port_range      = qr/(?:[1-9]\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])/;
my $graphsFrequency = qr/(?:daily|weekly|monthly|yearly)/;

my $blacklists_source = qr{(?:\d{1,3}\.){3}\d{1,3}(?:\/\d{1,2})?};
my $dos_global        = qr/(?:sshbruteforce)/;
my $dos_all           = qr/(?:limitconns|limitsec)/;
my $dos_tcp           = qr/(?:bogustcpflags|limitrst)/;

my $run_actions = qr/^(?:stop|start|restart)$/;

my $name  = qr/^(?:[a-zA-Z0-9][\w]{5,31})$/;
my $email = qr/(?:[a-zA-Z][\w\_\.]+)\@(?:[a-zA-Z0-9.-]+)\.(?:[a-zA-Z]{2,4})/;

my %format_re = (

    # generic types
    'integer'     => $integer,
    'natural_num' => $natural,
    'boolean'     => $boolean,
    'ipv4v6'      => $ipv4v6,
    'rrd_time'    => $rrdTime,

    # hostname
    'hostname' => $hostname,

    # license
    'license_format' => qr/(?:txt|html)/,

    # log
    'log' => qr/[\.\-\w]+/,

    # api
    'zapi_key'      => qr/[a-zA-Z0-9]+/,
    'zapi_status'   => $enable,
    'zapi_password' => qr/.+/,

    # common
    'port'      => $port_range,
    'multiport' => qr/(?:\*|(?:$port_range|$port_range\:$port_range)(?:,$port_range|,$port_range\:$port_range)*)/,

    'user'     => qr/[\w]+/,
    'password' => qr/.+/,

    # system
    'dns_nameserver' => $ipv4v6,
    'dns'            => qr/(?:primary|secondary)/,
    'ssh_port'       => $port_range,
    'ssh_listen'     => qr/(?:$ipv4v6|\*)/,
    'snmp_status'    => $boolean,
    'snmp_ip'        => qr/(?:$ipv4v6|\*)/,
    'snmp_community' => qr{.+},
    'snmp_port'      => $port_range,
    'snmp_scope'     => qr{(?:\d{1,3}\.){3}\d{1,3}\/\d{1,2}},    # ip/mask
    'ntp'            => qr{[\w\.\-]+},
    'http_proxy'     => qr{\S*},                                 # use any character except the spaces

    # farms
    'farm_name'             => qr/[a-zA-Z0-9\-]+/,
    'farm_profile'          => qr/HTTP|GSLB|L4XNAT|DATALINK/,
    'backend'               => qr/\d+/,
    'service'               => $service,
    'http_service'          => qr/[a-zA-Z0-9\-]+/,
    'gslb_service'          => qr/[a-zA-Z0-9][\w\-]*/,
    'farm_modules'          => qr/(?:gslb|dslb|lslb)/,
    'service_position'      => qr/\d+/,
    'l4_session'            => qr/[ \._\:\w]+/,
    'l7_session'            => qr/[ \._\:\w]+/,
    'farm_maintenance_mode' => qr/(?:drain|cut)/,               # not used from API 4

    # cipher
    'ciphers' => qr/(?:all|highsecurity|customsecurity|ssloffloading)/,    # not used from API 4

    # backup
    'backup'        => qr/[\w-]+/,
    'backup_action' => qr/apply/,

    # graphs
    'graphs_frequency' => $graphsFrequency,
    'graphs_system_id' => qr/(?:cpu|load|ram|swap)/,
    'mount_point'      => qr/root[\w\-\.\/]*/,

    # http
    'redirect_code'    => qr/(?:301|302|307)/,                             # not used from API 4
    'http_sts_status'  => qr/(?:true|false)/,                              # not used from API 4
    'http_sts_timeout' => qr/(?:\d+)/,

    # GSLB
    'zone'                => qr/(?:$hostname\.)+[a-z]{2,}/,
    'resource_id'         => qr/\d+/,
    'resource_name'       => qr/(?:[\w\-\.]+|\@)/,
    'resource_ttl'        => qr/$natural/,                                            # except zero
    'resource_type'       => qr/(?:NS|A|AAAA|CNAME|DYNA|MX|SRV|TXT|PTR|NAPTR)/,       # not used from API 4
    'resource_data'       => qr/.+/,                                                  # allow anything (TXT type needs it)
    'resource_data_A'     => $ipv4_addr,
    'resource_data_AAAA'  => $ipv6_addr,
    'resource_data_DYNA'  => $service,
    'resource_data_NS'    => qr/[a-zA-Z0-9\-]+/,
    'resource_data_CNAME' => qr/[a-z\.]+/,
    'resource_data_MX'    => qr/[a-z\.\ 0-9]+/,
    'resource_data_TXT'   => qr/.+/,                                                  # all characters allow
    'resource_data_SRV'   => qr/[0-9]+ [0-9]+ [0-9]+ .+/,                             # https://www.ietf.org/rfc/rfc2782
    'resource_data_PTR'   => qr/[a-z\.]+/,
    'resource_data_NAPTR' => qr/[0-9]+ [0-9]+\|[a-zA-Z]?\|[a-zA-Z0-9\+]*\|.*\|.+/,    # https://www.ietf.org/rfc/rfc2915

    # interfaces ( WARNING: length in characters < 16  )
    'mac_addr'         => $mac_addr,
    'interface'        => $interface,
    'nic_interface'    => $nic_if,
    'bond_interface'   => $bond_if,
    'vlan_interface'   => $vlan_if,
    'virt_interface'   => qr/(?:$bond_if|$nic_if)(?:\.$vlan_tag)?:$virtual_tag/,
    'routed_interface' => qr/(?:$nic_if|$bond_if|$vlan_if)/,
    'interface_type'   => qr/(?:nic|vlan|virtual|bond)/,
    'vlan_tag'         => qr/$vlan_tag/,
    'virtual_tag'      => qr/$virtual_tag/,
    'bond_mode_num'    => qr/[0-6]/,
    'bond_mode_short'  =>
      qr/(?:balance-rr|active-backup|balance-xor|broadcast|802.3ad|balance-tlb|balance-alb)/,    # not used from API 4

    # notifications
    'notif_alert'  => qr/(?:backends|cluster|license|interface|package|certificate)/,
    'notif_method' => qr/(?:email)/,
    'notif_tls'    => $boolean,
    'notif_action' => $enable,
    'notif_time'   => $natural,                                                                  # this value can't be 0

    # IPDS
    # blacklists
    'day_of_month'         => qr{$dayofmonth},
    'weekdays'             => qr{$weekdays},
    'blacklists_name'      => qr{\w+},
    'blacklists_source'    => qr{$blacklists_source},
    'blacklists_source_id' => qr{(?:\d+|$blacklists_source(?:,$blacklists_source)*)},

    'blacklists_url'            => qr{.+},
    'blacklists_hour'           => $hours,
    'blacklists_minutes'        => $minutes,
    'blacklists_period'         => $natural,
    'blacklists_day'            => qr{(:?$dayofmonth|$weekdays)},
    'blacklists_policy'         => qr{(:?allow|deny)},              # not used from API 4
    'blacklists_type'           => qr{(:?local|remote)},            # not used from API 4
    'blacklists_unit'           => qr{(:?hours|minutes)},           # not used from API 4
    'blacklists_frequency'      => qr{(:?daily|weekly|monthly)},    # not used from API 4
    'blacklists_frequency_type' => qr{(:?period|exact)},            # not used from API 4

    # DoS
    'dos_name'        => qr/[\w]+/,
    'dos_rule'        => qr/(?:$dos_global|$dos_all|$dos_tcp)/,
    'dos_rule_farm'   => qr/(?:$dos_all|$dos_tcp)/,
    'dos_rule_global' => $dos_global,
    'dos_rule_all'    => $dos_all,
    'dos_rule_tcp'    => $dos_tcp,
    'dos_time'        => $natural,
    'dos_limit_conns' => $natural,
    'dos_limit'       => $natural,
    'dos_limit_burst' => $natural,
    'dos_port'        => $port_range,
    'dos_hits'        => $natural,

    # RBL
    'rbl_name'          => qr/[\w]+/,
    'rbl_domain'        => qr/[\w\.\-]+/,
    'rbl_log_level'     => qr/[0-7]/,
    'rbl_only_logging'  => $boolean,
    'rbl_cache_size'    => $natural,
    'rbl_cache_time'    => $natural,
    'rbl_queue_size'    => $natural,
    'rbl_thread_max'    => $natural,
    'rbl_local_traffic' => $boolean,
    'rbl_actions'       => $run_actions,    # not used from API 4

    # WAF
    'http_code'      => qr/[0-9]{3}/,
    'waf_set_name'   => qr/[\.\w-]+/,
    'waf_rule_id'    => qr/\d+/,
    'waf_chain_id'   => qr/\d+/,
    'waf_severity'   => qr/[0-9]/,
    'waf_phase'      => qr/(?:[1-5]|request|response|logging)/,
    'waf_log'        => qr/(?:$boolean|)/,
    'waf_audit_log'  => qr/(?:$boolean|)/,
    'waf_skip'       => qr/[0-9]+/,
    'waf_skip_after' => qr/\w+/,
    'waf_set_status' => qr/(?:$boolean|detection)/,
    'waf_file'       => qr/(?:[\s+\w-]+)/,

    # certificates filenames
    'certificate_name'    => $cert_name,
    'certificate'         => qr/$cert_name\.(?:pem|csr)/,
    'cert_pem'            => qr/$cert_name\.pem/,
    'cert_name'           => qr/[a-zA-Z0-9\-]+/,
    'cert_csr'            => qr/\w[\w\.\-]*\.csr/,
    'cert_dh2048'         => qr/\w[\w\.\-]*_dh2048\.pem/,
    'le_certificate_name' => $cert_name,
    'le_mail'             => $email,

    # IPS
    'IPv4_addr' => qr/$ipv4_addr/,
    'IPv4_mask' => qr/(?:$ipv4_addr|3[0-2]|[1-2][0-9]|[0-9])/,

    'IPv6_addr' => qr/$ipv6_addr/,
    'IPv6_mask' => $UNSIGNED7BITS,

    'ip_addr'       => $ipv4v6,
    'ip_mask'       => qr/(?:$ipv4_addr|$UNSIGNED7BITS)/,
    'ip_addr_range' => qr/$ipv4_addr-$ipv4_addr/,

    # farm guardian
    'fg_name'    => qr/[\w-]+/,
    'fg_type'    => qr/(?:http|https|l4xnat|gslb)/,    # not used from API 4
    'fg_enabled' => $boolean,
    'fg_log'     => $boolean,
    'fg_time'    => qr/$natural/,                      # this value can't be 0

    # RBAC
    'user_name'     => qr/[a-z0-9][-a-z0-9_.]+/,
    'rbac_password' => qr/(?=.*[0-9])(?=.*[a-zA-Z]).{8,512}/,
    'group_name'    => qr/[\w-]+/,
    'role_name'     => qr/[\w-]+/,

    # alias
    'alias_id'        => qr/(?:$ipv4v6|$interface)/,
    'alias_backend'   => qr/$ipv4v6/,
    'alias_interface' => qr/$interface/,
    'alias_name'      => qr/(?:$zone|[\w-]+)/,
    'alias_type'      => qr/(?:backend|interface)/,

    # routing
    'route_rule_id'  => qr/$natural/,
    'route_table_id' => qr/[\w\.\-]+/,
    'route_entry_id' => qr/$natural/,

    # vpn
    'vpn_name' => qr/[a-zA-Z][a-zA-Z0-9\-]*/,
    'vpn_user' => qr/[a-zA-Z][a-zA-Z0-9\-]*/,

);

sub getAPIModel ($file_name) {
    require JSON;
    require Relianoid::API;
    require Relianoid::File;

    my $api_version = &getApiVersion();
    my $dir_name    = &getGlobalConfiguration("api_model_path") . "/v${api_version}/json";
    my $content     = getFile("${dir_name}/${file_name}");

    if ($content) {
        return JSON::decode_json($content)->{params};
    }
    else {
        return $content;
    }
}

=pod

=head1 getValidFormat

Validates a data format matching a value with a regular expression.
If no value is passed as an argument the regular expression is returned.

Usage:

    # validate exact data
    if ( ! &getValidFormat( "farm_name", $input_farmname ) ) {
        print "error";
    }

    # use the regular expression as a component for another regular expression
    my $file_regex = &getValidFormat( "certificate" );
    if ( $file_path =~ /$configdir\/$file_regex/ ) { ... }

Parameters:

    format_name	- type of format
    value		- value to be validated (optional)
    new_format_re	- structure with the formats to use. (optional)

Returns:

    false	- If value failed to be validated
    true	- If value was successfuly validated
    regex	- If no value was passed to be matched

See also:

    Mainly but not exclusively used in API v3.

=cut

sub getValidFormat ($format_name, $value = undef, %new_format_re) {
    # Checks if it should use the formats passed by parameters.
    %format_re = %new_format_re if (%new_format_re);

    #~ print "getValidFormat type:$format_name value:$value\n"; # DEBUG
    if (exists $format_re{$format_name}) {
        if (defined $value) {
            #~ print "$format_re{ $format_name }\n"; # DEBUG
            if (ref($value) eq "ARRAY") {
                return !grep { !/^$format_re{ $format_name }$/ } @{$value} > 0;
            }
            else {
                return $value =~ /^$format_re{ $format_name }$/;
            }
        }
        else {
            #~ print "$format_re{ $format_name }\n"; # DEBUG
            return $format_re{$format_name};
        }
    }
    else {
        my $message = "getValidFormat: format $format_name not found.";
        &log_info($message);
        die($message);
    }
}

=pod

=head1 getValidPort

Validate if the port is valid for a type of farm.

Parameters:

    port - Port number.
    profile - Farm profile (HTTP, L4XNAT, GSLB or DATALINK). Optional.

Returns:

    Boolean - TRUE for a valid port number, FALSE otherwise.

=cut

sub getValidPort ($port, $profile = undef) {
    if ($profile =~ /^(?:HTTP|GSLB|eproxy)$/i) {
        return &getValidFormat('port', $port);
    }
    elsif ($profile =~ /^(?:L4XNAT)$/i) {
        return &getValidFormat('multiport', $port);
    }
    elsif ($profile =~ /^(?:DATALINK)$/i) {
        return !defined $port;
    }
    elsif (!defined $profile) {
        return &getValidFormat('port', $port);
    }
    else    # profile not supported
    {
        return 0;
    }
}

=pod

=head1 checkApiParams

Function to check parameters of a PUT or POST call.
It check a list of parameters, and apply it some checks:

    - Almost 1 parameter
    - All required parameters must exist
    - All required parameters are correct

Also, it checks: getValidFormat funcion, if black is allowed, intervals, aditionals regex, excepts regex and a list with the possbile values

It is possible add a error message with the correct format. 

For example: $parameter . "must have letters and digits"

Parameters:

    Json_obj - Parameters sent in a POST or PUT call
    Parameters - Hash of parameter objects

    parameter object:

    {
        parameter :

        {		# parameter is the key or parameter name
            "required" 	: "true",		# or not defined
            "non_blank" : "true",		# or not defined
            "interval" 	: "1,65535",	# it is possible define strings matchs ( non implement). For example: "ports" = "1-65535", "log_level":"1-3", ...
                                        # ",10" indicates that the value has to be less than 10 but without low limit
                                        # "10," indicates that the value has to be more than 10 but without high limit
                                        # The values of the interval has to be integer numbers
            "exceptions"	: [ "api", "webgui", "root" ],	# The parameter can't have got any of the listed values
            "values" : ["priority", "weight"],		# list of possible values for a parameter
            "length" : 32,				# it is the maximum string size for the value
            "regex"	: "/\w+,\d+/",		# regex format
            "ref"	: "array|hash",		# the expected input must be an array or hash ref. To allow ref inputs and non ref for a parameter use the word 'none'. Example:  'ref' => 'array|none'
            "valid_format"	: "farmname",		# regex stored in Validate.pm file, it checks with the function getValidFormat
            "function" : \&func,		# function of validating, the input parameter is the value of the argument. The function has to return 0 or 'false' when a error exists
            "format_msg"	: "must have letters and digits",	# used message when a value is not correct
        }
        param2 :

        {
            ...
        }
        ....
    }

Returns:

    String - Return a error message with the first error found or undef on success

=cut

sub checkApiParams ($json_obj, $param_obj, $description) {
    my $err_msg;

    ## Remove parameters do not according to the edition
    for my $p (keys %$param_obj) {
        if (
            exists $param_obj->{$p}{edition}
            && (   ($param_obj->{$p}{edition} eq 'ee' && !$eload)
                || ($param_obj->{$p}{edition} eq 'ce' && $eload))
          )
        {
            delete $param_obj->{$p};
        }
    }

    my @rec_keys = keys %{$json_obj};

    # Returns a help with the expected input parameters
    if (!@rec_keys) {
        &httpResponseHelp($param_obj, $description);
    }

    # All required parameters must exist
    my @expect_params = keys %{$param_obj};

    $err_msg = &checkParamsRequired(\@rec_keys, \@expect_params, $param_obj);
    return $err_msg if ($err_msg);

    # All sent parameters are correct
    $err_msg = &checkParamsInvalid(\@rec_keys, \@expect_params);
    return $err_msg if ($err_msg);

    # check for each parameter
    for my $param (@rec_keys) {
        my $custom_msg = "The parameter '$param' has not a valid value.";

        # Store the input value to keep the data type,
        # and to be restored at the end of the loop.
        # This is because numeric type are converted to string
        # when used in a string context, like in a regex.
        my $current_param_value = $json_obj->{$param};

        if (exists $param_obj->{$param}{format_msg}) {
            $custom_msg = "$param $param_obj->{$param}{format_msg}";
        }

        if (
               not defined $json_obj->{$param}
            or not length $json_obj->{$param}
            or (    ref $json_obj->{$param}
                and ref $json_obj->{$param} eq 'ARRAY'
                and @{ $json_obj->{$param} } == 0)
          )
        {
            # if blank value is allowed
            if (    $param_obj->{$param}{non_blank}
                and $param_obj->{$param}{non_blank} eq 'true')
            {
                return "The parameter '$param' can't be in blank.";
            }

            next;
        }

        # the input has to be a ref
        my $r = ref $json_obj->{$param} // '';
        if (exists $param_obj->{$param}{ref}) {
            if ($r eq '') {
                if ('none' !~ /$param_obj->{ $param }{ 'ref' }/) {
                    return "The parameter '$param' expects a '$param_obj->{ $param }{ref}' reference as input";
                }
            }
            elsif ($r !~ /^$param_obj->{ $param }{ 'ref' }$/i) {
                return "The parameter '$param' expects a '$param_obj->{ $param }{ref}' reference as input";
            }
        }
        elsif ($r eq 'ARRAY' or $r eq 'HASH') {
            return "The parameter '$param' does not expect a $r as input";
        }

        if ((exists $param_obj->{$param}{values})) {
            if ($r eq 'ARRAY') {
                for my $value (@{ $json_obj->{$param} }) {
                    if (!grep { $value eq $_ } @{ $param_obj->{$param}{values} }) {
                        return
                          "The parameter '$param' expects some of the following values: '"
                          . join("', '", @{ $param_obj->{$param}{values} }) . "'";
                    }
                }
            }
            else {
                if (!grep { $json_obj->{$param} eq $_ } @{ $param_obj->{$param}{values} }) {
                    return
                      "The parameter '$param' expects one of the following values: '"
                      . join("', '", @{ $param_obj->{$param}{values} }) . "'";
                }
            }
        }

        # getValidFormat funcion:
        if (    (exists $param_obj->{$param}{valid_format})
            and (!&getValidFormat($param_obj->{$param}{valid_format}, $json_obj->{$param})))
        {
            return $custom_msg;
        }

        # length
        if (exists $param_obj->{$param}{length}) {
            my $data_length = length($json_obj->{$param});
            if ($data_length > $param_obj->{$param}{length}) {
                return "The maximum length for '$param' is '$param_obj->{ $param }{ 'length' }'";
            }
        }

        # intervals
        if (exists $param_obj->{$param}{interval}) {
            $err_msg =
              &checkParamsInterval($param_obj->{$param}{interval}, $param, $json_obj->{$param});
            return $err_msg if $err_msg;
        }

        # exceptions
        if (    (exists $param_obj->{$param}{exceptions})
            and (grep { /^$json_obj->{ $param }$/ } @{ $param_obj->{$param}{exceptions} }))
        {
            return "The value '$json_obj->{ $param }' is a reserved word of the parameter '$param'.";
        }

        # regex
        if ((exists $param_obj->{$param}{regex})) {
            if (defined $json_obj->{$param}) {
                # If ARRAY, evaluate all in values.
                if (ref($json_obj->{$param}) eq "ARRAY") {
                    for my $value (@{ $json_obj->{$param} }) {
                        return "The value '$value' is not valid for the parameter '$param'."
                          if (grep { !/^$param_obj->{ $param }{ 'regex' }$/ } $value);
                    }
                }
                else {
                    return "The value '$json_obj->{ $param }' is not valid for the parameter '$param'."
                      if ($json_obj->{$param} !~ /^$param_obj->{ $param }{ 'regex' }$/);
                }
            }
        }

        # negated_regex
        if ((exists $param_obj->{$param}{negated_regex})) {
            if (defined $json_obj->{$param}) {
                # If ARRAY, evaluate all in values.
                if (ref($json_obj->{$param}) eq "ARRAY") {
                    for my $value (@{ $json_obj->{$param} }) {
                        return "The value '$value' is not valid for the parameter '$param'."
                          if (grep { /^$param_obj->{ $param }{ 'regex' }$/ } $value);
                    }
                }
                else {
                    return "The value '$json_obj->{ $param }' is not valid for the parameter '$param'."
                      if ($json_obj->{$param} =~ /$param_obj->{ $param }{ 'negated_regex' }/);
                }
            }
        }

        # is_regex
        if (defined $param_obj->{$param}{is_regex}
            and $param_obj->{$param}{is_regex} eq 'true')
        {
            if (defined $json_obj->{$param}) {
                my $regex = eval { qr/$json_obj->{ $param }/ };
                return "The value of field $param is an invalid regex" if $@;
            }
        }

        if (exists $param_obj->{$param}{function}) {
            my $result =
              &{ $param_obj->{$param}{function} }($json_obj->{$param});

            return $custom_msg if (!$result || $result eq 'false');
        }

        # Restore the data type that was received as input
        # from the beginning of the loop
        $json_obj->{$param} = $current_param_value;
    }

    return;
}

=pod

=head1 checkParamsInterval

Check parameters when there are required params. The value has to be a integer number

Parameters:

    Interval - String with the expected interval. The low and high limits must be splitted with a comma character ','
    Parameter - Parameter name
    Value - Parameter value

Returns:

    String - It returns a string with the error message or undef on success

=cut

sub checkParamsInterval ($interval, $param, $value) {
    my $err_msg;

    if ($interval =~ /,/) {
        my ($low_limit, $high_limit) = split(',', $interval);

        my $msg = "";
        if (defined $low_limit and defined $high_limit and length $high_limit) {
            $msg = "'$param' has to be an integer number between '$low_limit' and '$high_limit'";
        }
        elsif (defined $low_limit) {
            $msg = "'$param' has to be an integer number greater than or equal to '$low_limit'";
        }
        elsif (defined $high_limit) {
            $msg = "'$param' has to be an integer number lower than or equal to '$high_limit'";
        }

        $err_msg = $msg
          if ( ($value !~ /^\d*$/)
            || ($high_limit and $value > $high_limit)
            || ($low_limit  and $value < $low_limit));
    }
    else {
        die "Expected a interval string, got: $interval";
    }

    return $err_msg;
}

=pod

=head1 checkParamsInvalid

Check if some of the sent parameters is invalid for the current API call

Parameters:

    Receive Parameters - It is the list of sent parameters in the API call
    Expected parameters - It is the list of expected parameters for a API call

Returns:

    String - It returns a string with the error message or undef on success

=cut

sub checkParamsInvalid ($rec_keys, $expect_params) {
    my $err_msg;
    my @non_valid;

    for my $param (@{$rec_keys}) {
        push @non_valid, "'$param'" if (!grep { /^$param$/ } @{$expect_params});
    }

    if (@non_valid) {
        $err_msg = &putArrayAsText(\@non_valid,
                "The parameter<sp>s</sp> <pl> <bs>is<|>are</bp> not correct for this call. Please, try with: '"
              . join("', '", @{$expect_params})
              . "'");
    }

    return $err_msg;
}

=pod

=head1 checkParamsRequired

Check if all the mandatory parameters has been sent in the current API call

Parameters:

    Receive Parameters - It is the list of sent parameters in the API call
    Expected parameters - It is the list of expected parameters for a API call
    Model - It is the struct with all allowed parameters and its possible values and options

Returns:

    String - It returns a string with the error message or undef on success

=cut

sub checkParamsRequired ($rec_keys, $expect_params, $param_obj) {
    my @miss_params;
    my $err_msg;

    for my $param (@{$expect_params}) {
        next if (!exists $param_obj->{$param}{required});

        if ($param_obj->{$param}{required} eq 'true') {
            push @miss_params, "'$param'"
              if (!grep { /^$param$/ } @{$rec_keys});
        }
    }

    if (@miss_params) {
        $err_msg = &putArrayAsText(\@miss_params, "The required parameter<sp>s</sp> <pl> <bs>is<|>are</bp> missing.");
    }
    return $err_msg;
}

=pod

=head1 httpResponseHelp

This function sends a response to client with the expected input parameters model.

This function returns a 400 HTTP error code

Parameters:

    Model - It is the struct with all allowed parameters and its possible values and options
    Description - Descriptive message about the API call

Returns:

    None

=cut

sub httpResponseHelp ($param_obj, $desc) {
    my $resp_param = [];

    # build the output
    for my $p (keys %{$param_obj}) {
        my $param->{name} = $p;
        if (exists $param_obj->{$p}{valid_format}) {
            $param->{format} = $param_obj->{$p}{valid_format};
        }
        if (exists $param_obj->{$p}{values}) {
            $param->{possible_values} = $param_obj->{$p}{values};
        }
        if (exists $param_obj->{$p}{interval}) {
            my ($ll, $hl) = split(',', $param_obj->{$p}{interval});
            $ll                = '-' if (!defined $ll);
            $hl                = '-' if (!defined $hl);
            $param->{interval} = "Expects a value between '$ll' and '$hl'.";
        }
        if (exists $param_obj->{$p}{non_blank}
            and $param_obj->{$p}{non_blank} eq 'true')
        {
            push @{ $param->{options} }, "non_blank";
        }
        if (exists $param_obj->{$p}{required}
            and $param_obj->{$p}{required} eq 'true')
        {
            push @{ $param->{options} }, "required";
        }
        if (exists $param_obj->{$p}{format_msg}) {
            $param->{description} = $param_obj->{$p}{format_msg};
        }
        if (exists $param_obj->{$p}{ref}) {
            $param->{ref} = $param_obj->{$p}{ref};
        }

        push @{$resp_param}, $param;
    }

    my $msg  = "No parameter has been sent. Please, try with:";
    my $body = {
        message => $msg,
        params  => $resp_param,
    };
    $body->{description} = $desc if (defined $desc);

    return &httpResponse({ code => 400, body => $body });
}

=pod

=head1 putArrayAsText

This funcion receives a text string and a list of values and it generates a
text with the values.

It uses a delimited to modify the text string passed as argument:

    put list - <pl>
    select plural - <sp>text</sp>
    select single - <ss>text</ss>
    select between single or plural - <bs>text_single<|>text_plural</bp>

Examples:

    putArrayAsText ( ["password", "user", "key"], "The possible value<sp>s</sp> <sp>are</sp>: <pl>")
        return: ""
    putArrayAsText ( ["", "", ""], "The values are")
        return: ""

Parameters:

    Parameters - List of parameters to add to the string message
    Text string - Text

Returns:

    String - Return a message adjust to the number of parameters passed

=cut

sub putArrayAsText ($array_ref, $msg) {
    my @array = @{$array_ref};

    # one element
    if (scalar @array == 1) {
        # save single tags
        $msg =~ s/<\/?ss>//g;

        # remove plural text
        #~ $msg =~ s/<sp>.+<\/?sp>// while ( $msg =~ /<sp>/ );
        $msg =~ s/<sp>.+<\/?sp>//g;

        # select between plural and single text
        #~ $msg =~ s/<bs>(.+)<|>.+<\/bp>/$1/ while ( $msg =~ /<|>/ );
        $msg =~ s/<bs>(.+)<\|>.+<\/bp>/$1/g;

        # put list
        $msg =~ s/<pl>/$array[0]/;
    }

    # more than one element
    else {
        # save plual tags
        $msg =~ s/<\/?sp>//g;

        # remove single text
        #~ $msg =~ s/<ss>.+<\/?ss>// while ( $msg =~ /<ss>/ );
        $msg =~ s/<ss>.+<\/?ss>//g;

        # select between plural and single text
        #~ $msg =~ s/<bs>.+<|>(.+)<\/bp>/$1/ while ( $msg =~ /<|>/ );
        $msg =~ s/<bs>.+<\|>(.+)<\/bp>/$1/g;

        my $lastItem = pop @array;
        my $list     = join(", ", @array);
        $list .= " and $lastItem";

        # put list
        $msg =~ s/<pl>/$list/;
    }

    return $msg;
}

1;

=== ./background/webmin-plugins/firewall/acl_security.pl ===


do 'firewall-lib.pl';
@acl_features = ("newchain", "delchain", "policy", "apply", "unapply", "bootup", "setup", "cluster");

# acl_security_form(&options)
# Output HTML for editing security options for the acl module
sub acl_security_form
{
my ($o) = @_;

# Show editable tables
my $tables = "";
foreach $t (@known_tables) {
	$tables .= &ui_checkbox($t, 1, $text{'index_table_'.$t},
				$o->{$t})."<br>\n";
	}
print &ui_table_row($text{'acl_tables'}, $tables, 3);

# Show allowed target types
print &ui_table_row($text{'acl_jumps'},
	&ui_opt_textbox("jumps", $o->{'jumps'}, 40, $text{'acl_jall'}), 3);

# Show bootup/apply options
foreach my $f (@acl_features) {
	print &ui_table_row($text{'acl_'.$f},
		&ui_yesno_radio($f, $o->{$f}));
	}
}

# acl_security_save(&options)
# Parse the form for security options for the acl module
sub acl_security_save
{
my ($o) = @_;

foreach my $t (@known_tables) {
	$o->{$t} = $in{$t};
	}
foreach my $f (@acl_features) {
	$o->{$f} = $in{$f};
	}
$o->{'jumps'} = $in{'jumps_def'} ? undef : $in{'jumps'};
}


=== ./background/webmin-plugins/firewall/backup_config.pl ===


do 'firewall-lib.pl';

# backup_config_files()
# Returns files and directories that can be backed up
sub backup_config_files
{
return ( $iptables_save_file );
}

# pre_backup(&files)
# Called before the files are actually read
sub pre_backup
{
return undef;
}

# post_backup(&files)
# Called after the files are actually read
sub post_backup
{
return undef;
}

# pre_restore(&files)
# Called before the files are restored from a backup
sub pre_restore
{
&run_before_command();
return undef;
}

# post_restore(&files)
# Called after the files are restored from a backup
sub post_restore
{
&run_after_command();
return &apply_configuration();
}

1;


=== ./background/webmin-plugins/firewall/cgi_args.pl ===


do 'firewall-lib.pl';

sub cgi_args
{
my ($cgi) = @_;
if ($cgi eq 'edit_rule.cgi') {
	my @tables = grep { &can_edit_table($_->{'name'}) }
			  &get_iptables_save();
	if (@tables) {
		my @rules = @{$tables[0]->{'rules'}};
		if (@rules) {
			return 'table='.&urlize($tables[0]->{'name'}).
			       '&idx='.$rules[0]->{'index'};
			}
		return 'table='.&urlize($tables[0]->{'name'}).'&new=1';
		}
	return 'none';
	}
return undef;
}

=== ./background/webmin-plugins/firewall/coherent-linux-lib.pl ===

# coherant-linux-lib.pl
# Deal with redhat's /etc/sysconfig/iptables save file and startup script

&foreign_require("init", "init-lib.pl");
$init_script = "$init::config{'init_dir'}/ip${ipvx}tables";

# check_iptables()
# Returns an error message if something is wrong with iptables on this system
sub check_iptables
{
if (!-r $init_script) {
	return &text('coherent_escript', "<tt>$init_script</tt>");
	}
if (!$config{'done_check_iptables'}) {
	local $out = `$init_script status 2>&1`;
	if ($out !~ /table:|INPUT|FORWARD|OUTPUT/) {
		return &text('coherent_eoutput',
			     "<tt>$init_script status</tt>");
		}
	$config{'done_check_iptables'} = 1;
	&save_module_config();
	}
return undef;
}

$ip6tables_save_file = "/etc/sysconfig/ip6tables";
$iptables_save_file = "/etc/sysconfig/iptables";

# apply_iptables()
# Applies the current iptables configuration from the save file
sub apply_iptables
{
local $out = &backquote_logged("cd / ; $init_script restart 2>&1");
$out =~ s/\033[^m]+m//g;
return $? || $out =~ /FAILED/ ? "<pre>$out</pre>" : undef;
}

# unapply_iptables()
# Writes the current iptables configuration to the save file
sub unapply_iptables
{
$out = &backquote_logged("cd / ; $init_script save 2>&1 </dev/null");
$out =~ s/\033[^m]+m//g;
return $? || $out =~ /FAILED/ ? "<pre>$out</pre>" : undef;
}

# started_at_boot()
sub started_at_boot
{
return &init::action_status("ip${ipvx}tables") == 2;
}

sub enable_at_boot
{
&init::enable_at_boot("ip${ipvx}tables");	 # Assumes init script exists
}

sub disable_at_boot
{
&init::disable_at_boot("ip${ipvx}tables");
}

1;


=== ./background/webmin-plugins/firewall/config.info.cs ===

line0=Nastavitelné volby,11
view_condition=Zobrazit podmínku v seznamu pravidel?,1,1-Ano,0-Ne
view_comment=Zobrazit komentář v seznamu pravidel?,1,1-Ano,0-Ne
comment_mod=Uchovávat komentáře jako,1,0-# komentáře v uloženém souboru,1-&#45;&#45;vylby komnetáře
cluster_mode=Aktualizovat sborník serverů,1.0-Kdykoliv při změně,1-Pouze při uplatnění konfigurace
before_cmd=Příkaz&#44; který má být spuštěn před změnou pravidel,3,Nic
after_cmd=Příkaz&#44; který má být spuštěn po změně pravidel,3,Nic
before_apply_cmd=Příkaz&#44; který má být spuštěn před uplatněním konfigurace,3,Nic
after_apply_cmd=Příkaz&#44; který má být spuštěn po uplatnění konfigurace,3,Nic
save_file=File to save/edit <tt>IPv4</tt> rules,3,Use operating system or Webmin default
direct=Přímo editovat pravidla firewallu namísto ukládání souboru?,1,1-Ano,0-Ne
save_file6=File to save/edit <tt>IPv6</tt> rules,3,Use operating system or Webmin default

=== ./background/webmin-plugins/firewall/config.info.pl ===

line0=Opcje konfiguracji,11
view_condition=Wyświetlać stan na liście reguł?,1,1-Tak,0-Nie
view_comment=Wyświetlać komentarz na liście reguł?,1,1-Tak,0-Nie
comment_mod=Zapisuj komentarze jako,1,0-# zapis w pliku komentarzy,1-&#45;&#45;opcja komentarzy
cluster_mode=Aktualizuj klaster serwerów,1,0-Zawsze&#44; gdy wprowadzono zmianę,1-Po zastosowaniu konfiguracji
before_cmd=Polecenie do uruchomienia przed zmienieniem reguł,3,Brak
after_cmd=Polecenie do uruchomienia po zmienieniu reguł,3,Brak
before_apply_cmd=Polecenie do uruchomienia przed zastosowaniem konfiguracji,3,Brak
after_apply_cmd=Polecenie do uruchomienia po zastosowaniu konfiguracji,3,Brak
force_init=Zawsze uruchamiaj firewall ze skryptem inita Debiana,1,1-Tak,0-Nie
save_file=File to save/edit <tt>IPv4</tt> rules,3,Use operating system or Webmin default
direct=Bezpośrednio edytuj reguły firewalla zamiast zapisywać do pliku?,1,1-Tak,0-Nie
save_file6=File to save/edit <tt>IPv6</tt> rules,3,Use operating system or Webmin default

=== ./background/webmin-plugins/firewall/debian-linux-lib.pl ===

# debians-linux-lib.pl
# Deal with debian's iptables save file and startup script

&foreign_require("init");

if ($gconfig{'os_version'} >= 3.1 &&
    !-r "/etc/init.d/ip${ipvx}tables" &&
    !-r "/etc/init.d/webmin-ip${ipvx}tables" &&
    !$config{'force_init'} &&
    !-d "/etc/netplan" &&
    !-d "/etc/iptables") {
	# In newer Debians, IPtable is started by the network init script, 
	# unless netplan is in use
	$has_new_debian_iptables = 1;
	$ip6tables_save_file = "/etc/ip6tables.up.rules";
	$iptables_save_file = "/etc/iptables.up.rules";
	$debian_init_script = "ip${ipvx}tables";
	}
elsif (-d "/etc/iptables") {
	# Ubuntu 20 uses files in /etc/iptables if iptables-persistent is
	# installed. However, on Debian 10 there is no init script!
	$ip6tables_save_file = "/etc/iptables/rules.v6";
	$iptables_save_file = "/etc/iptables/rules.v4";
	$debian_init_script = $ipvx == 4 ? "iptables" : "ip6tables";
	}
else {
	# Older Debians use an init script
	$has_debian_iptables = -r "/etc/init.d/iptables";
	$debian_ip6tables_dir = "/var/lib/ip6tables";
	$debian_iptables_dir = "/var/lib/iptables";
	if ($has_debian_iptables) {
		$debian_init_script = "iptables";
		mkdir($debian_ip6tables_dir, 0755) if (!-d $debian_ip6tables_dir);
		mkdir($debian_iptables_dir, 0755) if (!-d $debian_iptables_dir);
		$iptables_save_file = "$debian_iptables_dir/active";
		$ip6tables_save_file = "$debian_ip6tables_dir/active";
		}
	}

if (!&init::action_status($debian_init_script)) {
	# Expected script doesn't exist!
	$debian_init_script = undef;
	}

# apply_iptables()
# Applies the current iptables configuration from the save file
sub apply_iptables
{
if ($debian_init_script && &init::action_status($debian_init_script)) {
	my ($ok, $err) = &init::restart_action($debian_init_script);
	return $ok ? undef : &html_escape($err);
	}
else {
	return &iptables_restore();
	}
}

# unapply_iptables()
# Writes the current iptables configuration to the save file
sub unapply_iptables
{
if ($has_debian_iptables) {
	# On some debian versions the init script can do this
	$out = &backquote_logged("cd / ; /etc/init.d/ip${ipvx}tables save active 2>&1 </dev/null");
	return $? ? "<pre>$out</pre>" : undef;
	}
else {
	return &iptables_save();
	}
}

# started_at_boot()
sub started_at_boot
{
if ($debian_init_script) {
	# Check Debian init script
	return &init::action_status($debian_init_script) == 2;
	}
elsif ($has_new_debian_iptables) {
	# Check network interface config
	local $pri = &get_primary_network_interface();
	local ($debpri) = grep { $_->[0] eq $pri->{'fullname'} }
			       &net::get_interface_defs();
	foreach my $o (@{$debpri->[3]}) {
		if (($o->[0] eq "pre-up" || $o->[0] eq "post-up") &&
		    $o->[1] =~ /\S*ip${ipvx}tables-restore\s+<\s+(\S+)/ &&
		    $1 eq $ipvx_save) {
			return 1;
			}
		}
	}
else {
	# Check Webmin init script
	return &init::action_status("webmin-ip${ipvx}tables") == 2;
	}
}

sub enable_at_boot
{
if ($debian_init_script) {
	# Enable the init script (assumes it exists)
	&init::action_status($debian_init_script) > 0 ||
		&error("Bootup action $debian_init_script does not exist");
	&init::enable_at_boot($debian_init_script);
	}
elsif ($has_new_debian_iptables) {
	# Add to network interface config
	local $pri = &get_primary_network_interface();
	local ($debpri) = grep { $_->[0] eq $pri->{'fullname'} }
			       &net::get_interface_defs();
	if ($debpri && !&started_at_boot()) {
		my ($name, $addrfam, $method, $options, $file,$line) = @$debpri;
		push(@$options,
		     [ "post-up", "ip${ipvx}tables-restore < $ipvx_save" ]);
		&net::modify_interface_def($name, $addrfam, $method, $options,
					   0, $file);
		}
	}
else {
	&create_webmin_init();
	}
}

sub disable_at_boot
{
if ($debian_init_script) {
	# Turn off the init script
	&init::disable_at_boot($debian_init_script);
	}
elsif ($has_new_debian_iptables) {
	# Remove from network interface config
	local $pri = &get_primary_network_interface();
	local ($debpri) = grep { $_->[0] eq $pri->{'fullname'} }
			       &net::get_interface_defs();
	@{$debpri->[3]} = grep {
			($_->[0] ne "pre-up" && $_->[0] ne "post-up") ||
			 $_->[1] !~ /^\S*ip${ipvx}tables/ } @{$debpri->[3]};
	&net::modify_interface_def(@$debpri);
	}
else {
	&init::disable_at_boot("webmin-ip${ipvx}tables");
	}
}

sub get_primary_network_interface
{
&foreign_require("net");
local @boot = sort { $a->{'fullname'} cmp $b->{'fullname'} }
		   &net::boot_interfaces();
local $pri;
if ($config{'iface'}) {
	($pri) = grep { $_->{'fullname'} eq $config{'iface'} } @boot;
	}
local ($eth) = grep { $_->{'fullname'} =~ /^eth\d+$/ } @boot;
local ($ppp) = grep { $_->{'fullname'} =~ /^ppp\d+$/ } @boot;
local ($venetn) = grep { $_->{'fullname'} =~ /^venet\d+:\d+$/ } @boot;
local ($venet) = grep { $_->{'fullname'} =~ /^venet\d+$/ } @boot;
return $pri || $eth || $ppp || $venetn || $venet || $boot[0];
}

1;


=== ./background/webmin-plugins/firewall/firewall-lib.pl ===

# firewall-lib.pl
# Unified functions for firewall4-lib and firewall6-lib 
# has to be included from every perl and cgi script
# cgi scripts has also to include firewall4/6-lib based on result of get_ipvx_version() 

BEGIN { push(@INC, ".."); };
use WebminCore;
&init_config();

$config{'perpage'} ||= 50;	# a value of 0 can cause problems

# provide default values if only firewall-lib is included, e.g. foreign_require(firewall, firewall-lib.pl) calls
set_ipvx_version(get_ipvx_version());

# set_ipvx_version(version)
# version can be ipv6 or ipv4,
sub set_ipvx_version
{
$ipvx_save=$iptables_save_file;
$ipvx_lib='firewall4-lib.pl';
$ipv4_link='../firewall/';
$ipv6_link='../firewall6/';
$ipvx_icmp="";
$ipvx_arg="inet4";

if ($_[0] =~ /6$/i) {
	$ipvx='6';
	$ipvx_save=$ip6tables_save_file;
	$ipvx_lib='firewall6-lib.pl';
	$ipvx_icmp="v6";
        $ipvx_arg="inet6";
	}
}

# get_ipvx_version
# get iptables version used from environment
# if script runs in firewall6 or version=inet6, 6 is returned, else 4
sub get_ipvx_version
{
return $in{'version'} =~ /6$/ || $module_name =~ /6$/ ? 6 : 4;
}


# get_iptables_save([file|"direct"])
# Parse the iptables save file into a list of tables 
# format seems to be:
#  *table
#  :chain defaultpolicy
#  -A chain options
#  -N chain
#  COMMIT
sub get_iptables_save
{
local ($file) = @_;
local (@rv, $table, %got);
local $lnum = 0;

local $direct = "ip${ipvx}tables-save 2>/dev/null |";
if (!$file) {
	# Use default file
	$file = $config{"direct${ipvx}"} ? $direct : "<".$ipvx_save;
	}
elsif ($file eq "direct") {
	# Read active rules
	$file = $direct;
	}
open(FILE, $file);
local $cmt;
LINE:
while(<FILE>) {
        local $read_comment;
        s/\r|\n//g;
        # regex to filter out chains not managed by firewall, i.e. fail2ban
        if ($config{"direct${ipvx}"} && $config{'filter_chain'}) {
             foreach $filter (split(',', $config{'filter_chain'})) {
                 # NOTE: keep ":chain ..." as reference to avoid error when rebuild active config
                 # -A|-I chain ... -j chain -> skip line if machtes filter_chain
                 if (/^.?-(A|I)\s+(\S+).*\s+-j\s+(.*)/) {
                         next LINE if($2 =~ /^$filter$/);
                    }
                }
            }
	if (s/#\s*(.*)$//) {
		$cmt .= " " if ($cmt);
		$cmt .= $1;
		$read_comment=1;
		}
	if (/^\*(\S+)/) {
		# Start of a new table
		$got{$1}++;
		push(@rv, $table = { 'line' => $lnum,
				     'eline' => $lnum,
				     'name' => $1,
				     'rules' => [ ],
				     'defaults' => { } });
		}
	elsif (/^:(\S+)\s+(\S+)/) {
		# Default policy definition
		$table->{'defaults'}->{$1} = $2;
		}
	elsif (/^(\[[^\]]*\]\s+)?-N\s+(\S+)(.*)/) {
		# New chain definition
		$table->{'defaults'}->{$2} = '-';
		}
	elsif (/^(\[[^\]]*\]\s+)?-(A|I)\s+(\S+)(.*)/) {
		# Rule definition
		local $rule = { 'line' => $lnum,
				'eline' => $lnum,
				'index' => scalar(@{$table->{'rules'}}),
				'cmt' => $cmt,
				'chain' => $3,
				'args' => $4 };
		if ($2 eq "I") {
			unshift(@{$table->{'rules'}}, $rule);
			}
		else {
			push(@{$table->{'rules'}}, $rule);
			}

		# Parse arguments
		foreach $a (@known_args) {
			local @vl;
			while($rule->{'args'} =~
			       s/\s+(!?)\s*($a)\s+(!?)\s*("[^"]*")(\s+|$)/ / ||
			      $rule->{'args'} =~
                               s/\s+(!?)\s*($a)\s+(!?)\s*('[^']*')(\s+|$)/ / ||
			      $rule->{'args'} =~
			       s/\s+(!?)\s*($a)\s+(!?)\s*(([^ \-!]\S*(\s+|$))+)/ / ||
			      $rule->{'args'} =~
			       s/\s+(!?)\s*($a)()(\s+|$)/ /) {
				push(@vl, [ $1 || $3, &split_quoted_string($4) ]);
				}
			local ($aa = $a); $aa =~ s/^-+//;
			if ($a eq '-m') {
				$rule->{$aa} = \@vl if (@vl);
				}
			else {
				$rule->{$aa} = $vl[0];
				}
			}
		}
	elsif (/^COMMIT/) {
		# Marks end of a table
		$table->{'eline'} = $lnum;
		}
	elsif (/\S/) {
		&error(&text('eiptables2', "<tt>$_</tt>", $lnum+1));
		}
	$lnum++;
	if (! defined($read_comment)) { $cmt=undef; }
	}
close(FILE);
@rv = sort { $a->{'name'} cmp $b->{'name'} } @rv;
local $i;
map { $_->{'index'} = $i++ } @rv;
return @rv;
}

# save_table(&table)
# Updates an existing IPtable in the save file
sub save_table
{
local $lref;
if ($config{"direct${ipvx}"}) {
	# Read in the current iptables-save output
	$lref = &read_file_lines("ip${ipvx}tables-save 2>/dev/null |", 1);
	}
else {
	# Updating the save file
	$lref = &read_file_lines($ipvx_save);
	}
local @lines = ( "*$_[0]->{'name'}" );
local ($d, $r);
foreach $d (keys %{$_[0]->{'defaults'}}) {
	push(@lines, ":$d $_[0]->{'defaults'}->{$d} [0:0]");
	}
foreach $r (@{$_[0]->{'rules'}}) {
	local $line = "";
	$line = "# $r->{'cmt'}\n" if ($r->{'cmt'});
	$line .= &make_rule_command($r);
	push(@lines, $line);
	}
push(@lines, "COMMIT");
if (defined($_[0]->{'line'})) {
	# Update in file
	splice(@$lref, $_[0]->{'line'}, $_[0]->{'eline'} - $_[0]->{'line'} + 1,
	       @lines);
	}
else {
	# Append new table to file
	push(@$lref, "# Generated by webmin", @lines, "# Completed");
	}
if ($config{"direct${ipvx}"}) {
	# Pass new lines to iptables-restore
	open(SAVE, "| ip${ipvx}tables-restore");
	print SAVE map { $_."\n" } @$lref;
	close(SAVE);
	}
else {
	# Just save the file
	&flush_file_lines();
	}
}

# make_rule_command(&rule)
# Returns the flags needed to create a rule
sub make_rule_command
{
my ($r) = @_;
my $line = "-A $r->{'chain'}";
foreach my $a (@known_args) {
	my $aa = $a;
	$aa =~ s/^-+//;
	if ($r->{$aa}) {
		my @al = ref($r->{$aa}->[0]) ?  @{$r->{$aa}} : ( $r->{$aa} );
		foreach my $ag (@al) {
			my $n = shift(@$ag);
			my @w = ( $n ? ( $n ) : (), $a, @$ag );
			@w = map { $_ =~ /'/ ? "\"$_\"" :
				   $_ =~ /"/ ? "'".$_."'" :
				   $_ =~ /\s/ ? "\"$_\"" : $_ } @w;
			$line .= " ".join(" ", @w);
			}
		}
	}
$line .= " $r->{'args'}" if ($r->{'args'} =~ /\S/);
return $line;
}

# get_ipsets_active()
# return a list of active ipsets
sub get_ipsets_active
{
my (@rv, $name, $set);
open(FILE, "ipset list -t 2>/dev/null |");
while(<FILE>) {
	# remove newlines, get arg and value
        s/\r|\n//g;
	my ($n, $v) = split(/: /, $_);
	$n =~ s/^(\S+).*/$1/;
	if ($n eq "Name") {
		$set = { };
		push(@rv, $set);
		}
	$set->{$n} = $v;
	}
return @rv;
}


# describe_rule(&rule)
# Returns a human-readable description of some rule conditions
sub describe_rule
{
my ($rule) = @_;
my (@c, $d);
foreach $d ('p', 's', 'd', 'i', 'o', 'f', 'dport',
	    'sport', 'tcp-flags', 'tcp-option',
	    'icmp-type', 'icmpv6-type', 'mac-source', 'limit', 'limit-burst',
	    'ports', 'uid-owner', 'gid-owner',
	    'pid-owner', 'sid-owner', 'ctstate', 'state', 'tos',
	    'dports', 'sports', 'physdev-in', 'physdev-out', 'match-set',
	    'args') {
	if ($rule->{$d}) {
		# get name and values
		my ($n, @v) = @{$rule->{$d}};
		# with additional args
		if ($d eq 'args') {
			# get args
			@v = grep {/\S/} split(/ / , $rule->{$d});
			# first arg is name, next are values
			$n=shift(@v);
			# translate src and dest parameter for ipset
			push(@v, &text("desc_".pop(@v)))
				if ($n eq "--match-set");
			} 
		# uppercase for p
		@v = map { uc($_) } @v if ($d eq 'p');
		# merge all in one for s and d
		@v = map { join(", ", split(/,/, $_)) } @v
			if ($d eq 's' || $d eq 'd' );
		# compose desc_$n$d to get myized message, provide values
		# as $1, ..., $n
		if ($d eq 'match-set') {
			$v[1] = $text{'desc_'.$d.'_'.$v[1]} || $v[1];
			}
		my $txt = &text("desc_$d$n", map { "<b>$_</b>" } @v);
		push(@c, $txt) if ($txt);
		}
	}
my $rv;
if (@c) {
	$rv = &text('desc_conds', join(" $text{'desc_and'} ", @c));
	}
else {
	$rv = $text{'desc_always'};
	}
return $rv;
}

# create_firewall_init()
# Do whatever is needed to have the firewall started at boot time
sub create_firewall_init
{
if (defined(&enable_at_boot)) {
	# Use distro's function
	&enable_at_boot();
	}
else {
	# May need to create init script
	&create_webmin_init();
	}
}

# create_webmin_init()
# Create (if necessary) the Webmin iptables init script
sub create_webmin_init
{
local $res = &iptables_restore_command();
local $ipt = &has_command("ip${ipvx}tables");
local $out = &backquote_command("$res -h 2>&1 </dev/null");
if ($out =~ /\s+-w\s+/) {
	# Supports the wait flag, in case two instances are run at once
	$res .= " -w";
	$ipt .= " -w";
	}
local $start = "$res <$ipvx_save";
local $stop = "$ipt -t filter -F\n".
	      "$ipt -t nat -F\n".
	      "$ipt -t mangle -F\n".
	      "$ipt -t filter -P INPUT ACCEPT\n".
	      "$ipt -t filter -P OUTPUT ACCEPT\n".
	      "$ipt -t filter -P FORWARD ACCEPT\n".
	      "$ipt -t nat -P PREROUTING ACCEPT\n".
	      "$ipt -t nat -P POSTROUTING ACCEPT\n".
	      "$ipt -t nat -P OUTPUT ACCEPT\n".
	      "$ipt -t mangle -P PREROUTING ACCEPT\n".
	      "$ipt -t mangle -P OUTPUT ACCEPT";
&foreign_require("init", "init-lib.pl");
&init::enable_at_boot("webmin-ip${ipvx}tables",
		      "Load ip${ipvx}tables save file",
		      $start, $stop, undef, { 'exit' => 1 });
}

# interface_choice(name, value)
sub interface_choice
{
local ($name, $value) = @_;
local @ifaces;
if (&foreign_check("net")) {
	&foreign_require("net", "net-lib.pl");
	return &net::interface_choice($name, $value, undef, 0, 1);
	}
else {
	return &ui_textbox($name, $value, 6);
	}
}

sub check_previous
{
	my (@p,$max,$n)=@_;
	for ($i=0;$i<$max;$i++)
	{
		if ($n eq $p[$i]){return 1}
	}
	return -1;
}
 
sub by_string_for_iptables
{
	my @p=("PREROUTING","INPUT","FORWARD","OUTPUT","POSTROUTING");

	for ($i=0;$i<@p;$i++)
	{
		if ($a eq $p[$i]){
			if (&check_previous(@p,$i,$b)){return -1;}
			else{ return 1;}}
		if ($b eq $p[$i]){
			if (&check_previous(@p,$i,$b)){return 1;}
			else{ return -1;}}
	}

	return $a cmp $b;
}

sub missing_firewall_commands
{
local $c;
foreach $c ("ip${ipvx}tables", "ip${ipvx}tables-restore", "ip${ipvx}tables-save") {
	return $c if (!&has_command($c));
	}
return undef;
}

sub iptables_restore_command
{
return &has_command("ip${ipvx}tables-restore") ||
       &has_command("ip${ipvx}tables-legacy-restore");
}

# iptables_restore()
# Activates the current firewall rules, and returns any error
sub iptables_restore
{
local $rcmd = &iptables_restore_command();
local $out = &backquote_logged("cd / && $rcmd <$ipvx_save 2>&1");
return $? ? "<pre>$out</pre>" : undef;
}

sub iptables_save_command
{
return &has_command("ip${ipvx}tables-save") ||
       &has_command("ip${ipvx}tables-legacy-save");
}

# iptables_save()
# Saves the active firewall rules, and returns any error
sub iptables_save
{
local $scmd = &iptables_save_command();
local $out = &backquote_logged("cd / && $scmd >$ipvx_save 2>&1");
return $? ? "<pre>$out</pre>" : undef;
}

# can_edit_table(name)
sub can_edit_table
{
return $access{$_[0]};
}

# can_jump(jump|&rule)
sub can_jump
{
return 1 if (!$access{'jumps'});
if (!%can_jumps_cache) {
	%can_jumps_cache = map { lc($_), 1 } split(/\s+/, $access{'jumps'});
	}
local $j = ref($_[0]) ? $_[0]->{'j'}->[1] : $_[0];
return 1 if (!$j);	# always allow 'do nothing'
return $can_jumps_cache{lc($j)};
}

# run_before_command()
# Runs the before-saving command, if any
sub run_before_command
{
if ($config{'before_cmd'}) {
	&system_logged("($config{'before_cmd'}) </dev/null >/dev/null 2>&1");
	}
}

# run_after_command()
# Runs the after-saving command, if any
sub run_after_command
{
if ($config{'after_cmd'}) {
	&system_logged("($config{'after_cmd'}) </dev/null >/dev/null 2>&1");
	}
}

# run_before_apply_command()
# Runs the before-applying command, if any. If it fails, returns the error
# message output
sub run_before_apply_command
{
if ($config{'before_apply_cmd'}) {
	local $out = &backquote_logged("($config{'before_apply_cmd'}) </dev/null 2>&1");
	return $out if ($?);
	}
return undef;
}

# run_after_apply_command()
# Runs the after-applying command, if any
sub run_after_apply_command
{
if ($config{'after_apply_cmd'}) {
	&system_logged("($config{'after_apply_cmd'}) </dev/null >/dev/null 2>&1");
	}
}

# apply_configuration()
# Calls all the appropriate apply functions and programs, and returns an error
# message if anything fails
sub apply_configuration
{
local $err = &run_before_apply_command();
return $err if ($err);
local @oldlive = &get_iptables_save("direct");
if (defined(&apply_iptables)) {
	# Call distro's apply command
	$err = &apply_iptables();
	}
else {
	# Manually run iptables-restore
	$err = &iptables_restore();
	}
return $err if ($err);
if (!$config{"direct${ipvx}"}) {
	# Put back fail2ban rules
	local @newlive = &get_iptables_save("direct");
	&merge_fail2ban_rules(\@oldlive, \@newlive);
	}
&run_after_apply_command();
return undef;
}

# merge_fail2ban_rules(&old-live, &new-live)
# If there were fail2ban rules before applying but not after, re-create them
sub merge_fail2ban_rules
{
local ($oldlive, $newlive) = @_;

# Get old and new filter table
local ($oldfilter) = grep { $_->{'name'} eq 'filter' } @$oldlive;
local ($newfilter) = grep { $_->{'name'} eq 'filter' } @$newlive;
return if (!$oldfilter || !$newfilter);
local $oldrules = $oldfilter->{'rules'};
local $newrules = $newfilter->{'rules'};

# Get all old fail2ban chain rules and inputs that jump to them
local @oldrules = grep { $_->{'chain'} =~ /^f2b-/ } @$oldrules;
return if (!@oldrules);
local @oldjumps = grep { $_->{'chain'} eq 'INPUT' &&
			 $_->{'j'}->[1] =~ /^f2b-/ } @$oldrules;

# Get all new fail2ban chain rules and inputs that jump to them
local @newrules = grep { $_->{'chain'} =~ /^f2b-/ } @$newrules;
local @newjumps = grep { $_->{'chain'} eq 'INPUT' &&
			 $_->{'j'}->[1] =~ /^f2b-/ } @newrules;

# Re-create the chains
my @oldchains = &unique(map { $_->{'chain'} } @oldrules);
foreach my $c (@oldchains) {
	&system_logged("ip${ipvx}tables -t filter -N $c 2>&1");
	}

# Re-create any missing old rules
foreach my $r (@oldrules) {
	&create_active_rule($newfilter, $r, 0);
	}
foreach my $j (@oldjumps) {
	my ($nj) = grep { $_->{'j'}->[1] eq $j->{'j'}->[1] } @newjumps;
	if (!$nj) {
		&create_active_rule($newfilter, $j, 1);
		}
	}
}

# list_cluster_servers()
# Returns a list of servers on which the firewall is managed
sub list_cluster_servers
{
&foreign_require("servers", "servers-lib.pl");
local %ids = map { $_, 1 } split(/\s+/, $config{'servers'});
return grep { $ids{$_->{'id'}} } &servers::list_servers();
}

# add_cluster_server(&server)
sub add_cluster_server
{
local @sids = split(/\s+/, $config{'servers'});
$config{'servers'} = join(" ", @sids, $_[0]->{'id'});
&save_module_config();
}

# delete_cluster_server(&server)
sub delete_cluster_server
{
local @sids = split(/\s+/, $config{'servers'});
$config{'servers'} = join(" ", grep { $_ != $_[0]->{'id'} } @sids);
&save_module_config();
}

# server_name(&server)
sub server_name
{
return $_[0]->{'desc'} ? $_[0]->{'desc'} : $_[0]->{'host'};
}

# copy_to_cluster([force])
# Copy all firewall rules from this server to those in the cluster
sub copy_to_cluster
{
return if (!$config{'servers'});		# no servers defined
return if (!$_[0] && $config{'cluster_mode'});	# only push out when applying
local $s;
local $ltemp;
if ($config{"direct${ipvx}"}) {
	# Dump current configuration
	$ltemp = &transname();
	system("ip${ipvx}tables-save >$ltemp 2>/dev/null");
	}
foreach $s (&list_cluster_servers()) {
	&remote_foreign_require($s, $module_name);
	if ($config{"direct${ipvx}"}) {
		# Directly activate on remote server!
		local $rtemp = &remote_write($s, $ltemp);
		unlink($ltemp);
		local $err = &remote_eval($s, $module_name,
		  "\$out = `ip${ipvx}tables-restore <$rtemp 2>&1`; [ \$out, \$? ]"); 
		&remote_foreign_call($s, $module_name, "unlink_file", $rtemp);
		&error(&text('apply_remote', $s->{'host'}, $err->[0]))
			if ($err->[1]);
		}
	else {
		# Can just copy across save file
		local $rfile = &remote_eval($s, $module_name,
					    "\$ip${ipvx}tables_save_file");
		&remote_write($s, $ipvx_save, $rfile);
		}
	}
}

# apply_cluster_configuration()
# Activate the current configuration on all servers in the cluster
sub apply_cluster_configuration
{
return undef if (!$config{'servers'});
if ($config{'cluster_mode'}) {
	&copy_to_cluster(1);
	}
local $s;
foreach $s (&list_cluster_servers()) {
	&remote_foreign_require($s->{'host'}, $module_name);
	local $err = &remote_foreign_call(
		$s->{'host'}, $module_name, "apply_configuration");
	if ($err) {
		return &text('apply_remote', $s->{'host'}, $err);
		}
	}
return undef;
}

# validate_iptables_config()
# Tests that the rules file can be parsed
sub validate_iptables_config
{
my $out = &backquote_command(
	"ip${ipvx}tables-restore --test <$ipvx_save 2>&1");
return undef if (!$?);
$out =~ s/Try\s.*more\s+information.*//;
return $out;
}

sub supports_conntrack
{
if (!defined($supports_conntrack_cache)) {
	my $out = &backquote_command("uname -r 2>/dev/null");
	$supports_conntrack_cache = $out =~ /^[3-9]\./ ? 1 : 0;
	}
return $supports_conntrack_cache;
}

# create_active_rule(&table, &rule, insert?)
# Execute the commands to create one rule
sub create_active_rule
{
my ($table, $rule, $insert) = @_;
my $flags = &make_rule_command($rule);
$flags =~ s/^-A /-I / if ($insert);
my $cmd = "ip${ipvx}tables -t ".$table->{'name'}." ".$flags;
my $out = &backquote_logged("$cmd 2>&1 </dev/null");
return $? ? $out : undef;
}

# external_firewall_list(&tables)
# Returns a list of all external firewalls detected
sub external_firewall_list
{
my ($tables) = @_;
my @fwname;
my ($filter) = grep { $_->{'name'} eq 'filter' } @$tables;
if ($filter->{'defaults'}->{'shorewall'}) {
	push(@fwname, 'shorewall');
	}
if ($filter->{'defaults'}->{'INPUT_ZONES'}) {
	push(@fwname, 'firewalld');
	}
if ($filter->{'defaults'} =~ /^f2b-|^fail2ban-/ && !$config{'filter_chain'} ) {
	push(@fwname, 'fail2ban');
	}
if (&indexof('firewalld', @fwname) < 0 &&
    &foreign_installed("firewalld", 1) == 2) {
	push(@fwname, 'firewalld');
	}
if (&indexof('shorewall', @fwname) < 0 &&
    &foreign_installed("shorewall", 1) == 2) {
	push(@fwname, 'shorewall');
	}
return &unique(@fwname);
}

1;


=== ./background/webmin-plugins/firewall/firewall4-lib.pl ===

# firewall4-lib.pl
# has to be included after firewall-lib from every cgi

# ipv4 initialization
if ($config{'save_file'}) {
	# Force use of a different save file, and webmin's functions
	$iptables_save_file = $config{'save_file'};
	}
else {
	if (-r "$module_root_directory/$gconfig{'os_type'}-lib.pl") {
		# Use the operating system's save file and functions
		do "$gconfig{'os_type'}-lib.pl";
		}

	if (!$iptables_save_file) {
		# Use webmin's own save file
		$iptables_save_file = "$module_config_directory/iptables.save";
		}
	}

%access = &get_module_acl();

@known_tables = ( "filter", "mangle", "nat" );
@known_args =   ('-p', '-m', '-s', '-d', '-i', '-o', '-f',
		 '--dport', '--sport', '--tcp-flags', '--tcp-option',
		 '--icmp-type', '--mac-source', '--limit', '--limit-burst',
		 '--ports', '--uid-owner', '--gid-owner',
		 '--pid-owner', '--sid-owner', '--state', '--ctstate', '--tos',
		 '-j', '--to-ports', '--to-destination', '--to-source',
		 '--reject-with', '--dports', '--sports', '--match-set',
		 '--comment',
		 '--physdev-is-bridged',
		 '--physdev-is-in',
		 '--physdev-is-out',
		 '--physdev-in',
		 '--physdev-out');

@ipvx_rtypes = ( "icmp-net-unreachable", "icmp-host-unreachable",
		  "icmp-port-unreachable", "icmp-proto-unreachable",
		  "icmp-net-prohibited", "icmp-host-prohibited",
		  "echo-reply", "tcp-reset" );

$ipvx_todestpattern='^([0-9\.]+)(\-([0-9\.]+))?(:(\d+)(\-(\d+))?)?$';


# set IP Version
&set_ipvx_version('ipv4');

# IP V4 only functions
sub check_ipmask
{
foreach my $w (split(/[ \t\r\n,]+/, $_[0])) {
	my $ok = &to_ipaddress($w) ||
		$w =~ /^([0-9\.]+)\/([0-9\.]+)$/ &&
			&to_ipaddress("$1") &&
			(&check_ipaddress("$2") || ($2 =~ /^\d+$/ && $2 <= 32));
	return 0 if (!$ok);
	}
return 1;
}

# check_ipvx_ipaddress(ipv4)
# Validates an IPv4 address
sub check_ipvx_ipaddress
{
return &check_ipaddress(@_);
}

1;


=== ./background/webmin-plugins/firewall/firewall6-lib.pl ===

# firewall6-lib.pl
# has to be included after firewall-lib from every cgi

# ipv6 initialization
if ($config{'save_file6'}) {
	# Force use of a different save file, and webmin's functions
	$ip6tables_save_file = $config{'save_file6'};
	}
else {
	if (-r "$module_root_directory/$gconfig{'os_type'}-lib.pl") {
		# Use the operating system's save file and functions
		do "$gconfig{'os_type'}-lib.pl";
		}

	if (!$ip6tables_save_file) {
		# Use webmin's own save file
		$ip6tables_save_file = "$module_config_directory/ip6tables.save";
		}
	}

%access = &get_module_acl();

@known_tables = ( "filter", "mangle", "nat" );
@known_args =   ('-p', '-m', '-s', '-d', '-i', '-o', '-f',
		 '--dport', '--sport', '--tcp-flags', '--tcp-option',
		 '--icmpv6-type', '--mac-source', '--limit', '--limit-burst',
		 '--ports', '--uid-owner', '--gid-owner',
		 '--pid-owner', '--sid-owner', '--state', '--ctstate', '--tos',
		 '-j', '--to-ports', '--to-destination', '--to-source',
		 '--reject-with', '--dports', '--sports',
		 '--comment',
		 '--physdev-is-bridged',
		 '--physdev-is-in',
		 '--physdev-is-out',
		 '--physdev-in',
		 '--physdev-out');

@ipvx_rtypes = ( "icmp6-no-route", "icmp6-adm-prohibited",
		  "icmp6-addr-unreachable", "icmp6-port-unreachable",
		  "echo-reply", "tcp-reset" );

$ipvx_todestpattern='^\[([0-9A-Fa-f:]+)\](\-([0-9A-Fa-f:]+))?(:(\d+)(\-(\d+))?)?$';

# set IP Version
&set_ipvx_version('ipv6');

# IP V6 only functions
sub check_ipmask
{
foreach my $w (split(/,/, $_[0])) {
	my $ok = &to_ipaddress($w) ||
		$w =~ /^([0-9\.]+)\/([0-9\.]+)$/ &&
			&to_ipaddress("$1") &&
			(&check_ipaddress("$2") || ($2 =~ /^\d+$/ && $2 <= 32));
	return 1 if (!$ok);
	}
return 1;
}

# check_ipvx_ipaddress(ipv6)
# Validates an IPv6 address
sub check_ipvx_ipaddress
{
return &check_ip6address(@_);
}

1;


=== ./background/webmin-plugins/firewall/gentoo-linux-lib.pl ===

# gentoo-linux-lib.pl
# Deal with gentoo's iptables save file

# check_iptables()
# Returns an error message if something is wrong with iptables on this system
sub check_iptables
{
if (!-r "/etc/init.d/ip${ipvx}tables") {
	return &text('gentoo_escript', "<tt>/etc/init.d/ip${ipvx}tables</tt>");
	}
return undef;
}

local %iptconf;
&read_env_file("/etc/conf.d/ip${ipvx}tables", \%iptconf);
$ip6tables_save_file = $iptconf{'ip6tables_SAVE'};
$iptables_save_file = $iptconf{'iptables_SAVE'};

# apply_iptables()
# Applies the current iptables configuration from the save file
sub apply_iptables
{
local $out = &backquote_logged("cd / ; /etc/init.d/ip${ipvx}tables reload 2>&1");
return $? ? "<pre>$out</pre>" : undef;
}

1;


=== ./background/webmin-plugins/firewall/install_check.pl ===

# install_check.pl

do 'firewall-lib.pl';

# is_installed(mode)
# For mode 1, returns 2 if the server is installed and configured for use by
# Webmin, 1 if installed but not configured, or 0 otherwise.
# For mode 0, returns 1 if installed, 0 if not
sub is_installed
{
return 0 if (&missing_firewall_commands());
local $out = &backquote_command("iptables -n -t filter -L OUTPUT 2>&1");
return 0 if ($?);
if ($_[0]) {
	# Check if init script is setup
	if (!$config{'direct'} &&
	    (defined(&check_iptables) && &check_iptables() ||
	     !-s $iptables_save_file)) {
		return 1;
		}
	return 2;
	}
# Check if another firewall is in use
my @livetables = &get_iptables_save("ip${ipvx}tables-save 2>/dev/null |");
my @fwname = &external_firewall_list(\@livetables);
@fwname = grep { $_ ne 'fail2ban' } @fwname;
return 0 if (@fwname);
return 1;
}


=== ./background/webmin-plugins/firewall/log_parser.pl ===

# log_parser.pl
# Functions for parsing this module's logs

do 'firewall-lib.pl';

# parse_webmin_log(user, script, action, type, object, &params)
# Converts logged information from this module into human-readable form
sub parse_webmin_log
{
local ($user, $script, $action, $type, $object, $p) = @_;
if ($type eq "rule") {
	return &text("log_${action}_rule", "<tt>$p->{'chain'}</tt>",
					   "<tt>$p->{'table'}</tt>");
	}
elsif ($type eq "chain") {
	return &text("log_${action}_chain", "<tt>$p->{'chain'}</tt>",
					    "<tt>$p->{'table'}</tt>",
					    $p->{'count'});
	}
elsif ($type eq "host" || $type eq "group") {
	return &text("log_${action}_${type}", "<tt>$object</tt>");
	}
elsif ($action eq "openports") {
	return &text('log_openports', join(" ", split(/\0/, $p->{'ports'})));
	}
else {
	return $text{"log_$action"};
	}
}


=== ./background/webmin-plugins/firewall/mandrake-linux-lib.pl ===

# mandriva-linux-lib.pl
# Deal with Mandriva's /etc/sysconfig/iptables save file and startup script

# check_iptables()
# Returns an error message if something is wrong with iptables on this system
sub check_iptables
{
if (!-r "/usr/libexec/ip${ipvx}tables.init") {
	return &text("The iptabes service", "<tt>/usr/libexec/ip${ipvx}tables.init</tt>");
	}
if (!$config{'done_check_iptables'}) {
	local $out = `/usr/libexec/ip${ipvx}tables.init status 2>&1`;
	if ($out !~ /table:|INPUT|FORWARD|OUTPUT/) {
		return &text('redhat_eoutput',
			     "<tt>/usr/libexec/ip${ipvx}tables.init status</tt>");
		}
	$config{'done_check_iptables'} = 1;
	&save_module_config();
	}
return undef;
}

$ip6tables_save_file = "/etc/sysconfig/ip6tables";
$iptables_save_file = "/etc/sysconfig/iptables";

# apply_iptables()
# Applies the current iptables configuration from the save file
#sub apply_iptables
#{
#local $out = &backquote_logged("cd / ; /etc/rc.d/init.d/iptables restart 2>&1");
#$out =~ s/\033[^m]+m//g;
#return $? || $out =~ /FAILED/ ? "<pre>$out</pre>" : undef;
#}

# unapply_iptables()
# Writes the current iptables configuration to the save file
sub unapply_iptables
{
$out = &backquote_logged("cd / ; /usr/libexec/ip${ipvx}tables.init save 2>&1 </dev/null");
$out =~ s/\033[^m]+m//g;
return $? || $out =~ /FAILED/ ? "<pre>$out</pre>" : undef;
}

# started_at_boot()
sub started_at_boot
{
&foreign_require("init", "init-lib.pl");
return &init::action_status("ip${ipvx}tables") == 2;
}

sub enable_at_boot
{
&foreign_require("init", "init-lib.pl");
&init::enable_at_boot("ip${ipvx}tables");	 # Assumes init script exists
}

sub disable_at_boot
{
&foreign_require("init", "init-lib.pl");
&init::disable_at_boot("ip${ipvx}tables");
}

1;


=== ./background/webmin-plugins/firewall/module.info.cs ===

desc_cs=Firewall Linuxu

=== ./background/webmin-plugins/firewall/module.info.pl ===

desc_pl=Firewall Linuksa
longdesc_pl=Konfiguracja firewall linuksa używając iptables. Pozwala na edycję wszystkich tabel, reguł i opcji.

=== ./background/webmin-plugins/firewall/open-ports.pl ===

#!/usr/local/bin/perl
# Open some ports on the firewall. Exit statuses are :
# 0 - Nothing needed to be done
# 1 - Given ports were opened up
# 2 - IPtables is not installed or supported
# 3 - No firewall is active
# 4 - Could not apply configuration
# 5 - Bad args

$no_acl_check++;
$ENV{'WEBMIN_CONFIG'} = "/etc/webmin";
$ENV{'WEBMIN_VAR'} = "/var/webmin";
if ($0 =~ /^(.*\/)[^\/]+$/) {
	chdir($1);
	}
require './firewall-lib.pl';
if ($module_name ne 'firewall') {
	print STDERR "Command must be run with full path\n";
	exit(5);
	}

# Parse args
if ($ARGV[0] eq "--no-apply") {
	$no_apply = 1;
	shift(@ARGV);
	}
if (!@ARGV) {
	print STDERR "Missing ports to open\n";
	exit(5);
	}
foreach $p (@ARGV) {
	if ($p !~ /^\d+$/ && $p !~ /^\d+:\d+$/ && $p !~ /^\d+(,\d+)*$/) {
		print STDERR "Port $p must be number or start:end range\n";
		exit(5);
		}
	}

# Check IPtables support
if (&foreign_installed($module_name, 1) != 2) {
	print STDERR "IPtables is not available\n";
	exit(2);
	}

# Check if any rules exist
@tables = &get_iptables_save();
if (!@tables) {
	print STDERR "No IPtables rules exist yet\n";
	exit(3);
	}
($filter) = grep { $_->{'name'} eq 'filter' } @tables;
if (!$filter) {
	print STDERR "No IPtables filter table found\n";
	exit(3);
	}
elsif (!@{$filter->{'rules'}}) {
	print STDERR "No IPtables rules found in filter table\n";
	exit(3);
	}

# Check if any rules are active
@livetables = &get_iptables_save("iptables-save 2>/dev/null |");
($livefilter) = grep { $_->{'name'} eq 'filter' } @livetables;

@added = ( );
PORT: foreach $p (@ARGV) {
	# For each port, find existing rules
	print STDERR "Checking for port $p ..\n";
	foreach $r (@{$filter->{'rules'}}) {
		if ($r->{'chain'} eq 'INPUT' &&
		    $r->{'j'} && $r->{'j'}->[1] eq 'ACCEPT' &&
		    $r->{'p'} && $r->{'p'}->[0] eq '' &&
		    		 $r->{'p'}->[1] eq 'tcp') {
			# Found tcp rule .. check ports
			@rports = ( );
			$rrange = undef;
			if ($r->{'dports'} && $r->{'dports'}->[0] eq '') {
				push(@rports, split(/,/, $r->{'dports'}->[1]));
				$rrange = $r->{'dports'}->[1];
				}
			if ($r->{'dport'} && $r->{'dport'}->[0] eq '') {
				($s, $e) = split(":", $r->{'dport'}->[1]);
				if ($s && $e) {
					push(@rports, ($s .. $e));
					}
				elsif ($s) {
					push(@rports, $s);
					}
				$rrange = $r->{'dport'}->[1];
				}
			if (&indexof($p, @rports) >= 0 ||
			    $p eq $rrange) {
				print STDERR ".. already allowed\n";
				next PORT;
				}
			}
		}

	# Add a rule at the top for this port
	$r = { 'chain' => 'INPUT',
	       'm' => [ [ "", "tcp" ] ],
	       'p' => [ "", "tcp" ],
	       'j' => [ "", 'ACCEPT' ] };
	if ($p =~ /,/) {
		$r->{'dports'} = [ "", $p ];
		push(@{$r->{'m'}}, [ "", "multiport" ]);
		}
	else {
		$r->{'dport'} = [ "", $p ];
		}
	unshift(@{$filter->{'rules'}}, $r);
	push(@added, $p);
	}

if (@added) {
	# Added some rules .. save them
	&run_before_command();
	&lock_file($iptables_save_file);
	&save_table($filter);
	&unlock_file($iptables_save_file);
	&run_after_command();
	&copy_to_cluster();
	print STDERR "Opened ports ",join(" ", @added),"\n";

	# Apply, if live
	$ex = 1;
	if (!$no_apply && $livefilter && @{$livefilter->{'rules'}}) {
		$err = &apply_configuration();
		if ($err) {
			print "Failed to apply configuration : $err\n";
			$ex = 4;
			}
		else {
			print "Applied configuration successfully\n";
			}
		}
	&webmin_log("openports", undef, undef, { 'ports' => \@added });
	exit($ex);
	}
else {
	print STDERR "All ports are already open\n";
	exit(0);
	}

=== ./background/webmin-plugins/firewall/redhat-linux-lib.pl ===

# redhat-linux-lib.pl
# Deal with redhat's /etc/sysconfig/iptables save file and startup script

&foreign_require("init", "init-lib.pl");
$init_script = "$init::config{'init_dir'}/ip${ipvx}tables";

# check_iptables()
# Returns an error message if something is wrong with iptables on this system
sub check_iptables
{
&foreign_require("init");
&init::action_status("ip${ipvx}tables") > 0 ||
	return &text('redhat_einstalled2', "ip${ipvx}tables");
return undef if ($gconfig{'os_type'} eq 'trustix-linux');
return undef if ($gconfig{'os_type'} eq 'redhat-linux' &&
		 $gconfig{'os_version'} > 10);
if (!$config{'done_check_iptables'} && -r $init_script) {
	local $out = &backquote_command("$init_script status 2>&1");
	if ($out !~ /table:|INPUT|FORWARD|OUTPUT|is\s+stopped|firewall\s+stopped/) {
		return &text('redhat_eoutput',
			     "<tt>$init_script status</tt>");
		}
	$config{'done_check_iptables'} = 1;
	&save_module_config();
	}
return undef;
}

$ip6tables_save_file = "/etc/sysconfig/ip6tables";
$iptables_save_file = "/etc/sysconfig/iptables";

# apply_iptables()
# Applies the current iptables configuration from the save file
sub apply_iptables
{
if (-r $init_script) {
	local $out = &backquote_logged("cd / ; $init_script restart 2>&1");
	$out =~ s/\033[^m]+m//g;
	return $? || $out =~ /FAILED/ ? "<pre>$out</pre>" : undef;
	}
else {
	local $out = &backquote_logged("cd ; service ip${ipvx}tables restart 2>&1");
	return $? || $out =~ /FAILED/ ? "<pre>$out</pre>" : undef;
	}
}

# unapply_iptables()
# Writes the current iptables configuration to the save file
sub unapply_iptables
{
if (-r $init_script) {
	$out = &backquote_logged("cd / ; $init_script save 2>&1 </dev/null");
	$out =~ s/\033[^m]+m//g;
	if ($? && $out =~ /usage/i) {
		# 'save' argument not supported .. call iptables-save manually
		return &iptables_save();
		}
	return $? || $out =~ /FAILED/ ? "<pre>$out</pre>" : undef;
	}
else {
	return &iptables_save();
	}
}

# started_at_boot()
sub started_at_boot
{
return &init::action_status("ip${ipvx}tables") == 2;
}

sub enable_at_boot
{
&init::enable_at_boot("ip${ipvx}tables");	 # Assumes init script exists
}

sub disable_at_boot
{
&init::disable_at_boot("ip${ipvx}tables");
}

1;


=== ./background/webmin-plugins/firewalld/config.info.pl ===

firewall_cmd=Pełna ścieżka do programu firewall-cmd,0
init_name=Nazwa skryptu init FirewallD,0

=== ./background/webmin-plugins/firewalld/firewalld-lib.pl ===

# Functions for managing firewalld

BEGIN { push(@INC, ".."); };
use strict;
use warnings;
no warnings 'redefine';
no warnings 'uninitialized';
use WebminCore;
&init_config();
do 'md5-lib.pl';
our ($module_root_directory, %text, %config, %gconfig);
our %access = &get_module_acl();

# check_firewalld()
# Returns an error message if firewalld is not installed, undef if all is OK
sub check_firewalld
{
&has_command($config{'firewall_cmd'}) ||
	return &text('check_ecmd', "<tt>".$config{'firewall_cmd'}."</tt>");
return undef;
}

# get_config_files()
# Returns a list of all firewalld config files
sub get_config_files
{
my $conf_dir = $config{'config_dir'} || '/etc/firewalld';
return (glob("$conf_dir/*.xml"), glob("$conf_dir/*/*.xml"));
}

# check_ip_family()
# Determines which IP families are enabled and functional on the system
#
# Returns:
#   Hash with 'ipv4' and 'ipv6' keys set to 1 if enabled, 0 if disabled, -1 if unknown
sub check_ip_family
{
my %result = ( ipv4 => 0, ipv6 => 0 );

# Attempt to load IO::Socket::IP at runtime
eval {
	require IO::Socket::IP;
		IO::Socket::IP->import();
		1;
	};

# Return on error (must never happen on contemporary systems)
if ($@) {
	$result{ipv4} = -1; # unknown
	$result{ipv6} = -1; # unknown
	return %result;
	}

# Check IPv4
eval {
	my $sock4 = IO::Socket::IP->new(
		LocalHost => '127.0.0.1',
		LocalPort => 0,  # ephemeral port
		Proto     => 'tcp');
	$result{ipv4} = 1 if $sock4;
	};

# Check IPv6
eval {
	my $sock6 = IO::Socket::IP->new(
		LocalHost => '::1',
		LocalPort => 0,  # ephemeral port
		Proto     => 'tcp' );
	$result{ipv6} = 1 if $sock6;
	};

return %result;
}

# is_firewalld_running()
# Returns 1 if the server is running, 0 if not
sub is_firewalld_running
{
my $ex = system("$config{'firewall_cmd'} --state >/dev/null 2>&1 </dev/null");
return $ex ? 0 : 1;
}

# list_firewalld_zones([active-only])
# Returns an array of firewalld zones, each of which is a hash ref with fields
# like services and ports
sub list_firewalld_zones
{
my ($active) = @_;
my @rv;
my $out = &backquote_command("$config{'firewall_cmd'} --list-all-zones ".
			     ($active ? "" : "--permanent ")."</dev/null 2>&1");
if ($?) {
	&error("Failed to list zones : $out");
	}
my $default_zone = backquote_command(
	"$config{'firewall_cmd'} --get-default-zone </dev/null 2>&1");
chomp($default_zone);
my $zone;
my $lo;
foreach my $l (split(/\r?\n/, $out)) {
	if ($l =~ /^(\S+)(\s+\(.*\))?/) {
		# New zone
		$zone = { 'name' => $1,
			  'default' => $default_zone eq $1 ? 1 : 0 };
		$lo = undef;
		push(@rv, $zone);
		}
	elsif ($l =~ /^  (\S+):\s*(.*)/ && $zone) {
		# Option in some zone
		$lo = $1;
		$zone->{$1} = [ split(/\s+/, $2) ];
		}
	elsif ($l =~ /^\t(\S.*)/ && $zone && $lo) {
		# Continued option
		push(@{$zone->{$lo}}, split(/\s+/, $1));
		}
	}
return @rv;
}

# list_firewalld_services()
# Returns an array of known service names
sub list_firewalld_services
{
my $out = &backquote_command("$config{'firewall_cmd'} --get-services </dev/null 2>&1");
if ($?) {
	&error("Failed to list services : $out");
	}
$out =~ s/\r|\n//g;
return split(/\s+/, $out);
}

# list_firewalld_service_desc(service)
# Returns a hashref of ports and protocols 
# for in-built FirewallD service
sub list_firewalld_service_desc
{
my ($service) = @_;
$service =~ s/[^A-Za-z0-9\-]//g;
# This is native way but too slow
# my $out = &backquote_command("$config{'firewall_cmd'} --service=".quotemeta($service)." --get-ports --permanent </dev/null 2>&1");

# Check for file in directory containing all services as xml files
my @ports;
my @protos;
foreach my $services_dir ("/etc/firewalld/services",
			  "/usr/lib/firewalld/services") {
	my $service_file = "$services_dir/$service.xml";
	if (-r $service_file) {
		my $lref = &read_file_lines($service_file, 1);
		foreach my $l (@{$lref}) {
			if ($l =~ /<port\s+protocol=["'](?<proto>\S+)["']\s+port=["'](?<port>[\d-]+)["']\/>/) {
				my $port = "$+{port}";
				my $proto = "$+{proto}";
				push(@ports, $port) if ($port);
				push(@protos, $proto) if ($port && $proto);
				}
			}
		last if (@ports);
		}
	}
@ports = &unique(@ports);
@protos = &unique(@protos);
return {'ports' => join(", ", @ports), 'protocols' => uc(join('/', @protos))};
}

# list_firewalld_services_with_ports()
# Returns an array of service names and descriptions
sub list_firewalld_services_with_ports
{
my @rv;
foreach my $s (&list_firewalld_services()) {
	my @n = getservbyname($s, "tcp");
	if (!@n) {
		@n = getservbyname($s, "udp");
		}
	if (@n) {
		push(@rv, [ $s, $s." (".$n[2]." ".uc($n[3]).")" ]);
		}
	else {
		my $sportsprotos = &list_firewalld_service_desc($s);
		my $sports = $sportsprotos->{'ports'};
		my $sprotocols = $sportsprotos->{'protocols'};
		my $sdesc;
		$sdesc = " ($sports $sprotocols)" if ($sports);
		push(@rv, [ $s, "$s$sdesc" ]);
		}
	}
return @rv;
}

# create_firewalld_port(&zone, port|range, proto)
# Adds a new allowed port to a zone. Returns undef on success or an error
# message on failure
sub create_firewalld_port
{
my ($zone, $port, $proto) = @_;
my $out = &backquote_logged("$config{'firewall_cmd'} ".
			    "--zone ".quotemeta($zone->{'name'})." ".
			    "--permanent --add-port ".
			    quotemeta($port)."/".quotemeta($proto)." 2>&1");
return $? ? $out : undef;
}

# delete_firewalld_port(&zone, port|range, proto)
# Delete one existing port from a zone. Returns undef on success or an error
# message on failure
sub delete_firewalld_port
{
my ($zone, $port, $proto) = @_;
my $out = &backquote_logged("$config{'firewall_cmd'} ".
			    "--zone ".quotemeta($zone->{'name'})." ".
			    "--permanent --remove-port ".
			    quotemeta($port)."/".quotemeta($proto)." 2>&1");
return $? ? $out : undef;
}

# create_firewalld_service(&zone, service)
# Adds a new allowed service to a zone. Returns undef on success or an error
# message on failure
sub create_firewalld_service
{
my ($zone, $service) = @_;
my $out = &backquote_logged("$config{'firewall_cmd'} ".
			    "--zone ".quotemeta($zone->{'name'})." ".
			    "--permanent --add-service ".
			    quotemeta($service)." 2>&1");
return $? ? $out : undef;
}

# delete_firewalld_service(&zone, service)
# Delete one existing service from a zone. Returns undef on success or an error
# message on failure
sub delete_firewalld_service
{
my ($zone, $service) = @_;
my $out = &backquote_logged("$config{'firewall_cmd'} ".
			    "--zone ".quotemeta($zone->{'name'})." ".
			    "--permanent --remove-service ".
			    quotemeta($service)." 2>&1");
return $? ? $out : undef;
}

# create_firewalld_forward(&zone, src-port, src-proto, dst-port, dst-addr)
# Create a new forwarding rule in some zone. Returns undef on success or an
# error message on failure
sub create_firewalld_forward
{
my ($zone, $srcport, $srcproto, $dstport, $dstaddr) = @_;
my $out = &backquote_logged(
	$config{'firewall_cmd'}." ".
	"--zone ".quotemeta($zone->{'name'})." ".
	"--permanent ".
	"--add-forward-port=port=$srcport:proto=$srcproto".
	($dstport ? ":toport=$dstport" : "").
	($dstaddr ? ":toaddr=$dstaddr" : "").
	" 2>&1");
return $? ? $out : undef;
}

# delete_firewalld_forward(&zone, src-port, src-proto, dst-port, dst-addr)
# Deletes a forwarding rule in some zone. Returns undef on success or an
# error message on failure
sub delete_firewalld_forward
{
my ($zone, $srcport, $srcproto, $dstport, $dstaddr) = @_;
my $out = &backquote_logged(
	$config{'firewall_cmd'}." ".
	"--zone ".quotemeta($zone->{'name'})." ".
	"--permanent ".
	"--remove-forward-port=port=$srcport:proto=$srcproto".
	($dstport ? ":toport=$dstport" : "").
	($dstaddr ? ":toaddr=$dstaddr" : "").
	" 2>&1");
return $? ? $out : undef;
}

# parse_firewalld_forward(str)
# Parses a forward string into port, proto, dstport and dstaddr
sub parse_firewalld_forward
{
my ($str) = @_;
my %w = map { split(/=/, $_) } split(/:/, $str);
return ($w{'port'}, $w{'proto'}, $w{'toport'}, $w{'toaddr'});
}

# apply_firewalld()
# Make the current saved config active
sub apply_firewalld
{
&foreign_require("init");
my ($ok, $err) = &init::restart_action($config{'init_name'});
&restart_firewalld_dependent();
return $ok ? undef : $err;
}

# stop_firewalld()
# Shut down the firewalld service
sub stop_firewalld
{
&foreign_require("init");
my ($ok, $err) = &init::stop_action($config{'init_name'});
return $ok ? undef : $err;
}

# start_firewalld()
# Shut down the firewalld service
sub start_firewalld
{
&foreign_require("init");
my ($ok, $err) = &init::start_action($config{'init_name'});
&restart_firewalld_dependent();
return $ok ? undef : $err;
}

# restart_firewalld_dependent()
# Restarts dependent services
sub restart_firewalld_dependent
{
if (&foreign_exists("fail2ban")) {
	&foreign_require("fail2ban");
	if (&fail2ban::is_fail2ban_running()) {
		my $err = &fail2ban::restart_fail2ban_server(1);
		&error(&text('index_dependent', 'fail2ban'))
			if ($err);
		}
	}
}

# list_system_interfaces()
# Returns the list of all interfaces on the system
sub list_system_interfaces
{
&foreign_require("net");
my @rv = map { $_->{'name'} } &net::active_interfaces();
push(@rv, map { $_->{'name'} } &net::boot_interfaces());
return &unique(@rv);
}

# update_zone_interfaces(&zone, &interface-list)
# Update the interfaces a zone applies to
sub update_zone_interfaces
{
my ($zone, $newifaces) = @_;
my $oldifaces = $zone->{'interfaces'};
foreach my $i (&list_system_interfaces()) {
	my $inold = &indexof($i, @$oldifaces) >= 0;
	my $innew = &indexof($i, @$newifaces) >= 0;
	my $args;
	if ($inold && !$innew) {
		# Remove from this zone
		$args = "--remove-interface ".quotemeta($i);
		}
	elsif (!$inold && $innew) {
		# Add to from this zone
		$args = "--add-interface ".quotemeta($i);
		}
	else {
		next;
		}
	my $cmd = "$config{'firewall_cmd'} ".
		  "--zone ".quotemeta($zone->{'name'})." ".
		  "--permanent ".$args;
	my $out = &backquote_logged($cmd." 2>&1 </dev/null");
	return $out if ($?);
	}
return undef;
}

# create_firewalld_zone(name)
# Add a new zone with the given name
sub create_firewalld_zone
{
my ($name) = @_;
my $cmd = "$config{'firewall_cmd'} --permanent --new-zone ".quotemeta($name);
my $out = &backquote_logged($cmd." 2>&1 </dev/null");
return $? ? $out : undef;
}

# delete_firewalld_zone(&zone)
# Removes the specified zone
sub delete_firewalld_zone
{
my ($zone) = @_;
my $cmd = "$config{'firewall_cmd'} --permanent --delete-zone ".
	  quotemeta($zone->{'name'});
my $out = &backquote_logged($cmd." 2>&1 </dev/null");
return $? ? $out : undef;
}

# default_firewalld_zone(&zone)
# Makes the specified zone the default
sub default_firewalld_zone
{
my ($zone) = @_;
my $cmd = "$config{'firewall_cmd'} --set-default-zone ".
	  quotemeta($zone->{'name'});
my $out = &backquote_logged($cmd." 2>&1 </dev/null");
return $? ? $out : undef;
}

# parse_port_field(&in, name)
# Either returns a port expression, or calls error
sub parse_port_field
{
my ($in, $pfx) = @_;
if ($in->{$pfx.'mode'} == 0) {
	$in->{$pfx.'port'} =~ /^\d+$/ &&
	  $in->{$pfx.'port'} > 0 && $in->{$pfx.'port'} < 65536 ||
	  getservbyname($in->{$pfx.'port'}, $in->{'proto'}) ||
	     &error($text{'port_eport'});
	return $in->{$pfx.'port'};
	}
elsif ($in->{$pfx.'mode'} == 1) {
	$in->{$pfx.'portlow'} =~ /^\d+$/ &&
	  $in->{$pfx.'portlow'} > 0 && $in->{$pfx.'portlow'} < 65536 ||
	     &error($text{'port_eportlow'});
	$in->{$pfx.'porthigh'} =~ /^\d+$/ &&
	  $in->{$pfx.'porthigh'} > 0 && $in->{$pfx.'porthigh'} < 65536 ||
	     &error($text{'port_eporthigh'});
	$in->{$pfx.'portlow'} < $in->{$pfx.'porthigh'} ||
	     &error($text{'port_eportrange'});
	return $in->{$pfx.'portlow'}."-".$in->{$pfx.'porthigh'};
	}
else {
	# No port chosen
	return undef;
	}
}

# get_default_zone
# Returns default zone
sub get_default_zone
{
my @zones = &list_firewalld_zones();
my ($zone) = grep { $_->{'default'} } @zones;
return $zone;
}

# construct_rich_rule([@opts])
# Constructs rich firewalld rule and returns it as string
#
# Parameters:
#   @opts - Array of key-value pairs defining the rule properties
# 
# Example:
#   &construct_rich_rule(
#       'source address' => '0.0.0.0/0',
#       'log prefix' => 'BANDWIDTH_IN ',
#       'level' => 'info',
#       'action' => 'accept',
#   );
# 
# Returns:
#   A string representing the rich rule
sub construct_rich_rule
{
my (@opts) = @_;
my %opts = @opts;

# Action type
my $action_type = $config{'packet_handling'} eq '1' ? 'reject' : 'drop';
my $opts_action = delete($opts{'action'});
if ($opts_action) {
	$action_type = lc($opts_action)
		if ($opts_action &&
		    $opts_action =~ /^accept|reject|drop|mark$/);
	}

# Set family
my $family = delete($opts{'family'}) || 'ipv4';

# Validate IP addresses, and update family if needed
foreach my $ip_key ('source address', 'destination address') {
	if (my $full_ip = $opts{$ip_key}) {
		# Split IP and CIDR, if present
		my ($ip_only, $cidr) = split(/\//, $full_ip);

		# Validate the IP portion
		&check_ipaddress($ip_only) || &check_ip6address($ip_only) ||
			&error("$text{'list_rule_iperr'} : $ip_only");

		# Decide family based on presence of ':' in IP portion
		$family = $ip_only =~ /:/ ? 'ipv6' : 'ipv4';

		# If you still want to test or store the CIDR, do it here
		if (defined($cidr)) {
			# Make sure CIDR is numeric and within range
			$cidr =~ /^\d+$/ && $cidr <= ($family eq 'ipv6' ? 128 : 32) ||
				&error("$text{'save_rule_cidrerr'} : /$cidr");
			}
		}
	}

# Construct rule from given options
my $rule = "rule family=\"".quotemeta($family)."\"";

# Extended options handling for dynamic rules
foreach my $key (@opts) { # Iterate over all keys in given order
	next if (!defined($opts{$key}));
	# Keys cannot be quotemeta'd
	$key =~ tr/A-Za-z0-9\-\_\/ //cd;
	# Values can be quotemeta'd
	my $val = $opts{$key};
	$val =~ tr/A-Za-z0-9\-\_\=\'\:\.\,\/ //cd;
	$rule .= " $key=\"$val\"";
	}
$rule .= " ".quotemeta($action_type);
return $rule;
}

# rich_rule(action, [@opts])
# Adds or removes a rich firewalld rule with specified options and rich rule
# passed as string
#
# Parameters:
#   action - Required. Must be either 'add' or 'remove'
#   @opts  - Array of key-value pairs defining the rule properties
# 
# Example:
#   &rich_rule('add', {
#       'zone' => 'public',
#       'rule' => &construct_rich_rule('source address' => '0.0.0.0/0'),
#       'permanent' => 1,
#   });
# 
# Returns:
#   undef on success, or (error_message, error_code) on failure in list context
sub rich_rule
{
my ($action, $opts) = @_;

# Validate action
$action eq 'add' || $action eq 'remove' || &error($text{'list_rule_actionerr'});

# Zone name
my $zone = $opts->{'zone'};
if (!$zone) {
	($zone) = get_default_zone();
	$zone = $zone->{'name'};
	}

# Permanent rule
my $permanent = $opts->{'permanent'};

# Add/remove rich rule
my $get_cmd = sub {
	my ($rtype) = @_;
	my $type = $rtype ? " --permanent" : "";
	return "$config{'firewall_cmd'} --zone=\"".quotemeta($zone)."\"".
	       "$type --".quotemeta($action)."-rich-rule='$opts->{'rule'}'";
	};

for my $type (0..1) {
	next if ($type == 1 && !$permanent);
	my $cmd = &$get_cmd($type);
	my $out = &backquote_logged($cmd." 2>&1 </dev/null");
	return wantarray ? ($out, $?) : $out if ($?);
	}
return undef;
}

# check_rich_rule(rule, [&zone])
# Check if a rich rule exists in the given or default zone
sub check_rich_rule
{
my ($rule, $zone) = @_;

# Zone name
if (!$zone) {
	($zone) = get_default_zone();
	$zone = $zone->{'name'};
	}

# Command to query rules
my $cmd = "$config{'firewall_cmd'} --zone=".quotemeta($zone)." --list-rich-rules";
my $out = &backquote_logged($cmd." 2>&1 </dev/null");

# Check for rule existence
return ($out =~ /\Q$rule\E/);
}

# add_rich_rule(rule, [&zone])
# Add rich rule in given or default zone using raw rule string
sub add_rich_rule
{
my ($rule, $zone) = @_;
return &rich_rule('add',
	{ 'zone' => $zone->{'name'}, 'permanent' => 1, 'rule' => $rule });
}

# remove_rich_rule(rule, [&zone])
# Remove rich rule in given or default zone using raw rule string
sub remove_rich_rule
{
my ($rule, $zone) = @_;
return &rich_rule('remove',
	{ 'zone' => $zone->{'name'}, 'permanent' => 1, 'rule' => $rule });
}

# construct_direct_rule(&opts)
# Constructs a direct Firewalld rule string
#
# Opts can include:
#   'family'   => 'ipv4' | 'ipv6' | 'eb'  (default = 'ipv4')
#   'table'    => 'filter' | 'nat' | 'mangle' | 'raw' |
#                 'security' (default = 'filter')
#   'chain'    => 'INPUT' | 'OUTPUT' | 'FORWARD' |
#                 'PREROUTING' | 'POSTROUTING' (default = 'INPUT')
#   'priority' => integer priority (default = 0)
#   'rule'     => string containing iptables-like match/target
#
# Returns:
#   A string representing the direct rule is returned
#
sub construct_direct_rule
{
my ($opts) = @_;

# Defaults
my $family   = $opts->{'family'}   || 'ipv4';
my $table    = $opts->{'table'}    || 'filter';
my $chain    = $opts->{'chain'}    || 'INPUT';
my $priority = $opts->{'priority'} // 0;
my $rule     = $opts->{'rule'}     || '';

# Basic validation
$family =~ /^(ipv4|ipv6|eb)$/ ||
	&error(&text('save_rule_efamily', $family));

$table =~ /^(filter|nat|mangle|raw|security)$/ ||
	&error(&text('save_rule_etable', $table));

$chain =~ /^(INPUT|OUTPUT|FORWARD|PREROUTING|POSTROUTING)$/ ||
	&error(&text('save_rule_echain', $chain));

# Priority must be integer
$priority =~ /^\d+$/ || &error(&text('save_rule_epriority', $priority));

# If still empty after parsing, throw an error
$rule !~ /^\s*$/ || &error(&text('save_rule_erule'));

# Sanitize rule string by splitting into components and validating each
my @parts = split(/\s+/, $rule);
my $sanitized_rule = '';
for (my $i = 0; $i < @parts; $i++) {
	my $part = $parts[$i];
	next if (!defined($part) || $part eq '');

	if ($family =~ /^ipv[46]$/ &&
	    $part =~ /^(?:--source|--destination)$/) {
		# Get the IP value (next part)
		my $ip = $parts[++$i];
		if (defined($ip)) {
			# Split IP and CIDR if present
			my ($ip_only, $cidr) = split(/\//, $ip);

			# Validate the IP portion
			&check_ipaddress($ip_only) ||
			&check_ip6address($ip_only) ||
				&error("$text{'list_rule_iperr'} : $ip_only");

			# Verify IP family matches the rule family
			my $ip_family = $ip_only =~ /:/ ? 'ipv6' : 'ipv4';
			$ip_family eq $family ||
				&error(&text('save_rule_eruleipmismatch'));

			# Validate CIDR if present
			if (defined($cidr)) {
				# Make sure CIDR is numeric and within range
				my $cidr_valid = $family eq 'ipv6' ? 128 : 32;
				$cidr =~ /^\d+$/ && $cidr <= ($cidr_valid) ||
					&error("$text{'save_rule_cidrerr'} : /$cidr");
				}
			$sanitized_rule .= ' ' . $part . ' ' . $ip;
			}
		}
	elsif ($family eq 'eb' && $part =~ /^(?:--src-mac|--dst-mac)$/) {
		# Get the MAC value (next part)
		my $mac = $parts[++$i];
		if (defined($mac)) {
			# MAC validation could be added here
			$sanitized_rule .= ' ' . $part . ' ' . $mac;
			}
		}
	else {
		if ($part =~ /^-/) {
			# Options/flags can only contain certain characters
			$part =~ tr/A-Za-z0-9\-\_//cd;
			}
		else {
			# Values can contain more characters
			$part =~ tr/A-Za-z0-9\-\_\=\.\:\,\/\"\'//cd;
			}
		$sanitized_rule .= ' ' . $part;
		}
	}

# Remove extra possible spaces
$sanitized_rule =~ s/\s+/ /g;

# Return the constructed rule
return "$family $table $chain $priority $sanitized_rule";
}

# direct_rule(action, &opts)
# Add or remove a direct rule
#
# Returns:
#   undef on success, or (error_message, error_code) on failure in list context
sub direct_rule
{
my ($action, $opts) = @_;

# Validate action
$action eq 'add' || $action eq 'remove' || &error($text{'list_rule_actionerr'});

# Extract permanent flag and construct rule
my $permanent = delete($opts->{'permanent'});

# Get rule
my $rule = $opts->{'rule'};
$rule =~ s/\s+/ /g;

# Add/remove direct rule
my $get_cmd = sub {
	my ($perm) = @_;
	my $type = $perm ? " --permanent" : "";
	return "$config{'firewall_cmd'}$type --direct --$action-rule $rule";
	};

for my $type (0..1) {
	next if ($type == 1 && !$permanent);
	my $cmd = &$get_cmd($type);
	my $out = &backquote_logged($cmd." 2>&1 </dev/null");
	return wantarray ? ($out, $?) : $out if ($?);
	}
return undef;
}

# check_direct_rule(rule)
# Check if a direct rule exists
#
# Returns:
#   1 if rule exists, 0 if not
sub check_direct_rule
{
my ($rule) = @_;

# Construct rule for matching
my ($family, $table, $chain) = split(/\s+/, $rule);
my $rrule = $rule;
$rrule =~ s/^\Q$family\E\s+\Q$table\E\s+\Q$chain\E\s+//;
$rrule =~ s/\s+/ /g;

# Get existing rules
my $cmd = "$config{'firewall_cmd'} --direct --get-rules $family $table $chain";
my $out = &backquote_logged($cmd." 2>&1 </dev/null");
return $? ? 0 : ($out =~ /\Q$rrule\E/);
}

# remove_direct_rule(rule)
# Remove given direct rule passed as string
sub remove_direct_rule
{
my ($rule) = @_;
my ($out, $rs) = &direct_rule('remove', { 'rule' => $rule, 'permanent' => 1 });
return wantarray ? ($out, $?) : $out if ($?);
}

1;

=== ./background/webmin-plugins/firewalld/install_check.pl ===

# install_check.pl

use strict;
use warnings;
no warnings 'redefine';
no warnings 'uninitialized';
do 'firewalld-lib.pl';

# is_installed(mode)
# For mode 1, returns 2 if the server is installed and configured for use by
# Webmin, 1 if installed but not configured, or 0 otherwise.
# For mode 0, returns 1 if installed, 0 if not
sub is_installed
{
my ($mode) = @_;
return 0 if (&check_firewalld());
if ($mode) {
	return &is_firewalld_running() ? 2 : 1;
	}
return 1;
}


=== ./background/webmin-plugins/firewalld/log_parser.pl ===

# log_parser.pl
# Functions for parsing this module's logs

use strict;
use warnings;
no warnings 'redefine';
no warnings 'uninitialized';
do 'firewalld-lib.pl';
our (%text);

# parse_webmin_log(user, script, action, type, object, &params)
# Converts logged information from this module into human-readable form
sub parse_webmin_log
{
my ($user, $script, $action, $type, $object, $p) = @_;
if ($type eq "port" || $type eq "serv" || $type eq "forward") {
	return &text("log_${action}_${type}",
		     "<tt>".&html_escape($object)."</tt>");
	}
elsif ($type eq "rules") {
	return &text("log_${action}_${type}", &html_escape($object));
	}
elsif ($type eq "zone") {
	return &text("log_${action}_${type}",
		     "<tt>".&html_escape($object)."</tt>");
	}
elsif ($type eq "block" || $type eq "permblock") {
	return &text("log_${action}_${type}",
		     "<tt>".&html_escape($object)."</tt>");
	}
else {
	return $text{"log_${action}"};
	}
}


=== ./background/webmin-plugins/firewalld/module.info.pl ===

desc_pl=FirewallD
longdesc_pl=Konfiguracja Firewalla Linuksa używając FirewallD, poprzez edytowanie dozwolonych usług i portów.

=== ./background/webmin-plugins/firewalld/open-ports.pl ===

#!/usr/local/bin/perl
# Open some ports on the firewall. Exit statuses are :
# 0 - Nothing needed to be done
# 1 - Given ports were opened up
# 2 - IPtables is not installed or supported
# 3 - No firewall is active
# 4 - Could not apply configuration
# 5 - Bad args

use strict;
use warnings;
no warnings 'redefine';
no warnings 'uninitialized';
our ($module_name, $no_acl_check);
$no_acl_check++;
$ENV{'WEBMIN_CONFIG'} = "/etc/webmin";
$ENV{'WEBMIN_VAR'} = "/var/webmin";
if ($0 =~ /^(.*\/)[^\/]+$/) {
	chdir($1);
	}
require './firewalld-lib.pl';
if ($module_name ne 'firewalld') {
	print STDERR "Command must be run with full path\n";
	exit(5);
	}

# Parse args
my $no_apply = 0;
if ($ARGV[0] eq "--no-apply") {
	$no_apply = 1;
	shift(@ARGV);
	}
if (!@ARGV) {
	print STDERR "Missing ports to open\n";
	exit(5);
	}
foreach my $p (@ARGV) {
	if ($p !~ /^\d+$/ && $p !~ /^\d+:\d+$/ && $p !~ /^\d+(,\d+)*$/) {
		print STDERR "Port $p must be number or start:end range\n";
		exit(5);
		}
	}

# Check Firewalld support
if (&foreign_installed($module_name, 1) != 2) {
	print STDERR "Firewalld is not available\n";
	exit(2);
	}
if (!&is_firewalld_running()) {
	print STDERR "Firewalld is not running\n";
	exit(2);
	}

# Check if any zones are active
my @azones = &list_firewalld_zones(1);
if (!@azones) {
	print STDERR "No active FirewallD zones found\n";
	exit(3);
	}

# Get the default zone
my @zones = &list_firewalld_zones();
my ($zone) = grep { $_->{'default'} } @zones;
if (!$zone) {
	print STDERR "Default FirewallD zone not found\n";
	exit(3);
	}

my @added = ( );
foreach my $p (@ARGV) {
	# For each port, find existing rules
	$p =~ s/^(\d+):(\d+)/$1-$2/;
	print STDERR "Checking for port $p ..\n";
	if (&indexof($p."/tcp", @{$zone->{'ports'}}) >= 0) {
		print STDERR ".. already allowed\n";
		}
	else {
		# Need to add
		my $err = &create_firewalld_port($zone, $p, "tcp");
		if ($err) {
			print STDERR ".. failed : $err\n";
			}
		else {
			push(@added, $p);
			}
		}
	}

if (@added) {
	# Added some ports - apply them
	print STDERR "Opened ports ",join(" ", @added),"\n";
	my $ex = 1;
	if (!$no_apply) {
		my $err = &apply_firewalld();
		if ($err) {
			print "Failed to apply configuration : $err\n";
			$ex = 4;
			}
		else {
			print "Applied configuration successfully\n";
			}
		}
	&webmin_log("openports", undef, undef, { 'ports' => \@added });
	exit($ex);
	}
else {
	print STDERR "All ports are already open\n";
	exit(0);
	}

=== ./claude_proj_gather_script.sh ===

#!/bin/bash
# Claude Projects File Gatherer - Enhanced Version
# Add to any project in .claude_proj/ directory for instant Claude Projects integration
# Consolidates code, docs, and config files into readable text files

set -e  # Exit on any error

echo "Claude Projects File Gatherer - Enhanced Edition"
echo "   Optimizing your project for Claude Projects integration..."
echo ""

# Function to detect if we're in a project root
detect_project_root() {
    local indicators=()
    
    # Check for common project root indicators
    [ -f "README.md" ] && indicators+=("README.md")
    [ -f "README.rst" ] && indicators+=("README.rst")
    [ -f "requirements.txt" ] && indicators+=("requirements.txt")
    [ -f "package.json" ] && indicators+=("package.json")
    [ -f "pyproject.toml" ] && indicators+=("pyproject.toml")
    [ -f "setup.py" ] && indicators+=("setup.py")
    [ -f "Cargo.toml" ] && indicators+=("Cargo.toml")
    [ -f "pom.xml" ] && indicators+=("pom.xml")
    [ -f "build.gradle" ] && indicators+=("build.gradle")
    [ -f "go.mod" ] && indicators+=("go.mod")
    [ -f "Makefile" ] && indicators+=("Makefile")
    [ -f "docker-compose.yml" ] && indicators+=("docker-compose.yml")
    [ -f "Dockerfile" ] && indicators+=("Dockerfile")
    [ -d ".git" ] && indicators+=(".git/")
    [ -d "src" ] && indicators+=("src/")
    [ -d "docs" ] && indicators+=("docs/")
    [ -d ".claude_proj" ] && indicators+=(".claude_proj/")
    
    echo "${indicators[@]}"
}

# Check if we appear to be in a project root
echo "Detecting project structure..."
project_indicators=($(detect_project_root))

if [ ${#project_indicators[@]} -eq 0 ]; then
    echo "WARNING: No common project files detected in current directory!"
    echo "   Current directory: $(pwd)"
    echo ""
    echo "   Common project indicators not found:"
    echo "   - README.md/README.rst"
    echo "   - package.json, requirements.txt, Cargo.toml, go.mod"
    echo "   - .git directory"
    echo "   - src/ or docs/ directories"
    echo ""
    echo "   Are you sure you're in the project root directory?"
    echo "   (Hint: You should run this from where your main project files are,"
    echo "    not from inside the .claude_proj directory)"
    read -p "   Continue anyway? (y/N): " continue_anyway
    
    case $continue_anyway in
        [Yy]|[Yy][Ee][Ss])
            echo "   Continuing in current directory..."
            ;;
        *)
            echo "   Exiting. Please navigate to your project root directory first."
            echo "   Tip: Look for directories containing README.md, package.json, etc."
            exit 1
            ;;
    esac
else
    echo "Project root detected! Found indicators:"
    printf "   - %s\n" "${project_indicators[@]}"
fi
echo ""

PROJECT_DIR="claude_project_files"

# Check if directory exists and handle it
if [ -d "$PROJECT_DIR" ]; then
    echo "Directory $PROJECT_DIR already exists!"
    echo "Choose an option:"
    echo "  1) Remove existing directory and recreate"
    echo "  2) Add timestamp suffix (e.g., claude_project_files_20241206_143022)"
    echo "  3) Exit without changes"
    read -p "Enter choice (1/2/3): " choice
    
    case $choice in
        1)
            echo "Removing existing directory..."
            rm -rf "$PROJECT_DIR"
            ;;
        2)
            TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
            PROJECT_DIR="${PROJECT_DIR}_${TIMESTAMP}"
            echo "Using timestamped directory: $PROJECT_DIR"
            ;;
        3)
            echo "Exiting without changes"
            exit 0
            ;;
        *)
            echo "Invalid choice. Exiting."
            exit 1
            ;;
    esac
fi

echo "Creating Claude Projects directory: $PROJECT_DIR"

# Create the directory
mkdir -p "$PROJECT_DIR"

# Function to safely add file separator
add_separator() {
    local filename="$1"
    local output_file="$2"
    echo "" >> "$output_file"
    echo "=== $filename ===" >> "$output_file"
    echo "" >> "$output_file"
}

# 1. Gather all code files
echo "Gathering code files..."
CODE_FILE="$PROJECT_DIR/all_code.txt"
> "$CODE_FILE"  # Clear file

echo "# PROJECT CODE CONSOLIDATION" > "$CODE_FILE"
echo "# Generated on: $(date)" >> "$CODE_FILE"
echo "# Project: $(basename $(pwd))" >> "$CODE_FILE"
echo "# Claude Projects Integration" >> "$CODE_FILE"
echo "" >> "$CODE_FILE"

# Find and consolidate code files (comprehensive language support)
find . -type f \( \
    -name "*.py" -o \
    -name "*.js" -o \
    -name "*.ts" -o \
    -name "*.jsx" -o \
    -name "*.tsx" -o \
    -name "*.java" -o \
    -name "*.cpp" -o \
    -name "*.c" -o \
    -name "*.h" -o \
    -name "*.hpp" -o \
    -name "*.cs" -o \
    -name "*.go" -o \
    -name "*.rs" -o \
    -name "*.rb" -o \
    -name "*.php" -o \
    -name "*.swift" -o \
    -name "*.kt" -o \
    -name "*.scala" -o \
    -name "*.r" -o \
    -name "*.R" -o \
    -name "*.pl" -o \
    -name "*.pm" -o \
    -name "*.sh" -o \
    -name "*.bash" -o \
    -name "*.zsh" -o \
    -name "*.fish" -o \
    -name "*.sql" -o \
    -name "*.lua" -o \
    -name "*.dart" -o \
    -name "*.ex" -o \
    -name "*.exs" -o \
    -name "*.elm" -o \
    -name "*.hs" -o \
    -name "*.clj" -o \
    -name "*.cljs" -o \
    -name "*.fs" -o \
    -name "*.fsx" -o \
    -name "*.ml" -o \
    -name "*.vim" -o \
    -name "*.proto" -o \
    -name "*.graphql" -o \
    -name "*.gql" \
\) \
    -not -path "./.git/*" \
    -not -path "./node_modules/*" \
    -not -path "./__pycache__/*" \
    -not -path "./build/*" \
    -not -path "./dist/*" \
    -not -path "./.venv/*" \
    -not -path "./venv/*" \
    -not -path "./.pytest_cache/*" \
    -not -path "./docs/build/*" \
    -not -path "./docs/_build/*" \
    -not -path "./target/*" \
    -not -path "./.cargo/*" \
    -not -path "./vendor/*" \
    -not -path "./.claude_proj/*" \
    | sort | while read -r file; do
    if [ -s "$file" ]; then  # Only process non-empty files
        add_separator "$file" "$CODE_FILE"
        cat "$file" >> "$CODE_FILE"
    fi
done

echo "Code files saved to: $CODE_FILE"

# 2. Gather configuration files
echo "Gathering configuration files..."
CONFIG_FILE="$PROJECT_DIR/all_config.txt"
> "$CONFIG_FILE"

echo "# PROJECT CONFIGURATION FILES" > "$CONFIG_FILE"
echo "# Generated on: $(date)" >> "$CONFIG_FILE"
echo "# For Claude Projects upload and caching" >> "$CONFIG_FILE"
echo "" >> "$CONFIG_FILE"

# Find and consolidate config files
find . -type f \( \
    -name "*.yml" -o \
    -name "*.yaml" -o \
    -name "*.json" -o \
    -name "*.toml" -o \
    -name "*.ini" -o \
    -name "*.cfg" -o \
    -name "*.conf" -o \
    -name "*.env" -o \
    -name ".env*" -o \
    -name "*.xml" -o \
    -name "Dockerfile*" -o \
    -name "*.dockerfile" -o \
    -name "requirements.txt" -o \
    -name "package.json" -o \
    -name "package-lock.json" -o \
    -name "yarn.lock" -o \
    -name "Pipfile" -o \
    -name "Pipfile.lock" -o \
    -name "poetry.lock" -o \
    -name "pyproject.toml" -o \
    -name "setup.py" -o \
    -name "setup.cfg" -o \
    -name "Cargo.toml" -o \
    -name "Cargo.lock" -o \
    -name "go.mod" -o \
    -name "go.sum" -o \
    -name "pom.xml" -o \
    -name "build.gradle" -o \
    -name "gradle.properties" -o \
    -name "Makefile" -o \
    -name "makefile" -o \
    -name "*.mk" -o \
    -name "CMakeLists.txt" -o \
    -name ".gitignore" -o \
    -name ".gitattributes" -o \
    -name "*.editorconfig" \
\) \
    -not -path "./.git/*" \
    -not -path "./node_modules/*" \
    -not -path "./build/*" \
    -not -path "./dist/*" \
    -not -path "./docs/build/*" \
    -not -path "./docs/_build/*" \
    -not -path "./target/*" \
    -not -path "./vendor/*" \
    -not -path "./.claude_proj/*" \
    | sort | while read -r file; do
    if [ -s "$file" ]; then
        add_separator "$file" "$CONFIG_FILE"
        cat "$file" >> "$CONFIG_FILE"
    fi
done

echo "Configuration files saved to: $CONFIG_FILE"

# 3. Gather documentation files
echo "Gathering documentation files..."
DOCS_FILE="$PROJECT_DIR/all_docs.txt"
> "$DOCS_FILE"

echo "# PROJECT DOCUMENTATION" > "$DOCS_FILE"
echo "# Generated on: $(date)" >> "$DOCS_FILE"
echo "# Source documentation files for Claude Projects" >> "$DOCS_FILE"
echo "" >> "$DOCS_FILE"

# Find and consolidate documentation files
find . -type f \( \
    -name "*.rst" -o \
    -name "*.md" -o \
    -name "*.markdown" -o \
    -name "*.txt" -o \
    -name "*.css" -o \
    -name "*.html" -o \
    -name "*.htm" -o \
    -name "*.tex" -o \
    -name "*.adoc" -o \
    -name "*.asciidoc" -o \
    -name "README*" -o \
    -name "CHANGELOG*" -o \
    -name "CONTRIBUTING*" -o \
    -name "LICENSE*" -o \
    -name "INSTALL*" -o \
    -name "AUTHORS*" -o \
    -name "CREDITS*" -o \
    -name "USAGE*" -o \
    -name "EXAMPLES*" \
\) \
    -not -path "./.git/*" \
    -not -path "./node_modules/*" \
    -not -path "./build/*" \
    -not -path "./dist/*" \
    -not -path "./docs/build/*" \
    -not -path "./docs/_build/*" \
    -not -path "./_build/*" \
    -not -path "./site/*" \
    -not -path "./_site/*" \
    -not -path "./public/*" \
    -not -path "./.venv/*" \
    -not -path "./venv/*" \
    -not -path "./.next/*" \
    -not -path "./.nuxt/*" \
    -not -path "./target/doc/*" \
    -not -path "./vendor/*" \
    -not -path "./.claude_proj/*" \
    | sort | while read -r file; do
    if [ -s "$file" ]; then
        add_separator "$file" "$DOCS_FILE"
        cat "$file" >> "$DOCS_FILE"
    fi
done

echo "Documentation files saved to: $DOCS_FILE"

# 4. Copy important individual files
echo "Copying key individual files..."

# Copy critical files that should be uploaded separately
for file in README.md requirements.txt package.json pyproject.toml docker-compose.yml Dockerfile go.mod Cargo.toml pom.xml; do
    if [ -f "$file" ]; then
        cp "$file" "$PROJECT_DIR/"
        echo "  Copied: $file"
    fi
done

# Copy important config files from common locations
if [ -f "docs/source/conf.py" ]; then
    cp "docs/source/conf.py" "$PROJECT_DIR/"
    echo "  Copied: docs/source/conf.py"
fi

if [ -f ".claude_proj/gather_files.sh" ]; then
    cp ".claude_proj/gather_files.sh" "$PROJECT_DIR/gather_files_script.sh"
    echo "  Copied: .claude_proj/gather_files.sh"
fi

# 5. Create project structure overview
echo "Creating project structure overview..."
STRUCTURE_FILE="$PROJECT_DIR/project_structure.txt"

echo "# PROJECT STRUCTURE OVERVIEW" > "$STRUCTURE_FILE"
echo "# Generated on: $(date)" >> "$STRUCTURE_FILE"
echo "# Directory: $(pwd)" >> "$STRUCTURE_FILE"
echo "# For Claude Projects context and understanding" >> "$STRUCTURE_FILE"
echo "" >> "$STRUCTURE_FILE"

# Create tree-like structure (if tree command exists, otherwise use find)
if command -v tree >/dev/null 2>&1; then
    echo "## Directory Tree:" >> "$STRUCTURE_FILE"
    tree -I '__pycache__|*.pyc|node_modules|.git|build|dist|.venv|venv|target|vendor|.claude_proj' -L 4 >> "$STRUCTURE_FILE"
else
    echo "## Directory Structure (find-based):" >> "$STRUCTURE_FILE"
    find . -type d \
        -not -path "./.git*" \
        -not -path "./node_modules*" \
        -not -path "./__pycache__*" \
        -not -path "./build*" \
        -not -path "./dist*" \
        -not -path "./.venv*" \
        -not -path "./venv*" \
        -not -path "./target*" \
        -not -path "./vendor*" \
        -not -path "./.claude_proj*" \
        | head -50 | sort >> "$STRUCTURE_FILE"
fi

echo "" >> "$STRUCTURE_FILE"
echo "## File Count Summary:" >> "$STRUCTURE_FILE"
echo "Total source files: $(find . -name "*.py" -o -name "*.js" -o -name "*.go" -o -name "*.rs" -o -name "*.java" -o -name "*.cs" | wc -l)" >> "$STRUCTURE_FILE"
echo "Configuration files: $(find . -name "*.yml" -o -name "*.yaml" -o -name "*.json" -o -name "*.toml" | wc -l)" >> "$STRUCTURE_FILE"
echo "Documentation files: $(find . -name "*.rst" -o -name "*.md" | wc -l)" >> "$STRUCTURE_FILE"

# Detect primary language/framework
echo "" >> "$STRUCTURE_FILE"
echo "## Detected Technology Stack:" >> "$STRUCTURE_FILE"
[ -f "package.json" ] && echo "- Node.js/JavaScript (package.json found)" >> "$STRUCTURE_FILE"
[ -f "requirements.txt" ] && echo "- Python (requirements.txt found)" >> "$STRUCTURE_FILE"
[ -f "pyproject.toml" ] && echo "- Modern Python (pyproject.toml found)" >> "$STRUCTURE_FILE"
[ -f "Cargo.toml" ] && echo "- Rust (Cargo.toml found)" >> "$STRUCTURE_FILE"
[ -f "go.mod" ] && echo "- Go (go.mod found)" >> "$STRUCTURE_FILE"
[ -f "pom.xml" ] && echo "- Java Maven (pom.xml found)" >> "$STRUCTURE_FILE"
[ -f "build.gradle" ] && echo "- Java/Kotlin Gradle (build.gradle found)" >> "$STRUCTURE_FILE"
[ -d "docs/source" ] && echo "- Sphinx Documentation (docs/source/ found)" >> "$STRUCTURE_FILE"
[ -f "docker-compose.yml" ] && echo "- Docker Compose (docker-compose.yml found)" >> "$STRUCTURE_FILE"

echo "Project structure saved to: $STRUCTURE_FILE"

# 6. Create upload instructions with .claude_proj context
echo "Creating upload instructions..."
INSTRUCTIONS_FILE="$PROJECT_DIR/UPLOAD_INSTRUCTIONS.txt"

cat > "$INSTRUCTIONS_FILE" << 'EOF'
# CLAUDE PROJECT UPLOAD INSTRUCTIONS

## Quick Setup Summary:
This project uses the .claude_proj/ toolkit for Claude Projects integration.
All files in this directory were automatically generated and optimized for 
Claude Projects caching and token efficiency.

## Files to Upload to Claude Projects Knowledge Base:

### PRIORITY 1 (Upload these first for maximum token efficiency):
1. all_code.txt          - All source code consolidated (CACHED FOREVER)
2. all_config.txt        - Configuration files (CACHED FOREVER)
3. project_structure.txt - Project overview (CACHED FOREVER)
4. README.md             - Main project documentation

### PRIORITY 2 (Upload for complete context):
5. all_docs.txt          - All documentation files
6. Key config files individually (requirements.txt, package.json, etc.)

### PRIORITY 3 (Optional for specific needs):
7. gather_files_script.sh - The script that generated these files
8. Any project-specific files Claude requests

## Upload Tips:
- Upload files one by one if drag-and-drop fails
- If file upload fails, copy/paste content into a new text file
- Focus on Priority 1 files for immediate productivity gains
- The consolidated files provide 90% token savings through caching

## Claude Projects Custom Instructions Template:

Add this to your Claude Project custom instructions (customize for your stack):

"You are an expert developer working on [PROJECT_NAME]. This project contains:

TECHNOLOGY STACK: [List your main technologies from project_structure.txt]
PROJECT TYPE: [Brief description - e.g., 'web application', 'CLI tool', 'library']
DEVELOPMENT STAGE: [e.g., 'prototype', 'production', 'refactoring']

UPLOADED CONTEXT:
- Complete codebase in consolidated format (all_code.txt)
- Full configuration and build setup (all_config.txt)  
- Project structure and organization (project_structure.txt)
- Documentation and README files

PRIORITIES:
1. Reference the uploaded codebase context for all suggestions
2. Maintain consistency with existing architecture and patterns
3. Focus on production-quality code with proper error handling
4. Consider performance, security, and maintainability
5. Suggest improvements that align with the project's technology stack

When making suggestions, always consider the full context of the uploaded 
codebase and maintain consistency with established patterns."

## Language-Specific Enhancement:

Your project appears to use: [CHECK project_structure.txt for detected technologies]

If the gather_files.sh script missed file types specific to your technology stack,
you can enhance it using Claude Code CLI:

1. Navigate to your .claude_proj directory
2. Start Claude Code CLI: claude-code
3. Use this prompt:

"I have a gather_files.sh script that consolidates project files for Claude Projects.
Please analyze my project structure and create an enhanced version that includes
any missing file types for my specific technology stack.

CURRENT SCRIPT: [paste contents of gather_files.sh]
PROJECT TYPE: [describe your stack]

Please create gather_files_v2.sh with additional file types and exclusions
relevant to my technology stack."

## Next Steps:
1. Upload Priority 1 files to your Claude Project
2. Set up custom instructions using the template above
3. Test the setup with a simple question about your codebase
4. Consider enhancing the script for your specific technology needs

## Maintenance:
- Re-run ./.claude_proj/gather_files.sh when you make significant changes
- Update Claude Project files periodically to maintain context
- The cached content in Claude Projects never expires, providing permanent efficiency

EOF

echo "Upload instructions saved to: $INSTRUCTIONS_FILE"

# 7. Create CLI integration prompts
echo "Creating Claude Code CLI integration prompts..."
mkdir -p "$PROJECT_DIR/cli_prompts"

# Setup prompt
cat > "$PROJECT_DIR/cli_prompts/setup_enhancement.md" << 'EOF'
# Claude Code CLI Enhancement Prompt

Use this prompt in Claude Code CLI to enhance the gather_files.sh script for your specific technology stack:

```
I have a .claude_proj directory with a gather_files.sh script for consolidating 
project files for Claude Projects integration.

Please analyze my project structure and file types to determine if the current 
script covers all relevant text files for my technology stack.

CURRENT SCRIPT ANALYSIS NEEDED:
1. Review what file extensions the script currently handles
2. Identify any missing file types for my specific technology stack
3. Look for technology-specific configuration files not covered
4. Check for specialized documentation formats

PROJECT DETAILS:
- Technology stack: [DESCRIBE YOUR STACK]
- Primary language: [YOUR MAIN LANGUAGE]
- Framework/tools: [LIST KEY FRAMEWORKS]
- Special requirements: [ANY UNIQUE FILE TYPES]

DELIVERABLES:
1. Create gather_files_v2.sh with enhanced file type coverage
2. Add any missing exclusion patterns for build artifacts
3. Include technology-specific configuration files
4. Explain what was added and why it's important for Claude Projects

Focus on text-based files that Claude can read and understand. 
Skip binary formats but include any text-based config or source files 
specific to my technology stack.
```
EOF

# Maintenance prompt
cat > "$PROJECT_DIR/cli_prompts/project_maintenance.md" << 'EOF'
# Claude Projects Maintenance Prompt

Use this prompt in Claude Code CLI to update your Claude Project files after significant changes:

```
I have an existing Claude Project with cached codebase context. I've made 
significant changes to my local project and need to update the Claude Project 
files to maintain synchronization.

CURRENT CLAUDE PROJECT SETUP:
- Project name: [YOUR PROJECT NAME]
- Last updated: [DATE OF LAST UPDATE]
- Main files uploaded: all_code.txt, all_config.txt, project_structure.txt

RECENT CHANGES MADE:
[DESCRIBE WHAT YOU CHANGED - e.g., "Added new API endpoints", "Refactored database models", "Updated build configuration"]

TASKS NEEDED:
1. Analyze what has changed since the last Claude Project update
2. Generate new consolidated files (all_code.txt, all_config.txt, all_docs.txt)
3. Create a change summary explaining what's different
4. Update the project structure overview
5. Provide upload instructions for the changed files

Please focus on maintaining the efficiency of Claude Projects caching while 
ensuring the context stays current with my development work.
```
EOF

# Coordination prompt
cat > "$PROJECT_DIR/cli_prompts/cli_coordination.md" << 'EOF'
# Claude Code CLI + Projects Coordination Prompt

Use this prompt in Claude Code CLI when you want to coordinate between local development and your Claude Project:

```
I have a Claude Project called "[PROJECT_NAME]" with my complete codebase 
uploaded and cached. I want to work on [SPECIFIC_FEATURE/TASK] using Claude Code CLI 
while maintaining consistency with the broader project context.

CLAUDE PROJECT CONTEXT:
- Complete codebase cached in Claude Projects web interface  
- Project structure and architecture established
- Documentation and configuration files uploaded

CURRENT LOCAL WORK:
- Feature/task: [DESCRIBE WHAT YOU'RE WORKING ON]
- Files involved: [LIST KEY FILES YOU'LL MODIFY]
- Scope: [LOCAL CHANGES vs ARCHITECTURAL CHANGES]

COORDINATION NEEDS:
1. Reference the cached project context when making suggestions
2. Ensure consistency with existing architecture and patterns
3. Focus on the specific files and features I'm working on locally
4. Maintain code style and conventions from the broader codebase

Please help with [SPECIFIC_REQUEST] while keeping in mind the full project 
context that's available in my Claude Project knowledge base.
```
EOF

echo "CLI integration prompts saved to: $PROJECT_DIR/cli_prompts/"

# 8. Final summary and next steps
echo ""
echo "SUCCESS! Claude Projects integration ready"
echo ""
echo "Generated files in $PROJECT_DIR/:"
ls -la "$PROJECT_DIR" | grep -v "^total"
echo ""
echo "CLI coordination prompts in $PROJECT_DIR/cli_prompts/:"
ls -la "$PROJECT_DIR/cli_prompts/" | grep -v "^total"
echo ""
echo "NEXT STEPS:"
echo ""
echo "1. UPLOAD TO CLAUDE PROJECTS:"
echo "   * Go to claude.ai and create a new Project"
echo "   * Upload files from $PROJECT_DIR/ (start with Priority 1 files)"
echo "   * Follow instructions in UPLOAD_INSTRUCTIONS.txt"
echo ""
echo "2. SET UP PROJECT:"
echo "   * Add custom instructions using the template in UPLOAD_INSTRUCTIONS.txt"
echo "   * Test with a simple question about your codebase"
echo ""
echo "3. ENHANCE IF NEEDED:"
echo "   * Use prompts in cli_prompts/ to customize for your tech stack"
echo "   * Create enhanced versions (v2, v3) for specialized file types"
echo ""
echo "4. MAINTAIN:"
echo "   * Re-run this script when you make significant changes"
echo "   * Update Claude Project files to keep context current"
echo ""
echo "BENEFITS YOU'LL GET:"
echo "   * 90% token savings through Claude Projects caching"
echo "   * Persistent codebase knowledge across all conversations"
echo "   * No more re-uploading files or explaining project structure"
echo "   * Professional AI assistance tailored to YOUR specific project"
echo ""
echo "For complete guidance, see the Claude Projects documentation at:"
echo "   https://github.com/yourname/claude-project-connector"
echo ""
echo "Your project is now optimized for Claude Projects efficiency!"

=== ./webmin-firewalld-rich-rules/firewalld/firewalld-lib-extension.pl ===

# Extension to firewalld-lib.pl for rich rules UI support
# This file should be included at the end of firewalld-lib.pl

# Include the rich rules library
do 'firewalld-rich-lib.pl';

# Override or extend existing functions if needed

# Enhanced version of list_firewalld_zones to include rich rules count
sub list_firewalld_zones_with_rich_rules {
	my ($active) = @_;
	my @zones = &list_firewalld_zones($active);
	
	foreach my $zone (@zones) {
		my @rich_rules = &list_rich_rules($zone->{'name'});
		$zone->{'rich_rules_count'} = scalar(@rich_rules);
	}
	
	return @zones;
}

# Get firewalld version for compatibility checks
sub get_firewalld_version {
	my $out = &backquote_command("$config{'firewall_cmd'} --version 2>&1");
	if ($out =~ /(\d+\.\d+\.\d+)/) {
		return $1;
	}
	return "unknown";
}

# Check if rich rules are supported
sub rich_rules_supported {
	my $version = &get_firewalld_version();
	return $version ne "unknown" && $version ge "0.3.0";
}

# Get rich rules help text
sub get_rich_rules_help {
	my $out = &backquote_command("$config{'firewall_cmd'} --help 2>&1");
	
	if ($out =~ /rich-rule/i) {
		return 1;
	}
	return 0;
}

# Test if a specific rich rule feature is available
sub test_rich_rule_feature {
	my ($feature) = @_;
	
	# Test features by trying to create a temporary rule
	my $test_rule = "";
	
	if ($feature eq "priority") {
		$test_rule = 'rule priority="100" accept';
	} elsif ($feature eq "audit") {
		$test_rule = 'rule audit accept';
	} elsif ($feature eq "log_limit") {
		$test_rule = 'rule log limit value="1/m" accept';
	} else {
		return 0;
	}
	
	# Try to validate the rule
	my $cmd = "$config{'firewall_cmd'} --permanent --add-rich-rule='$test_rule' --timeout=1";
	my $out = &backquote_command($cmd." 2>&1");
	
	# Clean up any test rule that might have been added
	&backquote_command("$config{'firewall_cmd'} --permanent --remove-rich-rule='$test_rule' 2>/dev/null");
	
	return !$?;
}

# Get detailed firewalld information
sub get_firewalld_info {
	my %info = ();
	
	$info{'version'} = &get_firewalld_version();
	$info{'rich_rules_supported'} = &rich_rules_supported();
	$info{'backend'} = "unknown";
	
	# Try to detect backend
	my $out = &backquote_command("$config{'firewall_cmd'} --get-log-denied 2>&1");
	if ($out =~ /iptables|netfilter/) {
		$info{'backend'} = "iptables";
	} elsif ($out =~ /nftables/) {
		$info{'backend'} = "nftables";
	}
	
	return \%info;
}

# Generate rich rule template
sub generate_rich_rule_template {
	my ($type) = @_;
	
	my %templates = (
		'allow_ip' => 'rule family="ipv4" source address="192.168.1.100" accept',
		'block_ip' => 'rule family="ipv4" source address="192.168.1.100" drop',
		'allow_service' => 'rule family="ipv4" source address="192.168.1.0/24" service name="ssh" accept',
		'block_service' => 'rule family="ipv4" source address="192.168.1.0/24" service name="ssh" reject',
		'allow_port' => 'rule family="ipv4" source address="192.168.1.0/24" port port="8080" protocol="tcp" accept',
		'log_all' => 'rule family="ipv4" log prefix="FIREWALL: " level="info" accept',
		'rate_limit' => 'rule family="ipv4" service name="ssh" log limit value="3/m" accept',
		'mac_filter' => 'rule family="ipv4" source mac="00:11:22:33:44:55" accept',
		'interface_specific' => 'rule family="ipv4" source interface="eth0" accept',
		'priority_rule' => 'rule family="ipv4" priority="-100" source address="192.168.1.1" accept'
	);
	
	return $templates{$type} || $templates{'allow_ip'};
}

# Get rich rules examples for help
sub get_rich_rules_examples {
	return [
		{
			'title' => 'Allow specific IP',
			'rule' => 'rule family="ipv4" source address="192.168.1.100" accept',
			'description' => 'Allow all traffic from IP 192.168.1.100'
		},
		{
			'title' => 'Block IP range',
			'rule' => 'rule family="ipv4" source address="192.168.1.0/24" drop',
			'description' => 'Block all traffic from 192.168.1.0/24 network'
		},
		{
			'title' => 'Allow service with logging',
			'rule' => 'rule family="ipv4" service name="ssh" log prefix="SSH: " accept',
			'description' => 'Allow SSH service and log connections'
		},
		{
			'title' => 'Rate limit SSH',
			'rule' => 'rule family="ipv4" service name="ssh" log limit value="3/m" accept',
			'description' => 'Allow SSH but limit logging to 3 per minute'
		},
		{
			'title' => 'Block with custom reject',
			'rule' => 'rule family="ipv4" source address="192.168.1.100" reject type="icmp-admin-prohibited"',
			'description' => 'Block IP with admin prohibited ICMP message'
		}
	];
}

# Validate rich rule components
sub validate_rich_rule_components {
	my ($components) = @_;
	my @errors = ();
	
	# Validate family
	if ($components->{'family'} && $components->{'family'} !~ /^(ipv4|ipv6)$/) {
		push @errors, "Invalid family: must be ipv4 or ipv6";
	}
	
	# Validate priority
	if ($components->{'priority'} && 
	    ($components->{'priority'} !~ /^-?\d+$/ || 
	     $components->{'priority'} < -32768 || 
	     $components->{'priority'} > 32767)) {
		push @errors, "Invalid priority: must be between -32768 and 32767";
	}
	
	# Validate source address
	if ($components->{'source_address'}) {
		my $family = $components->{'family'} || 'ipv4';
		unless (&validate_ip_address($components->{'source_address'}, $family)) {
			push @errors, "Invalid source address";
		}
	}
	
	# Validate destination address
	if ($components->{'destination_address'}) {
		my $family = $components->{'family'} || 'ipv4';
		unless (&validate_ip_address($components->{'destination_address'}, $family)) {
			push @errors, "Invalid destination address";
		}
	}
	
	# Validate MAC address
	if ($components->{'source_mac'}) {
		unless ($components->{'source_mac'} =~ /^[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}$/) {
			push @errors, "Invalid MAC address format";
		}
	}
	
	# Validate port
	if ($components->{'port_number'}) {
		my $port = $components->{'port_number'};
		if ($port =~ /^(\d+)-(\d+)$/) {
			my ($low, $high) = ($1, $2);
			if ($low < 1 || $low > 65535 || $high < 1 || $high > 65535 || $low >= $high) {
				push @errors, "Invalid port range";
			}
		} elsif ($port !~ /^\d+$/ || $port < 1 || $port > 65535) {
			push @errors, "Invalid port number";
		}
	}
	
	# Validate service
	if ($components->{'service_name'}) {
		my @services = &list_firewalld_services();
		unless (grep { $_ eq $components->{'service_name'} } @services) {
			push @errors, "Unknown service: $components->{'service_name'}";
		}
	}
	
	# Validate log limit
	if ($components->{'log_limit'}) {
		unless ($components->{'log_limit'} =~ /^\d+\/[smhd]$/) {
			push @errors, "Invalid log limit format (use format like '5/m')";
		}
	}
	
	return @errors;
}

# Get rich rule performance impact estimate
sub estimate_rich_rule_performance {
	my ($rule) = @_;
	my $parsed = &parse_rich_rule($rule);
	my $impact = 0;
	
	# Base impact
	$impact += 1;
	
	# Source matching impact
	if ($parsed->{'source_type'} eq 'address') {
		$impact += 1;
	} elsif ($parsed->{'source_type'} eq 'mac') {
		$impact += 2;  # MAC matching is more expensive
	}
	
	# Service/port matching impact
	if ($parsed->{'service_type'} eq 'service') {
		$impact += 1;
	} elsif ($parsed->{'service_type'} eq 'port') {
		$impact += 1;
	}
	
	# Logging impact
	if ($parsed->{'log_enable'}) {
		$impact += 2;
	}
	
	# Audit impact
	if ($parsed->{'audit_enable'}) {
		$impact += 1;
	}
	
	return $impact;
}

1;
=== ./webmin-firewalld-rich-rules/firewalld/firewalld-rich-lib.pl ===

# Rich rules UI functions for firewalld
# This file extends firewalld-lib.pl with additional functions for rich rules management

# list_rich_rules(zone_name)
# Returns an array of rich rules for the specified zone
sub list_rich_rules {
	my ($zone_name) = @_;
	
	# Get permanent rich rules
	my $cmd = "$config{'firewall_cmd'} --permanent --zone=".quotemeta($zone_name).
		  " --list-rich-rules";
	my $out = &backquote_command($cmd." 2>&1");
	
	if ($?) {
		return ();
	}
	
	my @rules = split(/\n/, $out);
	@rules = grep { /\S/ } @rules;  # Remove empty lines
	
	return @rules;
}

# parse_rich_rule(rule_text)
# Parses a rich rule text and returns a hash with components
sub parse_rich_rule {
	my ($rule_text) = @_;
	my %parsed = ();
	
	# Remove leading/trailing whitespace
	$rule_text =~ s/^\s+|\s+$//g;
	
	# Basic rule structure: rule [options] action
	if ($rule_text !~ /^rule\s+(.+)\s+(accept|reject|drop)(\s+.*)?$/) {
		return \%parsed;
	}
	
	my $rule_body = $1;
	my $action = $2;
	my $action_params = $3 || "";
	
	$parsed{'action'} = $action;
	
	# Parse action parameters (for reject type)
	if ($action eq "reject" && $action_params =~ /type="([^"]+)"/) {
		$parsed{'reject_type'} = $1;
	}
	
	# Parse family
	if ($rule_body =~ /family="(ipv[46])"/) {
		$parsed{'family'} = $1;
		$rule_body =~ s/family="ipv[46]"\s*//;
	}
	
	# Parse priority
	if ($rule_body =~ /priority="(-?\d+)"/) {
		$parsed{'priority'} = $1;
		$rule_body =~ s/priority="-?\d+"\s*//;
	}
	
	# Parse source
	if ($rule_body =~ /source(\s+NOT)?\s+address="([^"]+)"/) {
		$parsed{'source_type'} = "address";
		$parsed{'source_address'} = $2;
		$parsed{'source_invert'} = defined($1) ? 1 : 0;
		$rule_body =~ s/source(\s+NOT)?\s+address="[^"]+"\s*//;
	}
	elsif ($rule_body =~ /source\s+mac="([^"]+)"/) {
		$parsed{'source_type'} = "mac";
		$parsed{'source_mac'} = $1;
		$rule_body =~ s/source\s+mac="[^"]+"\s*//;
	}
	elsif ($rule_body =~ /source\s+interface="([^"]+)"/) {
		$parsed{'source_type'} = "interface";
		$parsed{'source_interface'} = $1;
		$rule_body =~ s/source\s+interface="[^"]+"\s*//;
	}
	
	# Parse destination
	if ($rule_body =~ /destination(\s+NOT)?\s+address="([^"]+)"/) {
		$parsed{'destination_address'} = $2;
		$parsed{'destination_invert'} = defined($1) ? 1 : 0;
		$rule_body =~ s/destination(\s+NOT)?\s+address="[^"]+"\s*//;
	}
	
	# Parse service
	if ($rule_body =~ /service\s+name="([^"]+)"/) {
		$parsed{'service_type'} = "service";
		$parsed{'service_name'} = $1;
		$rule_body =~ s/service\s+name="[^"]+"\s*//;
	}
	
	# Parse port
	if ($rule_body =~ /port\s+port="([^"]+)"\s+protocol="([^"]+)"/) {
		$parsed{'service_type'} = "port";
		$parsed{'port_number'} = $1;
		$parsed{'port_protocol'} = $2;
		$rule_body =~ s/port\s+port="[^"]+"\s+protocol="[^"]+"\s*//;
	}
	
	# Parse protocol
	if ($rule_body =~ /protocol\s+value="([^"]+)"/) {
		$parsed{'service_type'} = "protocol";
		$parsed{'protocol_name'} = $1;
		$rule_body =~ s/protocol\s+value="[^"]+"\s*//;
	}
	
	# Parse logging
	if ($rule_body =~ /log(\s+prefix="([^"]+)")?(\s+level="([^"]+)")?(\s+limit\s+value="([^"]+)")?/) {
		$parsed{'log_enable'} = 1;
		$parsed{'log_prefix'} = $2 if $2;
		$parsed{'log_level'} = $4 if $4;
		$parsed{'log_limit'} = $6 if $6;
		$rule_body =~ s/log(\s+prefix="[^"]+"|)*(\s+level="[^"]+"|)*(\s+limit\s+value="[^"]+"|)*\s*//;
	}
	
	# Parse audit
	if ($rule_body =~ /audit/) {
		$parsed{'audit_enable'} = 1;
		$rule_body =~ s/audit\s*//;
	}
	
	# Check if rule is enabled (exists in runtime)
	$parsed{'enabled'} = &is_rich_rule_enabled($rule_text, $zone_name);
	
	return \%parsed;
}

# is_rich_rule_enabled(rule_text, zone_name)
# Check if a rich rule is currently active in runtime
sub is_rich_rule_enabled {
	my ($rule_text, $zone_name) = @_;
	
	my $cmd = "$config{'firewall_cmd'} --zone=".quotemeta($zone_name).
		  " --list-rich-rules";
	my $out = &backquote_command($cmd." 2>&1");
	
	return 0 if $?;
	
	# Check if rule exists in runtime
	return ($out =~ /\Q$rule_text\E/);
}

# encode_rich_rule_id(rule_text)
# Encode a rule text into a safe ID for use in forms
sub encode_rich_rule_id {
	my ($rule_text) = @_;
	
	# Simple base64-like encoding
	require MIME::Base64;
	return MIME::Base64::encode_base64url($rule_text);
}

# decode_rich_rule_id(rule_id)
# Decode a rule ID back to rule text
sub decode_rich_rule_id {
	my ($rule_id) = @_;
	
	require MIME::Base64;
	return MIME::Base64::decode_base64url($rule_id);
}

# get_rich_rule_display_info(rule_text)
# Get display-friendly information for a rich rule
sub get_rich_rule_display_info {
	my ($rule_text) = @_;
	my $parsed = &parse_rich_rule($rule_text);
	
	my %info = (
		'priority' => $parsed->{'priority'} || "0",
		'family' => $parsed->{'family'} || "ipv4",
		'source' => "-",
		'destination' => $parsed->{'destination_address'} || "-",
		'service' => "-",
		'action' => $parsed->{'action'} || "accept",
		'enabled' => $parsed->{'enabled'} ? 1 : 0
	);
	
	# Format source
	if ($parsed->{'source_type'} eq "address") {
		$info{'source'} = $parsed->{'source_address'};
		$info{'source'} = "NOT ".$info{'source'} if $parsed->{'source_invert'};
	}
	elsif ($parsed->{'source_type'} eq "mac") {
		$info{'source'} = "MAC:".$parsed->{'source_mac'};
	}
	elsif ($parsed->{'source_type'} eq "interface") {
		$info{'source'} = "IF:".$parsed->{'source_interface'};
	}
	
	# Format service
	if ($parsed->{'service_type'} eq "service") {
		$info{'service'} = $parsed->{'service_name'};
	}
	elsif ($parsed->{'service_type'} eq "port") {
		$info{'service'} = $parsed->{'port_number'}."/".$parsed->{'port_protocol'};
	}
	elsif ($parsed->{'service_type'} eq "protocol") {
		$info{'service'} = "proto:".$parsed->{'protocol_name'};
	}
	
	return \%info;
}

# validate_rich_rule_syntax(rule_text)
# Validate rich rule syntax using firewall-cmd
sub validate_rich_rule_syntax {
	my ($rule_text) = @_;
	
	# Try to parse the rule with firewall-cmd
	my $cmd = "$config{'firewall_cmd'} --check-rule='$rule_text'";
	my $out = &backquote_command($cmd." 2>&1");
	
	return $? ? $out : undef;
}

# get_rich_rule_conflicts(rule_text, zone_name)
# Check if a rich rule conflicts with existing rules
sub get_rich_rule_conflicts {
	my ($rule_text, $zone_name) = @_;
	my @conflicts = ();
	
	my @existing_rules = &list_rich_rules($zone_name);
	my $new_parsed = &parse_rich_rule($rule_text);
	
	foreach my $existing_rule (@existing_rules) {
		next if $existing_rule eq $rule_text;
		
		my $existing_parsed = &parse_rich_rule($existing_rule);
		
		# Check for conflicting rules with same source but different actions
		if ($new_parsed->{'source_type'} eq $existing_parsed->{'source_type'} &&
		    $new_parsed->{'source_address'} eq $existing_parsed->{'source_address'} &&
		    $new_parsed->{'service_type'} eq $existing_parsed->{'service_type'} &&
		    $new_parsed->{'service_name'} eq $existing_parsed->{'service_name'} &&
		    $new_parsed->{'action'} ne $existing_parsed->{'action'}) {
			push @conflicts, $existing_rule;
		}
	}
	
	return @conflicts;
}

# import_rich_rules_from_file(filename, zone_name)
# Import rich rules from a file
sub import_rich_rules_from_file {
	my ($filename, $zone_name) = @_;
	my @results = ();
	
	open(my $fh, '<', $filename) || return ( { 'error' => $! } );
	
	while (my $line = <$fh>) {
		chomp $line;
		next if $line =~ /^\s*#/ || $line =~ /^\s*$/;  # Skip comments and empty lines
		
		# Clean up the line
		$line =~ s/^\s+|\s+$//g;
		
		# Add the rule
		my $result = { 'rule' => $line };
		my $err = &add_rich_rule($line, { 'name' => $zone_name });
		
		if ($err) {
			$result->{'error'} = $err;
		} else {
			$result->{'success'} = 1;
		}
		
		push @results, $result;
	}
	
	close($fh);
	return @results;
}

# export_rich_rules_to_file(filename, zone_name)
# Export rich rules to a file
sub export_rich_rules_to_file {
	my ($filename, $zone_name) = @_;
	
	my @rules = &list_rich_rules($zone_name);
	
	open(my $fh, '>', $filename) || return $!;
	
	print $fh "# FirewallD Rich Rules Export\n";
	print $fh "# Zone: $zone_name\n";
	print $fh "# Generated: ".localtime()."\n";
	print $fh "#\n";
	print $fh "# To import these rules:\n";
	print $fh "# firewall-cmd --permanent --zone=$zone_name --add-rich-rule='RULE'\n";
	print $fh "#\n\n";
	
	foreach my $rule (@rules) {
		print $fh "$rule\n";
	}
	
	close($fh);
	return undef;
}

# get_rich_rule_statistics(zone_name)
# Get statistics about rich rules in a zone
sub get_rich_rule_statistics {
	my ($zone_name) = @_;
	
	my @rules = &list_rich_rules($zone_name);
	my %stats = (
		'total' => scalar(@rules),
		'enabled' => 0,
		'disabled' => 0,
		'accept' => 0,
		'reject' => 0,
		'drop' => 0,
		'ipv4' => 0,
		'ipv6' => 0,
		'with_logging' => 0,
		'with_audit' => 0
	);
	
	foreach my $rule (@rules) {
		my $parsed = &parse_rich_rule($rule);
		
		$stats{'enabled'}++ if $parsed->{'enabled'};
		$stats{'disabled'}++ if !$parsed->{'enabled'};
		$stats{$parsed->{'action'}}++ if $parsed->{'action'};
		$stats{$parsed->{'family'}}++ if $parsed->{'family'};
		$stats{'with_logging'}++ if $parsed->{'log_enable'};
		$stats{'with_audit'}++ if $parsed->{'audit_enable'};
	}
	
	return \%stats;
}

1;
=== ./claude_project_files/all_config.txt ===

# PROJECT CONFIGURATION FILES
# Generated on: Wed Jul  9 21:35:00 CEST 2025
# For Claude Projects upload and caching


=== ./.claude/settings.local.json ===

{
  "permissions": {
    "allow": [
      "WebFetch(domain:firewalld.org)",
      "Bash(mkdir:*)"
    ],
    "deny": []
  }
}
=== ./background/nftables-gui/.github/workflows/python-pytest.yml ===

name: Python Package

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python 3.10
      uses: actions/setup-python@v3
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Set PYTHONPATH
      run: echo "PYTHONPATH=$(pwd)/nftables-frontend" >> $GITHUB_ENV

    - name: List directory contents for debugging
      run: ls -R
      working-directory: nftables-frontend

    - name: Create necessary directories
      run: mkdir -p static/img
      working-directory: nftables-frontend

    - name: Create database directory
      run: mkdir -p instance
      working-directory: nftables-frontend

    - name: Lint with flake8
      run: |
        pip install flake8
        flake8 --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
      working-directory: nftables-frontend

    - name: Test with pytest
      run: |
        pip install pytest
        pytest
      working-directory: nftables-frontend

=== ./background/nftables-gui/.gitignore ===

# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class
report.html
report
assets
# C extensions
*.so
# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/#use-with-ide
.pdm.toml

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

=== ./background/nftables-gui/Dockerfile ===

FROM python
LABEL org.opencontainers.image.source=https://github.com/DZ-IO/nftables-gui
LABEL org.opencontainers.image.description="This is a repository to develop a web interface to enble configuration of nftables via GUI. (with docker support)"
LABEL org.opencontainers.image.licenses=GPLV3
COPY . /opt/app
WORKDIR /opt/app/nftables-frontend
RUN pip install \
gunicorn \
flask==3.0.1 \
flask-bootstrap==3.3.7.1 \
flask_sqlalchemy==3.1.1 \
flask-migrate==4.0.7 \
flask-login==0.6.3 \
flask-wtf==1.2.1 \
email_validator \
matplotlib \
python-Levenshtein requests \
&& apt-get update && apt-get install -y nftables \
python3-hug \
python3-nftables \
&& rm -rf /var/cache/* /var/log/* /tmp/*

VOLUME ["/opt/app/nftables-frontend/instance","/opt/app/nftables-frontend/static/img"]

ENTRYPOINT  ["/usr/local/bin/gunicorn","-c","gunicorn.conf.py"]
=== ./background/nftables-gui/nftables-frontend/migrations/alembic.ini ===

# A generic, single database configuration.

[alembic]
# template used to generate migration files
# file_template = %%(rev)s_%%(slug)s

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false


# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic,flask_migrate

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[logger_flask_migrate]
level = INFO
handlers =
qualname = flask_migrate

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

=== ./background/nftables-gui/nftables-frontend/nftables-config.conf ===

<VirtualHost *:8080>
    ServerName www.example.com
    ServerAlias example.com
    DocumentRoot /usr/share/nftables-frontend
    WSGIDaemonProcess nftables-frontend user=www-data group=www-data threads=5
    WSGIScriptAlias / /usr/share/nftables-frontend/run.wsgi
    <Directory /usr/share/nftables-frontend>
        WSGIProcessGroup nftables-frontend
        WSGIApplicationGroup %{GLOBAL}
        Options Indexes FollowSymLinks MultiViews
        AllowOverride All
        Require all granted
    </Directory>
    Alias /static /usr/share/nftables-frontend/static
    <Directory /usr/share/nftables-frontend/static>
        Require all granted
    </Directory>
    Alias /templates /usr/share/nftables-frontend/templates
    <Directory /usr/share/nftables-frontend/templates>
        Require all granted
    </Directory>
    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
</VirtualHost>

=== ./background/nftables-gui/nftables-parser/json_tests/create_rule.json ===


{"json_data": {"nftables":[ {"add": { "rule":{"family": "inet", "table": "filter", "chain": "input",  "expr": [
    {
      "counter": null
    }
  ] }}}]}}
=== ./background/nftables-gui/nftables-parser/json_tests/create_table.json ===

{
  "json_data": {
    "nftables": [
      {
        "add": {
          "table": {
            "family": "inet",
            "name": "my_table"
          }
        }
      }
    ]
  }
}
=== ./background/nftables-gui/nftables-parser/json_tests/delete_table.json ===

{"json_data": {"nftables": [{"delete": {"table":{"name": "table_name", "family": "ip"}}}]}}
=== ./background/nftables-gui/nftables-parser/json_tests/flush_table.json ===

{"json_data": {"nftables": [{"flush": {"table":{"name": "name", "family": "family"}}}]}}

=== ./background/nftables-gui/nftables-parser/json_tests/list_table.json ===

{"json_data": {"nftables": [{"list":{"table":{"name": "nat", "family": "ip"}}}]}}
=== ./background/nftables-gui/requirements.txt ===

flask==3.0.1
flask-bootstrap==3.3.7.1
flask_sqlalchemy==3.1.1
flask-migrate==4.0.7
flask-login==0.6.3
flask-wtf==1.2.1
hug
email_validator
matplotlib
python-Levenshtein
pytest
pytest-sugar
pytest-order
pytest-cov

=== ./background/relianoid/.gitignore ===

/build-pkg
/workdir
/*.deb

=== ./background/relianoid/etc/default/grub.d/relianoid.cfg ===

GRUB_DISTRIBUTOR="RELIANOID ADC Community Edition"
GRUB_CMDLINE_LINUX_DEFAULT="net.ifnames=0 quiet"
GRUB_TERMINAL=console
GRUB_TIMEOUT=10
=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/certificate_csr-create.json ===

{
   "action" : "add",
   "description" : "Create a Certificate Signing Request (CSR file).",
   "method" : "POST",
   "params" : {
      "country" : {
         "description" : "The two-letter ISO code for the country where your organization is localized.",
         "non_blank" : "true",
         "required" : "true"
      },
      "division" : {
         "description" : "The division of your organization handling the certificate.",
         "non_blank" : "true",
         "required" : "true"
      },
      "fqdn" : {
         "description" : "The fully qualified domain name of your server.",
         "format_msg" : "FQDN is not valid. It must be as these examples: domain.com, mail.domain.com, or *.domain.com. Try again.",
         "non_blank" : "true",
         "required" : "true"
      },
      "locality" : {
         "description" : "The city where your organization is located.",
         "non_blank" : "true",
         "required" : "true"
      },
      "mail" : {
         "description" : "An email address used to contact your organization.",
         "non_blank" : "true",
         "required" : "true"
      },
      "name" : {
         "description" : "Certificate ID name.",
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]+)",
         "required" : "true"
      },
      "organization" : {
         "description" : "The legal name of your organization.",
         "non_blank" : "true",
         "required" : "true"
      },
      "state" : {
         "description" : "The state/region where your organization is located.",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/certificates"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm-action.json ===

{
   "action" : "status",
   "description" : "Apply an action to a farm, see the Request parameters table for actions.",
   "method" : "PUT",
   "params" : {
      "action" : {
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "stop",
            "start",
            "restart"
         ]
      }
   },
   "url" : "/farms/<farmname>/actions"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm-create.json ===

{
   "action" : "create",
   "description" : "It creates a new farm.",
   "method" : "POST",
   "params" : {
      "copy_from" : {
         "description" : "This parameter expects the name of a farm that exists. If this parameter is sent, the farm is copied from the farm specified in it. The farmname, vip and vport values will be overwritten.",
         "format_msg" : "The farm name accepts alphabet letters, numbers or hypens (-).",
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]+)",
         "required" : "false"
      },
      "farmname" : {
         "description" : "Farm descriptive name. It is used as a unique identifier.",
         "exceptions" : [
            "0"
         ],
         "format_msg" : "The farm name accepts alphabet letters, numbers or hypens (-).",
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]+)",
         "required" : "true"
      },
      "profile" : {
         "description" : "The profile of the created Farm. For HTTP farms is http.",
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "http",
            "gslb",
            "l4xnat",
            "datalink",
            "eproxy"
         ]
      },
      "vip" : {
         "description" : "IP of the farm, where the virtual service is going to run. The indicated IP must be configured in the system and UP",
         "dyn_values" : "true",
         "required" : "true"
      },
      "vport" : {
         "depend_on" : "profile != datalink",
         "depend_on_msg" : "Mandatory if the profile is not datalink, else it is not expected",
         "description" : "Port of the farm where the virtual service is going to listen. The same virtual port and virtual IP must not be in use by another farm.",
         "format_msg" : "It expects a port number or multiport value for L4xnat farms",
         "non_blank" : "true",
         "regex" : "(?^:(?:\\*|(?:(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))|(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))\\:(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])))(?:,(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))|,(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))\\:(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])))*))"
      }
   },
   "url" : "/farms"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_certificate-add.json ===

{
   "action" : "add",
   "description" : "Include an available PEM Certificate to the SNI list or certlist array of an HTTP farm with an HTTPS listener.",
   "method" : "POST",
   "params" : {
      "file" : {
         "non_blank" : "true",
         "regex" : "(?^:(?^:(?:\\*[_|\\.])?\\w[\\w\\.\\(\\)\\@ \\-]*)\\.pem)",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/certificates"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_datalink-modify.json ===

{
   "action" : "set",
   "description" : "Modify the configuration of a datalink farm.",
   "method" : "PUT",
   "params" : {
      "algorithm" : {
         "non_blank" : "true",
         "values" : [
            "prio",
            "weight"
         ]
      },
      "newfarmname" : {
         "exceptions" : [
            "0"
         ],
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]+)"
      },
      "vip" : {
         "dyn_values" : "true",
         "format_msg" : "expects an IP",
         "non_blank" : "true"
      }
   },
   "url" : "/farm/<farmname>"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_datalink_service_backend-add.json ===

{
   "action" : "add",
   "description" : "Create a new Backend in a given datalink Farm.",
   "method" : "POST",
   "params" : {
      "interface" : {
         "non_blank" : "true",
         "required" : "true"
      },
      "ip" : {
         "format_msg" : "expects an IP",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))",
         "required" : "true"
      },
      "priority" : {
         "interval" : "1,9"
      },
      "weight" : {
         "interval" : "1,9"
      }
   },
   "url" : "/farms/<farmname>/backends"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_datalink_service_backend-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of a backend in for a datalink Farm. id is the backend unique identifier.",
   "method" : "PUT",
   "params" : {
      "interface" : {
         "non_blank" : "true"
      },
      "ip" : {
         "format_msg" : "expects an IP",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "priority" : {
         "interval" : "1,9"
      },
      "weight" : {
         "interval" : "1,9"
      }
   },
   "url" : "/farms/<farmname>/backends/<id>"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http-modify.json ===

{
   "action" : "set",
   "description" : "Modify the configuration of a http farm.",
   "method" : "PUT",
   "params" : {
      "certname" : {
         "depend_on" : "listener==https",
         "description" : "",
         "non_blank" : "true",
         "regex" : "(?^:(?^:(?:\\*[_|\\.])?\\w[\\w\\.\\(\\)\\@ \\-]*)\\.(?:pem|csr))"
      },
      "cipherc" : {
         "depend_on" : "listener==https, ciphers==customsecurity",
         "description" : "This is the allowed customized list of ciphers that will be accepted by the SSL connection, which it’s a string in the same format as in OpenSSL ciphers.",
         "non_blank" : "true"
      },
      "ciphers" : {
         "depend_on" : "listener==https",
         "description" : "It is used to build a list of ciphers accepted by SSL connections in order to harden the SSL connection.",
         "non_blank" : "true",
         "values" : [
            "all",
            "highsecurity",
            "customsecurity",
            "ssloffloading"
         ]
      },
      "contimeout" : {
         "description" : "How long the farm is going to wait for a connection to the backend in seconds.",
         "format_msg" : "expects a natural number",
         "non_blank" : "true",
         "regex" : "(?^:[1-9]\\d*)"
      },
      "disable_sslv2" : {
         "depend_on" : "listener==https",
         "description" : "Only in https listener. If this field has the value true the connections using an SSL security protocol with version 2 is not allowed; or false if the protocol SSLv2 is allowed.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "disable_sslv3" : {
         "depend_on" : "listener==https",
         "description" : "Only in https listener. If this field has the value true the connections using an SSL security protocol with version 3 is not allowed; or false if the protocol SSLv3 is allowed.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "disable_tlsv1" : {
         "depend_on" : "listener==https",
         "description" : "Only in https listener. If this field has the value true the connections using TLS security protocol with version 1 is not allowed; or false if the protocol TLSv1 is allowed.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "disable_tlsv1_1" : {
         "depend_on" : "listener==https",
         "description" : "Only in https listener. If this field has the value true the connections using TLS security protocol with version 1.1 is not allowed; or false if the protocol TLSv1.1 is allowed.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "disable_tlsv1_2" : {
         "depend_on" : "listener==https",
         "description" : "Only in https listener. If this field has the value true the connections using TLS security protocol with version 1.2 is not allowed; or false if the",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "error414" : {
         "description" : "",
         "required" : "false"
      },
      "error500" : {
         "description" : "Personalized message error 500.",
         "required" : "false"
      },
      "error501" : {
         "description" : "Personalized message error 501.",
         "required" : "false"
      },
      "error503" : {
         "description" : "Personalized message error 503.",
         "required" : "false"
      },
      "errorWAF" : {
         "description" : "Personalized message error 414.",
         "edition" : "ee"
      },
      "httpverb" : {
         "description" : "This field indicates the operations that will be permitted to the HTTP client requests. available values are: standardHTTP, accepted HTTP requests GET, POST, HEAD. extendedHTTP, accepted previous HTTP requests plus PUT,DELETE. optionsHTTP (from 4.0.1), add the OPTIONS verb to the previous ones. standardWebDAV, accepted previous HTTP requests plus LOCK, UNLOCK, PROPFIND, PROPPATCH, SEARCH, MKCOL, MOVE, COPY, OPTIONS, TRACE, MKACTIVITY, CHECKOUT, MERGE, REPORT, MSextWebDAV accepted previous HTTP requests plus SUBSCRIBE, UNSUBSCRIBE, NOTIFY, BPROPFIND, BPROPPATCH, POLL, BMOVE, BCOPY, BDELETE, CONNECT, or MSRPCext, accepted previous HTTP requests plus RPC_IN_DATA, RPC_OUT_DATA. Note that those values are case-sensitive.",
         "non_blank" : "true",
         "values" : [
            "standardHTTP",
            "extendedHTTP",
            "standardWebDAV",
            "MSextWebDAV",
            "MSRPCext",
            "optionsHTTP"
         ]
      },
      "ignore_100_continue" : {
         "description" : "If this field has the value true the 100 continue HTTP header will be ignored; if the value is false, the 100 continue header will be processed.",
         "edition" : "ee",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "listener" : {
         "description" : "A listener defines how the farm is going to play with the requests from the clients. The options are: http for not secured protocol or https for secured protocol.",
         "non_blank" : "true",
         "values" : [
            "http",
            "https"
         ]
      },
      "logs" : {
         "description" : "The farm Logs the trace of the HTTP connections. If this parameter has the value true, the logs are enabled; if it has the value false, logs are disabled.",
         "edition" : "ee",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "newfarmname" : {
         "depend_on" : "status==down",
         "depend_on_msg" : "The farm must be stopped.",
         "description" : "The ne farm name",
         "exceptions" : [
            "0"
         ],
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]+)"
      },
      "reqtimeout" : {
         "description" : "How long the farm is going to wait for a client request in seconds.",
         "format_msg" : "expects a natural number",
         "non_blank" : "true",
         "regex" : "(?^:[1-9]\\d*)"
      },
      "restimeout" : {
         "description" : "How long the farm is going to wait for a response from the backends in seconds.",
         "format_msg" : "expects a natural number",
         "non_blank" : "true",
         "regex" : "(?^:[1-9]\\d*)"
      },
      "resurrectime" : {
         "description" : "This value in seconds is the period to get out a blacklisted backend and checks if it is alive.",
         "format_msg" : "expects a natural number",
         "non_blank" : "true",
         "regex" : "(?^:[1-9]\\d*)"
      },
      "rewritelocation" : {
         "description" : "If it is enabled, the farm is forced to modify the Location: and Content-location: headers in responses to clients with the virtual host. The options are: enabled activated; disabled inactivated; or enabled-backends only the backend address is compared.",
         "non_blank" : "true",
         "values" : [
            "disabled",
            "enabled",
            "enabled-backends",
            "enabled-path",
            "enabled-backends-path"
         ]
      },
      "vip" : {
         "description" : "IP of the farm, where the virtual service is listening, this IP must be configured and up in the system.",
         "format_msg" : "expects an IP",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "vport" : {
         "description" : "Port of the farm, where the virtual service is listening.",
         "interval" : "1,65535",
         "non_blank" : "true"
      }
   },
   "url" : "/farm/<farmname>"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_header_request_add-create.json ===

{
   "action" : "add",
   "description" : "The farm will add the header to the backend request.",
   "method" : "POST",
   "params" : {
      "header" : {
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/addheader"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_header_request_add-modify.json ===

{
   "action" : "modify",
   "description" : "The farm will add the header to the backend request.",
   "method" : "PUT",
   "params" : {
      "header" : {
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/addheader/<id>"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_header_request_remove-create.json ===

{
   "action" : "add",
   "description" : "Remove certain headers from the incoming requests.",
   "method" : "POST",
   "params" : {
      "pattern" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/headremove"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_header_request_remove-modify.json ===

{
   "action" : "modify",
   "description" : "Remove certain headers from the incoming requests.",
   "method" : "PUT",
   "params" : {
      "pattern" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/headremove"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_header_request_replace-create.json ===

{
   "action" : "add",
   "description" : "Add rules to rewrite headers from the request.",
   "method" : "POST",
   "params" : {
      "header" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      },
      "match" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      },
      "replace" : {
         "negated_regex" : "(?^:\\n)",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/replacerequestheader"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_header_request_replace-modify.json ===

{
   "action" : "add",
   "description" : "Add rules to rewrite headers from the request.",
   "method" : "POST",
   "params" : {
      "header" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true"
      },
      "match" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true"
      },
      "replace" : {
         "negated_regex" : "(?^:\\n)"
      }
   },
   "url" : "/farms/<farmname>/replacerequestheader"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_header_request_replace-move.json ===

{
   "action" : "add",
   "description" : "Move a ReplaceHeader",
   "method" : "POST",
   "params" : {
      "position" : {
         "non_blank" : "true",
         "regex" : "(?^:\\d+)",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/replacerequestheader/<id>/actions"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_header_response_add-create.json ===

{
   "action" : "add",
   "description" : "The farm will add the header to the backend response.",
   "method" : "POST",
   "params" : {
      "header" : {
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/addresponseheader"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_header_response_add-modify.json ===

{
   "action" : "add",
   "description" : "The farm will add the header to the backend response.",
   "method" : "POST",
   "params" : {
      "header" : {
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/addresponseheader"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_header_response_remove-create.json ===

{
   "action" : "add",
   "description" : "Remove certain headers from the backend response.",
   "method" : "POST",
   "params" : {
      "pattern" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/removeresponseheader"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_header_response_remove-modify.json ===

{
   "action" : "add",
   "description" : "Remove certain headers from the backend response.",
   "method" : "POST",
   "params" : {
      "pattern" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/removeresponseheader"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_header_response_replace-create.json ===

{
   "action" : "add",
   "description" : "Add rules to rewrite headers from the response.",
   "method" : "POST",
   "params" : {
      "header" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      },
      "match" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      },
      "replace" : {
         "negated_regex" : "(?^:\\n)",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/replaceresponseheader"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_header_response_replace-modify.json ===

{
   "action" : "add",
   "description" : "Add rules to rewrite headers from the response.",
   "method" : "POST",
   "params" : {
      "header" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true"
      },
      "match" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true"
      },
      "replace" : {}
   },
   "url" : "/farms/<farmname>/replaceresponseheader"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_header_response_replace-move.json ===

{
   "action" : "add",
   "description" : "Move a ReplaceHeader",
   "method" : "POST",
   "params" : {
      "position" : {
         "non_blank" : "true",
         "regex" : "(?^:\\d+)",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/replaceresponseheader/<id>/actions"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_service-create.json ===

{
   "action" : "add",
   "description" : "Create a service in a given HTTP profile Farm.",
   "method" : "POST",
   "params" : {
      "id" : {
         "exceptions" : [
            "0"
         ],
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]+)"
      }
   },
   "url" : "/farms/<farmname>/services"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_service-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of a service in an HTTP profile.",
   "method" : "PUT",
   "params" : {
      "cookiedomain" : {
         "edition" : "ee"
      },
      "cookieinsert" : {
         "edition" : "ee",
         "values" : [
            "true",
            "false"
         ]
      },
      "cookiename" : {
         "edition" : "ee"
      },
      "cookiepath" : {
         "edition" : "ee"
      },
      "cookiettl" : {
         "edition" : "ee",
         "non_blank" : "true",
         "regex" : "(?^:[1-9]\\d*)"
      },
      "httpsb" : {
         "non_blank" : "true",
         "regex" : "(?^:(?:true|false))"
      },
      "leastresp" : {
         "non_blank" : "true",
         "regex" : "(?^:(?:true|false))"
      },
      "persistence" : {
         "non_blank" : "false",
         "values" : [
            "IP",
            "BASIC",
            "NONE",
            "URL",
            "PARM",
            "COOKIE",
            "HEADER"
         ]
      },
      "pinnedconnection" : {
         "non_blank" : "true",
         "values" : [
            0,
            1
         ]
      },
      "redirect" : {
         "non_blank" : "false",
         "regex" : "(?^:(http|https)://([^/]+)(.*))"
      },
      "redirect_code" : {
         "edition" : "ee",
         "values" : [
            301,
            302,
            307
         ]
      },
      "redirecttype" : {
         "values" : [
            "default",
            "append"
         ]
      },
      "rewritelocation" : {
         "non_blank" : "true",
         "values" : [
            "disabled",
            "enabled",
            "enabled-backends",
            "enabled-path",
            "enabled-backends-path"
         ]
      },
      "routingpolicy" : {
         "non_blank" : "true",
         "values" : [
            "ROUND_ROBIN",
            "LEAST_CONNECTIONS",
            "RESPONSE_TIME",
            "PENDING_CONNECTIONS"
         ]
      },
      "sessionid" : {},
      "sts_status" : {
         "edition" : "ee",
         "values" : [
            "true",
            "false"
         ]
      },
      "sts_timeout" : {
         "edition" : "ee",
         "regex" : "(?^:(?:\\d+))"
      },
      "ttl" : {
         "non_blank" : "true",
         "regex" : "(?^:[1-9]\\d*)"
      },
      "urlp" : {
         "is_regex" : "true"
      },
      "vhost" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:^\\^)"
      }
   },
   "url" : "/farms/<farmname>/services/<id>"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_service_backend-add.json ===

{
   "action" : "add",
   "description" : "Create a new Backend in a given HTTP profile. id is the service unique identifier.",
   "method" : "POST",
   "params" : {
      "connection_limit" : {
         "depend_on" : "proxy_ng==true",
         "interval" : "0,"
      },
      "ip" : {
         "format_msg" : "expects an IP",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))",
         "required" : "true"
      },
      "port" : {
         "non_blank" : "true",
         "regex" : "(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))",
         "required" : "true"
      },
      "priority" : {
         "depend_on" : "proxy_ng==true",
         "interval" : "1,9"
      },
      "timeout" : {
         "regex" : "(?^:[1-9]\\d*)"
      },
      "weight" : {
         "interval" : "1,9"
      }
   },
   "url" : "/farms/<farmname>/services/<id>/backends"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_service_backend-maintenance.json ===

{
   "action" : "maintenance",
   "description" : "Set a given action in a backend of an HTTP farm.",
   "method" : "PUT",
   "params" : {
      "action" : {
         "depend_on_msg" : "The farm cannot be in need_restart status to set maintenance",
         "non_blank" : "true",
         "values" : [
            "up",
            "maintenance"
         ]
      },
      "mode" : {
         "depend_on" : "action==maintenance",
         "non_blank" : "true",
         "values" : [
            "drain",
            "cut"
         ]
      }
   },
   "url" : "/farms/<farmname>/services/<id>/backends/<id>/maintenance"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_service_backend-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of a backend HTTP service.",
   "method" : "PUT",
   "params" : {
      "connection_limit" : {
         "depend_on" : "proxy_ng==true",
         "interval" : "0,"
      },
      "ip" : {
         "format_msg" : "expects an IP",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "port" : {
         "non_blank" : "true",
         "regex" : "(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))"
      },
      "priority" : {
         "depend_on" : "proxy_ng==true",
         "interval" : "1,9"
      },
      "timeout" : {
         "regex" : "(?^:[1-9]\\d*)"
      },
      "weight" : {
         "interval" : "1,9"
      }
   },
   "url" : "/farms/<farmname>/services/<id>/backends/<id>"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_service_url_rewrite-create.json ===

{
   "action" : "add",
   "description" : "It checks a pattern in order to get strings from URL and replace them.",
   "method" : "POST",
   "params" : {
      "last" : {
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "pattern" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      },
      "replace" : {
         "negated_regex" : "(?^:\\n)",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/service/<servicename>/rewriteurl"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_service_url_rewrite-modify.json ===

{
   "action" : "add",
   "description" : "It checks a pattern in order to get strings from URL and replace them.",
   "method" : "POST",
   "params" : {
      "last" : {
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "pattern" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true"
      },
      "replace" : {
         "negated_regex" : "(?^:\\n)"
      }
   },
   "url" : "/farms/<farmname>/service/<servicename>/rewriteurl"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_http_service_url_rewrite-move.json ===

{
   "action" : "move",
   "description" : "It checks a pattern in order to get strings from URL and replace them.",
   "method" : "POST",
   "params" : {
      "position" : {
         "non_blank" : "true",
         "regex" : "(?^:\\d+)",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/service/<servicename>/rewriteurl/<id>/actions"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_l4xnat-modify.json ===

{
   "action" : "set",
   "description" : "Modify the configuration of a l4xnat farm.",
   "method" : "PUT",
   "params" : {
      "algorithm" : {
         "non_blank" : "true",
         "values" : [
            "weight",
            "roundrobin",
            "hash_srcip_srcport",
            "hash_srcip",
            "symhash",
            "leastconn"
         ]
      },
      "logs" : {
         "edition" : "ee",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "nattype" : {
         "non_blank" : "true",
         "values" : [
            "nat",
            "dnat",
            "dsr",
            "stateless_dnat"
         ]
      },
      "newfarmname" : {
         "exceptions" : [
            "0"
         ],
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]+)"
      },
      "persistence" : {
         "values" : [
            "ip",
            "srcip",
            "srcport",
            "srcmac",
            "srcip_srcport",
            "srcip_dstport",
            "none"
         ]
      },
      "protocol" : {
         "non_blank" : "true",
         "values" : [
            "all",
            "tcp",
            "udp",
            "sctp",
            "sip",
            "ftp",
            "tftp",
            "amanda",
            "h323",
            "irc",
            "netbios-ns",
            "pptp",
            "sane",
            "snmp"
         ]
      },
      "ttl" : {
         "non_blank" : "true",
         "regex" : "(?^:[1-9]\\d*)"
      },
      "vip" : {
         "dyn_values" : "true",
         "format_msg" : "The vip IP must exist in some interface.",
         "non_blank" : "true"
      },
      "vport" : {
         "non_blank" : "true"
      }
   },
   "url" : "/farm/<farmname>"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_l4xnat_service_backend-add.json ===

{
   "action" : "add",
   "description" : "Create a new Backend in a given L4xNAT Farm.",
   "method" : "POST",
   "params" : {
      "ip" : {
         "format_msg" : "expects an IP",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))",
         "required" : "true"
      },
      "max_conns" : {
         "interval" : "0,"
      },
      "port" : {
         "format_msg" : "expects a port or port range",
         "regex" : "(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))"
      },
      "priority" : {
         "interval" : "1,9"
      },
      "weight" : {
         "interval" : "1,9"
      }
   },
   "url" : "/farms/<farmname>/backends"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_l4xnat_service_backend-maintenance.json ===

{
   "action" : "maintenance",
   "description" : "Set a given action in a backend of an L4xNAT farm.",
   "method" : "PUT",
   "params" : {
      "action" : {
         "non_blank" : "true",
         "values" : [
            "up",
            "maintenance"
         ]
      },
      "mode" : {
         "depend_on" : "action==maintenance",
         "non_blank" : "true",
         "values" : [
            "drain",
            "cut"
         ]
      }
   },
   "url" : "/farms/<farmname>/backends/<id>/maintenance"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farm_l4xnat_service_backend-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of a backend in for a L4xNAT Farm. id is the backend unique identifier.",
   "method" : "PUT",
   "params" : {
      "interface" : {
         "non_blank" : "true"
      },
      "ip" : {
         "format_msg" : "expects an IP",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "max_conns" : {
         "interval" : "0,"
      },
      "port" : {
         "regex" : "(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))"
      },
      "priority" : {
         "interval" : "1,9"
      },
      "weight" : {
         "interval" : "1,9"
      }
   },
   "url" : "/farms/<farmname>/backends/<id>"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farmguardian-create.json ===

{
   "action" : "create",
   "description" : "Create a monitoring check to evaluate the farm service status.",
   "method" : "POST",
   "params" : {
      "copy_from" : {
         "regex" : "(?^:[\\w-]+)"
      },
      "name" : {
         "exceptions" : [
            "0"
         ],
         "non_blank" : "true",
         "regex" : "(?^:[\\w-]+)",
         "required" : "true"
      }
   },
   "url" : "/monitoring/fg"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farmguardian-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of the health check",
   "method" : "PUT",
   "params" : {
      "backend_alias" : {
         "non_blank" : "false",
         "values" : [
            "true",
            "false"
         ]
      },
      "command" : {
         "non_blank" : "true"
      },
      "cut_conns" : {
         "non_blank" : "false",
         "values" : [
            "true",
            "false"
         ]
      },
      "description" : {
         "non_blank" : "true"
      },
      "force" : {
         "non_blank" : "false",
         "values" : [
            "true",
            "false"
         ]
      },
      "interval" : {
         "regex" : "(?^:[1-9]\\d*)"
      },
      "log" : {
         "non_blank" : "false",
         "values" : [
            "true",
            "false"
         ]
      },
      "timeout" : {
         "regex" : "(?^:[1-9]\\d*)"
      }
   },
   "url" : "/monitoring/fg/<name>"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/farmguardian_to_farm-add.json ===

{
   "action" : "add",
   "description" : "Apply a FarmGuardian to a service.",
   "method" : "POST",
   "params" : {
      "name" : {
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/services/<id>/fg"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/gateway-modify.json ===

{
   "action" : "set",
   "description" : "Modify the configuration of the gateway interface.",
   "method" : "PUT",
   "params" : {
      "address" : {
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "interface" : {
         "non_blank" : "true"
      }
   },
   "url" : "/interfaces/gateway/<ip_version>"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/letsencrypt-action.json ===

{
   "action" : "action",
   "description" : "Apply an action in a Letsencrypt certificate by first domain.",
   "method" : "POST",
   "params" : {
      "action" : {
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "renew"
         ]
      },
      "farmname" : {
         "description" : "Farm name which a temporal Service “LetsEncryptTemporalFarm” is configured in. Required if param vip is not sent.",
         "dyn_values" : "true",
         "non_blank" : "true"
      },
      "force_renewal" : {
         "description" : "true, force the certificate to be renewed even it is not expired, false, the certificate will be renewed if it is due to be renewed ( less than 30 days to expire ).",
         "values" : [
            "true",
            "false"
         ]
      },
      "restart" : {
         "description" : "true, all the farms using the certificate will be restarted. false, no farms using the certificate will be restarted.",
         "values" : [
            "true",
            "false"
         ]
      },
      "vip" : {
         "description" : "IP of the system, where a temporal Farm “LetsEncryptTemporalFarm” is configured. Required true if param vip is not sent.",
         "dyn_values" : "true",
         "non_blank" : "true"
      }
   },
   "url" : "/certificates/letsencrypt/<domain>/actions"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/letsencrypt-create.json ===

{
   "action" : "renew",
   "description" : "Create a new Letsencrypt certificate.",
   "method" : "POST",
   "params" : {
      "domains" : {
         "description" : "List of domains which the certificate is vaild for.",
         "ref" : "ARRAY",
         "required" : "true"
      },
      "farmname" : {
         "description" : "Farm name which a temporal Service Letsencryptz is configured in.",
         "dyn_values" : "true",
         "non_blank" : "true"
      },
      "force" : {
         "description" : "This parameter is used get a confirmation before creating a certificate.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "test" : {
         "description" : "true, the certificate is issued by LetsEncrypt Staging Server. false, the certificate is issued by LetsEncrypt Server and it will valid for Production environment.",
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "vip" : {
         "description" : "IP of the system, where a temporal Farm Letsencryptz is configured.",
         "dyn_values" : "true",
         "non_blank" : "true"
      }
   },
   "url" : "/certificates/letsencrypt"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/letsencrypt-modify.json ===

{
   "action" : "set",
   "description" : "Modify the Auto Renewal parameters of a Letsencrypt certificate.",
   "method" : "PUT",
   "params" : {
      "autorenewal" : {
         "description" : "true,the autorenewal will be configured.false, the autorenewal will be removed.",
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "farmname" : {
         "depend_on" : "autorenewal==true && vip!=defined",
         "description" : "Farm name which a temporal Service “LetsEncryptTemporalFarm” is configured in. Required if param vip is not sent.",
         "dyn_values" : "true",
         "non_blank" : "true"
      },
      "force_renewal" : {
         "depend_on" : "autorenewal==true",
         "description" : "true, force the certificate to be renewed even it is not expired, false, the certificate will be renewed if it is due to be renewed ( less than 30 days to expire ).",
         "required" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "restart" : {
         "depend_on" : "autorenewal==true",
         "description" : "true, all the farms using the certificate will be restarted. false, no farms using the certificate will be restarted.",
         "required" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "vip" : {
         "depend_on" : "autorenewal==true && farmname!=defined",
         "description" : "IP of the system, where a temporal Farm “LetsEncryptTemporalFarm” is configured. Required true if param vip is not sent.",
         "dyn_values" : "true",
         "non_blank" : "true"
      }
   },
   "url" : "/certificates/letsencrypt/<domain>"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/letsencrypt_config-modify.json ===

{
   "action" : "set",
   "description" : "Modify Letsencrypt Configuration.",
   "method" : "PUT",
   "params" : {
      "email" : {
         "description" : "Email for use as a contact in Letsencrypt",
         "non_blank" : "true",
         "regex" : "(?^:^(?:[a-zA-Z][\\w\\_\\.]+)\\@(?:[a-zA-Z0-9.-]+)\\.(?:[a-zA-Z]{2,4})$)",
         "required" : "true"
      }
   },
   "url" : "/certificates/letsencrypt/config"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/nic-action.json ===

{
   "action" : "status",
   "description" : "Apply an action to a NIC interface. This call lets enable or disable a network interface.",
   "method" : "POST",
   "params" : {
      "action" : {
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "up",
            "down"
         ]
      }
   },
   "url" : "/interfaces/nic/<name>/actions"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/nic-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of a NIC interface. name is the interface unique identifier.",
   "method" : "PUT",
   "params" : {
      "dhcp" : {
         "edition" : "ee",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "force" : {
         "non_blank" : "true",
         "values" : [
            "true"
         ]
      },
      "gateway" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "ip" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "netmask" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?:[0-9]{1,2}|10[0-9]|11[0-9]|12[0-8])))"
      }
   },
   "url" : "/interfaces/nic/<name>"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/system_backup-create.json ===

{
   "action" : "create",
   "description" : "Create a system configuration backup of the current configuration.",
   "method" : "POST",
   "params" : {
      "name" : {
         "description" : "It is the file name used as a unique identifier. The file extension is .tar.gz.",
         "non_blank" : "true",
         "regex" : "(?^:[\\w-]+)",
         "required" : "true"
      }
   },
   "url" : "/system/backup"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/system_backup-restore.json ===

{
   "action" : "apply",
   "description" : "Restore the configuration from a backup file. Name is the backup unique identifier.",
   "method" : "POST",
   "params" : {
      "action" : {
         "description" : "To restore the backup configuration, the value must be apply.",
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "apply"
         ]
      },
      "force" : {
         "description" : "This parameter is used get a confirmation before applying the backup.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      }
   },
   "url" : "/system/backup/<name>/actions"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/system_dns-modify.json ===

{
   "action" : "set",
   "description" : "Modify the DNS service configuration.",
   "method" : "POST",
   "params" : {
      "primary" : {
         "description" : "Primary DNS configurated in the system.",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "secondary" : {
         "description" : "Secondary DNS configurated in the system.",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      }
   },
   "url" : "/system/dns"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/system_factory-apply.json ===

{
   "action" : "factory",
   "description" : "Apply a factory reset in the system. It will delete all the user configuration. The root password, the hostname, one NIC interface and the certificate will not be modified. The system will be restarted while the process is going on.",
   "method" : "POST",
   "params" : {
      "force" : {
         "description" : "It is a confirmation about to apply the factory reset. This parameter has to be sent with true value for applying it.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "interface" : {
         "description" : "It is a NIC interface name. This interface will not be deleted in the factory reset process. The system will be available before factory reset through this interface.",
         "dyn_values" : "true",
         "non_blank" : "true",
         "required" : "true"
      },
      "remove_backups" : {
         "description" : "It is an option about remove all system backups. They will not be removed by default. If this parameter is set to true, the backups will be removed.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      }
   },
   "url" : "/system/factory"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/system_global-modify.json ===

{
   "action" : "set",
   "description" : "Modify RELIANOID global Settings.",
   "method" : "POST",
   "params" : {
      "arp_announce" : {
         "description" : "If this parameter is enabled true, the master node of the cluster will send a ARP packet to the network per minute and when the system boots. If the value is false the packet will be sent only when cluster switches to master or when a interface will be configurated.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "duplicated_network" : {
         "description" : "If this parameter is enabled true, the system will able to manage networks duplicated in different interfaces, a process will ensure that an interface does not route through another with the same netwoking. This can be disabled with the value false.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "force" : {
         "description" : "This parameter is used to force the settings when these require a service restart. This parameter accepts the value true.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "ssyncd" : {
         "description" : "Session synchronization daemon is which replies the client sessions between master and backup nodes for a cluster. This feature is enabled with the value true and disabled with false.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "waf_assistant" : {
         "description" : "If this parameter is enabled true, the system will assist the user with WAF settings of the farms.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      }
   },
   "url" : "/system/global"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/system_language-modify.json ===

{
   "action" : "factory",
   "description" : "Modify the WebGUI language.",
   "method" : "POST",
   "params" : {
      "language" : {
         "description" : "string with the language used in webgui.",
         "required" : "true"
      }
   },
   "url" : "/system/factory"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/system_ntp-modify.json ===

{
   "action" : "set",
   "description" : "Modify the NTP service configuration.",
   "method" : "POST",
   "params" : {
      "server" : {
         "description" : "Server where NTP client does the requests.",
         "non_blank" : "true",
         "regex" : "(?^:[\\w\\.\\-]+)",
         "required" : "true"
      }
   },
   "url" : "/system/ntp"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/system_proxy-modify.json ===

{
   "action" : "set",
   "description" : "Show the configuration about HTTP/HTTPS remote services. This proxy will be used to the remote HTTP request from the load balancer (as downloading IPDS rules and getting packages updates).",
   "method" : "POST",
   "params" : {
      "http_proxy" : {
         "description" : "It is the URL to the remote proxy server to send the requests that use the HTTP protocol, without SSL encryption.",
         "regex" : "(?^:\\S*)"
      },
      "https_proxy" : {
         "description" : "It is the URL to the remote proxy server to send the requests that use the HTTPS protocol, with SSL encryption.",
         "regex" : "(?^:\\S*)"
      }
   },
   "url" : "/system/proxy"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/system_snmp-modify.json ===

{
   "action" : "set",
   "description" : "Modify the SNMP service configuration.",
   "method" : "POST",
   "params" : {
      "community" : {
         "description" : "Community name. Read-Only Community used.",
         "length" : 32,
         "non_blank" : "true"
      },
      "ip" : {
         "description" : "Interface IP where the SNMP service is running. It’s safe to keep the All interfaces enabled using the character *.",
         "dyn_values" : "true",
         "non_blank" : "true"
      },
      "port" : {
         "description" : "Port where SNMP service is running.",
         "non_blank" : "true",
         "regex" : "(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))"
      },
      "scope" : {
         "description" : "IP or subnet with access (IP/bit). Allowed client IPs to access SNMPD service, in case you want to allow access only one IP please use the bit /32.",
         "non_blank" : "true",
         "regex" : "(?^:(?:\\d{1,3}\\.){3}\\d{1,3}\\/\\d{1,2})"
      },
      "status" : {
         "description" : "Status of SNMP service. The possible values are: true, the service is running; or false, the service is stopped.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      }
   },
   "url" : "/system/snmp"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/system_ssh-modify.json ===

{
   "action" : "set",
   "description" : "Modify the SSH service configuration.",
   "method" : "POST",
   "params" : {
      "listen" : {
         "description" : "IP of the system where the SSH service is listening. The character * is used to listen in all configurated IPs. Enabled to set an array to configure multiple ips.",
         "non_blank" : "true",
         "ref" : "array|none",
         "regex" : "(?^:(?:(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))|\\*))"
      },
      "port" : {
         "description" : "Port configurated for SSH service. Enabled to set an array to configure multiple ports.",
         "non_blank" : "true",
         "ref" : "array|none",
         "regex" : "(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))"
      }
   },
   "url" : "/system/ssh"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/system_user-modify.json ===

{
   "action" : "set",
   "description" : "Modify the configuration of the current user. The current user is authenticated with the API_KEY or logged in the WebGUI.",
   "method" : "POST",
   "params" : {
      "api_key" : {
         "description" : "Each user can have an API key. With this API key, the user can do action through the API key with the permissions of the user’s role.",
         "regex" : "(?^:[a-zA-Z0-9]+)"
      },
      "api_permissions" : {
         "description" : "The possible values are: true, to enable the access to the load balancer through the API; or false, to deny the access through the API.",
         "non_blank" : "true",
         "regex" : "(?^:(?:true|false))"
      },
      "newpassword" : {
         "description" : "New user password to access through the WebGUI.",
         "format_msg" : "must contain at least a letter and a number and a minimum length of 8 characters.",
         "non_blank" : "true",
         "regex" : "(?^:(?=.*[0-9])(?=.*[a-zA-Z]).{8,512})"
      },
      "password" : {
         "description" : "It is the current user password. It is required when newpassword is sent.",
         "non_blank" : "true"
      },
      "zapi_permissions" : {
         "description" : "The possible values are: true, to enable the access to the load balancer through the API; or false, to deny the access through the API. This parameter is deprecated and it will be removed, use `api_permissions` instead.",
         "non_blank" : "true",
         "regex" : "(?^:(?:true|false))"
      },
      "zapikey" : {
         "description" : "Each user can have an API key. With this API key, the user can do action through the API key with the permissions of the user’s role. This parameter is deprecated and it will be removed, use `api_key` instead.",
         "regex" : "(?^:[a-zA-Z0-9]+)"
      }
   },
   "url" : "/system/users"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/virtual-action.json ===

{
   "action" : "status",
   "description" : "Apply an action to a virtual interface. This call lets enable or disable a network interface.",
   "method" : "POST",
   "params" : {
      "action" : {
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "up",
            "down"
         ]
      }
   },
   "url" : "/interfaces/virtual/<name>/actions"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/virtual-create.json ===

{
   "action" : "create",
   "description" : "Create a virtual interface.",
   "method" : "POST",
   "params" : {
      "ip" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))",
         "required" : "true"
      },
      "name" : {
         "format_msg" : "is a string formed with the parent interface name, colon (:) and a virtual interface tag. E.g: eth1:virt1",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:[a-zA-Z0-9\\-]{1,15})|(?^:[a-zA-Z0-9\\-]{1,15}))(?:\\.(?^:\\d{1,4}))?:(?^:[a-zA-Z0-9\\-]{1,13}))",
         "required" : "true"
      }
   },
   "url" : "/interfaces/virtual"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/virtual-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of a virtual interface. name is the interface unique identifier.",
   "method" : "PUT",
   "params" : {
      "force" : {
         "non_blank" : "true",
         "values" : [
            "true"
         ]
      },
      "ip" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      }
   },
   "url" : "/interfaces/virtual/<name>"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/vlan-action.json ===

{
   "action" : "status",
   "description" : "Apply an action to a VLAN interface. This call lets enable or disable a network interface.",
   "method" : "POST",
   "params" : {
      "action" : {
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "up",
            "down"
         ]
      }
   },
   "url" : "/interfaces/vlan/<name>/actions"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/vlan-create.json ===

{
   "action" : "create",
   "description" : "Create a VLAN interface from a NIC or bonding interface. The new VLAN interface will share MAC, although the following network parameters must be different: ip, and the following can change: gateway, netmask.",
   "method" : "POST",
   "params" : {
      "dhcp" : {
         "edition" : "ee",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "gateway" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "ip" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "mac" : {
         "edition" : "ee",
         "regex" : "(?^:(?:(?^:(?:[A-Fa-f0-9]))(?^:(?:[A-Fa-f0-9]))\\:){5}(?^:(?:[A-Fa-f0-9]))(?^:(?:[A-Fa-f0-9])))"
      },
      "name" : {
         "format_msg" : "is a string formed with the parent interface name, dot (.) and a VLAN tag. E.g: eth1.1",
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]{1,13}\\.(?^:\\d{1,4}))",
         "required" : "true"
      },
      "netmask" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?:[0-9]{1,2}|10[0-9]|11[0-9]|12[0-8])))"
      }
   },
   "url" : "/interfaces/vlan"
}

=== ./background/relianoid/usr/local/relianoid/api-model/v4.0/json/vlan-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of a VLAN interface. name is the interface unique identifier.",
   "method" : "PUT",
   "params" : {
      "dhcp" : {
         "edition" : "ee",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "force" : {
         "non_blank" : "true",
         "values" : [
            "true"
         ]
      },
      "gateway" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "ip" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "mac" : {
         "edition" : "ee",
         "regex" : "(?^:(?:(?^:(?:[A-Fa-f0-9]))(?^:(?:[A-Fa-f0-9]))\\:){5}(?^:(?:[A-Fa-f0-9]))(?^:(?:[A-Fa-f0-9])))"
      },
      "netmask" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?:[0-9]{1,2}|10[0-9]|11[0-9]|12[0-8])))"
      }
   },
   "url" : "/interfaces/vlan/<name>"
}

=== ./background/relianoid/usr/local/relianoid/app/letsencrypt/etc/cherokee_localhost.conf ===

config!version = 001002104
server!bind!1!interface = 127.0.0.1
server!bind!1!port = 80
server!bind!1!tls = 0
server!ipv6 = 0
server!keepalive = 1
server!keepalive_max_requests = 500
server!panic_action = /usr/local/relianoid/app/cherokee/bin/cherokee_localhost-panic
server!pid_file = /usr/local/relianoid/app/cherokee/var/run/cherokee_localhost.pid
server!server_tokens = full
server!timeout = 60
server!tls = libssl
server!tls!protocol!SSLv2 = 0
server!user = root
vserver!1!directory_index = index.html
vserver!1!document_root = /opt/certs
vserver!1!error_writer!filename = /var/log/cherokee-error.log
vserver!1!error_writer!type = file
vserver!1!logger = combined
vserver!1!logger!access!buffsize = 16384
vserver!1!logger!access!filename = /var/log/cherokee-access.log
vserver!1!logger!access!type = file
vserver!1!nick = default
#vserver!1!rule!500!encoder!gzip = allow
#vserver!1!rule!500!encoder!gzip!compression_level = 9
vserver!1!rule!500!match = directory
vserver!1!rule!500!match!directory = /
vserver!1!rule!500!match!final = 0
vserver!1!rule!300!document_root = /usr/local/relianoid/app/letsencrypt/webroot/
#vserver!1!rule!300!encoder!gzip = allow
#vserver!1!rule!300!encoder!gzip!compression_level = 9
vserver!1!rule!300!handler = common
vserver!1!rule!300!handler!allow_dirlist = 0
vserver!1!rule!300!handler!allow_pathinfo = 0
vserver!1!rule!300!handler!iocache = 0
vserver!1!rule!300!match = or
vserver!1!rule!300!match!left = fullpath
vserver!1!rule!300!match!left!directory = /
vserver!1!rule!300!match!left!fullpath!1 = /index.html
vserver!1!rule!300!match!left!fullpath!2 = /
vserver!1!rule!300!match!left!request = ^$
vserver!1!rule!300!match!right = not
vserver!1!rule!300!match!right!right = request
vserver!1!rule!300!match!right!right!request = ^.*nothing.*
#vserver!1!rule!200!document_root = /usr/local/relianoid/app/letsencrypt/webroot/
#vserver!1!rule!200!handler = cgi
#vserver!1!rule!200!timeout = 60
#vserver!1!rule!200!handler!change_user = 0
#vserver!1!rule!200!handler!check_file = 1
#vserver!1!rule!200!handler!error_handler = 1
#vserver!1!rule!200!handler!pass_req_headers = 1
#vserver!1!rule!200!handler!xsendfile = 0
#vserver!1!rule!200!match = extensions
#vserver!1!rule!200!match!check_local_file = 0
#vserver!1!rule!200!match!extensions = cgi
#vserver!1!rule!100!match = default
vserver!1!ssl_certificate_file = /usr/local/relianoid/config/certificates/noid_ssl_cert.pem
vserver!1!ssl_certificate_key_file = /usr/local/relianoid/config/certificates/noid_ssl_cert.key
#vserver!1!ssl_cipher_server_preference = 1
#vserver!1!ssl_ciphers = HIGH:!aNULL:!MD5 
#vserver!1!ssl_ciphers = ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK
vserver!1!ssl_compression = 1
icons!default = page_white.png
icons!directory = folder.png
icons!file!bomb.png = core
icons!file!page_white_go.png = *README*
icons!parent_directory = arrow_turn_left.png
icons!suffix!camera.png = jpg,jpeg,jpe
icons!suffix!cd.png = iso,ngr,cue
icons!suffix!color_wheel.png = png,gif,xcf,bmp,pcx,tiff,tif,cdr,psd,xpm,xbm
icons!suffix!control_play.png = bin,exe,com,msi,out
icons!suffix!css.png = css
icons!suffix!cup.png = java,class,jar
icons!suffix!email.png = eml,mbox,box,email,mbx
icons!suffix!film.png = avi,mpeg,mpe,mpg,mpeg3,dl,fli,qt,mov,movie,flv,webm
icons!suffix!font.png = ttf
icons!suffix!html.png = html,htm
icons!suffix!music.png = au,snd,mid,midi,kar,mpga,mpega,mp2,mp3,sid,wav,aif,aiff,aifc,gsm,m3u,wma,wax,ra,rm,ram,pls,sd2,ogg
icons!suffix!package.png = tar,gz,bz2,zip,rar,ace,lha,7z,dmg,cpk
icons!suffix!page_white_acrobat.png = pdf
icons!suffix!page_white_c.png = c,h,cpp
icons!suffix!page_white_office.png = doc,ppt,xls
icons!suffix!page_white_php.png = php
icons!suffix!page_white_text.png = txt,text,rtf,sdw
icons!suffix!printer.png = ps,eps
icons!suffix!ruby.png = rb
icons!suffix!script.png = sh,csh,ksh,tcl,tk,py,pl
mime!application/bzip2!extensions = bz2
mime!application/gzip!extensions = gz
mime!application/hta!extensions = hta
mime!application/java-archive!extensions = jar
mime!application/java-serialized-object!extensions = ser
mime!application/java-vm!extensions = class
mime!application/json!extensions = json
mime!application/mac-binhex40!extensions = hqx
mime!application/msaccess!extensions = mdb
mime!application/msword!extensions = doc,dot
mime!application/octet-stream!extensions = bin
mime!application/octetstream!extensions = ace
mime!application/oda!extensions = oda
mime!application/ogg!extensions = ogx
mime!application/pdf!extensions = pdf
mime!application/pgp-keys!extensions = key
mime!application/pgp-signature!extensions = pgp
mime!application/pics-rules!extensions = prf
mime!application/postscript!extensions = ps,ai,eps
mime!application/rar!extensions = rar
mime!application/rdf+xml!extensions = rdf
mime!application/rss+xml!extensions = rss
mime!application/smil!extensions = smi,smil
mime!application/vnd.mozilla.xul+xml!extensions = xul
mime!application/vnd.ms-excel!extensions = xls,xlb,xlt
mime!application/vnd.ms-pki.seccat!extensions = cat
mime!application/vnd.ms-pki.stl!extensions = stl
mime!application/vnd.ms-powerpoint!extensions = ppt,pps
mime!application/vnd.oasis.opendocument.chart!extensions = odc
mime!application/vnd.oasis.opendocument.database!extensions = odb
mime!application/vnd.oasis.opendocument.formula!extensions = odf
mime!application/vnd.oasis.opendocument.graphics!extensions = odg
mime!application/vnd.oasis.opendocument.image!extensions = odi
mime!application/vnd.oasis.opendocument.presentation!extensions = odp
mime!application/vnd.oasis.opendocument.spreadsheet!extensions = ods
mime!application/vnd.oasis.opendocument.text!extensions = odt
mime!application/vnd.oasis.opendocument.text-master!extensions = odm
mime!application/vnd.oasis.opendocument.text-web!extensions = oth
mime!application/vnd.pkg5.info!extensions = p5i
mime!application/vnd.visio!extensions = vsd
mime!application/vnd.wap.wbxml!extensions = wbxml
mime!application/vnd.wap.wmlc!extensions = wmlc
mime!application/vnd.wap.wmlscriptc!extensions = wmlsc
mime!application/x-7z-compressed!extensions = 7z
mime!application/x-abiword!extensions = abw
mime!application/x-apple-diskimage!extensions = dmg
mime!application/x-bcpio!extensions = bcpio
mime!application/x-bittorrent!extensions = torrent
mime!application/x-cdf!extensions = cdf
mime!application/x-cpio!extensions = cpio
mime!application/x-csh!extensions = csh
mime!application/x-debian-package!extensions = deb,udeb
mime!application/x-director!extensions = dcr,dir,dxr
mime!application/x-dvi!extensions = dvi
mime!application/x-flac!extensions = flac
mime!application/x-font!extensions = pfa,pfb,gsf,pcf,pcf.Z
mime!application/x-freemind!extensions = mm
mime!application/x-gnumeric!extensions = gnumeric
mime!application/x-gtar!extensions = gtar,tgz,taz
mime!application/x-gzip!extensions = gz,tgz
mime!application/x-httpd-php!extensions = phtml,pht,php
mime!application/x-httpd-php-source!extensions = phps
mime!application/x-httpd-php3!extensions = php3
mime!application/x-httpd-php3-preprocessed!extensions = php3p
mime!application/x-httpd-php4!extensions = php4
mime!application/x-internet-signup!extensions = ins,isp
mime!application/x-iphone!extensions = iii
mime!application/x-iso9660-image!extensions = iso
mime!application/x-java-jnlp-file!extensions = jnlp
mime!application/x-javascript!extensions = js
mime!application/x-kchart!extensions = chrt
mime!application/x-killustrator!extensions = kil
mime!application/x-koan!extensions = skp,skd,skt,skm
mime!application/x-kpresenter!extensions = kpr,kpt
mime!application/x-kspread!extensions = ksp
mime!application/x-kword!extensions = kwd,kwt
mime!application/x-latex!extensions = latex
mime!application/x-lha!extensions = lha
mime!application/x-lzh!extensions = lzh
mime!application/x-lzx!extensions = lzx
mime!application/x-ms-wmd!extensions = wmd
mime!application/x-ms-wmz!extensions = wmz
mime!application/x-msdos-program!extensions = com,exe,bat,dll
mime!application/x-msi!extensions = msi
mime!application/x-netcdf!extensions = nc
mime!application/x-ns-proxy-autoconfig!extensions = pac
mime!application/x-nwc!extensions = nwc
mime!application/x-object!extensions = o
mime!application/x-oz-application!extensions = oza
mime!application/x-pkcs7-certreqresp!extensions = p7r
mime!application/x-pkcs7-crl!extensions = crl
mime!application/x-python-code!extensions = pyc,pyo
mime!application/x-quicktimeplayer!extensions = qtl
mime!application/x-redhat-package-manager!extensions = rpm
mime!application/x-sh!extensions = sh
mime!application/x-shar!extensions = shar
mime!application/x-shockwave-flash!extensions = swf,swfl
mime!application/x-stuffit!extensions = sit,sea
mime!application/x-sv4cpio!extensions = sv4cpio
mime!application/x-sv4crc!extensions = sv4crc
mime!application/x-tar!extensions = tar
mime!application/x-tcl!extensions = tcl
mime!application/x-tex-pk!extensions = pk
mime!application/x-texinfo!extensions = texinfo,texi
mime!application/x-trash!extensions = ~,bak,old,sik
mime!application/x-troff!extensions = t,tr,roff
mime!application/x-troff-man!extensions = man
mime!application/x-troff-me!extensions = me
mime!application/x-troff-ms!extensions = ms
mime!application/x-ustar!extensions = ustar
mime!application/x-x509-ca-cert!extensions = crt
mime!application/x-xcf!extensions = xcf
mime!application/x-xfig!extensions = fig
mime!application/x-xpinstall!extensions = xpi
mime!application/xhtml+xml!extensions = xhtml,xht
mime!application/xml!extensions = xml,xsl
mime!application/zip!extensions = zip
mime!audio/basic!extensions = au,snd
mime!audio/midi!extensions = mid,midi,kar
mime!audio/mpeg!extensions = mpga,mpega,mp2,mp3,m4a
mime!audio/ogg!extensions = ogg,oga
mime!audio/prs.sid!extensions = sid
mime!audio/x-aiff!extensions = aif,aiff,aifc
mime!audio/x-gsm!extensions = gsm
mime!audio/x-mpegurl!extensions = m3u
mime!audio/x-ms-wax!extensions = wax
mime!audio/x-ms-wma!extensions = wma
mime!audio/x-pn-realaudio!extensions = ra,rm,ram
mime!audio/x-realaudio!extensions = ra
mime!audio/x-scpls!extensions = pls
mime!audio/x-sd2!extensions = sd2
mime!audio/x-wav!extensions = wav
mime!chemical/x-cache!extensions = cac,cache
mime!chemical/x-cache-csf!extensions = csf
mime!chemical/x-cdx!extensions = cdx
mime!chemical/x-cif!extensions = cif
mime!chemical/x-cmdf!extensions = cmdf
mime!chemical/x-cml!extensions = cml
mime!chemical/x-compass!extensions = cpa
mime!chemical/x-crossfire!extensions = bsd
mime!chemical/x-csml!extensions = csml,csm
mime!chemical/x-ctx!extensions = ctx
mime!chemical/x-cxf!extensions = cxf,cef
mime!chemical/x-isostar!extensions = istr,ist
mime!chemical/x-jcamp-dx!extensions = jdx,dx
mime!chemical/x-kinemage!extensions = kin
mime!chemical/x-pdb!extensions = pdb,ent
mime!chemical/x-swissprot!extensions = sw
mime!chemical/x-vamas-iso14976!extensions = vms
mime!chemical/x-vmd!extensions = vmd
mime!chemical/x-xtel!extensions = xtel
mime!chemical/x-xyz!extensions = xyz
mime!image/gif!extensions = gif
mime!image/jpeg!extensions = jpeg,jpg,jpe
mime!image/pcx!extensions = pcx
mime!image/png!extensions = png
mime!image/svg+xml!extensions = svg,svgz
mime!image/tiff!extensions = tiff,tif
mime!image/vnd.djvu!extensions = djvu,djv
mime!image/vnd.wap.wbmp!extensions = wbmp
mime!image/x-icon!extensions = ico
mime!image/x-ms-bmp!extensions = bmp
mime!image/x-photoshop!extensions = psd
mime!image/x-portable-anymap!extensions = pnm
mime!image/x-portable-bitmap!extensions = pbm
mime!image/x-portable-graymap!extensions = pgm
mime!image/x-portable-pixmap!extensions = ppm
mime!image/x-xbitmap!extensions = xbm
mime!image/x-xpixmap!extensions = xpm
mime!image/x-xwindowdump!extensions = xwd
mime!model/iges!extensions = igs,iges
mime!model/mesh!extensions = msh,mesh,silo
mime!model/vrml!extensions = wrl,vrml
mime!text/calendar!extensions = ics,icz
mime!text/comma-separated-values!extensions = csv
mime!text/css!extensions = css
mime!text/h323!extensions = 323
mime!text/html!extensions = html,htm,shtml
mime!text/iuls!extensions = uls
mime!text/mathml!extensions = mml
mime!text/plain!extensions = asc,txt,text,diff,pot
mime!text/richtext!extensions = rtx
mime!text/rtf!extensions = rtf
mime!text/scriptlet!extensions = sct,wsc
mime!text/tab-separated-values!extensions = tsv
mime!text/vnd.sun.j2me.app-descriptor!extensions = jad
mime!text/vnd.wap.wml!extensions = wml
mime!text/vnd.wap.wmlscript!extensions = wmls
mime!text/x-boo!extensions = boo
mime!text/x-c++hdr!extensions = h++,hpp,hxx,hh
mime!text/x-c++src!extensions = c++,cpp,cxx,cc
mime!text/x-chdr!extensions = h
mime!text/x-csh!extensions = csh
mime!text/x-csrc!extensions = c
mime!text/x-dsrc!extensions = d
mime!text/x-haskell!extensions = hs
mime!text/x-java!extensions = java
mime!text/x-literate-haskell!extensions = lhs
mime!text/x-moc!extensions = moc
mime!text/x-pascal!extensions = p,pas
mime!text/x-pcs-gcd!extensions = gcd
mime!text/x-perl!extensions = pl,pm
mime!text/x-python!extensions = py
mime!text/x-setext!extensions = etx
mime!text/x-sh!extensions = sh
mime!text/x-tcl!extensions = tcl,tk
mime!text/x-tex!extensions = tex,ltx,sty,cls
mime!text/x-vcalendar!extensions = vcs
mime!text/x-vcard!extensions = vcf
mime!video/dl!extensions = dl
mime!video/dv!extensions = dif,dv
mime!video/fli!extensions = fli
mime!video/gl!extensions = gl
mime!video/mp4!extensions = mp4
mime!video/mpeg!extensions = mpeg,mpg,mpe
mime!video/ogg!extensions = ogv
mime!video/quicktime!extensions = qt,mov
mime!video/vnd.mpegurl!extensions = mxu
mime!video/webm!extensions = webm
mime!video/x-flv!extensions = flv
mime!video/x-la-asf!extensions = lsf,lsx
mime!video/x-mng!extensions = mng
mime!video/x-ms-asf!extensions = asf,asx
mime!video/x-ms-wm!extensions = wm
mime!video/x-ms-wmv!extensions = wmv
mime!video/x-ms-wmx!extensions = wmx
mime!video/x-ms-wvx!extensions = wvx
mime!video/x-msvideo!extensions = avi
mime!video/x-sgi-movie!extensions = movie
mime!x-conference/x-cooltalk!extensions = ice
mime!x-world/x-vrml!extensions = vrm,vrml,wrl
admin!lang = en

=== ./background/relianoid/usr/local/relianoid/share/poundtpl.cfg ===

######################################################################
##GLOBAL OPTIONS
User		"root"
Group		"root"
Name		[DESC]
## allow PUT and DELETE also (by default only GET, POST and HEAD)?:
#ExtendedHTTP	0
## Logging: (goes to syslog by default)
##	0	no logging
##	1	normal
##	2	extended
##	3	Apache-style (common log format)
#LogFacility	local5
LogLevel 	5
## check timeouts:
Timeout		45
ConnTO		20
Alive		21
Client		30
ThreadModel	dynamic
Control 	"/tmp/[DESC]_proxy.socket"
Ignore100Continue 0
#DHParams 	"/usr/local/relianoid/app/pound/etc/dh2048.pem"
##ECDHCurve 	"prime256v1"


#HTTP(S) LISTENERS
ListenHTTP
	Err414 "[CONFIGDIR]/[DESC]_Err414.html"
	Err500 "[CONFIGDIR]/[DESC]_Err500.html"
	Err501 "[CONFIGDIR]/[DESC]_Err501.html"
	Err503 "[CONFIGDIR]/[DESC]_Err503.html"
	Address [IP]
	Port [PORT]
	xHTTP 4
	RewriteLocation 1

	#Cert "/usr/local/relianoid/config/certificates/noid_ssl_cert.pem"
	#Ciphers "ALL"
	#Disable SSLv3
	#SSLHonorCipherOrder 1
	#ZWACL-INI

	#ZWACL-END


	#Service "[DESC]"
		##False##HTTPS-backend##
		#DynScale 1
		#BackendCookie "NOIDSESSIONID" "" "/" 3600
		#HeadRequire "Host: "
		#Url ""
		#Redirect ""
		#StrictTransportSecurity 21600000
		#Session
			#Type nothing
			#TTL 120
			#ID "sessionname"
		#End
		#BackEnd

		#End
	#End


End

=== ./background/relianoid/usr/local/relianoid/share/relianoid_nameservers.conf ===

nameserver 1.1.1.1
nameserver 8.8.8.8

=== ./background/relianoid_adc/source_tree/.gitignore ===

/build-pkg
/workdir
/*.deb

=== ./background/relianoid_adc/source_tree/etc/default/grub.d/relianoid.cfg ===

GRUB_DISTRIBUTOR="RELIANOID ADC Community Edition"
GRUB_CMDLINE_LINUX_DEFAULT="net.ifnames=0 quiet"
GRUB_TERMINAL=console
GRUB_TIMEOUT=10
=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/certificate_csr-create.json ===

{
   "action" : "add",
   "description" : "Create a Certificate Signing Request (CSR file).",
   "method" : "POST",
   "params" : {
      "country" : {
         "description" : "The two-letter ISO code for the country where your organization is localized.",
         "non_blank" : "true",
         "required" : "true"
      },
      "division" : {
         "description" : "The division of your organization handling the certificate.",
         "non_blank" : "true",
         "required" : "true"
      },
      "fqdn" : {
         "description" : "The fully qualified domain name of your server.",
         "format_msg" : "FQDN is not valid. It must be as these examples: domain.com, mail.domain.com, or *.domain.com. Try again.",
         "non_blank" : "true",
         "required" : "true"
      },
      "locality" : {
         "description" : "The city where your organization is located.",
         "non_blank" : "true",
         "required" : "true"
      },
      "mail" : {
         "description" : "An email address used to contact your organization.",
         "non_blank" : "true",
         "required" : "true"
      },
      "name" : {
         "description" : "Certificate ID name.",
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]+)",
         "required" : "true"
      },
      "organization" : {
         "description" : "The legal name of your organization.",
         "non_blank" : "true",
         "required" : "true"
      },
      "state" : {
         "description" : "The state/region where your organization is located.",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/certificates"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm-action.json ===

{
   "action" : "status",
   "description" : "Apply an action to a farm, see the Request parameters table for actions.",
   "method" : "PUT",
   "params" : {
      "action" : {
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "stop",
            "start",
            "restart"
         ]
      }
   },
   "url" : "/farms/<farmname>/actions"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm-create.json ===

{
   "action" : "create",
   "description" : "It creates a new farm.",
   "method" : "POST",
   "params" : {
      "copy_from" : {
         "description" : "This parameter expects the name of a farm that exists. If this parameter is sent, the farm is copied from the farm specified in it. The farmname, vip and vport values will be overwritten.",
         "format_msg" : "The farm name accepts alphabet letters, numbers or hypens (-).",
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]+)",
         "required" : "false"
      },
      "farmname" : {
         "description" : "Farm descriptive name. It is used as a unique identifier.",
         "exceptions" : [
            "0"
         ],
         "format_msg" : "The farm name accepts alphabet letters, numbers or hypens (-).",
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]+)",
         "required" : "true"
      },
      "profile" : {
         "description" : "The profile of the created Farm. For HTTP farms is http.",
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "http",
            "gslb",
            "l4xnat",
            "datalink",
            "eproxy"
         ]
      },
      "vip" : {
         "description" : "IP of the farm, where the virtual service is going to run. The indicated IP must be configured in the system and UP",
         "dyn_values" : "true",
         "required" : "true"
      },
      "vport" : {
         "depend_on" : "profile != datalink",
         "depend_on_msg" : "Mandatory if the profile is not datalink, else it is not expected",
         "description" : "Port of the farm where the virtual service is going to listen. The same virtual port and virtual IP must not be in use by another farm.",
         "format_msg" : "It expects a port number or multiport value for L4xnat farms",
         "non_blank" : "true",
         "regex" : "(?^:(?:\\*|(?:(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))|(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))\\:(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])))(?:,(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))|,(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))\\:(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])))*))"
      }
   },
   "url" : "/farms"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_certificate-add.json ===

{
   "action" : "add",
   "description" : "Include an available PEM Certificate to the SNI list or certlist array of an HTTP farm with an HTTPS listener.",
   "method" : "POST",
   "params" : {
      "file" : {
         "non_blank" : "true",
         "regex" : "(?^:(?^:(?:\\*[_|\\.])?\\w[\\w\\.\\(\\)\\@ \\-]*)\\.pem)",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/certificates"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_datalink-modify.json ===

{
   "action" : "set",
   "description" : "Modify the configuration of a datalink farm.",
   "method" : "PUT",
   "params" : {
      "algorithm" : {
         "non_blank" : "true",
         "values" : [
            "prio",
            "weight"
         ]
      },
      "newfarmname" : {
         "exceptions" : [
            "0"
         ],
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]+)"
      },
      "vip" : {
         "dyn_values" : "true",
         "format_msg" : "expects an IP",
         "non_blank" : "true"
      }
   },
   "url" : "/farm/<farmname>"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_datalink_service_backend-add.json ===

{
   "action" : "add",
   "description" : "Create a new Backend in a given datalink Farm.",
   "method" : "POST",
   "params" : {
      "interface" : {
         "non_blank" : "true",
         "required" : "true"
      },
      "ip" : {
         "format_msg" : "expects an IP",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))",
         "required" : "true"
      },
      "priority" : {
         "interval" : "1,9"
      },
      "weight" : {
         "interval" : "1,9"
      }
   },
   "url" : "/farms/<farmname>/backends"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_datalink_service_backend-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of a backend in for a datalink Farm. id is the backend unique identifier.",
   "method" : "PUT",
   "params" : {
      "interface" : {
         "non_blank" : "true"
      },
      "ip" : {
         "format_msg" : "expects an IP",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "priority" : {
         "interval" : "1,9"
      },
      "weight" : {
         "interval" : "1,9"
      }
   },
   "url" : "/farms/<farmname>/backends/<id>"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http-modify.json ===

{
   "action" : "set",
   "description" : "Modify the configuration of a http farm.",
   "method" : "PUT",
   "params" : {
      "certname" : {
         "depend_on" : "listener==https",
         "description" : "",
         "non_blank" : "true",
         "regex" : "(?^:(?^:(?:\\*[_|\\.])?\\w[\\w\\.\\(\\)\\@ \\-]*)\\.(?:pem|csr))"
      },
      "cipherc" : {
         "depend_on" : "listener==https, ciphers==customsecurity",
         "description" : "This is the allowed customized list of ciphers that will be accepted by the SSL connection, which it’s a string in the same format as in OpenSSL ciphers.",
         "non_blank" : "true"
      },
      "ciphers" : {
         "depend_on" : "listener==https",
         "description" : "It is used to build a list of ciphers accepted by SSL connections in order to harden the SSL connection.",
         "non_blank" : "true",
         "values" : [
            "all",
            "highsecurity",
            "customsecurity",
            "ssloffloading"
         ]
      },
      "contimeout" : {
         "description" : "How long the farm is going to wait for a connection to the backend in seconds.",
         "format_msg" : "expects a natural number",
         "non_blank" : "true",
         "regex" : "(?^:[1-9]\\d*)"
      },
      "disable_sslv2" : {
         "depend_on" : "listener==https",
         "description" : "Only in https listener. If this field has the value true the connections using an SSL security protocol with version 2 is not allowed; or false if the protocol SSLv2 is allowed.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "disable_sslv3" : {
         "depend_on" : "listener==https",
         "description" : "Only in https listener. If this field has the value true the connections using an SSL security protocol with version 3 is not allowed; or false if the protocol SSLv3 is allowed.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "disable_tlsv1" : {
         "depend_on" : "listener==https",
         "description" : "Only in https listener. If this field has the value true the connections using TLS security protocol with version 1 is not allowed; or false if the protocol TLSv1 is allowed.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "disable_tlsv1_1" : {
         "depend_on" : "listener==https",
         "description" : "Only in https listener. If this field has the value true the connections using TLS security protocol with version 1.1 is not allowed; or false if the protocol TLSv1.1 is allowed.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "disable_tlsv1_2" : {
         "depend_on" : "listener==https",
         "description" : "Only in https listener. If this field has the value true the connections using TLS security protocol with version 1.2 is not allowed; or false if the",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "error414" : {
         "description" : "",
         "required" : "false"
      },
      "error500" : {
         "description" : "Personalized message error 500.",
         "required" : "false"
      },
      "error501" : {
         "description" : "Personalized message error 501.",
         "required" : "false"
      },
      "error503" : {
         "description" : "Personalized message error 503.",
         "required" : "false"
      },
      "errorWAF" : {
         "description" : "Personalized message error 414.",
         "edition" : "ee"
      },
      "httpverb" : {
         "description" : "This field indicates the operations that will be permitted to the HTTP client requests. available values are: standardHTTP, accepted HTTP requests GET, POST, HEAD. extendedHTTP, accepted previous HTTP requests plus PUT,DELETE. optionsHTTP (from 4.0.1), add the OPTIONS verb to the previous ones. standardWebDAV, accepted previous HTTP requests plus LOCK, UNLOCK, PROPFIND, PROPPATCH, SEARCH, MKCOL, MOVE, COPY, OPTIONS, TRACE, MKACTIVITY, CHECKOUT, MERGE, REPORT, MSextWebDAV accepted previous HTTP requests plus SUBSCRIBE, UNSUBSCRIBE, NOTIFY, BPROPFIND, BPROPPATCH, POLL, BMOVE, BCOPY, BDELETE, CONNECT, or MSRPCext, accepted previous HTTP requests plus RPC_IN_DATA, RPC_OUT_DATA. Note that those values are case-sensitive.",
         "non_blank" : "true",
         "values" : [
            "standardHTTP",
            "extendedHTTP",
            "standardWebDAV",
            "MSextWebDAV",
            "MSRPCext",
            "optionsHTTP"
         ]
      },
      "ignore_100_continue" : {
         "description" : "If this field has the value true the 100 continue HTTP header will be ignored; if the value is false, the 100 continue header will be processed.",
         "edition" : "ee",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "listener" : {
         "description" : "A listener defines how the farm is going to play with the requests from the clients. The options are: http for not secured protocol or https for secured protocol.",
         "non_blank" : "true",
         "values" : [
            "http",
            "https"
         ]
      },
      "logs" : {
         "description" : "The farm Logs the trace of the HTTP connections. If this parameter has the value true, the logs are enabled; if it has the value false, logs are disabled.",
         "edition" : "ee",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "newfarmname" : {
         "depend_on" : "status==down",
         "depend_on_msg" : "The farm must be stopped.",
         "description" : "The ne farm name",
         "exceptions" : [
            "0"
         ],
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]+)"
      },
      "reqtimeout" : {
         "description" : "How long the farm is going to wait for a client request in seconds.",
         "format_msg" : "expects a natural number",
         "non_blank" : "true",
         "regex" : "(?^:[1-9]\\d*)"
      },
      "restimeout" : {
         "description" : "How long the farm is going to wait for a response from the backends in seconds.",
         "format_msg" : "expects a natural number",
         "non_blank" : "true",
         "regex" : "(?^:[1-9]\\d*)"
      },
      "resurrectime" : {
         "description" : "This value in seconds is the period to get out a blacklisted backend and checks if it is alive.",
         "format_msg" : "expects a natural number",
         "non_blank" : "true",
         "regex" : "(?^:[1-9]\\d*)"
      },
      "rewritelocation" : {
         "description" : "If it is enabled, the farm is forced to modify the Location: and Content-location: headers in responses to clients with the virtual host. The options are: enabled activated; disabled inactivated; or enabled-backends only the backend address is compared.",
         "non_blank" : "true",
         "values" : [
            "disabled",
            "enabled",
            "enabled-backends",
            "enabled-path",
            "enabled-backends-path"
         ]
      },
      "vip" : {
         "description" : "IP of the farm, where the virtual service is listening, this IP must be configured and up in the system.",
         "format_msg" : "expects an IP",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "vport" : {
         "description" : "Port of the farm, where the virtual service is listening.",
         "interval" : "1,65535",
         "non_blank" : "true"
      }
   },
   "url" : "/farm/<farmname>"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_header_request_add-create.json ===

{
   "action" : "add",
   "description" : "The farm will add the header to the backend request.",
   "method" : "POST",
   "params" : {
      "header" : {
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/addheader"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_header_request_add-modify.json ===

{
   "action" : "modify",
   "description" : "The farm will add the header to the backend request.",
   "method" : "PUT",
   "params" : {
      "header" : {
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/addheader/<id>"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_header_request_remove-create.json ===

{
   "action" : "add",
   "description" : "Remove certain headers from the incoming requests.",
   "method" : "POST",
   "params" : {
      "pattern" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/headremove"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_header_request_remove-modify.json ===

{
   "action" : "modify",
   "description" : "Remove certain headers from the incoming requests.",
   "method" : "PUT",
   "params" : {
      "pattern" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/headremove"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_header_request_replace-create.json ===

{
   "action" : "add",
   "description" : "Add rules to rewrite headers from the request.",
   "method" : "POST",
   "params" : {
      "header" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      },
      "match" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      },
      "replace" : {
         "negated_regex" : "(?^:\\n)",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/replacerequestheader"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_header_request_replace-modify.json ===

{
   "action" : "add",
   "description" : "Add rules to rewrite headers from the request.",
   "method" : "POST",
   "params" : {
      "header" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true"
      },
      "match" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true"
      },
      "replace" : {
         "negated_regex" : "(?^:\\n)"
      }
   },
   "url" : "/farms/<farmname>/replacerequestheader"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_header_request_replace-move.json ===

{
   "action" : "add",
   "description" : "Move a ReplaceHeader",
   "method" : "POST",
   "params" : {
      "position" : {
         "non_blank" : "true",
         "regex" : "(?^:\\d+)",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/replacerequestheader/<id>/actions"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_header_response_add-create.json ===

{
   "action" : "add",
   "description" : "The farm will add the header to the backend response.",
   "method" : "POST",
   "params" : {
      "header" : {
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/addresponseheader"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_header_response_add-modify.json ===

{
   "action" : "add",
   "description" : "The farm will add the header to the backend response.",
   "method" : "POST",
   "params" : {
      "header" : {
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/addresponseheader"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_header_response_remove-create.json ===

{
   "action" : "add",
   "description" : "Remove certain headers from the backend response.",
   "method" : "POST",
   "params" : {
      "pattern" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/removeresponseheader"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_header_response_remove-modify.json ===

{
   "action" : "add",
   "description" : "Remove certain headers from the backend response.",
   "method" : "POST",
   "params" : {
      "pattern" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/removeresponseheader"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_header_response_replace-create.json ===

{
   "action" : "add",
   "description" : "Add rules to rewrite headers from the response.",
   "method" : "POST",
   "params" : {
      "header" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      },
      "match" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      },
      "replace" : {
         "negated_regex" : "(?^:\\n)",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/replaceresponseheader"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_header_response_replace-modify.json ===

{
   "action" : "add",
   "description" : "Add rules to rewrite headers from the response.",
   "method" : "POST",
   "params" : {
      "header" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true"
      },
      "match" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true"
      },
      "replace" : {}
   },
   "url" : "/farms/<farmname>/replaceresponseheader"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_header_response_replace-move.json ===

{
   "action" : "add",
   "description" : "Move a ReplaceHeader",
   "method" : "POST",
   "params" : {
      "position" : {
         "non_blank" : "true",
         "regex" : "(?^:\\d+)",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/replaceresponseheader/<id>/actions"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_service-create.json ===

{
   "action" : "add",
   "description" : "Create a service in a given HTTP profile Farm.",
   "method" : "POST",
   "params" : {
      "id" : {
         "exceptions" : [
            "0"
         ],
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]+)"
      }
   },
   "url" : "/farms/<farmname>/services"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_service-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of a service in an HTTP profile.",
   "method" : "PUT",
   "params" : {
      "cookiedomain" : {
         "edition" : "ee"
      },
      "cookieinsert" : {
         "edition" : "ee",
         "values" : [
            "true",
            "false"
         ]
      },
      "cookiename" : {
         "edition" : "ee"
      },
      "cookiepath" : {
         "edition" : "ee"
      },
      "cookiettl" : {
         "edition" : "ee",
         "non_blank" : "true",
         "regex" : "(?^:[1-9]\\d*)"
      },
      "httpsb" : {
         "non_blank" : "true",
         "regex" : "(?^:(?:true|false))"
      },
      "leastresp" : {
         "non_blank" : "true",
         "regex" : "(?^:(?:true|false))"
      },
      "persistence" : {
         "non_blank" : "false",
         "values" : [
            "IP",
            "BASIC",
            "NONE",
            "URL",
            "PARM",
            "COOKIE",
            "HEADER"
         ]
      },
      "pinnedconnection" : {
         "non_blank" : "true",
         "values" : [
            0,
            1
         ]
      },
      "redirect" : {
         "non_blank" : "false",
         "regex" : "(?^:(http|https)://([^/]+)(.*))"
      },
      "redirect_code" : {
         "edition" : "ee",
         "values" : [
            301,
            302,
            307
         ]
      },
      "redirecttype" : {
         "values" : [
            "default",
            "append"
         ]
      },
      "rewritelocation" : {
         "non_blank" : "true",
         "values" : [
            "disabled",
            "enabled",
            "enabled-backends",
            "enabled-path",
            "enabled-backends-path"
         ]
      },
      "routingpolicy" : {
         "non_blank" : "true",
         "values" : [
            "ROUND_ROBIN",
            "LEAST_CONNECTIONS",
            "RESPONSE_TIME",
            "PENDING_CONNECTIONS"
         ]
      },
      "sessionid" : {},
      "sts_status" : {
         "edition" : "ee",
         "values" : [
            "true",
            "false"
         ]
      },
      "sts_timeout" : {
         "edition" : "ee",
         "regex" : "(?^:(?:\\d+))"
      },
      "ttl" : {
         "non_blank" : "true",
         "regex" : "(?^:[1-9]\\d*)"
      },
      "urlp" : {
         "is_regex" : "true"
      },
      "vhost" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:^\\^)"
      }
   },
   "url" : "/farms/<farmname>/services/<id>"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_service_backend-add.json ===

{
   "action" : "add",
   "description" : "Create a new Backend in a given HTTP profile. id is the service unique identifier.",
   "method" : "POST",
   "params" : {
      "connection_limit" : {
         "depend_on" : "proxy_ng==true",
         "interval" : "0,"
      },
      "ip" : {
         "format_msg" : "expects an IP",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))",
         "required" : "true"
      },
      "port" : {
         "non_blank" : "true",
         "regex" : "(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))",
         "required" : "true"
      },
      "priority" : {
         "depend_on" : "proxy_ng==true",
         "interval" : "1,9"
      },
      "timeout" : {
         "regex" : "(?^:[1-9]\\d*)"
      },
      "weight" : {
         "interval" : "1,9"
      }
   },
   "url" : "/farms/<farmname>/services/<id>/backends"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_service_backend-maintenance.json ===

{
   "action" : "maintenance",
   "description" : "Set a given action in a backend of an HTTP farm.",
   "method" : "PUT",
   "params" : {
      "action" : {
         "depend_on_msg" : "The farm cannot be in need_restart status to set maintenance",
         "non_blank" : "true",
         "values" : [
            "up",
            "maintenance"
         ]
      },
      "mode" : {
         "depend_on" : "action==maintenance",
         "non_blank" : "true",
         "values" : [
            "drain",
            "cut"
         ]
      }
   },
   "url" : "/farms/<farmname>/services/<id>/backends/<id>/maintenance"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_service_backend-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of a backend HTTP service.",
   "method" : "PUT",
   "params" : {
      "connection_limit" : {
         "depend_on" : "proxy_ng==true",
         "interval" : "0,"
      },
      "ip" : {
         "format_msg" : "expects an IP",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "port" : {
         "non_blank" : "true",
         "regex" : "(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))"
      },
      "priority" : {
         "depend_on" : "proxy_ng==true",
         "interval" : "1,9"
      },
      "timeout" : {
         "regex" : "(?^:[1-9]\\d*)"
      },
      "weight" : {
         "interval" : "1,9"
      }
   },
   "url" : "/farms/<farmname>/services/<id>/backends/<id>"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_service_url_rewrite-create.json ===

{
   "action" : "add",
   "description" : "It checks a pattern in order to get strings from URL and replace them.",
   "method" : "POST",
   "params" : {
      "last" : {
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "pattern" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true",
         "required" : "true"
      },
      "replace" : {
         "negated_regex" : "(?^:\\n)",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/service/<servicename>/rewriteurl"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_service_url_rewrite-modify.json ===

{
   "action" : "add",
   "description" : "It checks a pattern in order to get strings from URL and replace them.",
   "method" : "POST",
   "params" : {
      "last" : {
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "pattern" : {
         "is_regex" : "true",
         "negated_regex" : "(?^:\\n)",
         "non_blank" : "true"
      },
      "replace" : {
         "negated_regex" : "(?^:\\n)"
      }
   },
   "url" : "/farms/<farmname>/service/<servicename>/rewriteurl"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_http_service_url_rewrite-move.json ===

{
   "action" : "move",
   "description" : "It checks a pattern in order to get strings from URL and replace them.",
   "method" : "POST",
   "params" : {
      "position" : {
         "non_blank" : "true",
         "regex" : "(?^:\\d+)",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/service/<servicename>/rewriteurl/<id>/actions"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_l4xnat-modify.json ===

{
   "action" : "set",
   "description" : "Modify the configuration of a l4xnat farm.",
   "method" : "PUT",
   "params" : {
      "algorithm" : {
         "non_blank" : "true",
         "values" : [
            "weight",
            "roundrobin",
            "hash_srcip_srcport",
            "hash_srcip",
            "symhash",
            "leastconn"
         ]
      },
      "logs" : {
         "edition" : "ee",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "nattype" : {
         "non_blank" : "true",
         "values" : [
            "nat",
            "dnat",
            "dsr",
            "stateless_dnat"
         ]
      },
      "newfarmname" : {
         "exceptions" : [
            "0"
         ],
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]+)"
      },
      "persistence" : {
         "values" : [
            "ip",
            "srcip",
            "srcport",
            "srcmac",
            "srcip_srcport",
            "srcip_dstport",
            "none"
         ]
      },
      "protocol" : {
         "non_blank" : "true",
         "values" : [
            "all",
            "tcp",
            "udp",
            "sctp",
            "sip",
            "ftp",
            "tftp",
            "amanda",
            "h323",
            "irc",
            "netbios-ns",
            "pptp",
            "sane",
            "snmp"
         ]
      },
      "ttl" : {
         "non_blank" : "true",
         "regex" : "(?^:[1-9]\\d*)"
      },
      "vip" : {
         "dyn_values" : "true",
         "format_msg" : "The vip IP must exist in some interface.",
         "non_blank" : "true"
      },
      "vport" : {
         "non_blank" : "true"
      }
   },
   "url" : "/farm/<farmname>"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_l4xnat_service_backend-add.json ===

{
   "action" : "add",
   "description" : "Create a new Backend in a given L4xNAT Farm.",
   "method" : "POST",
   "params" : {
      "ip" : {
         "format_msg" : "expects an IP",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))",
         "required" : "true"
      },
      "max_conns" : {
         "interval" : "0,"
      },
      "port" : {
         "format_msg" : "expects a port or port range",
         "regex" : "(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))"
      },
      "priority" : {
         "interval" : "1,9"
      },
      "weight" : {
         "interval" : "1,9"
      }
   },
   "url" : "/farms/<farmname>/backends"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_l4xnat_service_backend-maintenance.json ===

{
   "action" : "maintenance",
   "description" : "Set a given action in a backend of an L4xNAT farm.",
   "method" : "PUT",
   "params" : {
      "action" : {
         "non_blank" : "true",
         "values" : [
            "up",
            "maintenance"
         ]
      },
      "mode" : {
         "depend_on" : "action==maintenance",
         "non_blank" : "true",
         "values" : [
            "drain",
            "cut"
         ]
      }
   },
   "url" : "/farms/<farmname>/backends/<id>/maintenance"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farm_l4xnat_service_backend-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of a backend in for a L4xNAT Farm. id is the backend unique identifier.",
   "method" : "PUT",
   "params" : {
      "interface" : {
         "non_blank" : "true"
      },
      "ip" : {
         "format_msg" : "expects an IP",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "max_conns" : {
         "interval" : "0,"
      },
      "port" : {
         "regex" : "(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))"
      },
      "priority" : {
         "interval" : "1,9"
      },
      "weight" : {
         "interval" : "1,9"
      }
   },
   "url" : "/farms/<farmname>/backends/<id>"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farmguardian-create.json ===

{
   "action" : "create",
   "description" : "Create a monitoring check to evaluate the farm service status.",
   "method" : "POST",
   "params" : {
      "copy_from" : {
         "regex" : "(?^:[\\w-]+)"
      },
      "name" : {
         "exceptions" : [
            "0"
         ],
         "non_blank" : "true",
         "regex" : "(?^:[\\w-]+)",
         "required" : "true"
      }
   },
   "url" : "/monitoring/fg"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farmguardian-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of the health check",
   "method" : "PUT",
   "params" : {
      "backend_alias" : {
         "non_blank" : "false",
         "values" : [
            "true",
            "false"
         ]
      },
      "command" : {
         "non_blank" : "true"
      },
      "cut_conns" : {
         "non_blank" : "false",
         "values" : [
            "true",
            "false"
         ]
      },
      "description" : {
         "non_blank" : "true"
      },
      "force" : {
         "non_blank" : "false",
         "values" : [
            "true",
            "false"
         ]
      },
      "interval" : {
         "regex" : "(?^:[1-9]\\d*)"
      },
      "log" : {
         "non_blank" : "false",
         "values" : [
            "true",
            "false"
         ]
      },
      "timeout" : {
         "regex" : "(?^:[1-9]\\d*)"
      }
   },
   "url" : "/monitoring/fg/<name>"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/farmguardian_to_farm-add.json ===

{
   "action" : "add",
   "description" : "Apply a FarmGuardian to a service.",
   "method" : "POST",
   "params" : {
      "name" : {
         "non_blank" : "true",
         "required" : "true"
      }
   },
   "url" : "/farms/<farmname>/services/<id>/fg"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/gateway-modify.json ===

{
   "action" : "set",
   "description" : "Modify the configuration of the gateway interface.",
   "method" : "PUT",
   "params" : {
      "address" : {
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "interface" : {
         "non_blank" : "true"
      }
   },
   "url" : "/interfaces/gateway/<ip_version>"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/letsencrypt-action.json ===

{
   "action" : "action",
   "description" : "Apply an action in a Letsencrypt certificate by first domain.",
   "method" : "POST",
   "params" : {
      "action" : {
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "renew"
         ]
      },
      "farmname" : {
         "description" : "Farm name which a temporal Service “LetsEncryptTemporalFarm” is configured in. Required if param vip is not sent.",
         "dyn_values" : "true",
         "non_blank" : "true"
      },
      "force_renewal" : {
         "description" : "true, force the certificate to be renewed even it is not expired, false, the certificate will be renewed if it is due to be renewed ( less than 30 days to expire ).",
         "values" : [
            "true",
            "false"
         ]
      },
      "restart" : {
         "description" : "true, all the farms using the certificate will be restarted. false, no farms using the certificate will be restarted.",
         "values" : [
            "true",
            "false"
         ]
      },
      "vip" : {
         "description" : "IP of the system, where a temporal Farm “LetsEncryptTemporalFarm” is configured. Required true if param vip is not sent.",
         "dyn_values" : "true",
         "non_blank" : "true"
      }
   },
   "url" : "/certificates/letsencrypt/<domain>/actions"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/letsencrypt-create.json ===

{
   "action" : "renew",
   "description" : "Create a new Letsencrypt certificate.",
   "method" : "POST",
   "params" : {
      "domains" : {
         "description" : "List of domains which the certificate is vaild for.",
         "ref" : "ARRAY",
         "required" : "true"
      },
      "farmname" : {
         "description" : "Farm name which a temporal Service Letsencryptz is configured in.",
         "dyn_values" : "true",
         "non_blank" : "true"
      },
      "force" : {
         "description" : "This parameter is used get a confirmation before creating a certificate.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "test" : {
         "description" : "true, the certificate is issued by LetsEncrypt Staging Server. false, the certificate is issued by LetsEncrypt Server and it will valid for Production environment.",
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "vip" : {
         "description" : "IP of the system, where a temporal Farm Letsencryptz is configured.",
         "dyn_values" : "true",
         "non_blank" : "true"
      }
   },
   "url" : "/certificates/letsencrypt"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/letsencrypt-modify.json ===

{
   "action" : "set",
   "description" : "Modify the Auto Renewal parameters of a Letsencrypt certificate.",
   "method" : "PUT",
   "params" : {
      "autorenewal" : {
         "description" : "true,the autorenewal will be configured.false, the autorenewal will be removed.",
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "farmname" : {
         "depend_on" : "autorenewal==true && vip!=defined",
         "description" : "Farm name which a temporal Service “LetsEncryptTemporalFarm” is configured in. Required if param vip is not sent.",
         "dyn_values" : "true",
         "non_blank" : "true"
      },
      "force_renewal" : {
         "depend_on" : "autorenewal==true",
         "description" : "true, force the certificate to be renewed even it is not expired, false, the certificate will be renewed if it is due to be renewed ( less than 30 days to expire ).",
         "required" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "restart" : {
         "depend_on" : "autorenewal==true",
         "description" : "true, all the farms using the certificate will be restarted. false, no farms using the certificate will be restarted.",
         "required" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "vip" : {
         "depend_on" : "autorenewal==true && farmname!=defined",
         "description" : "IP of the system, where a temporal Farm “LetsEncryptTemporalFarm” is configured. Required true if param vip is not sent.",
         "dyn_values" : "true",
         "non_blank" : "true"
      }
   },
   "url" : "/certificates/letsencrypt/<domain>"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/letsencrypt_config-modify.json ===

{
   "action" : "set",
   "description" : "Modify Letsencrypt Configuration.",
   "method" : "PUT",
   "params" : {
      "email" : {
         "description" : "Email for use as a contact in Letsencrypt",
         "non_blank" : "true",
         "regex" : "(?^:^(?:[a-zA-Z][\\w\\_\\.]+)\\@(?:[a-zA-Z0-9.-]+)\\.(?:[a-zA-Z]{2,4})$)",
         "required" : "true"
      }
   },
   "url" : "/certificates/letsencrypt/config"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/nic-action.json ===

{
   "action" : "status",
   "description" : "Apply an action to a NIC interface. This call lets enable or disable a network interface.",
   "method" : "POST",
   "params" : {
      "action" : {
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "up",
            "down"
         ]
      }
   },
   "url" : "/interfaces/nic/<name>/actions"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/nic-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of a NIC interface. name is the interface unique identifier.",
   "method" : "PUT",
   "params" : {
      "dhcp" : {
         "edition" : "ee",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "force" : {
         "non_blank" : "true",
         "values" : [
            "true"
         ]
      },
      "gateway" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "ip" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "netmask" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?:[0-9]{1,2}|10[0-9]|11[0-9]|12[0-8])))"
      }
   },
   "url" : "/interfaces/nic/<name>"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/system_backup-create.json ===

{
   "action" : "create",
   "description" : "Create a system configuration backup of the current configuration.",
   "method" : "POST",
   "params" : {
      "name" : {
         "description" : "It is the file name used as a unique identifier. The file extension is .tar.gz.",
         "non_blank" : "true",
         "regex" : "(?^:[\\w-]+)",
         "required" : "true"
      }
   },
   "url" : "/system/backup"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/system_backup-restore.json ===

{
   "action" : "apply",
   "description" : "Restore the configuration from a backup file. Name is the backup unique identifier.",
   "method" : "POST",
   "params" : {
      "action" : {
         "description" : "To restore the backup configuration, the value must be apply.",
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "apply"
         ]
      },
      "force" : {
         "description" : "This parameter is used get a confirmation before applying the backup.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      }
   },
   "url" : "/system/backup/<name>/actions"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/system_dns-modify.json ===

{
   "action" : "set",
   "description" : "Modify the DNS service configuration.",
   "method" : "POST",
   "params" : {
      "primary" : {
         "description" : "Primary DNS configurated in the system.",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "secondary" : {
         "description" : "Secondary DNS configurated in the system.",
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      }
   },
   "url" : "/system/dns"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/system_factory-apply.json ===

{
   "action" : "factory",
   "description" : "Apply a factory reset in the system. It will delete all the user configuration. The root password, the hostname, one NIC interface and the certificate will not be modified. The system will be restarted while the process is going on.",
   "method" : "POST",
   "params" : {
      "force" : {
         "description" : "It is a confirmation about to apply the factory reset. This parameter has to be sent with true value for applying it.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "interface" : {
         "description" : "It is a NIC interface name. This interface will not be deleted in the factory reset process. The system will be available before factory reset through this interface.",
         "dyn_values" : "true",
         "non_blank" : "true",
         "required" : "true"
      },
      "remove_backups" : {
         "description" : "It is an option about remove all system backups. They will not be removed by default. If this parameter is set to true, the backups will be removed.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      }
   },
   "url" : "/system/factory"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/system_global-modify.json ===

{
   "action" : "set",
   "description" : "Modify RELIANOID global Settings.",
   "method" : "POST",
   "params" : {
      "arp_announce" : {
         "description" : "If this parameter is enabled true, the master node of the cluster will send a ARP packet to the network per minute and when the system boots. If the value is false the packet will be sent only when cluster switches to master or when a interface will be configurated.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "duplicated_network" : {
         "description" : "If this parameter is enabled true, the system will able to manage networks duplicated in different interfaces, a process will ensure that an interface does not route through another with the same netwoking. This can be disabled with the value false.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "force" : {
         "description" : "This parameter is used to force the settings when these require a service restart. This parameter accepts the value true.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "ssyncd" : {
         "description" : "Session synchronization daemon is which replies the client sessions between master and backup nodes for a cluster. This feature is enabled with the value true and disabled with false.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "waf_assistant" : {
         "description" : "If this parameter is enabled true, the system will assist the user with WAF settings of the farms.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      }
   },
   "url" : "/system/global"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/system_language-modify.json ===

{
   "action" : "factory",
   "description" : "Modify the WebGUI language.",
   "method" : "POST",
   "params" : {
      "language" : {
         "description" : "string with the language used in webgui.",
         "required" : "true"
      }
   },
   "url" : "/system/factory"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/system_ntp-modify.json ===

{
   "action" : "set",
   "description" : "Modify the NTP service configuration.",
   "method" : "POST",
   "params" : {
      "server" : {
         "description" : "Server where NTP client does the requests.",
         "non_blank" : "true",
         "regex" : "(?^:[\\w\\.\\-]+)",
         "required" : "true"
      }
   },
   "url" : "/system/ntp"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/system_proxy-modify.json ===

{
   "action" : "set",
   "description" : "Show the configuration about HTTP/HTTPS remote services. This proxy will be used to the remote HTTP request from the load balancer (as downloading IPDS rules and getting packages updates).",
   "method" : "POST",
   "params" : {
      "http_proxy" : {
         "description" : "It is the URL to the remote proxy server to send the requests that use the HTTP protocol, without SSL encryption.",
         "regex" : "(?^:\\S*)"
      },
      "https_proxy" : {
         "description" : "It is the URL to the remote proxy server to send the requests that use the HTTPS protocol, with SSL encryption.",
         "regex" : "(?^:\\S*)"
      }
   },
   "url" : "/system/proxy"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/system_snmp-modify.json ===

{
   "action" : "set",
   "description" : "Modify the SNMP service configuration.",
   "method" : "POST",
   "params" : {
      "community" : {
         "description" : "Community name. Read-Only Community used.",
         "length" : 32,
         "non_blank" : "true"
      },
      "ip" : {
         "description" : "Interface IP where the SNMP service is running. It’s safe to keep the All interfaces enabled using the character *.",
         "dyn_values" : "true",
         "non_blank" : "true"
      },
      "port" : {
         "description" : "Port where SNMP service is running.",
         "non_blank" : "true",
         "regex" : "(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))"
      },
      "scope" : {
         "description" : "IP or subnet with access (IP/bit). Allowed client IPs to access SNMPD service, in case you want to allow access only one IP please use the bit /32.",
         "non_blank" : "true",
         "regex" : "(?^:(?:\\d{1,3}\\.){3}\\d{1,3}\\/\\d{1,2})"
      },
      "status" : {
         "description" : "Status of SNMP service. The possible values are: true, the service is running; or false, the service is stopped.",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      }
   },
   "url" : "/system/snmp"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/system_ssh-modify.json ===

{
   "action" : "set",
   "description" : "Modify the SSH service configuration.",
   "method" : "POST",
   "params" : {
      "listen" : {
         "description" : "IP of the system where the SSH service is listening. The character * is used to listen in all configurated IPs. Enabled to set an array to configure multiple ips.",
         "non_blank" : "true",
         "ref" : "array|none",
         "regex" : "(?^:(?:(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))|\\*))"
      },
      "port" : {
         "description" : "Port configurated for SSH service. Enabled to set an array to configure multiple ports.",
         "non_blank" : "true",
         "ref" : "array|none",
         "regex" : "(?^:(?:[1-9]\\d{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))"
      }
   },
   "url" : "/system/ssh"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/system_user-modify.json ===

{
   "action" : "set",
   "description" : "Modify the configuration of the current user. The current user is authenticated with the API_KEY or logged in the WebGUI.",
   "method" : "POST",
   "params" : {
      "api_key" : {
         "description" : "Each user can have an API key. With this API key, the user can do action through the API key with the permissions of the user’s role.",
         "regex" : "(?^:[a-zA-Z0-9]+)"
      },
      "api_permissions" : {
         "description" : "The possible values are: true, to enable the access to the load balancer through the API; or false, to deny the access through the API.",
         "non_blank" : "true",
         "regex" : "(?^:(?:true|false))"
      },
      "newpassword" : {
         "description" : "New user password to access through the WebGUI.",
         "format_msg" : "must contain at least a letter and a number and a minimum length of 8 characters.",
         "non_blank" : "true",
         "regex" : "(?^:(?=.*[0-9])(?=.*[a-zA-Z]).{8,512})"
      },
      "password" : {
         "description" : "It is the current user password. It is required when newpassword is sent.",
         "non_blank" : "true"
      },
      "zapi_permissions" : {
         "description" : "The possible values are: true, to enable the access to the load balancer through the API; or false, to deny the access through the API. This parameter is deprecated and it will be removed, use `api_permissions` instead.",
         "non_blank" : "true",
         "regex" : "(?^:(?:true|false))"
      },
      "zapikey" : {
         "description" : "Each user can have an API key. With this API key, the user can do action through the API key with the permissions of the user’s role. This parameter is deprecated and it will be removed, use `api_key` instead.",
         "regex" : "(?^:[a-zA-Z0-9]+)"
      }
   },
   "url" : "/system/users"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/virtual-action.json ===

{
   "action" : "status",
   "description" : "Apply an action to a virtual interface. This call lets enable or disable a network interface.",
   "method" : "POST",
   "params" : {
      "action" : {
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "up",
            "down"
         ]
      }
   },
   "url" : "/interfaces/virtual/<name>/actions"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/virtual-create.json ===

{
   "action" : "create",
   "description" : "Create a virtual interface.",
   "method" : "POST",
   "params" : {
      "ip" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))",
         "required" : "true"
      },
      "name" : {
         "format_msg" : "is a string formed with the parent interface name, colon (:) and a virtual interface tag. E.g: eth1:virt1",
         "non_blank" : "true",
         "regex" : "(?^:(?:(?^:[a-zA-Z0-9\\-]{1,15})|(?^:[a-zA-Z0-9\\-]{1,15}))(?:\\.(?^:\\d{1,4}))?:(?^:[a-zA-Z0-9\\-]{1,13}))",
         "required" : "true"
      }
   },
   "url" : "/interfaces/virtual"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/virtual-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of a virtual interface. name is the interface unique identifier.",
   "method" : "PUT",
   "params" : {
      "force" : {
         "non_blank" : "true",
         "values" : [
            "true"
         ]
      },
      "ip" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      }
   },
   "url" : "/interfaces/virtual/<name>"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/vlan-action.json ===

{
   "action" : "status",
   "description" : "Apply an action to a VLAN interface. This call lets enable or disable a network interface.",
   "method" : "POST",
   "params" : {
      "action" : {
         "non_blank" : "true",
         "required" : "true",
         "values" : [
            "up",
            "down"
         ]
      }
   },
   "url" : "/interfaces/vlan/<name>/actions"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/vlan-create.json ===

{
   "action" : "create",
   "description" : "Create a VLAN interface from a NIC or bonding interface. The new VLAN interface will share MAC, although the following network parameters must be different: ip, and the following can change: gateway, netmask.",
   "method" : "POST",
   "params" : {
      "dhcp" : {
         "edition" : "ee",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "gateway" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "ip" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "mac" : {
         "edition" : "ee",
         "regex" : "(?^:(?:(?^:(?:[A-Fa-f0-9]))(?^:(?:[A-Fa-f0-9]))\\:){5}(?^:(?:[A-Fa-f0-9]))(?^:(?:[A-Fa-f0-9])))"
      },
      "name" : {
         "format_msg" : "is a string formed with the parent interface name, dot (.) and a VLAN tag. E.g: eth1.1",
         "non_blank" : "true",
         "regex" : "(?^:[a-zA-Z0-9\\-]{1,13}\\.(?^:\\d{1,4}))",
         "required" : "true"
      },
      "netmask" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?:[0-9]{1,2}|10[0-9]|11[0-9]|12[0-8])))"
      }
   },
   "url" : "/interfaces/vlan"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/api-model/v4.0/json/vlan-modify.json ===

{
   "action" : "set",
   "description" : "Modify the parameters of a VLAN interface. name is the interface unique identifier.",
   "method" : "PUT",
   "params" : {
      "dhcp" : {
         "edition" : "ee",
         "non_blank" : "true",
         "values" : [
            "true",
            "false"
         ]
      },
      "force" : {
         "non_blank" : "true",
         "values" : [
            "true"
         ]
      },
      "gateway" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "ip" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?^::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))))"
      },
      "mac" : {
         "edition" : "ee",
         "regex" : "(?^:(?:(?^:(?:[A-Fa-f0-9]))(?^:(?:[A-Fa-f0-9]))\\:){5}(?^:(?:[A-Fa-f0-9]))(?^:(?:[A-Fa-f0-9])))"
      },
      "netmask" : {
         "regex" : "(?^:(?:(?^:(?:(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0)\\.){3}(?:25[0-5]|2[0-4]\\d|(?!0)[1]?\\d\\d?|0))|(?:[0-9]{1,2}|10[0-9]|11[0-9]|12[0-8])))"
      }
   },
   "url" : "/interfaces/vlan/<name>"
}

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/app/letsencrypt/etc/cherokee_localhost.conf ===

config!version = 001002104
server!bind!1!interface = 127.0.0.1
server!bind!1!port = 80
server!bind!1!tls = 0
server!ipv6 = 0
server!keepalive = 1
server!keepalive_max_requests = 500
server!panic_action = /usr/local/relianoid/app/cherokee/bin/cherokee_localhost-panic
server!pid_file = /usr/local/relianoid/app/cherokee/var/run/cherokee_localhost.pid
server!server_tokens = full
server!timeout = 60
server!tls = libssl
server!tls!protocol!SSLv2 = 0
server!user = root
vserver!1!directory_index = index.html
vserver!1!document_root = /opt/certs
vserver!1!error_writer!filename = /var/log/cherokee-error.log
vserver!1!error_writer!type = file
vserver!1!logger = combined
vserver!1!logger!access!buffsize = 16384
vserver!1!logger!access!filename = /var/log/cherokee-access.log
vserver!1!logger!access!type = file
vserver!1!nick = default
#vserver!1!rule!500!encoder!gzip = allow
#vserver!1!rule!500!encoder!gzip!compression_level = 9
vserver!1!rule!500!match = directory
vserver!1!rule!500!match!directory = /
vserver!1!rule!500!match!final = 0
vserver!1!rule!300!document_root = /usr/local/relianoid/app/letsencrypt/webroot/
#vserver!1!rule!300!encoder!gzip = allow
#vserver!1!rule!300!encoder!gzip!compression_level = 9
vserver!1!rule!300!handler = common
vserver!1!rule!300!handler!allow_dirlist = 0
vserver!1!rule!300!handler!allow_pathinfo = 0
vserver!1!rule!300!handler!iocache = 0
vserver!1!rule!300!match = or
vserver!1!rule!300!match!left = fullpath
vserver!1!rule!300!match!left!directory = /
vserver!1!rule!300!match!left!fullpath!1 = /index.html
vserver!1!rule!300!match!left!fullpath!2 = /
vserver!1!rule!300!match!left!request = ^$
vserver!1!rule!300!match!right = not
vserver!1!rule!300!match!right!right = request
vserver!1!rule!300!match!right!right!request = ^.*nothing.*
#vserver!1!rule!200!document_root = /usr/local/relianoid/app/letsencrypt/webroot/
#vserver!1!rule!200!handler = cgi
#vserver!1!rule!200!timeout = 60
#vserver!1!rule!200!handler!change_user = 0
#vserver!1!rule!200!handler!check_file = 1
#vserver!1!rule!200!handler!error_handler = 1
#vserver!1!rule!200!handler!pass_req_headers = 1
#vserver!1!rule!200!handler!xsendfile = 0
#vserver!1!rule!200!match = extensions
#vserver!1!rule!200!match!check_local_file = 0
#vserver!1!rule!200!match!extensions = cgi
#vserver!1!rule!100!match = default
vserver!1!ssl_certificate_file = /usr/local/relianoid/config/certificates/noid_ssl_cert.pem
vserver!1!ssl_certificate_key_file = /usr/local/relianoid/config/certificates/noid_ssl_cert.key
#vserver!1!ssl_cipher_server_preference = 1
#vserver!1!ssl_ciphers = HIGH:!aNULL:!MD5 
#vserver!1!ssl_ciphers = ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK
vserver!1!ssl_compression = 1
icons!default = page_white.png
icons!directory = folder.png
icons!file!bomb.png = core
icons!file!page_white_go.png = *README*
icons!parent_directory = arrow_turn_left.png
icons!suffix!camera.png = jpg,jpeg,jpe
icons!suffix!cd.png = iso,ngr,cue
icons!suffix!color_wheel.png = png,gif,xcf,bmp,pcx,tiff,tif,cdr,psd,xpm,xbm
icons!suffix!control_play.png = bin,exe,com,msi,out
icons!suffix!css.png = css
icons!suffix!cup.png = java,class,jar
icons!suffix!email.png = eml,mbox,box,email,mbx
icons!suffix!film.png = avi,mpeg,mpe,mpg,mpeg3,dl,fli,qt,mov,movie,flv,webm
icons!suffix!font.png = ttf
icons!suffix!html.png = html,htm
icons!suffix!music.png = au,snd,mid,midi,kar,mpga,mpega,mp2,mp3,sid,wav,aif,aiff,aifc,gsm,m3u,wma,wax,ra,rm,ram,pls,sd2,ogg
icons!suffix!package.png = tar,gz,bz2,zip,rar,ace,lha,7z,dmg,cpk
icons!suffix!page_white_acrobat.png = pdf
icons!suffix!page_white_c.png = c,h,cpp
icons!suffix!page_white_office.png = doc,ppt,xls
icons!suffix!page_white_php.png = php
icons!suffix!page_white_text.png = txt,text,rtf,sdw
icons!suffix!printer.png = ps,eps
icons!suffix!ruby.png = rb
icons!suffix!script.png = sh,csh,ksh,tcl,tk,py,pl
mime!application/bzip2!extensions = bz2
mime!application/gzip!extensions = gz
mime!application/hta!extensions = hta
mime!application/java-archive!extensions = jar
mime!application/java-serialized-object!extensions = ser
mime!application/java-vm!extensions = class
mime!application/json!extensions = json
mime!application/mac-binhex40!extensions = hqx
mime!application/msaccess!extensions = mdb
mime!application/msword!extensions = doc,dot
mime!application/octet-stream!extensions = bin
mime!application/octetstream!extensions = ace
mime!application/oda!extensions = oda
mime!application/ogg!extensions = ogx
mime!application/pdf!extensions = pdf
mime!application/pgp-keys!extensions = key
mime!application/pgp-signature!extensions = pgp
mime!application/pics-rules!extensions = prf
mime!application/postscript!extensions = ps,ai,eps
mime!application/rar!extensions = rar
mime!application/rdf+xml!extensions = rdf
mime!application/rss+xml!extensions = rss
mime!application/smil!extensions = smi,smil
mime!application/vnd.mozilla.xul+xml!extensions = xul
mime!application/vnd.ms-excel!extensions = xls,xlb,xlt
mime!application/vnd.ms-pki.seccat!extensions = cat
mime!application/vnd.ms-pki.stl!extensions = stl
mime!application/vnd.ms-powerpoint!extensions = ppt,pps
mime!application/vnd.oasis.opendocument.chart!extensions = odc
mime!application/vnd.oasis.opendocument.database!extensions = odb
mime!application/vnd.oasis.opendocument.formula!extensions = odf
mime!application/vnd.oasis.opendocument.graphics!extensions = odg
mime!application/vnd.oasis.opendocument.image!extensions = odi
mime!application/vnd.oasis.opendocument.presentation!extensions = odp
mime!application/vnd.oasis.opendocument.spreadsheet!extensions = ods
mime!application/vnd.oasis.opendocument.text!extensions = odt
mime!application/vnd.oasis.opendocument.text-master!extensions = odm
mime!application/vnd.oasis.opendocument.text-web!extensions = oth
mime!application/vnd.pkg5.info!extensions = p5i
mime!application/vnd.visio!extensions = vsd
mime!application/vnd.wap.wbxml!extensions = wbxml
mime!application/vnd.wap.wmlc!extensions = wmlc
mime!application/vnd.wap.wmlscriptc!extensions = wmlsc
mime!application/x-7z-compressed!extensions = 7z
mime!application/x-abiword!extensions = abw
mime!application/x-apple-diskimage!extensions = dmg
mime!application/x-bcpio!extensions = bcpio
mime!application/x-bittorrent!extensions = torrent
mime!application/x-cdf!extensions = cdf
mime!application/x-cpio!extensions = cpio
mime!application/x-csh!extensions = csh
mime!application/x-debian-package!extensions = deb,udeb
mime!application/x-director!extensions = dcr,dir,dxr
mime!application/x-dvi!extensions = dvi
mime!application/x-flac!extensions = flac
mime!application/x-font!extensions = pfa,pfb,gsf,pcf,pcf.Z
mime!application/x-freemind!extensions = mm
mime!application/x-gnumeric!extensions = gnumeric
mime!application/x-gtar!extensions = gtar,tgz,taz
mime!application/x-gzip!extensions = gz,tgz
mime!application/x-httpd-php!extensions = phtml,pht,php
mime!application/x-httpd-php-source!extensions = phps
mime!application/x-httpd-php3!extensions = php3
mime!application/x-httpd-php3-preprocessed!extensions = php3p
mime!application/x-httpd-php4!extensions = php4
mime!application/x-internet-signup!extensions = ins,isp
mime!application/x-iphone!extensions = iii
mime!application/x-iso9660-image!extensions = iso
mime!application/x-java-jnlp-file!extensions = jnlp
mime!application/x-javascript!extensions = js
mime!application/x-kchart!extensions = chrt
mime!application/x-killustrator!extensions = kil
mime!application/x-koan!extensions = skp,skd,skt,skm
mime!application/x-kpresenter!extensions = kpr,kpt
mime!application/x-kspread!extensions = ksp
mime!application/x-kword!extensions = kwd,kwt
mime!application/x-latex!extensions = latex
mime!application/x-lha!extensions = lha
mime!application/x-lzh!extensions = lzh
mime!application/x-lzx!extensions = lzx
mime!application/x-ms-wmd!extensions = wmd
mime!application/x-ms-wmz!extensions = wmz
mime!application/x-msdos-program!extensions = com,exe,bat,dll
mime!application/x-msi!extensions = msi
mime!application/x-netcdf!extensions = nc
mime!application/x-ns-proxy-autoconfig!extensions = pac
mime!application/x-nwc!extensions = nwc
mime!application/x-object!extensions = o
mime!application/x-oz-application!extensions = oza
mime!application/x-pkcs7-certreqresp!extensions = p7r
mime!application/x-pkcs7-crl!extensions = crl
mime!application/x-python-code!extensions = pyc,pyo
mime!application/x-quicktimeplayer!extensions = qtl
mime!application/x-redhat-package-manager!extensions = rpm
mime!application/x-sh!extensions = sh
mime!application/x-shar!extensions = shar
mime!application/x-shockwave-flash!extensions = swf,swfl
mime!application/x-stuffit!extensions = sit,sea
mime!application/x-sv4cpio!extensions = sv4cpio
mime!application/x-sv4crc!extensions = sv4crc
mime!application/x-tar!extensions = tar
mime!application/x-tcl!extensions = tcl
mime!application/x-tex-pk!extensions = pk
mime!application/x-texinfo!extensions = texinfo,texi
mime!application/x-trash!extensions = ~,bak,old,sik
mime!application/x-troff!extensions = t,tr,roff
mime!application/x-troff-man!extensions = man
mime!application/x-troff-me!extensions = me
mime!application/x-troff-ms!extensions = ms
mime!application/x-ustar!extensions = ustar
mime!application/x-x509-ca-cert!extensions = crt
mime!application/x-xcf!extensions = xcf
mime!application/x-xfig!extensions = fig
mime!application/x-xpinstall!extensions = xpi
mime!application/xhtml+xml!extensions = xhtml,xht
mime!application/xml!extensions = xml,xsl
mime!application/zip!extensions = zip
mime!audio/basic!extensions = au,snd
mime!audio/midi!extensions = mid,midi,kar
mime!audio/mpeg!extensions = mpga,mpega,mp2,mp3,m4a
mime!audio/ogg!extensions = ogg,oga
mime!audio/prs.sid!extensions = sid
mime!audio/x-aiff!extensions = aif,aiff,aifc
mime!audio/x-gsm!extensions = gsm
mime!audio/x-mpegurl!extensions = m3u
mime!audio/x-ms-wax!extensions = wax
mime!audio/x-ms-wma!extensions = wma
mime!audio/x-pn-realaudio!extensions = ra,rm,ram
mime!audio/x-realaudio!extensions = ra
mime!audio/x-scpls!extensions = pls
mime!audio/x-sd2!extensions = sd2
mime!audio/x-wav!extensions = wav
mime!chemical/x-cache!extensions = cac,cache
mime!chemical/x-cache-csf!extensions = csf
mime!chemical/x-cdx!extensions = cdx
mime!chemical/x-cif!extensions = cif
mime!chemical/x-cmdf!extensions = cmdf
mime!chemical/x-cml!extensions = cml
mime!chemical/x-compass!extensions = cpa
mime!chemical/x-crossfire!extensions = bsd
mime!chemical/x-csml!extensions = csml,csm
mime!chemical/x-ctx!extensions = ctx
mime!chemical/x-cxf!extensions = cxf,cef
mime!chemical/x-isostar!extensions = istr,ist
mime!chemical/x-jcamp-dx!extensions = jdx,dx
mime!chemical/x-kinemage!extensions = kin
mime!chemical/x-pdb!extensions = pdb,ent
mime!chemical/x-swissprot!extensions = sw
mime!chemical/x-vamas-iso14976!extensions = vms
mime!chemical/x-vmd!extensions = vmd
mime!chemical/x-xtel!extensions = xtel
mime!chemical/x-xyz!extensions = xyz
mime!image/gif!extensions = gif
mime!image/jpeg!extensions = jpeg,jpg,jpe
mime!image/pcx!extensions = pcx
mime!image/png!extensions = png
mime!image/svg+xml!extensions = svg,svgz
mime!image/tiff!extensions = tiff,tif
mime!image/vnd.djvu!extensions = djvu,djv
mime!image/vnd.wap.wbmp!extensions = wbmp
mime!image/x-icon!extensions = ico
mime!image/x-ms-bmp!extensions = bmp
mime!image/x-photoshop!extensions = psd
mime!image/x-portable-anymap!extensions = pnm
mime!image/x-portable-bitmap!extensions = pbm
mime!image/x-portable-graymap!extensions = pgm
mime!image/x-portable-pixmap!extensions = ppm
mime!image/x-xbitmap!extensions = xbm
mime!image/x-xpixmap!extensions = xpm
mime!image/x-xwindowdump!extensions = xwd
mime!model/iges!extensions = igs,iges
mime!model/mesh!extensions = msh,mesh,silo
mime!model/vrml!extensions = wrl,vrml
mime!text/calendar!extensions = ics,icz
mime!text/comma-separated-values!extensions = csv
mime!text/css!extensions = css
mime!text/h323!extensions = 323
mime!text/html!extensions = html,htm,shtml
mime!text/iuls!extensions = uls
mime!text/mathml!extensions = mml
mime!text/plain!extensions = asc,txt,text,diff,pot
mime!text/richtext!extensions = rtx
mime!text/rtf!extensions = rtf
mime!text/scriptlet!extensions = sct,wsc
mime!text/tab-separated-values!extensions = tsv
mime!text/vnd.sun.j2me.app-descriptor!extensions = jad
mime!text/vnd.wap.wml!extensions = wml
mime!text/vnd.wap.wmlscript!extensions = wmls
mime!text/x-boo!extensions = boo
mime!text/x-c++hdr!extensions = h++,hpp,hxx,hh
mime!text/x-c++src!extensions = c++,cpp,cxx,cc
mime!text/x-chdr!extensions = h
mime!text/x-csh!extensions = csh
mime!text/x-csrc!extensions = c
mime!text/x-dsrc!extensions = d
mime!text/x-haskell!extensions = hs
mime!text/x-java!extensions = java
mime!text/x-literate-haskell!extensions = lhs
mime!text/x-moc!extensions = moc
mime!text/x-pascal!extensions = p,pas
mime!text/x-pcs-gcd!extensions = gcd
mime!text/x-perl!extensions = pl,pm
mime!text/x-python!extensions = py
mime!text/x-setext!extensions = etx
mime!text/x-sh!extensions = sh
mime!text/x-tcl!extensions = tcl,tk
mime!text/x-tex!extensions = tex,ltx,sty,cls
mime!text/x-vcalendar!extensions = vcs
mime!text/x-vcard!extensions = vcf
mime!video/dl!extensions = dl
mime!video/dv!extensions = dif,dv
mime!video/fli!extensions = fli
mime!video/gl!extensions = gl
mime!video/mp4!extensions = mp4
mime!video/mpeg!extensions = mpeg,mpg,mpe
mime!video/ogg!extensions = ogv
mime!video/quicktime!extensions = qt,mov
mime!video/vnd.mpegurl!extensions = mxu
mime!video/webm!extensions = webm
mime!video/x-flv!extensions = flv
mime!video/x-la-asf!extensions = lsf,lsx
mime!video/x-mng!extensions = mng
mime!video/x-ms-asf!extensions = asf,asx
mime!video/x-ms-wm!extensions = wm
mime!video/x-ms-wmv!extensions = wmv
mime!video/x-ms-wmx!extensions = wmx
mime!video/x-ms-wvx!extensions = wvx
mime!video/x-msvideo!extensions = avi
mime!video/x-sgi-movie!extensions = movie
mime!x-conference/x-cooltalk!extensions = ice
mime!x-world/x-vrml!extensions = vrm,vrml,wrl
admin!lang = en

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/share/poundtpl.cfg ===

######################################################################
##GLOBAL OPTIONS
User		"root"
Group		"root"
Name		[DESC]
## allow PUT and DELETE also (by default only GET, POST and HEAD)?:
#ExtendedHTTP	0
## Logging: (goes to syslog by default)
##	0	no logging
##	1	normal
##	2	extended
##	3	Apache-style (common log format)
#LogFacility	local5
LogLevel 	5
## check timeouts:
Timeout		45
ConnTO		20
Alive		21
Client		30
ThreadModel	dynamic
Control 	"/tmp/[DESC]_proxy.socket"
Ignore100Continue 0
#DHParams 	"/usr/local/relianoid/app/pound/etc/dh2048.pem"
##ECDHCurve 	"prime256v1"


#HTTP(S) LISTENERS
ListenHTTP
	Err414 "[CONFIGDIR]/[DESC]_Err414.html"
	Err500 "[CONFIGDIR]/[DESC]_Err500.html"
	Err501 "[CONFIGDIR]/[DESC]_Err501.html"
	Err503 "[CONFIGDIR]/[DESC]_Err503.html"
	Address [IP]
	Port [PORT]
	xHTTP 4
	RewriteLocation 1

	#Cert "/usr/local/relianoid/config/certificates/noid_ssl_cert.pem"
	#Ciphers "ALL"
	#Disable SSLv3
	#SSLHonorCipherOrder 1
	#ZWACL-INI

	#ZWACL-END


	#Service "[DESC]"
		##False##HTTPS-backend##
		#DynScale 1
		#BackendCookie "NOIDSESSIONID" "" "/" 3600
		#HeadRequire "Host: "
		#Url ""
		#Redirect ""
		#StrictTransportSecurity 21600000
		#Session
			#Type nothing
			#TTL 120
			#ID "sessionname"
		#End
		#BackEnd

		#End
	#End


End

=== ./background/relianoid_adc/source_tree/usr/local/relianoid/share/relianoid_nameservers.conf ===

nameserver 1.1.1.1
nameserver 8.8.8.8

=== ./claude_project_files/all_docs.txt ===

